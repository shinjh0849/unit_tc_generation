public void testBooleanUtilsConstructor() { [EOL] new BooleanUtils(); [EOL] }
public void testIsTrue_WithTrue() { [EOL] boolean result = isTrue(Boolean.TRUE); [EOL] assertTrue(result); [EOL] }
public void testIsTrue_WithFalse() { [EOL] boolean result = isTrue(Boolean.FALSE); [EOL] assertFalse(result); [EOL] }
public void testIsTrue_WithNull() { [EOL] boolean result = isTrue(null); [EOL] assertFalse(result); [EOL] }
public void testToBooleanDefaultIfNullWhenBoolIsNullAndValueIfNullIsTrue() { [EOL] boolean result = toBooleanDefaultIfNull(null, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testToBooleanDefaultIfNullWhenBoolIsNullAndValueIfNullIsFalse() { [EOL] boolean result = toBooleanDefaultIfNull(null, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testToBooleanDefaultIfNullWhenBoolIsTrue() { [EOL] boolean result = toBooleanDefaultIfNull(Boolean.TRUE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testToBooleanDefaultIfNullWhenBoolIsFalse() { [EOL] boolean result = toBooleanDefaultIfNull(Boolean.FALSE, true); [EOL] assertFalse(result); [EOL] }
public void testToBoolean_True() { [EOL] assertTrue(StringUtils.toBoolean(1)); [EOL] }
public void testToBoolean_False() { [EOL] assertFalse(StringUtils.toBoolean(0)); [EOL] }
public void testToBooleanObject_WithNull() { [EOL] Integer input = null; [EOL] Boolean result = toBooleanObject(input); [EOL] assertNull(result); [EOL] } [EOL] public void testToBooleanObject_WithZero() { [EOL] Integer input = 0; [EOL] Boolean result = toBooleanObject(input); [EOL] assertFalse(result); [EOL] } [EOL] public void testToBooleanObject_WithPositive() { [EOL] Integer input = 1; [EOL] Boolean result = toBooleanObject(input); [EOL] assertTrue(result); [EOL] } [EOL] public void testToBooleanObject_WithNegative() { [EOL] Integer input = -1; [EOL] Boolean result = toBooleanObject(input); [EOL] assertTrue(result); [EOL] }
public void testToBooleanObject_TrueString() { [EOL] assertEquals(Boolean.TRUE, StringUtils.toBooleanObject("true")); [EOL] }
public void testToBooleanObject_NullString() { [EOL] assertNull(StringUtils.toBooleanObject(null)); [EOL] }
public void testToBooleanObject_SingleCharY() { [EOL] assertEquals(Boolean.TRUE, StringUtils.toBooleanObject("y")); [EOL] }
public void testToBooleanObject_SingleCharN() { [EOL] assertEquals(Boolean.FALSE, StringUtils.toBooleanObject("n")); [EOL] }
public void testToBooleanObject_SingleCharT() { [EOL] assertEquals(Boolean.TRUE, StringUtils.toBooleanObject("t")); [EOL] }
public void testToBooleanObject_SingleCharF() { [EOL] assertEquals(Boolean.FALSE, StringUtils.toBooleanObject("f")); [EOL] }
public void testToBooleanObject_TwoCharOn() { [EOL] assertEquals(Boolean.TRUE, StringUtils.toBooleanObject("on")); [EOL] }
public void testToBooleanObject_TwoCharNo() { [EOL] assertEquals(Boolean.FALSE, StringUtils.toBooleanObject("no")); [EOL] }
public void testToBooleanObject_ThreeCharYes() { [EOL] assertEquals(Boolean.TRUE, StringUtils.toBooleanObject("yes")); [EOL] }
public void testToBooleanObject_ThreeCharOff() { [EOL] assertEquals(Boolean.FALSE, StringUtils.toBooleanObject("off")); [EOL] }
public void testToBooleanObject_FourCharTrue() { [EOL] assertEquals(Boolean.TRUE, StringUtils.toBooleanObject("true")); [EOL] }
public void testToBooleanObject_FiveCharFalse() { [EOL] assertEquals(Boolean.FALSE, StringUtils.toBooleanObject("false")); [EOL] }
public void testToBooleanObject_UnrecognizedString() { [EOL] assertNull(StringUtils.toBooleanObject("unrecognized")); [EOL] }
public void testToBooleanObject_AllNullInputs() { [EOL] Boolean result = toBooleanObject(null, null, null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testToBooleanObject_TrueStringMatches() { [EOL] Boolean result = toBooleanObject("true", "true", "false", "null"); [EOL] assertTrue(result); [EOL] } [EOL] public void testToBooleanObject_FalseStringMatches() { [EOL] Boolean result = toBooleanObject("false", "true", "false", "null"); [EOL] assertFalse(result); [EOL] } [EOL] public void testToBooleanObject_NullStringMatches() { [EOL] Boolean result = toBooleanObject("null", "true", "false", "null"); [EOL] assertNull(result); [EOL] } [EOL] public void testToBooleanObject_NoMatchThrowsException() { [EOL] try { [EOL] toBooleanObject("unknown", "true", "false", "null"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToBooleanObject_StrNullTrueStringNotNull() { [EOL] Boolean result = toBooleanObject(null, "true", null, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testToBooleanObject_StrNullFalseStringNotNull() { [EOL] Boolean result = toBooleanObject(null, null, "false", null); [EOL] assertTrue(result); [EOL] } [EOL] public void testToBooleanObject_StrNullNullStringNotNull() { [EOL] Boolean result = toBooleanObject(null, null, null, "null"); [EOL] assertNull(result); [EOL] }
public void testToStringYesNo_BooleanTrue() { [EOL] String result = StringUtils.toStringYesNo(Boolean.TRUE); [EOL] assertEquals("yes", result); [EOL] } [EOL] public void testToStringYesNo_BooleanFalse() { [EOL] String result = StringUtils.toStringYesNo(Boolean.FALSE); [EOL] assertEquals("no", result); [EOL] } [EOL] public void testToStringYesNo_BooleanNull() { [EOL] String result = StringUtils.toStringYesNo(null); [EOL] assertNull(result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.and((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.and(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.and(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ValidArrayAllTrue_ReturnsTrue() { [EOL] Boolean result = Lang3.and(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testAnd_ValidArrayWithFalse_ReturnsFalse() { [EOL] Boolean result = Lang3.and(new Boolean[]{true, false, true}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.or((boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.or(new boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_AllFalse_ReturnsFalse() { [EOL] boolean result = Lang3.or(false, false, false); [EOL] assertFalse(result); [EOL] }
public void testOr_OneTrue_ReturnsTrue() { [EOL] boolean result = Lang3.or(false, true, false); [EOL] assertTrue(result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testOr_AllTrue() { [EOL] Boolean result = Lang3.or(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testOr_AllFalse() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testOr_MixedValues_ReturnsTrue() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testXor_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.xor(null); [EOL] fail("Expected IllegalArgumentException for null array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testXor_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.xor(new boolean[]{}); [EOL] fail("Expected IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testXor_SingleTrue_ReturnsTrue() { [EOL] boolean result = Lang3.xor(new boolean[]{true}); [EOL] assertTrue("Expected true for single true value", result); [EOL] }
public void testXor_SingleFalse_ReturnsFalse() { [EOL] boolean result = Lang3.xor(new boolean[]{false}); [EOL] assertFalse("Expected false for single false value", result); [EOL] }
public void testXor_MultipleTrue_ReturnsFalse() { [EOL] boolean result = Lang3.xor(new boolean[]{true, true}); [EOL] assertFalse("Expected false for multiple true values", result); [EOL] }
public void testXor_OneTrueOneFalse_ReturnsTrue() { [EOL] boolean result = Lang3.xor(new boolean[]{true, false}); [EOL] assertTrue("Expected true for one true and one false value", result); [EOL] }
public void testXor_MultipleFalse_ReturnsFalse() { [EOL] boolean result = Lang3.xor(new boolean[]{false, false}); [EOL] assertFalse("Expected false for multiple false values", result); [EOL] }
public void testXor_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testXor_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testXor_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testXor_ValidArrayWithSingleTrue_ReturnsTrue() { [EOL] Boolean result = Lang3.xor(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testXor_ValidArrayWithMultipleTrue_ReturnsFalse() { [EOL] Boolean result = Lang3.xor(new Boolean[]{true, true, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testXor_ValidArrayWithAllFalse_ReturnsFalse() { [EOL] Boolean result = Lang3.xor(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testNumericEntityUnescaperWithNoOptions() { [EOL] NumericEntityUnescaper unescaper = new NumericEntityUnescaper(); [EOL] assertTrue(unescaper.options.contains(NumericEntityUnescaper.OPTION.semiColonRequired)); [EOL] }
public void testNumericEntityUnescaperWithOptions() { [EOL] NumericEntityUnescaper unescaper = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonRequired); [EOL] assertTrue(unescaper.options.contains(NumericEntityUnescaper.OPTION.semiColonRequired)); [EOL] }
public void testTranslateWithAmpersandAndHashAtTheEnd() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("&#", 0, out); [EOL] assertEquals(0, result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithValidHexEntity() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("&#x41;", 0, out); [EOL] assertEquals(5, result); [EOL] assertEquals("A", out.toString()); [EOL] }
public void testTranslateWithValidDecimalEntity() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("&#65;", 0, out); [EOL] assertEquals(4, result); [EOL] assertEquals("A", out.toString()); [EOL] }
public void testTranslateWithInvalidEntityMissingSemicolon() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("&#65", 0, out); [EOL] assertEquals(0, result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithInvalidEntityMissingSemicolonError() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("&#65", 0, out); [EOL] fail("Should throw IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Semi-colon required at end of numeric entity", ex.getMessage()); [EOL] } [EOL] }
public void testTranslateWithInvalidHexEntity() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("&#xZZ;", 0, out); [EOL] assertEquals(0, result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithEntityValueGreaterThan0xFFFF() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("&#x10000;", 0, out); [EOL] assertEquals(9, result); [EOL] assertEquals("\uD800\uDC00", out.toString()); // This is the UTF-16 encoding for the code point U+10000 [EOL] }
public void testInvokeMethodWithNullArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object result = invokeMethod(object, methodName, (Object[]) null); [EOL] assertEquals(object.toString(), result); [EOL] }
public void testInvokeMethodWithEmptyArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object result = invokeMethod(object, methodName); [EOL] assertEquals(object.toString(), result); [EOL] }
public void testInvokeMethodWithArgs() throws Exception { [EOL] final String methodName = "equals"; [EOL] final Object object = new Object(); [EOL] final Object[] args = new Object[]{object}; [EOL] Object result = invokeMethod(object, methodName, args); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testInvokeMethodWithNullParameterTypesAndArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object result = invokeMethod(object, methodName, null, null); [EOL] assertEquals("Should invoke Object's toString method.", object.toString(), result); [EOL] } [EOL] public void testInvokeMethodWithEmptyParameterTypesAndArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object[] args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL] Class<?>[] parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL] Object result = invokeMethod(object, methodName, args, parameterTypes); [EOL] assertEquals("Should invoke Object's toString method.", object.toString(), result); [EOL] } [EOL] public void testInvokeMethodWithIncorrectMethodName() { [EOL] final String methodName = "nonExistentMethod"; [EOL] final Object object = new Object(); [EOL] try { [EOL] invokeMethod(object, methodName, null, null); [EOL] fail("Should have thrown NoSuchMethodException."); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] } [EOL] public void testInvokeMethodWithCorrectMethodNameButIncorrectParameters() { [EOL] final String methodName = "equals"; [EOL] final Object object = new Object(); [EOL] Object[] args = new Object[]{new Object()}; [EOL] Class<?>[] parameterTypes = new Class<?>[]{Object.class}; [EOL] try { [EOL] invokeMethod(object, methodName, args, parameterTypes); [EOL] fail("Should have thrown IllegalArgumentException due to incorrect argument type."); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected IllegalArgumentException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }

public void testInvokeStaticMethodWithNullArgs() throws Exception { [EOL] Object result = ClassUtils.invokeStaticMethod(StringUtils.class, "isEmpty", (Object[]) null); [EOL] assertNotNull(result); [EOL] }
public void testInvokeStaticMethodWithEmptyArgs() throws Exception { [EOL] Object result = ClassUtils.invokeStaticMethod(StringUtils.class, "isEmpty", new Object[]{""}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testInvokeStaticMethodWithNonEmptyArgs() throws Exception { [EOL] Object result = ClassUtils.invokeStaticMethod(StringUtils.class, "isEmpty", new Object[]{" "}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testInvokeStaticMethodWithNullParameterTypesAndArgs() throws Exception { [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] Object result = MyClass.invokeStaticMethod(MyClass.class, "staticMethodName", args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals("ExpectedValue", result); [EOL] }
public void testInvokeStaticMethodWithNonNullParameterTypesAndArgs() throws Exception { [EOL] Object[] args = new Object[] { "arg1", 123 }; [EOL] Class<?>[] parameterTypes = new Class<?>[] { String.class, Integer.class }; [EOL] Object result = MyClass.invokeStaticMethod(MyClass.class, "staticMethodName", args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals("ExpectedValue", result); [EOL] }
public void testInvokeStaticMethodThrowsNoSuchMethodException() { [EOL] Object[] args = new Object[] { "arg1", 123 }; [EOL] Class<?>[] parameterTypes = new Class<?>[] { String.class, Integer.class }; [EOL] try { [EOL] MyClass.invokeStaticMethod(MyClass.class, "nonExistentMethod", args, parameterTypes); [EOL] fail("Expected NoSuchMethodException to be thrown"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL] try { [EOL] final Method method = cls.getMethod(methodName, parameterTypes); [EOL] MemberUtils.setAccessibleWorkaround(method); [EOL] return method; [EOL] } catch (final NoSuchMethodException e) { [EOL] } [EOL] Method bestMatch = null; [EOL] final Method[] methods = cls.getMethods(); [EOL] for (final Method method : methods) { [EOL] if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL] final Method accessibleMethod = getAccessibleMethod(method); [EOL] if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL] bestMatch = accessibleMethod; [EOL] } [EOL] } [EOL] } [EOL] if (bestMatch != null) { [EOL] MemberUtils.setAccessibleWorkaround(bestMatch); [EOL] } [EOL] return bestMatch; [EOL] }
It appears that the provided input text is the constructor for a utility class, likely `NumberUtils` from the Apache Commons Lang library. Since constructors for utility classes are often private to prevent instantiation and the body of the constructor in this case only calls `super()`, which is a default behavior for any class constructor in Java, there is no meaningful behavior to test. Utility classes are usually designed to be stateless and provide static methods. [EOL] However, if we were to assume that there is a need to ensure that the constructor is private and cannot be accessed, we could write a test case to reflect this. But since the input text does not provide any methods with logic to test, and constructors like this are not meant to be covered by unit tests, there are no meaningful assertions or line coverage to be achieved here. [EOL] If you have a different method with logic that needs to be tested, please provide the method signature and its body for me to generate meaningful test cases.
public static int toInt(final String str, final int defaultValue) { [EOL] if (str == null) { [EOL] return defaultValue; [EOL] } [EOL] try { [EOL] return Integer.parseInt(str); [EOL] } catch (final NumberFormatException nfe) { [EOL] return defaultValue; [EOL] } [EOL] }
public void testToInt_NullString() { [EOL] int defaultValue = 5; [EOL] int result = StringUtils.toInt(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] } [EOL] public void testToInt_ValidNumberString() { [EOL] String validNumberString = "123"; [EOL] int expectedValue = 123; [EOL] int result = StringUtils.toInt(validNumberString, 0); [EOL] assertEquals(expectedValue, result); [EOL] } [EOL] public void testToInt_InvalidNumberString() { [EOL] String invalidNumberString = "abc"; [EOL] int defaultValue = 5; [EOL] int result = StringUtils.toInt(invalidNumberString, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToByte_ValidNumberString_ShouldReturnByteValue() { [EOL] byte expected = 10; [EOL] byte actual = StringUtils.toByte("10"); [EOL] assertEquals(expected, actual); [EOL] }
public void testToByte_InvalidNumberString_ShouldReturnDefaultValue() { [EOL] byte expected = 0; [EOL] byte actual = StringUtils.toByte("invalid"); [EOL] assertEquals(expected, actual); [EOL] }
public void testToByte_NullString_ShouldReturnDefaultValue() { [EOL] byte expected = 0; [EOL] byte actual = StringUtils.toByte(null); [EOL] assertEquals(expected, actual); [EOL] }
public void testToByte_NullString() { [EOL] final byte defaultValue = 1; [EOL] byte result = StringUtils.toByte(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] } [EOL] public void testToByte_ValidNumberString() { [EOL] final byte defaultValue = 1; [EOL] byte result = StringUtils.toByte("2", defaultValue); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testToByte_InvalidNumberString() { [EOL] final byte defaultValue = 1; [EOL] byte result = StringUtils.toByte("invalid", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToShort_withValidNumberString() { [EOL] short expected = 123; [EOL] short actual = StringUtils.toShort("123"); [EOL] assertEquals(expected, actual); [EOL] }
public void testToShort_withInvalidNumberString() { [EOL] short expected = 0; [EOL] short actual = StringUtils.toShort("invalid"); [EOL] assertEquals(expected, actual); [EOL] }
public void testToShort_withNullString() { [EOL] short expected = 0; [EOL] short actual = StringUtils.toShort(null); [EOL] assertEquals(expected, actual); [EOL] }
public void testToShort_NullString() { [EOL] final short defaultValue = 1; [EOL] short result = StringUtils.toShort(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToShort_EmptyString() { [EOL] final short defaultValue = 1; [EOL] short result = StringUtils.toShort("", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToShort_ValidNumberString() { [EOL] final short defaultValue = 1; [EOL] short result = StringUtils.toShort("123", defaultValue); [EOL] assertEquals(123, result); [EOL] }
public void testToShort_InvalidNumberString() { [EOL] final short defaultValue = 1; [EOL] short result = StringUtils.toShort("invalid", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL] if (str == null) { [EOL] return null; [EOL] } [EOL] if (StringUtils.isBlank(str)) { [EOL] throw new NumberFormatException("A blank string is not a valid number"); [EOL] } [EOL] final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL] int pfxLen = 0; [EOL] for (final String pfx : hex_prefixes) { [EOL] if (str.startsWith(pfx)) { [EOL] pfxLen += pfx.length(); [EOL] break; [EOL] } [EOL] } [EOL] if (pfxLen > 0) { [EOL] char firstSigDigit = 0; [EOL] for (int i = pfxLen; i < str.length(); i++) { [EOL] firstSigDigit = str.charAt(i); [EOL] if (firstSigDigit == '0') { [EOL] pfxLen++; [EOL] } else { [EOL] break; [EOL] } [EOL] } [EOL] final int hexDigits = str.length() - pfxLen; [EOL] if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL] return createBigInteger(str); [EOL] } [EOL] if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL] return createLong(str); [EOL] } [EOL] return createInteger(str); [EOL] } [EOL] final char lastChar = str.charAt(str.length() - 1); [EOL] String mant; [EOL] String dec; [EOL] String exp; [EOL] final int decPos = str.indexOf('.'); [EOL] final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL] int numDecimals = 0; [EOL] if (decPos > -1) { [EOL] if (expPos > -1) { [EOL] if (expPos < decPos || expPos > str.length()) { [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] } [EOL] dec = str.substring(decPos + 1, expPos); [EOL] } else { [EOL] dec = str.substring(decPos + 1); [EOL] } [EOL] mant = str.substring(0, decPos); [EOL] numDecimals = dec.length(); [EOL] } else { [EOL] if (expPos > -1) { [EOL] if (expPos > str.length()) { [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] } [EOL] mant = str.substring(0, expPos); [EOL] } else { [EOL] mant = str; [EOL] } [EOL] dec = null; [EOL] } [EOL] if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL] if (expPos > -1 && expPos < str.length() - 1) { [EOL] exp = str.substring(expPos + 1, str.length() - 1); [EOL] } else { [EOL] exp = null; [EOL] } [EOL] final String numeric = str.substring(0, str.length() - 1); [EOL] final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL] switch(lastChar) { [EOL] case 'l': [EOL] case 'L': [EOL] if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL] try { [EOL] return createLong(numeric); [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] return createBigInteger(numeric); [EOL] } [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] case 'f': [EOL] case 'F': [EOL] try { [EOL] final Float f = NumberUtils.createFloat(numeric); [EOL] if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL] return f; [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] case 'd': [EOL] case 'D': [EOL] try { [EOL] final Double d = NumberUtils.createDouble(numeric); [EOL] if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL] return d; [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] try { [EOL] return createBigDecimal(numeric); [EOL] } catch (final NumberFormatException e) { [EOL] } [EOL] default: [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] } [EOL] } [EOL] if (expPos > -1 && expPos < str.length() - 1) { [EOL] exp = str.substring(expPos + 1, str.length()); [EOL] } else { [EOL] exp = null; [EOL] } [EOL] if (dec == null && exp == null) { [EOL] try { [EOL] return createInteger(str); [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] try { [EOL] return createLong(str); [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] return createBigInteger(str); [EOL] } [EOL] final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL] try { [EOL] if (numDecimals <= 7) { [EOL] final Float f = createFloat(str); [EOL] if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL] return f; [EOL] } [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] try { [EOL] if (numDecimals <= 16) { [EOL] final Double d = createDouble(str); [EOL] if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL] return d; [EOL] } [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] return createBigDecimal(str); [EOL] }
public void testIsAllZerosWithNull() { [EOL] assertTrue(isAllZeros(null)); [EOL] }
public void testIsAllZerosWithEmptyString() { [EOL] assertFalse(isAllZeros("")); [EOL] }
public void testIsAllZerosWithOnlyZeros() { [EOL] assertTrue(isAllZeros("0000")); [EOL] }
public void testIsAllZerosWithNonZeroCharacter() { [EOL] assertFalse(isAllZeros("00010")); [EOL] }
public void testCreateIntegerWithNull() { [EOL] Integer result = StringUtils.createInteger(null); [EOL] assertNull(result); [EOL] } [EOL] public void testCreateIntegerWithValidNumber() { [EOL] Integer result = StringUtils.createInteger("123"); [EOL] assertNotNull(result); [EOL] assertEquals(123, result.intValue()); [EOL] } [EOL] public void testCreateIntegerWithHexNumber() { [EOL] Integer result = StringUtils.createInteger("0x1F"); [EOL] assertNotNull(result); [EOL] assertEquals(31, result.intValue()); [EOL] } [EOL] public void testCreateIntegerWithOctalNumber() { [EOL] Integer result = StringUtils.createInteger("010"); [EOL] assertNotNull(result); [EOL] assertEquals(8, result.intValue()); [EOL] } [EOL] public void testCreateIntegerWithInvalidNumber() { [EOL] try { [EOL] StringUtils.createInteger("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateLongWithNull() { [EOL] Long result = StringUtils.createLong(null); [EOL] assertNull(result); [EOL] } [EOL] public void testCreateLongWithValidNumberString() { [EOL] Long expected = 123L; [EOL] Long result = StringUtils.createLong("123"); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testCreateLongWithInvalidNumberString() { [EOL] try { [EOL] StringUtils.createLong("abc"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateLongWithHexNumberString() { [EOL] Long expected = 0x1FL; [EOL] Long result = StringUtils.createLong("0x1F"); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testCreateLongWithOctalNumberString() { [EOL] Long expected = 017L; [EOL] Long result = StringUtils.createLong("017"); [EOL] assertEquals(expected, result); [EOL] }

public void testCreateBigIntegerWithNull() { [EOL] BigInteger result = Lang3.createBigInteger(null); [EOL] assertNull(result); [EOL] }
public void testCreateBigIntegerWithNegativeHex() { [EOL] BigInteger result = Lang3.createBigInteger("-0x1A"); [EOL] assertEquals(new BigInteger("-26"), result); [EOL] }
public void testCreateBigIntegerWithPositiveHex() { [EOL] BigInteger result = Lang3.createBigInteger("0x1A"); [EOL] assertEquals(new BigInteger("26"), result); [EOL] }
public void testCreateBigIntegerWithNegativeDecimal() { [EOL] BigInteger result = Lang3.createBigInteger("-123"); [EOL] assertEquals(new BigInteger("-123"), result); [EOL] }
public void testCreateBigIntegerWithPositiveDecimal() { [EOL] BigInteger result = Lang3.createBigInteger("123"); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testCreateBigIntegerWithNegativeOctal() { [EOL] BigInteger result = Lang3.createBigInteger("-0123"); [EOL] assertEquals(new BigInteger("-83"), result); [EOL] }
public void testCreateBigIntegerWithPositiveOctal() { [EOL] BigInteger result = Lang3.createBigInteger("0123"); [EOL] assertEquals(new BigInteger("83"), result); [EOL] }
public void testCreateBigIntegerWithHashPrefix() { [EOL] BigInteger result = Lang3.createBigInteger("#1A"); [EOL] assertEquals(new BigInteger("26"), result); [EOL] }
public void testCreateBigDecimalWithNullInput() { [EOL] BigDecimal result = Lang3.createBigDecimal(null); [EOL] assertNull(result); [EOL] }
public void testCreateBigDecimalWithBlankString() { [EOL] try { [EOL] Lang3.createBigDecimal(" "); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("A blank string is not a valid number", e.getMessage()); [EOL] } [EOL] }
public void testCreateBigDecimalWithDoubleMinus() { [EOL] try { [EOL] Lang3.createBigDecimal("--123"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("--123 is not a valid number.", e.getMessage()); [EOL] } [EOL] }
public void testCreateBigDecimalWithValidString() { [EOL] BigDecimal expected = new BigDecimal("123"); [EOL] BigDecimal result = Lang3.createBigDecimal("123"); [EOL] assertEquals(expected, result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] long[] array = {5}; [EOL] long result = min(array); [EOL] assertEquals(5, result); [EOL] }
public void testMinWithMultipleElementsArray() { [EOL] long[] array = {5, 3, 7, 1, 4}; [EOL] long result = min(array); [EOL] assertEquals(1, result); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] long[] array = {2, 2, 2, 2, 2}; [EOL] long result = min(array); [EOL] assertEquals(2, result); [EOL] }
public void testMinWithNegativeElementsArray() { [EOL] long[] array = {-3, -1, -4, -2, -5}; [EOL] long result = min(array); [EOL] assertEquals(-5, result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] int[] array = new int[]{42}; [EOL] int result = min(array); [EOL] assertEquals(42, result); [EOL] } [EOL] public void testMinWithMultipleElementArray() { [EOL] int[] array = new int[]{10, 22, -5, 0}; [EOL] int result = min(array); [EOL] assertEquals(-5, result); [EOL] } [EOL] public void testMinWithAllEqualElementsArray() { [EOL] int[] array = new int[]{7, 7, 7, 7}; [EOL] int result = min(array); [EOL] assertEquals(7, result); [EOL] } [EOL] public void testMinWithDescendingOrderArray() { [EOL] int[] array = new int[]{10, 9, 8, 7}; [EOL] int result = min(array); [EOL] assertEquals(7, result); [EOL] } [EOL] public void testMinWithAscendingOrderArray() { [EOL] int[] array = new int[]{1, 2, 3, 4}; [EOL] int result = min(array); [EOL] assertEquals(1, result); [EOL] }
public void testMinWithValidArray() { [EOL] double[] array = {1.0, 2.0, 0.5, 3.0}; [EOL] double result = YourClass.min(array); [EOL] assertEquals(0.5, result, 0.0); [EOL] }
public void testMinWithNaN() { [EOL] double[] array = {1.0, Double.NaN, 0.5, 3.0}; [EOL] double result = YourClass.min(array); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testMinWithEmptyArray() { [EOL] double[] array = {}; [EOL] try { [EOL] YourClass.min(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMinWithSingleElementArray() { [EOL] double[] array = {2.0}; [EOL] double result = YourClass.min(array); [EOL] assertEquals(2.0, result, 0.0); [EOL] }
public void testMin_withValidArray() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float result = YourClass.min(array); [EOL] assertEquals(1.0f, result, 0.01f); [EOL] }
public void testMin_withNaN() { [EOL] float[] array = {1.0f, Float.NaN, 3.0f}; [EOL] float result = YourClass.min(array); [EOL] assertTrue(Float.isNaN(result)); [EOL] }
public void testMin_withNegativeValues() { [EOL] float[] array = {-1.0f, -2.0f, -3.0f}; [EOL] float result = YourClass.min(array); [EOL] assertEquals(-3.0f, result, 0.01f); [EOL] }
public void testMin_withSingleElement() { [EOL] float[] array = {42.0f}; [EOL] float result = YourClass.min(array); [EOL] assertEquals(42.0f, result, 0.01f); [EOL] }
public void testMin_withEmptyArray() { [EOL] float[] array = {}; [EOL] try { [EOL] YourClass.min(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithSingleElementArray() { [EOL] long[] array = {42}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(42, result); [EOL] }
public void testMaxWithMultipleElementArray() { [EOL] long[] array = {1, 3, 2, 5, 4}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(5, result); [EOL] }
public void testMaxWithAllElementsEqualArray() { [EOL] long[] array = {2, 2, 2, 2, 2}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(2, result); [EOL] }
public void testMaxWithNegativeElementsArray() { [EOL] long[] array = {-1, -3, -2, -5, -4}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(-1, result); [EOL] }
public void testMaxWithMixedElementsArray() { [EOL] long[] array = {-1, 3, 0, 5, -4}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(5, result); [EOL] }
public void testMaxWithNonEmptyArray() { [EOL] short[] array = {1, 3, 2, 4, 5}; [EOL] short result = ArrayUtils.max(array); [EOL] assertEquals(5, result); [EOL] }
public void testMaxWithSingleElementArray() { [EOL] short[] array = {42}; [EOL] short result = ArrayUtils.max(array); [EOL] assertEquals(42, result); [EOL] }
public void testMaxWithAllEqualElementsArray() { [EOL] short[] array = {2, 2, 2, 2, 2}; [EOL] short result = ArrayUtils.max(array); [EOL] assertEquals(2, result); [EOL] }
public void testMaxWithNegativeNumbers() { [EOL] short[] array = {-1, -3, -2, -4, -5}; [EOL] short result = ArrayUtils.max(array); [EOL] assertEquals(-1, result); [EOL] }
public void testMaxWithEmptyArray() { [EOL] try { [EOL] short[] array = {}; [EOL] ArrayUtils.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testValidateArrayWithNullArray() { [EOL] try { [EOL] validateArray(null); [EOL] fail("Expected IllegalArgumentException for null array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testValidateArrayWithEmptyArray() { [EOL] try { [EOL] validateArray(new Object[0]); [EOL] fail("Expected IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array cannot be empty.", ex.getMessage()); [EOL] } [EOL] }
public void testValidateArrayWithNonEmptyArray() { [EOL] try { [EOL] validateArray(new Object[1]); [EOL] } catch (IllegalArgumentException ex) { [EOL] fail("No exception expected for non-empty array"); [EOL] } [EOL] }
public void testMin_FirstIsMin() { [EOL] long a = 1; [EOL] long b = 2; [EOL] long c = 3; [EOL] long result = YourClass.min(a, b, c); [EOL] assertEquals(a, result); [EOL] } [EOL] public void testMin_SecondIsMin() { [EOL] long a = 3; [EOL] long b = 1; [EOL] long c = 2; [EOL] long result = YourClass.min(a, b, c); [EOL] assertEquals(b, result); [EOL] } [EOL] public void testMin_ThirdIsMin() { [EOL] long a = 2; [EOL] long b = 3; [EOL] long c = 1; [EOL] long result = YourClass.min(a, b, c); [EOL] assertEquals(c, result); [EOL] } [EOL] public void testMin_AllEqual() { [EOL] long a = 2; [EOL] long b = 2; [EOL] long c = 2; [EOL] long result = YourClass.min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMin_FirstIsMin() { [EOL] int a = 1; [EOL] int b = 2; [EOL] int c = 3; [EOL] int result = YourClass.min(a, b, c); [EOL] assertEquals(a, result); [EOL] } [EOL] public void testMin_SecondIsMin() { [EOL] int a = 3; [EOL] int b = 1; [EOL] int c = 2; [EOL] int result = YourClass.min(a, b, c); [EOL] assertEquals(b, result); [EOL] } [EOL] public void testMin_ThirdIsMin() { [EOL] int a = 2; [EOL] int b = 3; [EOL] int c = 1; [EOL] int result = YourClass.min(a, b, c); [EOL] assertEquals(c, result); [EOL] }
public void testMin_AllEqual() { [EOL] int a = 1; [EOL] int b = 1; [EOL] int c = 1; [EOL] int result = YourClass.min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMinWithFirstByteMinimum() { [EOL] byte a = 1; [EOL] byte b = 2; [EOL] byte c = 3; [EOL] byte result = min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMinWithSecondByteMinimum() { [EOL] byte a = 2; [EOL] byte b = 1; [EOL] byte c = 3; [EOL] byte result = min(a, b, c); [EOL] assertEquals(b, result); [EOL] }
public void testMinWithThirdByteMinimum() { [EOL] byte a = 3; [EOL] byte b = 2; [EOL] byte c = 1; [EOL] byte result = min(a, b, c); [EOL] assertEquals(c, result); [EOL] }
public void testMax_AllEqual() { [EOL] short a = 10; [EOL] short b = 10; [EOL] short c = 10; [EOL] short result = YourClass.max(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMax_AGreater() { [EOL] short a = 20; [EOL] short b = 10; [EOL] short c = 15; [EOL] short result = YourClass.max(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMax_BGreater() { [EOL] short a = 10; [EOL] short b = 20; [EOL] short c = 15; [EOL] short result = YourClass.max(a, b, c); [EOL] assertEquals(b, result); [EOL] }
public void testMax_CGreater() { [EOL] short a = 10; [EOL] short b = 15; [EOL] short c = 20; [EOL] short result = YourClass.max(a, b, c); [EOL] assertEquals(c, result); [EOL] }
public void testIsNumber_EmptyString() { [EOL] assertFalse(StringUtils.isNumber("")); [EOL] } [EOL] public void testIsNumber_NullString() { [EOL] assertFalse(StringUtils.isNumber(null)); [EOL] }
public void testIsNumber_HexNumber() { [EOL] assertTrue(StringUtils.isNumber("0x10")); [EOL] } [EOL] public void testIsNumber_InvalidHexNumber() { [EOL] assertFalse(StringUtils.isNumber("0x1G")); [EOL] }
public void testIsNumber_SimpleNumber() { [EOL] assertTrue(StringUtils.isNumber("123")); [EOL] } [EOL] public void testIsNumber_NegativeNumber() { [EOL] assertTrue(StringUtils.isNumber("-123")); [EOL] }
public void testIsNumber_DecimalNumber() { [EOL] assertTrue(StringUtils.isNumber("123.45")); [EOL] } [EOL] public void testIsNumber_NegativeDecimalNumber() { [EOL] assertTrue(StringUtils.isNumber("-123.45")); [EOL] }
public void testIsNumber_ScientificNotation() { [EOL] assertTrue(StringUtils.isNumber("1e10")); [EOL] } [EOL] public void testIsNumber_NegativeScientificNotation() { [EOL] assertTrue(StringUtils.isNumber("-1e10")); [EOL] }
public void testIsNumber_InvalidScientificNotation() { [EOL] assertFalse(StringUtils.isNumber("1e")); [EOL] } [EOL] public void testIsNumber_InvalidScientificNotationWithSign() { [EOL] assertFalse(StringUtils.isNumber("1e+")); [EOL] }
public void testIsNumber_DoubleWithD() { [EOL] assertTrue(StringUtils.isNumber("123.45D")); [EOL] } [EOL] public void testIsNumber_FloatWithF() { [EOL] assertTrue(StringUtils.isNumber("123.45F")); [EOL] }
public void testIsNumber_LongWithL() { [EOL] assertTrue(StringUtils.isNumber("123L")); [EOL] } [EOL] public void testIsNumber_InvalidLongWithL() { [EOL] assertFalse(StringUtils.isNumber("123.45L")); [EOL] }
public void testIsNumber_InvalidCharacter() { [EOL] assertFalse(StringUtils.isNumber("123a")); [EOL] } [EOL] public void testIsNumber_InvalidSignPosition() { [EOL] assertFalse(StringUtils.isNumber("123-45")); [EOL] }
public void testIsNumber_MultipleDecimalPoints() { [EOL] assertFalse(StringUtils.isNumber("123.4.5")); [EOL] } [EOL] public void testIsNumber_DecimalPointInExponent() { [EOL] assertFalse(StringUtils.isNumber("1e1.0")); [EOL] }
public void testIsNumber_SignAfterExponent() { [EOL] assertTrue(StringUtils.isNumber("1e+10")); [EOL] } [EOL] public void testIsNumber_NegativeSignAfterExponent() { [EOL] assertTrue(StringUtils.isNumber("1e-10")); [EOL] }
public void testIsNumber_MultipleSigns() { [EOL] assertFalse(StringUtils.isNumber("1e--10")); [EOL] } [EOL] public void testIsNumber_SignWithoutExponent() { [EOL] assertFalse(StringUtils.isNumber("123+45")); [EOL] }
public void testBitFieldConstructorWithNonZeroMask() { [EOL] int mask = 0x0F; // Example mask with non-zero value [EOL] BitField bitField = new BitField(mask); [EOL] assertEquals("The mask should be set correctly", mask, bitField.getMask()); [EOL] assertEquals("The shift count should be correct", 0, bitField.getShiftCount()); [EOL] }
public void testBitFieldConstructorWithZeroMask() { [EOL] int mask = 0; [EOL] BitField bitField = new BitField(mask); [EOL] assertEquals("The mask should be zero", mask, bitField.getMask()); [EOL] assertEquals("The shift count should be zero for a zero mask", 0, bitField.getShiftCount()); [EOL] }
public void testIsSet_WithZeroHolder() { [EOL] final int holder = 0; [EOL] final int mask = 1; [EOL] BitField bitField = new BitField(mask); [EOL] boolean result = bitField.isSet(holder); [EOL] assertFalse(result); [EOL] }
public void testIsSet_WithHolderHavingBitSet() { [EOL] final int holder = 1; [EOL] final int mask = 1; [EOL] BitField bitField = new BitField(mask); [EOL] boolean result = bitField.isSet(holder); [EOL] assertTrue(result); [EOL] }
public void testIsSet_WithHolderHavingDifferentBitSet() { [EOL] final int holder = 2; [EOL] final int mask = 1; [EOL] BitField bitField = new BitField(mask); [EOL] boolean result = bitField.isSet(holder); [EOL] assertFalse(result); [EOL] }
public void testClearByte_Zero() { [EOL] byte holder = 0x00; // 00000000 [EOL] byte result = clearByte(holder); [EOL] assertEquals(0x00, result); // Assert that clearing a zero byte results in zero [EOL] }
public void testClearByte_Positive() { [EOL] byte holder = 0x0F; // 00001111 [EOL] byte result = clearByte(holder); [EOL] assertEquals(0x00, result); // Assert that clearing a byte with positive bits results in zero [EOL] }
public void testClearByte_Negative() { [EOL] byte holder = (byte) 0xFF; // 11111111 [EOL] byte result = clearByte(holder); [EOL] assertEquals(0x00, result); // Assert that clearing a byte with all bits set results in zero [EOL] }
public void testSetByte_MaxValue() { [EOL] final byte maxValue = Byte.MAX_VALUE; [EOL] byte result = setByte(maxValue); [EOL] assertEquals(maxValue, result); [EOL] } [EOL] public void testSetByte_MinValue() { [EOL] final byte minValue = Byte.MIN_VALUE; [EOL] byte result = setByte(minValue); [EOL] assertEquals(minValue, result); [EOL] } [EOL] public void testSetByte_AnyValue() { [EOL] final byte anyValue = 0x1A; // Some arbitrary byte value [EOL] byte result = setByte(anyValue); [EOL] assertEquals(anyValue, result); [EOL] }
public void testSetByteBooleanTrue() { [EOL] final byte initialHolder = 0x00; // Any initial byte value [EOL] final boolean flag = true; // Set flag to true [EOL] final byte expectedHolder = setByte(initialHolder); // Expected result when flag is true [EOL] final byte resultHolder = setByteBoolean(initialHolder, flag); // Actual result from the method [EOL] assertEquals(expectedHolder, resultHolder); // Assert that the expected and actual results match [EOL] }
public void testSetByteBooleanFalse() { [EOL] final byte initialHolder = 0x00; // Any initial byte value [EOL] final boolean flag = false; // Set flag to false [EOL] final byte expectedHolder = clearByte(initialHolder); // Expected result when flag is false [EOL] final byte resultHolder = setByteBoolean(initialHolder, flag); // Actual result from the method [EOL] assertEquals(expectedHolder, resultHolder); // Assert that the expected and actual results match [EOL] }
public void testAddEventListenerWithValidListener() { [EOL] Object eventSource = new EventSource(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] } catch (Exception e) { [EOL] fail("No exception should be thrown for a valid listener"); [EOL] } [EOL] }
public void testAddEventListenerWithInvalidListenerType() { [EOL] Object eventSource = new EventSource(); [EOL] Object invalidListener = new Object(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, invalidListener); [EOL] fail("IllegalArgumentException expected for invalid listener type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (Exception e) { [EOL] fail("IllegalArgumentException expected, but another exception was thrown"); [EOL] } [EOL] }
public void testAddEventListenerWithInaccessibleMethod() { [EOL] Object eventSource = new PrivateEventSource(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] fail("IllegalArgumentException expected for inaccessible method"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (Exception e) { [EOL] fail("IllegalArgumentException expected, but another exception was thrown"); [EOL] } [EOL] }
public void testAddEventListenerWithNoMethod() { [EOL] Object eventSource = new Object(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] fail("IllegalArgumentException expected for no such method"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (Exception e) { [EOL] fail("IllegalArgumentException expected, but another exception was thrown"); [EOL] } [EOL] }
public void testAddEventListenerWithInvocationTargetException() { [EOL] Object eventSource = new EventSourceWithException(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] fail("RuntimeException expected for InvocationTargetException"); [EOL] } catch (RuntimeException e) { [EOL] } catch (Exception e) { [EOL] fail("RuntimeException expected, but another exception was thrown"); [EOL] } [EOL] }
public void testBindEventsToMethodWithValidArguments() { [EOL] Object target = new Object(); [EOL] String methodName = "someMethod"; [EOL] Object eventSource = new Object(); [EOL] Class<EventListener> listenerType = EventListener.class; [EOL] String[] eventTypes = new String[] {"eventType1", "eventType2"}; [EOL] ReflectionUtils.bindEventsToMethod(target, methodName, eventSource, listenerType, eventTypes); [EOL] }
public void testBindEventsToMethodWithNullTarget() { [EOL] String methodName = "someMethod"; [EOL] Object eventSource = new Object(); [EOL] Class<EventListener> listenerType = EventListener.class; [EOL] String[] eventTypes = new String[] {"eventType1", "eventType2"}; [EOL] try { [EOL] ReflectionUtils.bindEventsToMethod(null, methodName, eventSource, listenerType, eventTypes); [EOL] fail("Expected IllegalArgumentException for null target"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBindEventsToMethodWithNullMethodName() { [EOL] Object target = new Object(); [EOL] Object eventSource = new Object(); [EOL] Class<EventListener> listenerType = EventListener.class; [EOL] String[] eventTypes = new String[] {"eventType1", "eventType2"}; [EOL] try { [EOL] ReflectionUtils.bindEventsToMethod(target, null, eventSource, listenerType, eventTypes); [EOL] fail("Expected IllegalArgumentException for null methodName"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBindEventsToMethodWithNullEventSource() { [EOL] Object target = new Object(); [EOL] String methodName = "someMethod"; [EOL] Class<EventListener> listenerType = EventListener.class; [EOL] String[] eventTypes = new String[] {"eventType1", "eventType2"}; [EOL] try { [EOL] ReflectionUtils.bindEventsToMethod(target, methodName, null, listenerType, eventTypes); [EOL] fail("Expected IllegalArgumentException for null eventSource"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBindEventsToMethodWithNullListenerType() { [EOL] Object target = new Object(); [EOL] String methodName = "someMethod"; [EOL] Object eventSource = new Object(); [EOL] String[] eventTypes = new String[] {"eventType1", "eventType2"}; [EOL] try { [EOL] ReflectionUtils.bindEventsToMethod(target, methodName, eventSource, null, eventTypes); [EOL] fail("Expected IllegalArgumentException for null listenerType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBindEventsToMethodWithEmptyEventTypes() { [EOL] Object target = new Object(); [EOL] String methodName = "someMethod"; [EOL] Object eventSource = new Object(); [EOL] Class<EventListener> listenerType = EventListener.class; [EOL] String[] eventTypes = new String[] {}; [EOL] ReflectionUtils.bindEventsToMethod(target, methodName, eventSource, listenerType, eventTypes); [EOL] }
public void testBindEventsToMethodWithNullEventTypes() { [EOL] Object target = new Object(); [EOL] String methodName = "someMethod"; [EOL] Object eventSource = new Object(); [EOL] Class<EventListener> listenerType = EventListener.class; [EOL] ReflectionUtils.bindEventsToMethod(target, methodName, eventSource, listenerType, (String[]) null); [EOL] }
public void testEventBindingInvocationHandlerWithValidArguments() { [EOL] Object target = new Object(); [EOL] String methodName = "testMethod"; [EOL] String[] eventTypes = {"click", "change"}; [EOL] EventBindingInvocationHandler handler = new EventBindingInvocationHandler(target, methodName, eventTypes); [EOL] assertNotNull(handler); [EOL] assertEquals(target, handler.target); [EOL] assertEquals(methodName, handler.methodName); [EOL] assertEquals(new HashSet<String>(Arrays.asList(eventTypes)), handler.eventTypes); [EOL] }
public void testEventBindingInvocationHandlerWithNullTarget() { [EOL] String methodName = "testMethod"; [EOL] String[] eventTypes = {"click", "change"}; [EOL] EventBindingInvocationHandler handler = new EventBindingInvocationHandler(null, methodName, eventTypes); [EOL] assertNotNull(handler); [EOL] assertNull(handler.target); [EOL] assertEquals(methodName, handler.methodName); [EOL] assertEquals(new HashSet<String>(Arrays.asList(eventTypes)), handler.eventTypes); [EOL] }
public void testEventBindingInvocationHandlerWithNullMethodName() { [EOL] Object target = new Object(); [EOL] String[] eventTypes = {"click", "change"}; [EOL] EventBindingInvocationHandler handler = new EventBindingInvocationHandler(target, null, eventTypes); [EOL] assertNotNull(handler); [EOL] assertEquals(target, handler.target); [EOL] assertNull(handler.methodName); [EOL] assertEquals(new HashSet<String>(Arrays.asList(eventTypes)), handler.eventTypes); [EOL] }
public void testEventBindingInvocationHandlerWithNullEventTypes() { [EOL] Object target = new Object(); [EOL] String methodName = "testMethod"; [EOL] EventBindingInvocationHandler handler = new EventBindingInvocationHandler(target, methodName, null); [EOL] assertNotNull(handler); [EOL] assertEquals(target, handler.target); [EOL] assertEquals(methodName, handler.methodName); [EOL] assertNull(handler.eventTypes); [EOL] }
public void testEventBindingInvocationHandlerWithEmptyEventTypes() { [EOL] Object target = new Object(); [EOL] String methodName = "testMethod"; [EOL] String[] eventTypes = {}; [EOL] EventBindingInvocationHandler handler = new EventBindingInvocationHandler(target, methodName, eventTypes); [EOL] assertNotNull(handler); [EOL] assertEquals(target, handler.target); [EOL] assertEquals(methodName, handler.methodName); [EOL] assertTrue(handler.eventTypes.isEmpty()); [EOL] }
public void testInvokeWithEmptyEventTypes() throws Throwable { [EOL] EventListenerSupport.InvocationHandler handler = new EventListenerSupport.InvocationHandler(new Object(), new HashSet<>()); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = handler.invoke(new Object(), method, null); [EOL] assertNull(result); [EOL] } [EOL] public void testInvokeWithEventTypesContainingMethod() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("toString"); [EOL] EventListenerSupport.InvocationHandler handler = new EventListenerSupport.InvocationHandler(new Object(), eventTypes); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = handler.invoke(new Object(), method, null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testInvokeWithEventTypesNotContainingMethod() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("hashCode"); [EOL] EventListenerSupport.InvocationHandler handler = new EventListenerSupport.InvocationHandler(new Object(), eventTypes); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = handler.invoke(new Object(), method, null); [EOL] assertNull(result); [EOL] } [EOL] public void testInvokeWithMatchingParametersMethod() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("equals"); [EOL] EventListenerSupport.InvocationHandler handler = new EventListenerSupport.InvocationHandler(new Object(), eventTypes); [EOL] Method method = Object.class.getMethod("equals", Object.class); [EOL] Object[] parameters = new Object[]{new Object()}; [EOL] Object result = handler.invoke(new Object(), method, parameters); [EOL] assertNotNull(result); [EOL] } [EOL] public void testInvokeWithoutMatchingParametersMethod() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("toString"); [EOL] EventListenerSupport.InvocationHandler handler = new EventListenerSupport.InvocationHandler(new Object(), eventTypes); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = handler.invoke(new Object(), method, new Object[0]); [EOL] assertNotNull(result); [EOL] }
public void testHasMatchingParametersMethod_WithMatchingMethod() { [EOL] Method method = target.getClass().getMethod(methodName, /* parameter types */); [EOL] boolean result = hasMatchingParametersMethod(method); [EOL] assertTrue(result); [EOL] }
public void testHasMatchingParametersMethod_WithNonMatchingMethod() { [EOL] Method method = target.getClass().getMethod(methodName, /* non-matching parameter types */); [EOL] boolean result = hasMatchingParametersMethod(method); [EOL] assertFalse(result); [EOL] }
public void testExtendedMessageFormatWithPatternAndRegistry() { [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern", registry); [EOL] assertNotNull(emf); [EOL] assertEquals("pattern", emf.toPattern()); [EOL] }
public void testExtendedMessageFormatWithPattern() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern"); [EOL] assertNotNull(emf); [EOL] assertEquals("pattern", emf.toPattern()); [EOL] }
public void testExtendedMessageFormatWithPatternAndLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern", locale); [EOL] assertNotNull(emf); [EOL] assertEquals("pattern", emf.toPattern()); [EOL] }
public void testExtendedMessageFormatWithPatternLocaleAndRegistry() { [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] Locale locale = new Locale("en", "US"); [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern", locale, registry); [EOL] assertNotNull(emf); [EOL] assertEquals("pattern", emf.toPattern()); [EOL] }
public void testApplyPattern() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(""); [EOL] emf.applyPattern("new pattern"); [EOL] assertEquals("new pattern", emf.toPattern()); [EOL] }
public void testSetFormat() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("{0}"); [EOL] Format format = NumberFormat.getInstance(); [EOL] emf.setFormat(0, format); [EOL] }
public void testSetFormatByArgumentIndex() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("{0}"); [EOL] Format format = NumberFormat.getInstance(); [EOL] emf.setFormatByArgumentIndex(0, format); [EOL] }
public void testSetFormats() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("{0}"); [EOL] Format[] formats = {NumberFormat.getInstance()}; [EOL] emf.setFormats(formats); [EOL] }
public void testSetFormatsByArgumentIndex() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("{0}"); [EOL] Format[] formats = {NumberFormat.getInstance()}; [EOL] emf.setFormatsByArgumentIndex(formats); [EOL] }
public void testEqualsAndHashCode() { [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat("pattern"); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat("pattern"); [EOL] assertEquals(emf1, emf2); [EOL] assertEquals(emf1.hashCode(), emf2.hashCode()); [EOL] }
public void testNotEquals() { [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat("pattern1"); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat("pattern2"); [EOL] assertNotEquals(emf1, emf2); [EOL] }
public void testGetThreadCount_WhenThreadCounterIsZero() { [EOL] AtomicLong threadCounter = new AtomicLong(0); [EOL] MyClass myClass = new MyClass(threadCounter); [EOL] long result = myClass.getThreadCount(); [EOL] assertEquals(0, result); [EOL] }
public void testGetThreadCount_WhenThreadCounterIsPositive() { [EOL] AtomicLong threadCounter = new AtomicLong(5); [EOL] MyClass myClass = new MyClass(threadCounter); [EOL] long result = myClass.getThreadCount(); [EOL] assertEquals(5, result); [EOL] }
public void testInitializeThreadWithNamingPattern() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .namingPattern("test-thread-%d") [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.getName().matches("test-thread-\\d+")); [EOL] }
public void testInitializeThreadWithUncaughtExceptionHandler() { [EOL] Thread.UncaughtExceptionHandler handler = (thread, throwable) -> { /* No-op */ }; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .uncaughtExceptionHandler(handler) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(handler, t.getUncaughtExceptionHandler()); [EOL] }
public void testInitializeThreadWithPriority() { [EOL] int priority = Thread.NORM_PRIORITY + 1; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .priority(priority) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(priority, t.getPriority()); [EOL] }
public void testInitializeThreadWithDaemonFlag() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .daemon(true) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.isDaemon()); [EOL] }
public void testInitializeThreadWithNullValues() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder().build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertNotNull(t.getName()); [EOL] assertNull(t.getUncaughtExceptionHandler()); [EOL] assertEquals(Thread.NORM_PRIORITY, t.getPriority()); [EOL] assertFalse(t.isDaemon()); [EOL] }
public void testNamingPatternWithNull() { [EOL] try { [EOL] Builder builder = new Builder(); [EOL] builder.namingPattern(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Naming pattern must not be null!", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNamingPatternWithValidPattern() { [EOL] Builder builder = new Builder(); [EOL] builder.namingPattern("validPattern"); [EOL] assertEquals("validPattern", builder.getNamingPattern()); [EOL] }
public void testTimedSemaphoreConstructorWithValidArguments() { [EOL] ScheduledExecutorService service = mock(ScheduledExecutorService.class); [EOL] long timePeriod = 1L; [EOL] TimeUnit timeUnit = TimeUnit.SECONDS; [EOL] int limit = 10; [EOL] TimedSemaphore semaphore = new TimedSemaphore(service, timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getPeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] assertFalse(semaphore.isOwnExecutor()); [EOL] }
public void testTimedSemaphoreConstructorWithNullService() { [EOL] long timePeriod = 1L; [EOL] TimeUnit timeUnit = TimeUnit.SECONDS; [EOL] int limit = 10; [EOL] TimedSemaphore semaphore = new TimedSemaphore(null, timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getPeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] assertTrue(semaphore.isOwnExecutor()); [EOL] }
public void testTimedSemaphoreConstructorWithInvalidTimePeriod() { [EOL] ScheduledExecutorService service = mock(ScheduledExecutorService.class); [EOL] long timePeriod = 0L; [EOL] TimeUnit timeUnit = TimeUnit.SECONDS; [EOL] int limit = 10; [EOL] try { [EOL] new TimedSemaphore(service, timePeriod, timeUnit, limit); [EOL] fail("Expected IllegalArgumentException for zero time period"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Time period must be greater 0!", iae.getMessage()); [EOL] } [EOL] }
public void testGetLimit() { [EOL] MyClass myClassInstance = new MyClass(10); // Assuming there is a constructor that sets the limit [EOL] int result = myClassInstance.getLimit(); [EOL] assertEquals(10, result); [EOL] }
public void testSetLimit_Positive() { [EOL] YourClass instance = new YourClass(); [EOL] int expected = 10; [EOL] instance.setLimit(expected); [EOL] assertEquals(expected, instance.getLimit()); [EOL] }
public void testSetLimit_Negative() { [EOL] YourClass instance = new YourClass(); [EOL] int expected = -10; [EOL] instance.setLimit(expected); [EOL] assertEquals(expected, instance.getLimit()); [EOL] }
public void testSetLimit_Zero() { [EOL] YourClass instance = new YourClass(); [EOL] int expected = 0; [EOL] instance.setLimit(expected); [EOL] assertEquals(expected, instance.getLimit()); [EOL] }
public void testIsShutdownWhenNotShutdown() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.isShutdown(); [EOL] assertFalse(result); [EOL] }
public void testIsShutdownWhenShutdown() { [EOL] YourClass instance = new YourClass(); [EOL] instance.shutdown(); // Assuming there is a method to shutdown the instance [EOL] boolean result = instance.isShutdown(); [EOL] assertTrue(result); [EOL] }
public void testAcquireWithShutdown() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.shutdown(); [EOL] try { [EOL] semaphore.acquire(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("TimedSemaphore is shut down!", e.getMessage()); [EOL] } [EOL] }
public void testAcquireStartsTimer() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.acquire(); [EOL] assertNotNull(semaphore.getTask()); [EOL] }
public void testAcquireWhenNoLimit() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(TimedSemaphore.NO_LIMIT); [EOL] semaphore.acquire(); [EOL] assertEquals(1, semaphore.getAcquireCount()); [EOL] }
public void testAcquireWhenUnderLimit() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(10); [EOL] for (int i = 0; i < 5; i++) { [EOL] semaphore.acquire(); [EOL] } [EOL] assertEquals(5, semaphore.getAcquireCount()); [EOL] }
public void testAcquireBlocksWhenLimitExceeded() throws InterruptedException { [EOL] final TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(1); [EOL] semaphore.acquire(); // should acquire immediately [EOL] Thread testThread = new Thread(new Runnable() { [EOL] @Override [EOL] public void run() { [EOL] try { [EOL] semaphore.acquire(); // should block [EOL] } catch (InterruptedException e) { [EOL] Thread.currentThread().interrupt(); [EOL] } [EOL] } [EOL] }); [EOL] testThread.start(); [EOL] Thread.sleep(100); // give the thread time to run [EOL] testThread.interrupt(); // we interrupt the thread to stop it [EOL] testThread.join(); // wait for the thread to finish [EOL] assertTrue(testThread.isInterrupted()); [EOL] assertEquals(1, semaphore.getAcquireCount()); [EOL] }
public void testGetLastAcquiresPerPeriod() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] int expected = 0; // Assuming default value is 0, set the expected value accordingly [EOL] int result = instance.getLastAcquiresPerPeriod(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAverageCallsPerPeriod_ZeroPeriodCount() { [EOL] YourClass instance = new YourClass(); [EOL] instance.periodCount = 0; [EOL] instance.totalAcquireCount = 10; // This value is arbitrary as it should not affect the result [EOL] double result = instance.getAverageCallsPerPeriod(); [EOL] assertEquals(0, result, 0.0); [EOL] }
public void testGetAverageCallsPerPeriod_NonZeroPeriodCount() { [EOL] YourClass instance = new YourClass(); [EOL] instance.periodCount = 5; [EOL] instance.totalAcquireCount = 10; [EOL] double result = instance.getAverageCallsPerPeriod(); [EOL] assertEquals(2.0, result, 0.0); [EOL] }
public long getPeriod() { [EOL] return period; [EOL] }
public void testGetUnit() { [EOL] MyClass instance = new MyClass(TimeUnit.SECONDS); [EOL] TimeUnit result = instance.getUnit(); [EOL] assertEquals(TimeUnit.SECONDS, result); [EOL] }
protected ScheduledExecutorService getExecutorService() { [EOL] return executorService; [EOL] }
public void testContextedRuntimeExceptionWithMessageAndCause() { [EOL] String message = "Error message"; [EOL] Throwable cause = new Exception("Cause"); [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(message, cause); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertNotNull(exception.getContext()); [EOL] }
public void testContextedRuntimeExceptionWithNullContext() { [EOL] String message = "Error message"; [EOL] Throwable cause = new RuntimeException("Cause"); [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(message, cause, null); [EOL] assertNotNull(exception); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertNotNull(exception.getContext()); [EOL] } [EOL] public void testContextedRuntimeExceptionWithNonNullContext() { [EOL] String message = "Error message"; [EOL] Throwable cause = new RuntimeException("Cause"); [EOL] ExceptionContext context = new DefaultExceptionContext(); [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(message, cause, context); [EOL] assertNotNull(exception); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertEquals(context, exception.getContext()); [EOL] }
public void testGetMessage_NullSuperMessage() { [EOL] Exception e = new Exception(null); [EOL] CustomException customException = new CustomException(e); [EOL] assertNull(customException.getMessage()); [EOL] }
public void testGetMessage_NonNullSuperMessage() { [EOL] Exception e = new Exception("Super Message"); [EOL] CustomException customException = new CustomException(e); [EOL] assertEquals("Super Message", customException.getMessage()); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessage() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Throwable testException = new ThrowableWithExceptionContext(exceptionContext); [EOL] String result = testException.getFormattedExceptionMessage(null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("Exception Context")); [EOL] }
public void testGetFormattedExceptionMessageWithNonNullBaseMessage() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addValue("key", "value"); [EOL] Throwable testException = new ThrowableWithExceptionContext(exceptionContext); [EOL] String baseMessage = "Base Message"; [EOL] String result = testException.getFormattedExceptionMessage(baseMessage); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(baseMessage)); [EOL] assertTrue(result.contains("key=value")); [EOL] }
public void testTranslateWithBackslashAndUnicode() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u0041", 0, out); [EOL] assertEquals("Should return 6 because it processes '\\u' and four hex digits", 6, result); [EOL] assertEquals("Output should be 'A'", "A", out.toString()); [EOL] }
public void testTranslateWithMultipleLeadingUs() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\uuuu0041", 0, out); [EOL] assertEquals("Should return 8 because it processes multiple 'u's and four hex digits", 8, result); [EOL] assertEquals("Output should be 'A'", "A", out.toString()); [EOL] }
public void testTranslateWithPlusSign() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u+0041", 0, out); [EOL] assertEquals("Should return 7 because it processes '\\u', a plus sign, and four hex digits", 7, result); [EOL] assertEquals("Output should be 'A'", "A", out.toString()); [EOL] }
public void testTranslateWithIncompleteUnicode() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u004", 0, out); [EOL] fail("Should have thrown IllegalArgumentException due to incomplete unicode value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTranslateWithInvalidUnicode() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\uXYZ1", 0, out); [EOL] fail("Should have thrown IllegalArgumentException due to invalid unicode value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTranslateWithoutBackslash() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("A", 0, out); [EOL] assertEquals("Should return 0 because there is no backslash", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateWithBackslashNotFollowedByU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\A", 0, out); [EOL] assertEquals("Should return 0 because backslash is not followed by 'u'", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateAtEndOfString() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u", 0, out); [EOL] fail("Should have thrown IllegalArgumentException due to string ending after '\\u'"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void add_whenOperandIsNull_shouldThrowNullPointerException() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] Number operand = null; [EOL] assertThrows(NullPointerException.class, () -> adder.add(operand)); [EOL] }
public void add_whenOperandIsPositiveNumber_shouldIncreaseValue() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] adder.add(1.0f); // Assuming the initial value is 0 [EOL] Number operand = 2.0f; [EOL] float expected = 3.0f; [EOL] adder.add(operand); [EOL] assertEquals(expected, adder.getValue()); [EOL] }
public void add_whenOperandIsNegativeNumber_shouldDecreaseValue() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] adder.add(1.0f); // Assuming the initial value is 0 [EOL] Number operand = -0.5f; [EOL] float expected = 0.5f; [EOL] adder.add(operand); [EOL] assertEquals(expected, adder.getValue()); [EOL] }
public void add_whenOperandIsZero_shouldNotChangeValue() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] adder.add(1.0f); // Assuming the initial value is 0 [EOL] Number operand = 0.0f; [EOL] float expected = 1.0f; [EOL] adder.add(operand); [EOL] assertEquals(expected, adder.getValue()); [EOL] }
public void testCompareTo_SameValue() { [EOL] MutableFloat first = new MutableFloat(1.0f); [EOL] MutableFloat second = new MutableFloat(1.0f); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableFloat first = new MutableFloat(1.0f); [EOL] MutableFloat second = new MutableFloat(2.0f); [EOL] int result = first.compareTo(second); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] MutableFloat first = new MutableFloat(2.0f); [EOL] MutableFloat second = new MutableFloat(1.0f); [EOL] int result = first.compareTo(second); [EOL] assertTrue(result > 0); [EOL] }
public void testToString_whenValueIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setValue("Test"); [EOL] String expected = "Test"; [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToString_whenValueIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setValue(null); [EOL] String expected = "null"; [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
It appears that the provided input text is the constructor for a utility class, likely intended to be private to prevent instantiation. However, the constructor is marked as public, which is unusual for utility classes. Typically, utility classes have a private constructor because they contain static methods and are not meant to be instantiated. [EOL] Since constructors cannot be directly tested and the provided constructor does nothing but call the superclass constructor (which is `Object` by default), there is no meaningful behavior to test here. In a typical scenario, you would want to ensure that the constructor is private to prevent instantiation of the utility class. However, since the constructor is public and does nothing, there is no test case to generate that would increase line coverage or provide meaningful assertions. [EOL] If the intent was to ensure that the class cannot be instantiated, you would modify the class to have a private constructor and then write a test that reflects this. But as it stands, no test case is needed for the provided constructor code.
public void testGetShortClassNameWithNullClass() { [EOL] String result = ClassUtils.getShortClassName(null); [EOL] assertEquals("", result); [EOL] }
public void testGetShortClassNameWithNonNullClass() { [EOL] String result = ClassUtils.getShortClassName(java.lang.String.class); [EOL] assertEquals("String", result); [EOL] }
public void testGetShortClassNameEmpty() { [EOL] String className = ""; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals(StringUtils.EMPTY, result); [EOL] } [EOL] public void testGetShortClassNameArray() { [EOL] String className = "[[Ljava.lang.String;"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String[][]", result); [EOL] } [EOL] public void testGetShortClassNameInnerClass() { [EOL] String className = "java.util.Map$Entry"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("Entry", result); [EOL] } [EOL] public void testGetShortClassNameNoPackage() { [EOL] String className = "String"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testGetShortClassNameWithPackage() { [EOL] String className = "java.lang.String"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testGetShortClassNamePrimitiveArray() { [EOL] String className = "[I"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("int[]", result); [EOL] } [EOL] public void testGetShortClassNameComplexArray() { [EOL] String className = "[[Ljava.util.Map$Entry;"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("Entry[][]", result); [EOL] }

public void testGetPackageName_NullOrEmpty() { [EOL] assertEquals("", StringUtils.getPackageName(null)); [EOL] assertEquals("", StringUtils.getPackageName("")); [EOL] } [EOL] public void testGetPackageName_NoPackage() { [EOL] assertEquals("", StringUtils.getPackageName("NoPackageClass")); [EOL] } [EOL] public void testGetPackageName_WithPackage() { [EOL] assertEquals("java.lang", StringUtils.getPackageName("java.lang.String")); [EOL] } [EOL] public void testGetPackageName_ArrayType() { [EOL] assertEquals("java.lang", StringUtils.getPackageName("[Ljava.lang.String;")); [EOL] } [EOL] public void testGetPackageName_ArrayTypePrimitive() { [EOL] assertEquals("", StringUtils.getPackageName("[I")); [EOL] } [EOL] public void testGetPackageName_WithPackageAndSemicolon() { [EOL] assertEquals("java.lang", StringUtils.getPackageName("Ljava.lang.String;")); [EOL] }

public void testGetAllSuperclassesWithNullInput() { [EOL] List<Class<?>> result = MyClass.getAllSuperclasses(null); [EOL] assertNull(result); [EOL] }
public void testGetAllSuperclassesWithObjectClass() { [EOL] List<Class<?>> result = MyClass.getAllSuperclasses(Object.class); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetAllSuperclassesWithCustomClass() { [EOL] List<Class<?>> result = MyClass.getAllSuperclasses(CustomClass.class); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue(result.contains(Object.class)); [EOL] }
public void testConvertClassesToClassNames_withNullInput() { [EOL] List<Class<?>> classes = null; [EOL] List<String> classNames = ClassNameUtils.convertClassesToClassNames(classes); [EOL] assertNull(classNames); [EOL] } [EOL] public void testConvertClassesToClassNames_withEmptyList() { [EOL] List<Class<?>> classes = new ArrayList<>(); [EOL] List<String> classNames = ClassNameUtils.convertClassesToClassNames(classes); [EOL] assertTrue(classNames.isEmpty()); [EOL] } [EOL] public void testConvertClassesToClassNames_withValidClasses() { [EOL] List<Class<?>> classes = new ArrayList<>(); [EOL] classes.add(String.class); [EOL] classes.add(Integer.class); [EOL] List<String> classNames = ClassNameUtils.convertClassesToClassNames(classes); [EOL] assertEquals(2, classNames.size()); [EOL] assertEquals("java.lang.String", classNames.get(0)); [EOL] assertEquals("java.lang.Integer", classNames.get(1)); [EOL] } [EOL] public void testConvertClassesToClassNames_withNullClassElement() { [EOL] List<Class<?>> classes = new ArrayList<>(); [EOL] classes.add(String.class); [EOL] classes.add(null); [EOL] List<String> classNames = ClassNameUtils.convertClassesToClassNames(classes); [EOL] assertEquals(2, classNames.size()); [EOL] assertEquals("java.lang.String", classNames.get(0)); [EOL] assertNull(classNames.get(1)); [EOL] }
public void testIsAssignable_NullNull() { [EOL] boolean result = ClassUtils.isAssignable(null, (Class<?>[]) null); [EOL] assertTrue(result); [EOL] }
public void testIsAssignable_EmptyNull() { [EOL] boolean result = ClassUtils.isAssignable(new Class[]{}, (Class<?>[]) null); [EOL] assertTrue(result); [EOL] }
public void testIsAssignable_NullEmpty() { [EOL] boolean result = ClassUtils.isAssignable(null, new Class[]{}); [EOL] assertFalse(result); [EOL] }
public void testIsAssignable_EmptyEmpty() { [EOL] boolean result = ClassUtils.isAssignable(new Class[]{}, new Class[]{}); [EOL] assertTrue(result); [EOL] }
public void testIsAssignable_ValidInvalid() { [EOL] boolean result = ClassUtils.isAssignable(new Class[]{Integer.class}, new Class[]{String.class}); [EOL] assertFalse(result); [EOL] }
public void testIsAssignable_ValidValid() { [EOL] boolean result = ClassUtils.isAssignable(new Class[]{Object.class}, new Class[]{String.class}); [EOL] assertTrue(result); [EOL] }
public void testIsAssignable_BothArraysNull() { [EOL] boolean result = isAssignable(null, null, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignable_BothArraysEmpty() { [EOL] boolean result = isAssignable(new Class<?>[0], new Class<?>[0], true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignable_DifferentLengthArrays() { [EOL] boolean result = isAssignable(new Class<?>[]{Integer.class}, new Class<?>[]{Integer.class, String.class}, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignable_SameLengthIncompatibleTypes() { [EOL] boolean result = isAssignable(new Class<?>[]{Integer.class}, new Class<?>[]{String.class}, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignable_SameLengthCompatibleTypes() { [EOL] boolean result = isAssignable(new Class<?>[]{Object.class}, new Class<?>[]{String.class}, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignable_SameLengthWithAutoboxing() { [EOL] boolean result = isAssignable(new Class<?>[]{int.class}, new Class<?>[]{Integer.class}, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignable_SameLengthWithoutAutoboxing() { [EOL] boolean result = isAssignable(new Class<?>[]{int.class}, new Class<?>[]{Integer.class}, false); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithNullToClass() { [EOL] boolean result = isAssignable(String.class, null, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithNullCls() { [EOL] boolean result = isAssignable(null, String.class, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingTruePrimitiveToWrapper() { [EOL] boolean result = isAssignable(int.class, Integer.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingTrueWrapperToPrimitive() { [EOL] boolean result = isAssignable(Integer.class, int.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingFalsePrimitiveToWrapper() { [EOL] boolean result = isAssignable(int.class, Integer.class, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingFalseWrapperToPrimitive() { [EOL] boolean result = isAssignable(Integer.class, int.class, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithEqualClasses() { [EOL] boolean result = isAssignable(String.class, String.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveToNonAssignablePrimitive() { [EOL] boolean result = isAssignable(int.class, boolean.class, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveToAssignablePrimitive() { [EOL] boolean result = isAssignable(int.class, double.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithNonPrimitiveToPrimitive() { [EOL] boolean result = isAssignable(String.class, int.class, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithAssignableNonPrimitives() { [EOL] boolean result = isAssignable(Number.class, Integer.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithNonAssignableNonPrimitives() { [EOL] boolean result = isAssignable(String.class, Integer.class, true); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithPrimitiveBoolean() { [EOL] boolean result = isAssignable(boolean.class, boolean.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveDouble() { [EOL] boolean result = isAssignable(double.class, double.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveFloatToDouble() { [EOL] boolean result = isAssignable(float.class, double.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveCharacterToInteger() { [EOL] boolean result = isAssignable(char.class, int.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveShortToInteger() { [EOL] boolean result = isAssignable(short.class, int.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveByteToShort() { [EOL] boolean result = isAssignable(byte.class, short.class, true); [EOL] assertTrue(result); [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL] try { [EOL] Class<?> clazz; [EOL] if (abbreviationMap.containsKey(className)) { [EOL] final String clsName = "[" + abbreviationMap.get(className); [EOL] clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL] } else { [EOL] clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL] } [EOL] return clazz; [EOL] } catch (final ClassNotFoundException ex) { [EOL] final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL] if (lastDotIndex != -1) { [EOL] try { [EOL] return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL] } catch (final ClassNotFoundException ex2) { [EOL] } [EOL] } [EOL] throw ex; [EOL] } [EOL] }
public void testGetClassWithExistingClassName() throws ClassNotFoundException { [EOL] String className = "java.lang.String"; [EOL] Class<?> clazz = StringUtils.getClass(className); [EOL] assertNotNull(clazz); [EOL] assertEquals(String.class, clazz); [EOL] }
public void testGetClassWithNonExistingClassName() { [EOL] String className = "non.existing.ClassName"; [EOL] try { [EOL] StringUtils.getClass(className); [EOL] fail("Should have thrown ClassNotFoundException"); [EOL] } catch (ClassNotFoundException expected) { [EOL] } [EOL] }
public void testGetClassWithNonNullContextClassLoaderAndInitialize() throws ClassNotFoundException { [EOL] String className = "java.lang.String"; [EOL] boolean initialize = true; [EOL] Class<?> result = ClassUtils.getClass(className, initialize); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] } [EOL] public void testGetClassWithNonNullContextClassLoaderAndNoInitialize() throws ClassNotFoundException { [EOL] String className = "java.lang.String"; [EOL] boolean initialize = false; [EOL] Class<?> result = ClassUtils.getClass(className, initialize); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] } [EOL] public void testGetClassWithNullContextClassLoaderAndInitialize() throws ClassNotFoundException { [EOL] Thread.currentThread().setContextClassLoader(null); [EOL] String className = "java.lang.String"; [EOL] boolean initialize = true; [EOL] Class<?> result = ClassUtils.getClass(className, initialize); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] } [EOL] public void testGetClassWithNullContextClassLoaderAndNoInitialize() throws ClassNotFoundException { [EOL] Thread.currentThread().setContextClassLoader(null); [EOL] String className = "java.lang.String"; [EOL] boolean initialize = false; [EOL] Class<?> result = ClassUtils.getClass(className, initialize); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetClassWithInvalidClassName() { [EOL] String className = "invalid.ClassName"; [EOL] boolean initialize = true; [EOL] try { [EOL] ClassUtils.getClass(className, initialize); [EOL] fail("Should have thrown ClassNotFoundException"); [EOL] } catch (ClassNotFoundException e) { [EOL] } [EOL] }
public void testToCanonicalNameWithNullInput() { [EOL] try { [EOL] String result = toCanonicalName(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("className must not be null.", e.getMessage()); [EOL] } [EOL] }
public void testToCanonicalNameWithEmptyString() { [EOL] try { [EOL] String result = toCanonicalName(""); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("className must not be null.", e.getMessage()); [EOL] } [EOL] }
public void testToCanonicalNameWithoutArrayBrackets() { [EOL] String className = "java.lang.String"; [EOL] String result = toCanonicalName(className); [EOL] assertEquals("java.lang.String", result); [EOL] }
public void testToCanonicalNameWithArrayBrackets() { [EOL] String className = "java.lang.String[]"; [EOL] String result = toCanonicalName(className); [EOL] assertEquals("[Ljava.lang.String;", result); [EOL] }
public void testToCanonicalNameWithMultipleArrayBrackets() { [EOL] String className = "java.lang.String[][]"; [EOL] String result = toCanonicalName(className); [EOL] assertEquals("[[Ljava.lang.String;", result); [EOL] }
public void testToCanonicalNameWithWhitespace() { [EOL] String className = " java.lang.String "; [EOL] String result = toCanonicalName(className); [EOL] assertEquals("java.lang.String", result); [EOL] }
public void testToCanonicalNameWithPrimitiveType() { [EOL] String className = "int[]"; [EOL] String result = toCanonicalName(className); [EOL] assertEquals("[I", result); [EOL] }
public void testGetPackageCanonicalNameWithNullObject() { [EOL] String expected = "default"; [EOL] String actual = StringUtils.getPackageCanonicalName(null, "default"); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetPackageCanonicalNameWithNonNullObject() { [EOL] String expected = "java.lang"; [EOL] Object object = new String(); [EOL] String actual = StringUtils.getPackageCanonicalName(object, "default"); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetPackageCanonicalName_NullInput() { [EOL] String result = ClassUtils.getPackageCanonicalName(null); [EOL] assertNull(result); [EOL] } [EOL] public void testGetPackageCanonicalName_EmptyString() { [EOL] String result = ClassUtils.getPackageCanonicalName(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetPackageCanonicalName_RegularClass() { [EOL] String result = ClassUtils.getPackageCanonicalName("java.lang.String"); [EOL] assertEquals("java.lang", result); [EOL] } [EOL] public void testGetPackageCanonicalName_DefaultPackageClass() { [EOL] String result = ClassUtils.getPackageCanonicalName("SomeClass"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetPackageCanonicalName_ArrayClass() { [EOL] String result = ClassUtils.getPackageCanonicalName("[Ljava.lang.String;"); [EOL] assertEquals("java.lang", result); [EOL] } [EOL] public void testGetPackageCanonicalName_PrimitiveArray() { [EOL] String result = ClassUtils.getPackageCanonicalName("[I"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetPackageCanonicalName_InnerClass() { [EOL] String result = ClassUtils.getPackageCanonicalName("java.util.Map$Entry"); [EOL] assertEquals("java.util", result); [EOL] }
public void testStart_WhenNotStartedAndExternalExecutorIsNull() { [EOL] MyClass testClass = new MyClass(); [EOL] when(testClass.isStarted()).thenReturn(false); [EOL] when(testClass.getExternalExecutor()).thenReturn(null); [EOL] when(testClass.createExecutor()).thenReturn(mock(ExecutorService.class)); [EOL] when(testClass.createTask(any())).thenReturn(mock(Callable.class)); [EOL] boolean result = testClass.start(); [EOL] assertTrue(result); [EOL] assertNotNull(testClass.executor); [EOL] assertNotNull(testClass.future); [EOL] }
public void testStart_WhenNotStartedAndExternalExecutorIsNotNull() { [EOL] MyClass testClass = new MyClass(); [EOL] when(testClass.isStarted()).thenReturn(false); [EOL] ExecutorService mockExecutor = mock(ExecutorService.class); [EOL] when(testClass.getExternalExecutor()).thenReturn(mockExecutor); [EOL] when(testClass.createTask(null)).thenReturn(mock(Callable.class)); [EOL] boolean result = testClass.start(); [EOL] assertTrue(result); [EOL] assertSame(mockExecutor, testClass.executor); [EOL] assertNotNull(testClass.future); [EOL] }
public void testStart_WhenAlreadyStarted() { [EOL] MyClass testClass = new MyClass(); [EOL] when(testClass.isStarted()).thenReturn(true); [EOL] boolean result = testClass.start(); [EOL] assertFalse(result); [EOL] }
public void testGetWhenFutureCompletesSuccessfully() throws Exception { [EOL] Future<T> future = mock(Future.class); [EOL] T expectedValue = mock(T.class); [EOL] when(future.get()).thenReturn(expectedValue); [EOL] MyClass<T> myClass = new MyClass<>(future); [EOL] T actualValue = myClass.get(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetWhenExecutionExceptionOccurs() throws Exception { [EOL] Future<T> future = mock(Future.class); [EOL] ExecutionException executionException = new ExecutionException(new Exception()); [EOL] when(future.get()).thenThrow(executionException); [EOL] MyClass<T> myClass = new MyClass<>(future); [EOL] try { [EOL] myClass.get(); [EOL] fail("Expected ConcurrentUtils.handleCause to be called with ExecutionException"); [EOL] } catch (ConcurrentException expected) { [EOL] } [EOL] }
public void testGetWhenInterruptedExceptionOccurs() throws Exception { [EOL] Future<T> future = mock(Future.class); [EOL] InterruptedException interruptedException = new InterruptedException(); [EOL] when(future.get()).thenThrow(interruptedException); [EOL] MyClass<T> myClass = new MyClass<>(future); [EOL] try { [EOL] myClass.get(); [EOL] fail("Expected InterruptedException to be thrown"); [EOL] } catch (ConcurrentException expected) { [EOL] assertTrue(Thread.currentThread().isInterrupted()); [EOL] } [EOL] }
public void testGetFutureWhenNotStarted() { [EOL] YourClass instance = new YourClass(); [EOL] try { [EOL] instance.getFuture(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("start() must be called first!", e.getMessage()); [EOL] } [EOL] }
public void testGetFutureWhenStarted() { [EOL] YourClass instance = new YourClass(); [EOL] instance.start(); // Assuming start() method initializes the future. [EOL] assertNotNull(instance.getFuture()); [EOL] }
public void testConcurrentRuntimeExceptionWithMessageAndCause() { [EOL] String expectedMessage = "Test Message"; [EOL] Throwable expectedCause = new RuntimeException("Cause"); [EOL] ConcurrentRuntimeException exception = new ConcurrentRuntimeException(expectedMessage, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public void testConcurrentRuntimeExceptionWithNullMessageAndNullCause() { [EOL] ConcurrentRuntimeException exception = new ConcurrentRuntimeException(null, null); [EOL] assertNull(exception.getMessage()); [EOL] assertNull(exception.getCause()); [EOL] }
public void testNoneLookup() { [EOL] StrLookup<?> lookup = StrLookup.noneLookup(); [EOL] assertNotNull(lookup); [EOL] assertSame(StrLookup.noneLookup(), lookup); [EOL] }
public void testMapLookupWithNonNullMap() { [EOL] Map<String, String> map = new HashMap<>(); [EOL] map.put("key", "value"); [EOL] StrLookup<String> lookup = StringUtils.mapLookup(map); [EOL] assertEquals("value", lookup.lookup("key")); [EOL] }
public void testMapLookupWithNullMap() { [EOL] StrLookup<Object> lookup = StringUtils.mapLookup(null); [EOL] assertNull(lookup.lookup("key")); [EOL] }
public void testStrLookupConstructor() { [EOL] StrLookup lookup = new StrLookup() {}; [EOL] assertNotNull(lookup); [EOL] }
public void testMapStrLookupWithNull() { [EOL] MapStrLookup<Object> lookup = new MapStrLookup<>(null); [EOL] assertNull("Map should be null", lookup.map); [EOL] }
public void testMapStrLookupWithEmptyMap() { [EOL] Map<String, Object> emptyMap = new HashMap<>(); [EOL] MapStrLookup<Object> lookup = new MapStrLookup<>(emptyMap); [EOL] assertNotNull("Map should not be null", lookup.map); [EOL] assertTrue("Map should be empty", lookup.map.isEmpty()); [EOL] }
public void testMapStrLookupWithNonEmptyMap() { [EOL] Map<String, Object> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("key", "value"); [EOL] MapStrLookup<Object> lookup = new MapStrLookup<>(nonEmptyMap); [EOL] assertNotNull("Map should not be null", lookup.map); [EOL] assertFalse("Map should not be empty", lookup.map.isEmpty()); [EOL] assertEquals("Map should contain the key-value pair", "value", lookup.map.get("key")); [EOL] }
public void testLookupWhenMapIsNull() { [EOL] MapLookup mapLookup = new MapLookup(null); [EOL] String result = mapLookup.lookup("key"); [EOL] assertNull(result); [EOL] } [EOL] public void testLookupWhenKeyNotPresent() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] MapLookup mapLookup = new MapLookup(map); [EOL] String result = mapLookup.lookup("key"); [EOL] assertNull(result); [EOL] } [EOL] public void testLookupWhenKeyPresent() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] map.put("key", "value"); [EOL] MapLookup mapLookup = new MapLookup(map); [EOL] String result = mapLookup.lookup("key"); [EOL] assertEquals("value", result); [EOL] }
public void testExtractCauseUncheckedWithNullExecutionException() { [EOL] ExecutionException ex = null; [EOL] ConcurrentRuntimeException result = extractCauseUnchecked(ex); [EOL] assertNull(result); [EOL] }
public void testExtractCauseUncheckedWithNullCause() { [EOL] ExecutionException ex = new ExecutionException("Error", null); [EOL] ConcurrentRuntimeException result = extractCauseUnchecked(ex); [EOL] assertNull(result); [EOL] }
public void testExtractCauseUncheckedWithNonNullCause() { [EOL] Throwable cause = new RuntimeException("Cause"); [EOL] ExecutionException ex = new ExecutionException("Error", cause); [EOL] try { [EOL] extractCauseUnchecked(ex); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (ConcurrentRuntimeException cre) { [EOL] assertEquals("Error", cre.getMessage()); [EOL] assertSame(cause, cre.getCause()); [EOL] } [EOL] }
public void testHandleCauseUncheckedWithConcurrentRuntimeException() { [EOL] ExecutionException ex = new ExecutionException(new ConcurrentRuntimeException("Test")); [EOL] try { [EOL] Lang3.handleCauseUnchecked(ex); [EOL] fail("Should have thrown ConcurrentRuntimeException"); [EOL] } catch (ConcurrentRuntimeException crex) { [EOL] assertEquals("Test", crex.getMessage()); [EOL] } [EOL] }
public void testHandleCauseUncheckedWithNonConcurrentRuntimeException() { [EOL] ExecutionException ex = new ExecutionException(new RuntimeException("Test")); [EOL] try { [EOL] Lang3.handleCauseUnchecked(ex); [EOL] fail("Should have thrown RuntimeException wrapped in a ConcurrentRuntimeException"); [EOL] } catch (ConcurrentRuntimeException crex) { [EOL] Throwable cause = crex.getCause(); [EOL] assertTrue(cause instanceof RuntimeException); [EOL] assertEquals("Test", cause.getMessage()); [EOL] } [EOL] }
public void testHandleCauseUncheckedWithNullCause() { [EOL] ExecutionException ex = new ExecutionException(null); [EOL] Lang3.handleCauseUnchecked(ex); [EOL] }
public void testThrowCauseWithRuntimeException() { [EOL] ExecutionException ex = new ExecutionException(new RuntimeException("Test RuntimeException")); [EOL] try { [EOL] throwCause(ex); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Test RuntimeException", e.getMessage()); [EOL] } [EOL] }
public void testThrowCauseWithError() { [EOL] ExecutionException ex = new ExecutionException(new Error("Test Error")); [EOL] try { [EOL] throwCause(ex); [EOL] } catch (Error e) { [EOL] assertEquals("Test Error", e.getMessage()); [EOL] } [EOL] }
public void testThrowCauseWithNonRuntimeExceptionOrError() { [EOL] ExecutionException ex = new ExecutionException(new Exception("Test Exception")); [EOL] try { [EOL] throwCause(ex); [EOL] fail("Expected an Exception to be thrown"); [EOL] } catch (ExecutionException e) { [EOL] assertEquals("Test Exception", e.getCause().getMessage()); [EOL] } [EOL] }
public void testCreateIfAbsentWithNullMap() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = null; [EOL] Object key = new Object(); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentWithNullInitializer() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] ConcurrentInitializer<Object> init = null; [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentWithExistingKey() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertSame(value, result); [EOL] }
public void testCreateIfAbsentWithAbsentKey() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertNotNull(result); [EOL] assertSame(result, map.get(key)); [EOL] }
private void init() { [EOL] final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL] thisYear = definingCalendar.get(Calendar.YEAR); [EOL] final StringBuilder regex = new StringBuilder(); [EOL] final List<Strategy> collector = new ArrayList<Strategy>(); [EOL] final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL] if (!patternMatcher.lookingAt()) { [EOL] throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL] } [EOL] currentFormatField = patternMatcher.group(); [EOL] Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL] for (; ; ) { [EOL] patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL] if (!patternMatcher.lookingAt()) { [EOL] nextStrategy = null; [EOL] break; [EOL] } [EOL] final String nextFormatField = patternMatcher.group(); [EOL] nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL] if (currentStrategy.addRegex(this, regex)) { [EOL] collector.add(currentStrategy); [EOL] } [EOL] currentFormatField = nextFormatField; [EOL] currentStrategy = nextStrategy; [EOL] } [EOL] if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL] throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL] } [EOL] if (currentStrategy.addRegex(this, regex)) { [EOL] collector.add(currentStrategy); [EOL] } [EOL] currentFormatField = null; [EOL] strategies = collector.toArray(new Strategy[collector.size()]); [EOL] parsePattern = Pattern.compile(regex.toString()); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
@Override [EOL] public String getPattern() { [EOL] return pattern; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testStrSubstitutorWithMapConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] assertEquals("value", substitutor.replace("${key}")); [EOL] } [EOL] public void testStrSubstitutorWithEmptyMapConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] assertEquals("${key}", substitutor.replace("${key}")); [EOL] } [EOL] public void testStrSubstitutorWithNullMapConstructor() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(null); [EOL] assertEquals("${key}", substitutor.replace("${key}")); [EOL] } [EOL] public void testStrSubstitutorWithMapAndPrefixSuffixConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, "<", ">"); [EOL] assertEquals("value", substitutor.replace("<key>")); [EOL] } [EOL] public void testStrSubstitutorWithMapPrefixSuffixAndEscapeConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, "<", ">", '!'); [EOL] assertEquals("value", substitutor.replace("<key>")); [EOL] assertEquals("<key>", substitutor.replace("!<key>")); [EOL] } [EOL] public void testStrSubstitutorWithStrLookupConstructor() { [EOL] StrLookup<String> variableResolver = StrLookup.mapLookup(Collections.singletonMap("key", "value")); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver); [EOL] assertEquals("value", substitutor.replace("${key}")); [EOL] } [EOL] public void testStrSubstitutorWithStrLookupAndPrefixSuffixEscapeConstructor() { [EOL] StrLookup<String> variableResolver = StrLookup.mapLookup(Collections.singletonMap("key", "value")); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, StrMatcher.stringMatcher("<"), StrMatcher.stringMatcher(">"), '!'); [EOL] assertEquals("value", substitutor.replace("<key>")); [EOL] assertEquals("<key>", substitutor.replace("!<key>")); [EOL] }
public void testStrSubstitutorConstructorWithVariableResolverPrefixMatcherSuffixMatcherEscape() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrMatcher prefixMatcher = StrMatcher.stringMatcher("<<"); [EOL] StrMatcher suffixMatcher = StrMatcher.stringMatcher(">>"); [EOL] char escape = '!'; [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, prefixMatcher, suffixMatcher, escape); [EOL] assertEquals(variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals(prefixMatcher, substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(suffixMatcher, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(escape, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorDefaultConstructor() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] assertNotNull(substitutor.getVariableResolver()); [EOL] assertEquals(StrSubstitutor.DEFAULT_PREFIX, substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_SUFFIX, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] assertEquals(StrLookup.mapLookup(valueMap), substitutor.getVariableResolver()); [EOL] assertEquals(StrSubstitutor.DEFAULT_PREFIX, substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_SUFFIX, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithValueMapPrefixSuffix() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String prefix = "((("; [EOL] String suffix = ")))"; [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, prefix, suffix); [EOL] assertEquals(StrLookup.mapLookup(valueMap), substitutor.getVariableResolver()); [EOL] assertEquals(StrMatcher.stringMatcher(prefix), substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher(suffix), substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithValueMapPrefixSuffixEscape() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String prefix = "{{{"; [EOL] String suffix = "}}}"; [EOL] char escape = '*'; [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, prefix, suffix, escape); [EOL] assertEquals(StrLookup.mapLookup(valueMap), substitutor.getVariableResolver()); [EOL] assertEquals(StrMatcher.stringMatcher(prefix), substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher(suffix), substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(escape, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithVariableResolver() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver); [EOL] assertEquals(variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals(StrSubstitutor.DEFAULT_PREFIX, substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_SUFFIX, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithVariableResolverPrefixSuffixEscape() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] String prefix = "[["; [EOL] String suffix = "]]"; [EOL] char escape = '^'; [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, prefix, suffix, escape); [EOL] assertEquals(variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals(StrMatcher.stringMatcher(prefix), substitutor.getVariablePrefixMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher(suffix), substitutor.getVariableSuffixMatcher()); [EOL] assertEquals(escape, substitutor.getEscapeChar()); [EOL] }
public String replace(final String source) { [EOL] if (source == null) { [EOL] return null; [EOL] } [EOL] final StrBuilder buf = new StrBuilder(source); [EOL] if (substitute(buf, 0, source.length()) == false) { [EOL] return source; [EOL] } [EOL] return buf.toString(); [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testReplaceWithNullSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String result = sub.replace(null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceWithValidSourceNoSubstitution() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "No substitution here"; [EOL] String result = sub.replace(source, 0, source.length()); [EOL] assertEquals("No substitution here", result); [EOL] }
public void testReplaceWithValidSourceAndSubstitution() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap); [EOL] String source = "${key}"; [EOL] String result = sub.replace(source, 0, source.length()); [EOL] assertEquals("value", result); [EOL] }
public void testReplaceWithOffsetAndLength() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "Ignore this part${key}Include this part"; [EOL] String result = sub.replace(source, 15, 17); [EOL] assertEquals("Include this part", result); [EOL] }
public void testReplaceWithInvalidOffset() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "Short string"; [EOL] try { [EOL] sub.replace(source, 20, 10); [EOL] fail("IndexOutOfBoundsException expected"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceWithInvalidLength() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "Short string"; [EOL] try { [EOL] sub.replace(source, 0, 50); [EOL] fail("IndexOutOfBoundsException expected"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceCharArray_NullInput() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = null; [EOL] String result = sub.replace(source); [EOL] assertNull(result); [EOL] }
public void testReplaceCharArray_EmptyInput() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = new char[0]; [EOL] String result = sub.replace(source); [EOL] assertEquals("", result); [EOL] }
public void testReplaceCharArray_NonEmptyInput() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = new char[]{'a', 'b', 'c'}; [EOL] String result = sub.replace(source); [EOL] assertEquals("abc", result); [EOL] }
public void testReplaceWithNullStringBuffer() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String result = sub.replace((StringBuffer) null); [EOL] assertNull(result); [EOL] } [EOL] public void testReplaceWithStringBuffer() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("abc"); [EOL] String result = sub.replace(source); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public String replace(CharSequence source) { [EOL] if (source == null) { [EOL] return null; [EOL] } [EOL] return replace(source, 0, source.length()); [EOL] }
public void testReplaceWithNullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace((CharSequence) null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceWithValidSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace("abcdef", 2, 3); [EOL] assertNotNull(result); [EOL] assertEquals("cde", result); [EOL] }
public void testReplaceWithEmptySource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace("", 0, 0); [EOL] assertEquals("", result); [EOL] }
public void testReplaceWithOutOfBoundsOffset() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.replace("abcdef", 10, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceWithOutOfBoundsLength() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.replace("abcdef", 2, 10); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceWithNegativeOffset() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.replace("abcdef", -1, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceWithNegativeLength() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.replace("abcdef", 2, -1); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_StrBuilder_Null() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace((StrBuilder) null); [EOL] assertNull(result); [EOL] }
public void testReplace_StrBuilder() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abc"); [EOL] String result = substitutor.replace(source); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public void testReplaceWithNullSource() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] String result = strSubstitutor.replace((Object) null); [EOL] assertNull(result); [EOL] }
public void testReplaceWithNonNullSource() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] String input = "test"; [EOL] String result = strSubstitutor.replace((Object) input); [EOL] assertNotNull(result); [EOL] assertEquals("test", result); [EOL] }
public void testReplaceInStringBuffer_NullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] boolean result = substitutor.replaceIn((StringBuffer) null); [EOL] assertFalse("replaceIn should return false for null source", result); [EOL] }
public void testReplaceInStringBuffer_EmptySource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer(""); [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertTrue("replaceIn should return true for empty source", result); [EOL] assertEquals("Result should be an empty StringBuffer", "", source.toString()); [EOL] }
public void testReplaceInStringBuffer_NonEmptySource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("test"); [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertTrue("replaceIn should return true for non-empty source", result); [EOL] assertEquals("Result should be the same as the input", "test", source.toString()); [EOL] }
public boolean replaceIn(final StringBuffer source, final int offset, final int length) { [EOL] if (source == null) { [EOL] return false; [EOL] } [EOL] final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL] if (substitute(buf, 0, length) == false) { [EOL] return false; [EOL] } [EOL] source.replace(offset, offset + length, buf.toString()); [EOL] return true; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testReplaceInStringBuilderWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] boolean result = substitutor.replaceIn((StringBuilder) null); [EOL] assertFalse("replaceIn should return false when source is null", result); [EOL] }
public void testReplaceInStringBuilderWithNonNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuilder source = new StringBuilder("test"); [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertTrue("replaceIn should return true when source is not null", result); [EOL] }
public void testReplaceInStringBuilderNullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuilder source = null; [EOL] boolean result = substitutor.replaceIn(source, 0, 10); [EOL] assertFalse(result); [EOL] }
public void testReplaceInStringBuilderValidSourceNoSubstitution() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuilder source = new StringBuilder("No substitution here"); [EOL] boolean result = substitutor.replaceIn(source, 0, source.length()); [EOL] assertFalse(result); [EOL] }
public void testReplaceInStringBuilderValidSourceWithSubstitution() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] StringBuilder source = new StringBuilder("${key} substitution here"); [EOL] boolean result = substitutor.replaceIn(source, 0, source.length()); [EOL] assertTrue(result); [EOL] assertEquals("value substitution here", source.toString()); [EOL] }
public void testReplaceInStringBuilderValidSourceWithSubstitutionOffsetLength() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] StringBuilder source = new StringBuilder("Prefix ${key} substitution here"); [EOL] boolean result = substitutor.replaceIn(source, 7, 15); [EOL] assertTrue(result); [EOL] assertEquals("Prefix value substitution here", source.toString()); [EOL] }
public void testReplaceInStringBuilderValidSourceWithSubstitutionInvalidOffset() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] StringBuilder source = new StringBuilder("Prefix ${key} substitution here"); [EOL] boolean result = substitutor.replaceIn(source, 50, 10); [EOL] assertFalse(result); [EOL] }
public void testReplaceInStringBuilderValidSourceWithSubstitutionInvalidLength() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] StringBuilder source = new StringBuilder("Prefix ${key} substitution here"); [EOL] boolean result = substitutor.replaceIn(source, 0, 50); [EOL] assertTrue(result); [EOL] assertEquals("Prefix value substitution here", source.toString()); [EOL] }
public void testReplaceInStrBuilderWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = null; [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertFalse("replaceIn should return false when source is null", result); [EOL] }
public void testReplaceInStrBuilderWithNonNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("test"); [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertTrue("replaceIn should return true when source is non-null", result); [EOL] }
protected boolean substitute(final StrBuilder buf, final int offset, final int length) { [EOL] return substitute(buf, offset, length, null) > 0; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL] final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL] final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL] final char escape = getEscapeChar(); [EOL] final boolean top = priorVariables == null; [EOL] boolean altered = false; [EOL] int lengthChange = 0; [EOL] char[] chars = buf.buffer; [EOL] int bufEnd = offset + length; [EOL] int pos = offset; [EOL] while (pos < bufEnd) { [EOL] final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL] if (startMatchLen == 0) { [EOL] pos++; [EOL] } else { [EOL] if (pos > offset && chars[pos - 1] == escape) { [EOL] buf.deleteCharAt(pos - 1); [EOL] chars = buf.buffer; [EOL] lengthChange--; [EOL] altered = true; [EOL] bufEnd--; [EOL] } else { [EOL] final int startPos = pos; [EOL] pos += startMatchLen; [EOL] int endMatchLen = 0; [EOL] int nestedVarCount = 0; [EOL] while (pos < bufEnd) { [EOL] if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL] nestedVarCount++; [EOL] pos += endMatchLen; [EOL] continue; [EOL] } [EOL] endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL] if (endMatchLen == 0) { [EOL] pos++; [EOL] } else { [EOL] if (nestedVarCount == 0) { [EOL] String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL] if (isEnableSubstitutionInVariables()) { [EOL] final StrBuilder bufName = new StrBuilder(varName); [EOL] substitute(bufName, 0, bufName.length()); [EOL] varName = bufName.toString(); [EOL] } [EOL] pos += endMatchLen; [EOL] final int endPos = pos; [EOL] if (priorVariables == null) { [EOL] priorVariables = new ArrayList<String>(); [EOL] priorVariables.add(new String(chars, offset, length)); [EOL] } [EOL] checkCyclicSubstitution(varName, priorVariables); [EOL] priorVariables.add(varName); [EOL] final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL] if (varValue != null) { [EOL] final int varLen = varValue.length(); [EOL] buf.replace(startPos, endPos, varValue); [EOL] altered = true; [EOL] int change = substitute(buf, startPos, varLen, priorVariables); [EOL] change = change + varLen - (endPos - startPos); [EOL] pos += change; [EOL] bufEnd += change; [EOL] lengthChange += change; [EOL] chars = buf.buffer; [EOL] } [EOL] priorVariables.remove(priorVariables.size() - 1); [EOL] break; [EOL] } else { [EOL] nestedVarCount--; [EOL] pos += endMatchLen; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (top) { [EOL] return altered ? 1 : 0; [EOL] } [EOL] return lengthChange; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testCheckCyclicSubstitution_NoCycle() { [EOL] List<String> priorVariables = new ArrayList<>(); [EOL] priorVariables.add("var1"); [EOL] priorVariables.add("var2"); [EOL] String varName = "var3"; [EOL] checkCyclicSubstitution(varName, priorVariables); [EOL] }
public void testCheckCyclicSubstitution_WithCycle() { [EOL] List<String> priorVariables = new ArrayList<>(); [EOL] priorVariables.add("var1"); [EOL] priorVariables.add("var2"); [EOL] priorVariables.add("var1"); // Introduce a cycle [EOL] String varName = "var1"; [EOL] try { [EOL] checkCyclicSubstitution(varName, priorVariables); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Infinite loop in property interpolation of var1: var2->var1", e.getMessage()); [EOL] } [EOL] }
protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL] final StrLookup<?> resolver = getVariableResolver(); [EOL] if (resolver == null) { [EOL] return null; [EOL] } [EOL] return resolver.lookup(variableName); [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testGetEscapeChar() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] assertEquals('$', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorDefaultConstructor() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] assertNotNull(sub.getVariableResolver()); [EOL] assertEquals(StrMatcher.stringMatcher("${"), sub.getVariablePrefixMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher("}"), sub.getVariableSuffixMatcher()); [EOL] assertEquals('$', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorMapConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap); [EOL] assertEquals(valueMap, sub.getVariableResolver().getVariableResolver()); [EOL] }
public void testStrSubstitutorMapPrefixSuffixConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap, "<", ">"); [EOL] assertEquals('<', sub.getVariablePrefixMatcher().getChar()); [EOL] assertEquals('>', sub.getVariableSuffixMatcher().getChar()); [EOL] }
public void testStrSubstitutorMapPrefixSuffixEscapeConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap, "<", ">", '*'); [EOL] assertEquals('<', sub.getVariablePrefixMatcher().getChar()); [EOL] assertEquals('>', sub.getVariableSuffixMatcher().getChar()); [EOL] assertEquals('*', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorVariableResolverConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver); [EOL] assertEquals(variableResolver, sub.getVariableResolver()); [EOL] }
public void testStrSubstitutorVariableResolverPrefixSuffixEscapeConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver, "${", "}", '!'); [EOL] assertEquals(variableResolver, sub.getVariableResolver()); [EOL] assertEquals(StrMatcher.stringMatcher("${"), sub.getVariablePrefixMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher("}"), sub.getVariableSuffixMatcher()); [EOL] assertEquals('!', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorVariableResolverPrefixSuffixMatcherEscapeConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrMatcher prefixMatcher = StrMatcher.charMatcher('<'); [EOL] StrMatcher suffixMatcher = StrMatcher.charMatcher('>'); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver, prefixMatcher, suffixMatcher, '#'); [EOL] assertEquals(variableResolver, sub.getVariableResolver()); [EOL] assertEquals(prefixMatcher, sub.getVariablePrefixMatcher()); [EOL] assertEquals(suffixMatcher, sub.getVariableSuffixMatcher()); [EOL] assertEquals('#', sub.getEscapeChar()); [EOL] }
public void testSetEscapeChar() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] sub.setEscapeChar('#'); [EOL] assertEquals('#', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorDefaultConstructor() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] assertNotNull(sub); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, sub.getEscapeChar()); [EOL] assertEquals(StrSubstitutor.DEFAULT_PREFIX, sub.getVariablePrefixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_SUFFIX, sub.getVariableSuffixMatcher()); [EOL] }
public void testStrSubstitutorMapConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap); [EOL] assertNotNull(sub); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorMapPrefixSuffixConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap, "<", ">"); [EOL] assertNotNull(sub); [EOL] assertEquals('<', sub.getVariablePrefixMatcher().toString().charAt(0)); [EOL] assertEquals('>', sub.getVariableSuffixMatcher().toString().charAt(0)); [EOL] }
public void testStrSubstitutorMapPrefixSuffixEscapeConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap, "<", ">", '*'); [EOL] assertNotNull(sub); [EOL] assertEquals('*', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorStrLookupConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver); [EOL] assertNotNull(sub); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorStrLookupPrefixSuffixEscapeConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver, "<", ">", '*'); [EOL] assertNotNull(sub); [EOL] assertEquals('*', sub.getEscapeChar()); [EOL] }
public void testStrSubstitutorStrLookupPrefixSuffixMatcherEscapeConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrMatcher prefixMatcher = StrMatcher.stringMatcher("<"); [EOL] StrMatcher suffixMatcher = StrMatcher.stringMatcher(">"); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver, prefixMatcher, suffixMatcher, '*'); [EOL] assertNotNull(sub); [EOL] assertEquals('*', sub.getEscapeChar()); [EOL] }
public void testGetVariablePrefixMatcher() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StrMatcher defaultPrefixMatcher = StrMatcher.stringMatcher("${"); [EOL] assertEquals(defaultPrefixMatcher, sub.getVariablePrefixMatcher()); [EOL] }
public void testStrSubstitutorConstructors() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor sub1 = new StrSubstitutor(); [EOL] assertNotNull(sub1.getVariableResolver()); [EOL] assertEquals('$', sub1.getEscapeChar()); [EOL] assertEquals(StrMatcher.stringMatcher("${"), sub1.getVariablePrefixMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher("}"), sub1.getVariableSuffixMatcher()); [EOL] StrSubstitutor sub2 = new StrSubstitutor(valueMap); [EOL] assertEquals(valueMap, sub2.getVariableResolver().lookup("key")); [EOL] StrSubstitutor sub3 = new StrSubstitutor(valueMap, "<", ">"); [EOL] assertEquals('<', sub3.getVariablePrefixMatcher().isMatch("<prefix>".toCharArray(), 0)); [EOL] assertEquals('>', sub3.getVariableSuffixMatcher().isMatch("<suffix>".toCharArray(), 0)); [EOL] StrSubstitutor sub4 = new StrSubstitutor(valueMap, "<", ">", '?'); [EOL] assertEquals('?', sub4.getEscapeChar()); [EOL] StrLookup<?> variableResolver = StrLookup.mapLookup(valueMap); [EOL] StrSubstitutor sub5 = new StrSubstitutor(variableResolver); [EOL] assertEquals(variableResolver, sub5.getVariableResolver()); [EOL] StrSubstitutor sub6 = new StrSubstitutor(variableResolver, "<", ">", '?'); [EOL] assertEquals('<', sub6.getVariablePrefixMatcher().isMatch("<prefix>".toCharArray(), 0)); [EOL] assertEquals('>', sub6.getVariableSuffixMatcher().isMatch("<suffix>".toCharArray(), 0)); [EOL] assertEquals('?', sub6.getEscapeChar()); [EOL] StrMatcher prefixMatcher = StrMatcher.charMatcher('<'); [EOL] StrMatcher suffixMatcher = StrMatcher.charMatcher('>'); [EOL] StrSubstitutor sub7 = new StrSubstitutor(variableResolver, prefixMatcher, suffixMatcher, '?'); [EOL] assertEquals(prefixMatcher, sub7.getVariablePrefixMatcher()); [EOL] assertEquals(suffixMatcher, sub7.getVariableSuffixMatcher()); [EOL] assertEquals('?', sub7.getEscapeChar()); [EOL] }
public void testSetVariablePrefixMatcherWithNull() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] try { [EOL] strSubstitutor.setVariablePrefixMatcher(null); [EOL] fail("Expected IllegalArgumentException for null prefixMatcher"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Variable prefix matcher must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testSetVariablePrefixMatcherWithNonNull() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] StrMatcher prefixMatcher = StrMatcher.charMatcher('#'); [EOL] StrSubstitutor result = strSubstitutor.setVariablePrefixMatcher(prefixMatcher); [EOL] assertSame("Expected same StrSubstitutor returned after setting prefixMatcher", strSubstitutor, result); [EOL] assertSame("Expected prefixMatcher to be set", prefixMatcher, strSubstitutor.getVariablePrefixMatcher()); [EOL] }
public StrMatcher getVariableSuffixMatcher() { [EOL] return suffixMatcher; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testSetVariableSuffixMatcherWithNonNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrMatcher suffixMatcher = StrMatcher.stringMatcher("}"); [EOL] substitutor.setVariableSuffixMatcher(suffixMatcher); [EOL] assertEquals(suffixMatcher, substitutor.getVariableSuffixMatcher()); [EOL] }
public void testSetVariableSuffixMatcherWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.setVariableSuffixMatcher(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Variable suffix matcher must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testGetVariableResolver() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] assertNull(substitutor.getVariableResolver()); [EOL] }
public void testStrSubstitutorMapConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] assertNotNull(substitutor.getVariableResolver()); [EOL] }
public void testStrSubstitutorMapPrefixSuffixConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, "${", "}"); [EOL] assertNotNull(substitutor.getVariableResolver()); [EOL] assertEquals("${", substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("}", substitutor.getVariableSuffixMatcher().toString()); [EOL] }
public void testStrSubstitutorMapPrefixSuffixEscapeConstructor() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, "${", "}", '$'); [EOL] assertNotNull(substitutor.getVariableResolver()); [EOL] assertEquals("${", substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("}", substitutor.getVariableSuffixMatcher().toString()); [EOL] assertEquals('$', substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorStrLookupConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver); [EOL] assertSame(variableResolver, substitutor.getVariableResolver()); [EOL] }
public void testStrSubstitutorStrLookupPrefixSuffixEscapeConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, "${", "}", '$'); [EOL] assertSame(variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals("${", substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("}", substitutor.getVariableSuffixMatcher().toString()); [EOL] assertEquals('$', substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorStrLookupStrMatcherStrMatcherEscapeConstructor() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrMatcher prefixMatcher = StrMatcher.stringMatcher("<<"); [EOL] StrMatcher suffixMatcher = StrMatcher.stringMatcher(">>"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, prefixMatcher, suffixMatcher, '$'); [EOL] assertSame(variableResolver, substitutor.getVariableResolver()); [EOL] assertSame(prefixMatcher, substitutor.getVariablePrefixMatcher()); [EOL] assertSame(suffixMatcher, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals('$', substitutor.getEscapeChar()); [EOL] }
public void testSetVariableResolver() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] substitutor.setVariableResolver(variableResolver); [EOL] assertSame(variableResolver, substitutor.getVariableResolver()); [EOL] }
public void testIsEnableSubstitutionInVariables_DefaultConstructor() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] assertFalse(substitutor.isEnableSubstitutionInVariables()); [EOL] } [EOL] public void testIsEnableSubstitutionInVariables_Enabled() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] substitutor.setEnableSubstitutionInVariables(true); [EOL] assertTrue(substitutor.isEnableSubstitutionInVariables()); [EOL] } [EOL] public void testIsEnableSubstitutionInVariables_Disabled() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] substitutor.setEnableSubstitutionInVariables(false); [EOL] assertFalse(substitutor.isEnableSubstitutionInVariables()); [EOL] }
public void testGetReducedFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getReducedFraction(1, 0); [EOL] fail("Expected ArithmeticException due to zero denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_ZeroNumerator_ReturnsZero() { [EOL] Fraction result = Fraction.getReducedFraction(0, 1); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_NegativeDenominator_PositiveNumerator() { [EOL] Fraction result = Fraction.getReducedFraction(1, -1); [EOL] assertNotNull(result); [EOL] assertEquals(-1, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_NegativeDenominator_NegativeNumerator() { [EOL] Fraction result = Fraction.getReducedFraction(-1, -1); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_MinValueDenominatorEvenNumerator() { [EOL] Fraction result = Fraction.getReducedFraction(2, Integer.MIN_VALUE); [EOL] assertNotNull(result); [EOL] assertEquals(-1, result.getNumerator()); [EOL] assertEquals(Integer.MAX_VALUE / 2 + 1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_MinValueNumerator() { [EOL] try { [EOL] Fraction.getReducedFraction(Integer.MIN_VALUE, -1); [EOL] fail("Expected ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_MinValueDenominator() { [EOL] try { [EOL] Fraction.getReducedFraction(-1, Integer.MIN_VALUE); [EOL] fail("Expected ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_CommonCase() { [EOL] Fraction result = Fraction.getReducedFraction(2, 4); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] }
public void testAddAndCheckNoOverflow() { [EOL] int a = 50; [EOL] int b = 30; [EOL] int result = addAndCheck(a, b); [EOL] assertEquals(80, result); [EOL] }
public void testAddAndCheckOverflowPositive() { [EOL] try { [EOL] addAndCheck(Integer.MAX_VALUE, 1); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: add", ae.getMessage()); [EOL] } [EOL] }
public void testAddAndCheckOverflowNegative() { [EOL] try { [EOL] addAndCheck(Integer.MIN_VALUE, -1); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: add", ae.getMessage()); [EOL] } [EOL] }
public void testAddWithNullFraction() { [EOL] final Fraction fraction1 = Fraction.getFraction(1, 2); [EOL] try { [EOL] fraction1.add(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testAddWithZeroFraction() { [EOL] final Fraction fraction1 = Fraction.getFraction(1, 2); [EOL] final Fraction fraction2 = Fraction.getFraction(0, 1); [EOL] Fraction result = fraction1.add(fraction2); [EOL] assertEquals(Fraction.getFraction(1, 2), result); [EOL] }
public void testAddWithPositiveFraction() { [EOL] final Fraction fraction1 = Fraction.getFraction(1, 2); [EOL] final Fraction fraction2 = Fraction.getFraction(1, 3); [EOL] Fraction result = fraction1.add(fraction2); [EOL] assertEquals(Fraction.getFraction(5, 6), result); [EOL] }
public void testAddWithNegativeFraction() { [EOL] final Fraction fraction1 = Fraction.getFraction(1, 2); [EOL] final Fraction fraction2 = Fraction.getFraction(-1, 4); [EOL] Fraction result = fraction1.add(fraction2); [EOL] assertEquals(Fraction.getFraction(1, 4), result); [EOL] }
public void testAddSub_NullFraction_ThrowsIllegalArgumentException() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] try { [EOL] fraction.addSub(null, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testAddSub_ZeroNumerator_ReturnsFraction() { [EOL] Fraction zeroFraction = new Fraction(0, 3); [EOL] Fraction nonZeroFraction = new Fraction(1, 3); [EOL] Fraction resultAdd = zeroFraction.addSub(nonZeroFraction, true); [EOL] assertEquals(nonZeroFraction, resultAdd); [EOL] Fraction resultSub = zeroFraction.addSub(nonZeroFraction, false); [EOL] assertEquals(nonZeroFraction.negate(), resultSub); [EOL] } [EOL] public void testAddSub_FractionWithZeroNumerator_ReturnsThis() { [EOL] Fraction fraction = new Fraction(1, 3); [EOL] Fraction zeroFraction = new Fraction(0, 3); [EOL] Fraction result = fraction.addSub(zeroFraction, true); [EOL] assertEquals(fraction, result); [EOL] } [EOL] public void testAddSub_GCDOfDenominatorsIsOne_ReturnsNewFraction() { [EOL] Fraction fraction1 = new Fraction(1, 2); [EOL] Fraction fraction2 = new Fraction(1, 3); [EOL] Fraction resultAdd = fraction1.addSub(fraction2, true); [EOL] assertEquals(new Fraction(5, 6), resultAdd); [EOL] Fraction resultSub = fraction1.addSub(fraction2, false); [EOL] assertEquals(new Fraction(1, 6), resultSub); [EOL] } [EOL] public void testAddSub_GCDOfDenominatorsNotOne_ReturnsNewFraction() { [EOL] Fraction fraction1 = new Fraction(1, 8); [EOL] Fraction fraction2 = new Fraction(1, 8); [EOL] Fraction resultAdd = fraction1.addSub(fraction2, true); [EOL] assertEquals(new Fraction(1, 4), resultAdd); [EOL] Fraction resultSub = fraction1.addSub(fraction2, false); [EOL] assertEquals(new Fraction(0, 1), resultSub); [EOL] } [EOL] public void testAddSub_NumeratorOverflow_ThrowsArithmeticException() { [EOL] Fraction fraction1 = new Fraction(Integer.MAX_VALUE, 1); [EOL] Fraction fraction2 = new Fraction(1, Integer.MAX_VALUE); [EOL] try { [EOL] fraction1.addSub(fraction2, true); [EOL] fail("Should have thrown ArithmeticException due to numerator overflow"); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testToStringWhenToStringIsNull() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] String result = fraction.toString(); [EOL] assertNotNull("toString should not return null", result); [EOL] assertEquals("toString should return the correct format", "1/2", result); [EOL] } [EOL] public void testToStringWhenToStringIsNotNull() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] fraction.toString(); [EOL] String result = fraction.toString(); [EOL] assertNotNull("toString should not return null on subsequent calls", result); [EOL] assertEquals("toString should return the same result on subsequent calls", "1/2", result); [EOL] }
public void testSubSequenceWithNull() { [EOL] CharSequence result = StringUtils.subSequence(null, 0); [EOL] assertNull(result); [EOL] }
public void testSubSequenceWithEmptyString() { [EOL] CharSequence result = StringUtils.subSequence("", 0); [EOL] assertEquals("", result.toString()); [EOL] }
public void testSubSequenceWithNonEmptyString() { [EOL] CharSequence input = "abcdef"; [EOL] CharSequence result = StringUtils.subSequence(input, 2); [EOL] assertEquals("cdef", result.toString()); [EOL] }
public void testSubSequenceWithFullLength() { [EOL] CharSequence input = "abcdef"; [EOL] CharSequence result = StringUtils.subSequence(input, 0); [EOL] assertEquals("abcdef", result.toString()); [EOL] }
public void testSubSequenceWithLengthExceedingString() { [EOL] try { [EOL] StringUtils.subSequence("abcdef", 10); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testStrTokenizerDefaultConstructor() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] assertNull(tokenizer.next()); [EOL] }
public void testStrTokenizerWithNonNullInput() { [EOL] String input = "test"; [EOL] StrTokenizer tokenizer = new StrTokenizer(input); [EOL] char[] expectedChars = input.toCharArray(); [EOL] char[] actualChars = tokenizer.getTokenArray(); [EOL] assertArrayEquals(expectedChars, actualChars); [EOL] }
public void testStrTokenizerWithNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer(null); [EOL] char[] actualChars = tokenizer.getTokenArray(); [EOL] assertNull(actualChars); [EOL] }
public void testCheckTokenizedWithNullTokensAndNullChars() { [EOL] this.tokens = null; [EOL] this.chars = null; [EOL] this.checkTokenized(); [EOL] assertNotNull(this.tokens); [EOL] assertEquals(0, this.tokens.length); [EOL] }
public void testCheckTokenizedWithNullTokensAndNonNullChars() { [EOL] this.tokens = null; [EOL] this.chars = new char[]{'a', 'b', 'c'}; [EOL] this.checkTokenized(); [EOL] assertNotNull(this.tokens); [EOL] assertEquals(3, this.tokens.length); [EOL] }
public void testTokenize_NullInput() { [EOL] List<String> result = tokenize(null, 0, 0); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testTokenize_EmptyCount() { [EOL] List<String> result = tokenize(new char[]{'a', 'b', 'c'}, 0, 0); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testTokenize_ValidInput() { [EOL] List<String> result = tokenize(new char[]{'a', ' ', 'b'}, 0, 3); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("a", result.get(0)); [EOL] assertEquals("b", result.get(1)); [EOL] }
public void testTokenize_OffsetInput() { [EOL] List<String> result = tokenize(new char[]{'a', ' ', 'b'}, 1, 3); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("b", result.get(0)); [EOL] }
public void testTokenize_PosAtCount() { [EOL] List<String> result = tokenize(new char[]{'a', ' ', 'b'}, 0, 2); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("a", result.get(0)); [EOL] }
public void testReadNextTokenAtEndOfString() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(-1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("", tokens.get(0)); [EOL] }
public void testReadNextTokenWithIgnoredAndTrimmer() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "   a".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(3, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("", tokens.get(0)); [EOL] }
public void testReadNextTokenWithDelimiter() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = ",a".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("", tokens.get(0)); [EOL] }
public void testReadNextTokenWithQuote() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "\"a\"".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertTrue(result > 0); [EOL] assertEquals(0, tokens.size()); [EOL] }
public void testReadNextTokenWithoutSpecialCharacters() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "a".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertTrue(result > 0); [EOL] assertEquals(0, tokens.size()); [EOL] }
public void testReadWithQuotes_NoQuotes() { [EOL] char[] chars = "test".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals("test", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithQuotes() { [EOL] char[] chars = "a \"quoted\" word".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 2; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(10, result); [EOL] assertEquals("a ", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithEscapedQuotes() { [EOL] char[] chars = "a \"quo\\\"ted\" word".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 2; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(13, result); [EOL] assertEquals("a ", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithDelimiter() { [EOL] char[] chars = "a,b".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(1, result); [EOL] assertEquals("a", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithIgnored() { [EOL] char[] chars = "a  b".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals("a  b", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithTrimmer() { [EOL] char[] chars = "a    b".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals("a    b", tokens.get(0)); [EOL] }
public void testSetDelimiterMatcherWithNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] StrMatcher delimMatcher = null; [EOL] tokenizer.setDelimiterMatcher(delimMatcher); [EOL] assertEquals(StrMatcher.noneMatcher(), tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetDelimiterMatcherWithNonNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] StrMatcher delimMatcher = StrMatcher.commaMatcher(); [EOL] tokenizer.setDelimiterMatcher(delimMatcher); [EOL] assertEquals(delimMatcher, tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetDelimiterString_Null() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] tokenizer.setDelimiterString(null); [EOL] assertEquals(StrMatcher.noneMatcher(), tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetDelimiterString_Empty() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] tokenizer.setDelimiterString(""); [EOL] assertEquals(StrMatcher.stringMatcher(""), tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetDelimiterString_Valid() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] tokenizer.setDelimiterString(","); [EOL] assertEquals(StrMatcher.stringMatcher(","), tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetIgnoredMatcherWithNonNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrMatcher matcher = StrMatcher.noneMatcher(); [EOL] tokenizer.setIgnoredMatcher(matcher); [EOL] assertEquals(matcher, tokenizer.getIgnoredMatcher()); [EOL] } [EOL] public void testSetIgnoredMatcherWithNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrMatcher initialMatcher = tokenizer.getIgnoredMatcher(); [EOL] tokenizer.setIgnoredMatcher(null); [EOL] assertEquals(initialMatcher, tokenizer.getIgnoredMatcher()); [EOL] }
public void testSetIgnoredChar() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] char ignoredChar = ' '; [EOL] tokenizer.setIgnoredChar(ignoredChar); [EOL] assertTrue(tokenizer.isIgnored(ignoredChar)); [EOL] }
public void testSetIgnoredChar_NoEffectWithNonIgnored() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] char nonIgnoredChar = 'x'; [EOL] tokenizer.setIgnoredChar(nonIgnoredChar); [EOL] assertFalse(tokenizer.isIgnored('a')); [EOL] assertFalse(tokenizer.isIgnored('b')); [EOL] assertFalse(tokenizer.isIgnored('c')); [EOL] }
public void testGetContent_NullChars() { [EOL] CharArray ca = new CharArray(null); [EOL] String result = ca.getContent(); [EOL] assertNull(result); [EOL] }
public void testGetContent_NonNullChars() { [EOL] char[] testChars = {'a', 'b', 'c'}; [EOL] CharArray ca = new CharArray(testChars); [EOL] String result = ca.getContent(); [EOL] assertEquals("abc", result); [EOL] }
public void testClone_CoverCloneNotSupportedException() throws Exception { [EOL] MyClass obj = new MyClass() { [EOL] @Override [EOL] public Object cloneReset() throws CloneNotSupportedException { [EOL] throw new CloneNotSupportedException("Clone not supported"); [EOL] } [EOL] }; [EOL] Object clonedObj = obj.clone(); [EOL] assertNull(clonedObj); [EOL] }
public void testToString_NotTokenized() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] String expected = "StrTokenizer[not tokenized yet]"; [EOL] String actual = tokenizer.toString(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testToString_Tokenized() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] tokenizer.getTokenList(); // This will tokenize the string [EOL] String expected = "StrTokenizer" + tokenizer.getTokenList(); [EOL] String actual = tokenizer.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testFormatUTCWithValidInputs() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.formatUTC(millis, pattern, locale); [EOL] assertNotNull(formattedDate); [EOL] assertTrue(formattedDate.length() > 0); [EOL] }
public void testFormatUTCWithNullPattern() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = null; [EOL] Locale locale = Locale.US; [EOL] try { [EOL] StringUtils.formatUTC(millis, pattern, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormatUTCWithNullLocale() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] Locale locale = null; [EOL] String formattedDate = StringUtils.formatUTC(millis, pattern, locale); [EOL] assertNotNull(formattedDate); [EOL] assertTrue(formattedDate.length() > 0); [EOL] }
public void testFormatWithMillisAndPattern() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(millis, pattern); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisAndNullPattern() { [EOL] long millis = System.currentTimeMillis(); [EOL] String formattedDate = StringUtils.format(millis, null); [EOL] assertNull(formattedDate); [EOL] }
public void testFormatWithMillisPatternLocale() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(millis, pattern, locale); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern, locale); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisPatternLocaleNull() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(millis, pattern, null); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisPatternLocaleFrench() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.FRENCH; [EOL] String formattedDate = StringUtils.format(millis, pattern, locale); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern, locale); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisAndPatternAndTimeZoneAndLocale() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(millis, pattern, timeZone, locale); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern, locale); [EOL] sdf.setTimeZone(timeZone); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisAndPatternAndTimeZoneAndLocale_NullPattern() { [EOL] long millis = System.currentTimeMillis(); [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] try { [EOL] StringUtils.format(millis, null, timeZone, locale); [EOL] fail("Should have thrown IllegalArgumentException for null pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormatWithMillisAndPatternAndTimeZoneAndLocale_NullTimeZone() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(millis, pattern, null, locale); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern, locale); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisAndPatternAndTimeZoneAndLocale_NullLocale() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] String formattedDate = StringUtils.format(millis, pattern, timeZone, null); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] sdf.setTimeZone(timeZone); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testAppendToWithLessThan100() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 99; [EOL] appendTo(buffer, value); [EOL] assertEquals("0099", buffer.toString()); [EOL] }
public void testAppendToWithLessThan1000() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 999; [EOL] appendTo(buffer, value); [EOL] assertEquals("0999", buffer.toString()); [EOL] }
public void testAppendToWith1000OrMore() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 1000; [EOL] appendTo(buffer, value); [EOL] assertEquals("1000", buffer.toString()); [EOL] }
public void testAppendToWithNegativeValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = -1; [EOL] try { [EOL] appendTo(buffer, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendToWithNegativeOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, -3 * 60 * 60 * 1000); // Set timezone offset to -3 hours [EOL] calendar.set(Calendar.DST_OFFSET, 0); // No daylight saving time offset [EOL] appendTo(buffer, calendar); [EOL] String result = buffer.toString(); [EOL] assertTrue(result.startsWith("-")); [EOL] assertEquals(5, result.length()); [EOL] assertEquals("03:00", result.substring(1)); [EOL] }
public void testAppendToWithPositiveOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, 3 * 60 * 60 * 1000); // Set timezone offset to +3 hours [EOL] calendar.set(Calendar.DST_OFFSET, 0); // No daylight saving time offset [EOL] appendTo(buffer, calendar); [EOL] String result = buffer.toString(); [EOL] assertTrue(result.startsWith("+")); [EOL] assertEquals(5, result.length()); [EOL] assertEquals("03:00", result.substring(1)); [EOL] }
public void testAppendToWithZeroOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, 0); [EOL] calendar.set(Calendar.DST_OFFSET, 0); [EOL] appendTo(buffer, calendar); [EOL] String result = buffer.toString(); [EOL] assertTrue(result.startsWith("+")); [EOL] assertEquals(5, result.length()); [EOL] assertEquals("00:00", result.substring(1)); [EOL] }
public void testAppendToWithDSTOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, 3 * 60 * 60 * 1000); // Set timezone offset to +3 hours [EOL] calendar.set(Calendar.DST_OFFSET, 1 * 60 * 60 * 1000); // Set daylight saving time offset to +1 hour [EOL] appendTo(buffer, calendar); [EOL] String result = buffer.toString(); [EOL] assertTrue(result.startsWith("+")); [EOL] assertEquals(5, result.length()); [EOL] assertEquals("04:00", result.substring(1)); [EOL] }
It seems there was a misunderstanding. The `EqualsBuilder()` constructor you've provided does not contain any executable code that can be covered by a unit test. Constructors that only contain an opening and closing bracket without any code (like the one you've provided) do not alter the state of an object or have any side effects that can be tested. [EOL] In Java, a default constructor like this is only necessary if there are other constructors present and you still want to allow instantiation of the object without any parameters. If this is the only constructor, it's actually not needed at all, as Java provides a default no-argument constructor implicitly if no other constructors are defined. [EOL] Since there's no behavior or state change to test, no unit test case is necessary or possible for this constructor. If you have a different method with executable code, I can help generate test cases for that.
public void testReflectionEqualsWithExcludeFields() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] String[] excludeFields = new String[] {"id", "timestamp"}; [EOL] boolean result = reflectionEquals(lhs, rhs, excludeFields); [EOL] assertFalse(result); [EOL] }
public void testReflectionEqualsWithNoExcludeFields() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] boolean result = reflectionEquals(lhs, rhs); [EOL] assertFalse(result); [EOL] }
public void testReflectionEqualsWithNullExcludeFields() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] boolean result = reflectionEquals(lhs, rhs, (String[]) null); [EOL] assertFalse(result); [EOL] }
public void testReflectionEqualsWithEmptyExcludeFields() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] String[] excludeFields = new String[0]; [EOL] boolean result = reflectionEquals(lhs, rhs, excludeFields); [EOL] assertFalse(result); [EOL] }
public void testAppend_BothValuesNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(null, null); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_SameObject() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object obj = new Object(); [EOL] builder.append(obj, obj); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentNonArrayObjects() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_OneNullOneNonNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = null; [EOL] Object rhs = new Object(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_DifferentArrayTypes() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = new int[]{1, 2, 3}; [EOL] long[] rhs = new long[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_LongArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] long[] lhs = new long[]{1, 2, 3}; [EOL] long[] rhs = new long[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_IntArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = new int[]{1, 2, 3}; [EOL] int[] rhs = new int[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ShortArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] short[] lhs = new short[]{1, 2, 3}; [EOL] short[] rhs = new short[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_CharArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ByteArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = new byte[]{1, 2, 3}; [EOL] byte[] rhs = new byte[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DoubleArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] double[] lhs = new double[]{1.0, 2.0, 3.0}; [EOL] double[] rhs = new double[]{1.0, 2.0, 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_FloatArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] float[] lhs = new float[]{1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = new float[]{1.0f, 2.0f, 3.0f}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_BooleanArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] boolean[] lhs = new boolean[]{true, false, true}; [EOL] boolean[] rhs = new boolean[]{true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ObjectArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[]{"a", "b", "c"}; [EOL] Object[] rhs = new Object[]{"a", "b", "c"}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendLongsEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] long lhs = 1L; [EOL] long rhs = 1L; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendLongsNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] long lhs = 1L; [EOL] long rhs = 2L; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongsWhenIsEqualsIsFalse() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.isEquals = false; [EOL] long lhs = 1L; [EOL] long rhs = 1L; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendDifferentDoubles() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(1.0, 2.0); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendSameDoubles() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(1.0, 1.0); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendDoubleWhenAlreadyNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(1.0, 2.0); [EOL] builder.append(3.0, 3.0); [EOL] assertFalse(builder.isEquals()); [EOL] }

public void testAppendFloatEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] float lhs = 10.0f; [EOL] float rhs = 10.0f; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendFloatNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] float lhs = 10.0f; [EOL] float rhs = 20.0f; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendFloatWhenAlreadyNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(1.0f, 2.0f); [EOL] builder.append(10.0f, 10.0f); // This should not change the isEquals to true [EOL] assertFalse(builder.isEquals()); [EOL] }

public void testAppendArraysWithDifferentLengths() { [EOL] double[] lhs = new double[] {1.0, 2.0}; [EOL] double[] rhs = new double[] {1.0}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendEqualArrays() { [EOL] double[] lhs = new double[] {1.0, 2.0}; [EOL] double[] rhs = new double[] {1.0, 2.0}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendNonEqualArrays() { [EOL] double[] lhs = new double[] {1.0, 2.0}; [EOL] double[] rhs = new double[] {2.0, 1.0}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendArraysWithNullLeftHandSide() { [EOL] double[] lhs = null; [EOL] double[] rhs = new double[] {1.0, 2.0}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendArraysWithNullRightHandSide() { [EOL] double[] lhs = new double[] {1.0, 2.0}; [EOL] double[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendArraysWithBothNulls() { [EOL] double[] lhs = null; [EOL] double[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendArraysWithSameReference() { [EOL] double[] lhs = new double[] {1.0, 2.0}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, lhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendArraysWhenEqualsIsAlreadyFalse() { [EOL] double[] lhs = new double[] {1.0, 2.0}; [EOL] double[] rhs = new double[] {1.0, 2.0}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysWithEqualArrays() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendFloatArraysFirstArrayNull() { [EOL] float[] lhs = null; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysSecondArrayNull() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysDifferentLength() { [EOL] float[] lhs = {1.0f, 2.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysSameArray() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, lhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendFloatArraysIsEqualsFalse() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {4.0f, 5.0f, 6.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testIsEqualsTrue() { [EOL] MyClass myClassInstance = new MyClass(true); [EOL] assertTrue(myClassInstance.isEquals()); [EOL] }
public void testIsEqualsFalse() { [EOL] MyClass myClassInstance = new MyClass(false); [EOL] assertFalse(myClassInstance.isEquals()); [EOL] }
protected void setEquals(final boolean isEquals) { [EOL] this.isEquals = isEquals; [EOL] }
public void testSingleQuoteMatcher() { [EOL] StrMatcher matcher = StrMatcher.singleQuoteMatcher(); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher instanceof StrMatcher.CharMatcher); [EOL] assertEquals('\'', ((StrMatcher.CharMatcher) matcher).getChar()); [EOL] }
public void testRandomAsciiZeroCount() { [EOL] String ascii = StringUtils.randomAscii(0); [EOL] assertNotNull(ascii); [EOL] assertEquals("", ascii); [EOL] }
public void testRandomAsciiPositiveCount() { [EOL] int count = 5; [EOL] String ascii = StringUtils.randomAscii(count); [EOL] assertNotNull(ascii); [EOL] assertEquals(count, ascii.length()); [EOL] for (char ch : ascii.toCharArray()) { [EOL] assertTrue(ch >= 32 && ch < 127); [EOL] } [EOL] }
public void testRandomAlphabetic_PositiveCount() { [EOL] int count = 5; [EOL] String result = StringUtils.randomAlphabetic(count); [EOL] assertNotNull(result); [EOL] assertEquals(count, result.length()); [EOL] assertTrue(StringUtils.isAlpha(result)); [EOL] }
public void testRandomAlphabetic_ZeroCount() { [EOL] int count = 0; [EOL] String result = StringUtils.randomAlphabetic(count); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testRandomAlphabetic_NegativeCount() { [EOL] int count = -1; [EOL] String result = StringUtils.randomAlphabetic(count); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testRandomAlphanumeric_ZeroCount() { [EOL] String result = RandomStringUtils.randomAlphanumeric(0); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testRandomAlphanumeric_PositiveCount() { [EOL] int count = 5; [EOL] String result = RandomStringUtils.randomAlphanumeric(count); [EOL] assertNotNull(result); [EOL] assertEquals(count, result.length()); [EOL] assertTrue(result.matches("[a-zA-Z0-9]+")); [EOL] }
public void testRandomNumeric_zeroCount() { [EOL] String result = RandomStringUtils.randomNumeric(0); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testRandomNumeric_positiveCount() { [EOL] int count = 5; [EOL] String result = RandomStringUtils.randomNumeric(count); [EOL] assertNotNull(result); [EOL] assertEquals(count, result.length()); [EOL] assertTrue(result.matches("\\d+")); // The result should only contain digits [EOL] }
public void testRandomWithZeroCount() { [EOL] String result = RandomStringUtils.random(0, 0, 0, false, false, null, new Random()); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRandomWithNegativeCount() { [EOL] try { [EOL] RandomStringUtils.random(-1, 0, 0, false, false, null, new Random()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testRandomWithEmptyCharsArray() { [EOL] try { [EOL] RandomStringUtils.random(1, 0, 0, false, false, new char[0], new Random()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testRandomWithEndBeforeStart() { [EOL] try { [EOL] RandomStringUtils.random(1, 10, 5, false, false, null, new Random()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testRandomWithStartAndEnd() { [EOL] String result = RandomStringUtils.random(5, 50, 100, false, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] } [EOL] public void testRandomWithLettersAndNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] } [EOL] public void testRandomWithLettersOnly() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] } [EOL] public void testRandomWithNumbersOnly() { [EOL] String result = RandomStringUtils.random(5, 0, 0, false, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] } [EOL] public void testRandomWithNoLettersOrNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, false, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] } [EOL] public void testRandomWithCharsArray() { [EOL] char[] chars = new char[] {'a', 'b', 'c'}; [EOL] String result = RandomStringUtils.random(5, 0, chars.length, false, false, chars, new Random()); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] } [EOL] public void testRandomWithHighSurrogatePairAtEnd() { [EOL] Random random = new Random() { [EOL] @Override [EOL] public int nextInt(int bound) { [EOL] return bound - 1; // Always return the last valid index [EOL] } [EOL] }; [EOL] String result = RandomStringUtils.random(2, 0, 0, false, false, null, random); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length()); [EOL] } [EOL] public void testRandomWithLowSurrogatePairAtEnd() { [EOL] Random random = new Random() { [EOL] @Override [EOL] public int nextInt(int bound) { [EOL] return 128; // Always return a value that results in a low surrogate pair [EOL] } [EOL] }; [EOL] String result = RandomStringUtils.random(2, 0, 0, false, false, null, random); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length()); [EOL] } [EOL] public void testRandomWithInvalidSurrogatePairAtEnd() { [EOL] Random random = new Random() { [EOL] @Override [EOL] public int nextInt(int bound) { [EOL] return 129; // Always return a value that results in an invalid surrogate pair [EOL] } [EOL] }; [EOL] String result = RandomStringUtils.random(2, 0, 0, false, false, null, random); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length()); [EOL] }
public void testRandomWithNullChars() { [EOL] String randomString = StringUtils.random(5, (char[]) null); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] }
public void testRandomWithEmptyCharsArray() { [EOL] String randomString = StringUtils.random(5, new char[0]); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] }
public void testRandomWithSpecificChars() { [EOL] char[] chars = new char[] {'a', 'b', 'c'}; [EOL] String randomString = StringUtils.random(5, chars); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] for (char c : randomString.toCharArray()) { [EOL] assertTrue(ArrayUtils.contains(chars, c)); [EOL] } [EOL] }
public void testMutableByteWithNull() { [EOL] try { [EOL] new MutableByte(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableByteWithByte() { [EOL] final byte testValue = 0x01; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed", testValue, mutByte.byteValue()); [EOL] }
public void testMutableByteWithShort() { [EOL] final short testValue = 1; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed", (byte)testValue, mutByte.byteValue()); [EOL] }
public void testMutableByteWithInteger() { [EOL] final int testValue = 1; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed", (byte)testValue, mutByte.byteValue()); [EOL] }
public void testMutableByteWithLong() { [EOL] final long testValue = 1L; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed", (byte)testValue, mutByte.byteValue()); [EOL] }
public void testMutableByteWithFloat() { [EOL] final float testValue = 1.0f; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed", (byte)testValue, mutByte.byteValue()); [EOL] }
public void testMutableByteWithDouble() { [EOL] final double testValue = 1.0; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed", (byte)testValue, mutByte.byteValue()); [EOL] }
public void testAddWithNullOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] try { [EOL] arithmeticUtils.add(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testAddWithPositiveOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] arithmeticUtils.add(10); [EOL] assertEquals(15, arithmeticUtils.value); [EOL] } [EOL] public void testAddWithNegativeOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] arithmeticUtils.add(-3); [EOL] assertEquals(2, arithmeticUtils.value); [EOL] } [EOL] public void testAddWithZeroOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] arithmeticUtils.add(0); [EOL] assertEquals(5, arithmeticUtils.value); [EOL] }
public void testSubtract_PositiveOperand() { [EOL] MutableByte mutableByte = new MutableByte((byte) 10); [EOL] mutableByte.subtract((byte) 5); [EOL] assertEquals((byte) 5, mutableByte.byteValue()); [EOL] } [EOL] public void testSubtract_NegativeOperand() { [EOL] MutableByte mutableByte = new MutableByte((byte) 10); [EOL] mutableByte.subtract((byte) -5); [EOL] assertEquals((byte) 15, mutableByte.byteValue()); [EOL] } [EOL] public void testSubtract_ZeroOperand() { [EOL] MutableByte mutableByte = new MutableByte((byte) 10); [EOL] mutableByte.subtract((byte) 0); [EOL] assertEquals((byte) 10, mutableByte.byteValue()); [EOL] }
public void testFloatValue_Positive() { [EOL] MutableFloat mutableFloat = new MutableFloat(1.0f); [EOL] assertEquals(1.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testFloatValue_Negative() { [EOL] MutableFloat mutableFloat = new MutableFloat(-1.0f); [EOL] assertEquals(-1.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testFloatValue_Zero() { [EOL] MutableFloat mutableFloat = new MutableFloat(0.0f); [EOL] assertEquals(0.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testDoubleValue_Positive() { [EOL] DoubleValue instance = new DoubleValue(10.5); [EOL] double result = instance.doubleValue(); [EOL] assertEquals(10.5, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] DoubleValue instance = new DoubleValue(-10.5); [EOL] double result = instance.doubleValue(); [EOL] assertEquals(-10.5, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] DoubleValue instance = new DoubleValue(0.0); [EOL] double result = instance.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testToByte_NullValue() { [EOL] YourClass instance = new YourClass(null); [EOL] try { [EOL] Byte result = instance.toByte(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testToByte_ValidValue() { [EOL] YourClass instance = new YourClass((byte) 1); [EOL] Byte expected = 1; [EOL] Byte result = instance.toByte(); [EOL] assertEquals("The byte value should be equal to the original value", expected, result); [EOL] }
public void testEquals_SameMutableByteObject() { [EOL] MutableByte mutableByte1 = new MutableByte((byte) 10); [EOL] MutableByte mutableByte2 = mutableByte1; [EOL] boolean result = mutableByte1.equals(mutableByte2); [EOL] assert result; [EOL] }
public void testEquals_DifferentMutableByteObject_SameValue() { [EOL] MutableByte mutableByte1 = new MutableByte((byte) 10); [EOL] MutableByte mutableByte2 = new MutableByte((byte) 10); [EOL] boolean result = mutableByte1.equals(mutableByte2); [EOL] assert result; [EOL] }
public void testEquals_DifferentMutableByteObject_DifferentValue() { [EOL] MutableByte mutableByte1 = new MutableByte((byte) 10); [EOL] MutableByte mutableByte2 = new MutableByte((byte) 5); [EOL] boolean result = mutableByte1.equals(mutableByte2); [EOL] assert !result; [EOL] }
public void testEquals_NonMutableByteObject() { [EOL] MutableByte mutableByte = new MutableByte((byte) 10); [EOL] Object obj = new Object(); [EOL] boolean result = mutableByte.equals(obj); [EOL] assert !result; [EOL] }
public void testTranslateWithNullInput() { [EOL] String result = translate(null); [EOL] assertNull(result); [EOL] }
public void testTranslateWithEmptyString() { [EOL] String result = translate(""); [EOL] assertEquals("", result); [EOL] }
public void testTranslateWithNonEmptyString() { [EOL] String input = "test"; [EOL] String result = translate(input); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testTranslateWithIOException() { [EOL] CharSequence input = new CharSequence() { [EOL] @Override [EOL] public int length() { [EOL] return 2; [EOL] } [EOL] @Override [EOL] public char charAt(int index) { [EOL] throw new RuntimeException("Stub!"); [EOL] } [EOL] @Override [EOL] public CharSequence subSequence(int start, int end) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String toString() { [EOL] throw new RuntimeException("Stub!"); [EOL] } [EOL] }; [EOL] try { [EOL] translate(input); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] assertTrue(e.getCause() instanceof IOException); [EOL] } [EOL] }
public void testTranslateWithNullWriter() { [EOL] try { [EOL] new YourClass().translate("test", null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Writer must not be null", ex.getMessage()); [EOL] } catch (IOException ex) { [EOL] fail("Expected IllegalArgumentException, not IOException"); [EOL] } [EOL] }
public void testTranslateWithNullInput() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate(null, writer); [EOL] assertEquals("", writer.toString()); [EOL] }
public void testTranslateWithEmptyInput() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("", writer); [EOL] assertEquals("", writer.toString()); [EOL] }
public void testTranslateWithNonEmptyInput() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("abc", writer); [EOL] assertEquals("abc", writer.toString()); [EOL] }
public void testTranslateWithSpecialCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("a\u00E9c", writer); // Assuming translate method handles special characters [EOL] assertEquals("a\u00E9c", writer.toString()); [EOL] }
public void testTranslateWithSurrogatePairs() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("a\uD83D\uDE00c", writer); // Assuming translate method handles surrogate pairs [EOL] assertEquals("a\uD83D\uDE00c", writer.toString()); [EOL] }
public void testAppendWithValidParameters() { [EOL] CharSequence seq = "Test"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision); [EOL] assertNotNull(result); [EOL] assertEquals("Test", result.toString().trim()); [EOL] } [EOL] public void testAppendWithNullSeq() { [EOL] CharSequence seq = null; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision); [EOL] assertNotNull(result); [EOL] assertEquals("", result.toString().trim()); [EOL] } [EOL] public void testAppendWithNullFormatter() { [EOL] CharSequence seq = "Test"; [EOL] Formatter formatter = null; [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] try { [EOL] StringUtils.append(seq, formatter, flags, width, precision); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testAppendWithNullEllipsisAndNegativePrecision() { [EOL] CharSequence seq = "TestSequence"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = -1; [EOL] char padChar = ' '; [EOL] CharSequence ellipsis = null; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, padChar, ellipsis); [EOL] assertEquals("TestSequence", result.toString()); [EOL] }
public void testAppendWithNonNullEllipsisAndValidPrecision() { [EOL] CharSequence seq = "TestSequence"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] char padChar = ' '; [EOL] CharSequence ellipsis = "..."; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, padChar, ellipsis); [EOL] assertEquals("Test...", result.toString()); [EOL] }
public void testAppendWithPaddingAndLeftJustify() { [EOL] CharSequence seq = "Test"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = StringUtils.LEFT_JUSTIFY; [EOL] int width = 10; [EOL] int precision = -1; [EOL] char padChar = '_'; [EOL] CharSequence ellipsis = null; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, padChar, ellipsis); [EOL] assertEquals("Test______", result.toString()); [EOL] }
public void testAppendWithPaddingAndRightJustify() { [EOL] CharSequence seq = "Test"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; // No LEFT_JUSTIFY flag [EOL] int width = 10; [EOL] int precision = -1; [EOL] char padChar = '_'; [EOL] CharSequence ellipsis = null; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, padChar, ellipsis); [EOL] assertEquals("______Test", result.toString()); [EOL] }
public void testAppendWithEllipsisExceedingPrecision() { [EOL] CharSequence seq = "TestSequence"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 2; [EOL] char padChar = ' '; [EOL] CharSequence ellipsis = "..."; [EOL] try { [EOL] StringUtils.append(seq, formatter, flags, width, precision, padChar, ellipsis); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetEnumWithNullName() { [EOL] assertNull(EnumUtils.getEnum(SomeEnum.class, null)); [EOL] }
public void testGetEnumWithValidName() { [EOL] assertEquals(SomeEnum.VALUE_ONE, EnumUtils.getEnum(SomeEnum.class, "VALUE_ONE")); [EOL] }
public void testGetEnumWithInvalidName() { [EOL] assertNull(EnumUtils.getEnum(SomeEnum.class, "INVALID_VALUE")); [EOL] }
public void testGetInstanceWithNullPattern() { [EOL] try { [EOL] getInstance(null, TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("pattern must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetInstanceWithNullTimeZone() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] F result = getInstance(pattern, null, Locale.getDefault()); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithNullLocale() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] F result = getInstance(pattern, TimeZone.getDefault(), null); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithAllNonNull() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] final TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] final Locale locale = Locale.CANADA; [EOL] F result = getInstance(pattern, timeZone, locale); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithCachedInstance() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] final TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] final Locale locale = Locale.CANADA; [EOL] F firstCallResult = getInstance(pattern, timeZone, locale); [EOL] F secondCallResult = getInstance(pattern, timeZone, locale); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
public void testHashCode_LeftMiddleRightNonNull() { [EOL] Triple<Integer, Integer, Integer> triple = new ImmutableTriple<>(1, 2, 3); [EOL] int expectedHashCode = Integer.valueOf(1).hashCode() ^ Integer.valueOf(2).hashCode() ^ Integer.valueOf(3).hashCode(); [EOL] assertEquals(expectedHashCode, triple.hashCode()); [EOL] }
public void testHashCode_LeftNull() { [EOL] Triple<Integer, Integer, Integer> triple = new ImmutableTriple<>(null, 2, 3); [EOL] int expectedHashCode = 0 ^ Integer.valueOf(2).hashCode() ^ Integer.valueOf(3).hashCode(); [EOL] assertEquals(expectedHashCode, triple.hashCode()); [EOL] }
public void testHashCode_MiddleNull() { [EOL] Triple<Integer, Integer, Integer> triple = new ImmutableTriple<>(1, null, 3); [EOL] int expectedHashCode = Integer.valueOf(1).hashCode() ^ 0 ^ Integer.valueOf(3).hashCode(); [EOL] assertEquals(expectedHashCode, triple.hashCode()); [EOL] }
public void testHashCode_RightNull() { [EOL] Triple<Integer, Integer, Integer> triple = new ImmutableTriple<>(1, 2, null); [EOL] int expectedHashCode = Integer.valueOf(1).hashCode() ^ Integer.valueOf(2).hashCode() ^ 0; [EOL] assertEquals(expectedHashCode, triple.hashCode()); [EOL] }
public void testHashCode_AllNull() { [EOL] Triple<Integer, Integer, Integer> triple = new ImmutableTriple<>(null, null, null); [EOL] assertEquals(0, triple.hashCode()); [EOL] }
public void testAppendLongArray_Null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] long[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{}"); [EOL] } [EOL] public void testAppendLongArray_Empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] long[] array = new long[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{}"); [EOL] } [EOL] public void testAppendLongArray_NonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] long[] array = new long[] {1, 2, 3}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{1,2,3}"); [EOL] }

public void testAppend_StringObject() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] String fieldName = "field"; [EOL] Object value = new Object(); [EOL] ToStringBuilder result = tsb.append(fieldName, value); [EOL] assertNotNull(result); [EOL] assertTrue(result.toString().contains(fieldName)); [EOL] assertTrue(result.toString().contains(value.toString())); [EOL] }
public void testAppend_StringObject_NullField() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] String fieldName = null; [EOL] Object value = new Object(); [EOL] ToStringBuilder result = tsb.append(fieldName, value); [EOL] assertNotNull(result); [EOL] assertFalse(result.toString().contains("null=")); [EOL] }
public void testAppend_StringObject_NullObject() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] String fieldName = "field"; [EOL] Object value = null; [EOL] ToStringBuilder result = tsb.append(fieldName, value); [EOL] assertNotNull(result); [EOL] assertTrue(result.toString().contains(fieldName + "=null")); [EOL] }
public void testToStringWhenObjectIsNull() { [EOL] this.setObject(null); // Set the object to null [EOL] String result = this.toString(); [EOL] String expected = this.getStyle().getNullText(); [EOL] assertEquals(expected, result); [EOL] }
public void testToStringWhenObjectIsNotNull() { [EOL] this.setObject(new Object()); // Set the object to a non-null value [EOL] String result = this.toString(); [EOL] String expected = this.getStringRepresentation(this.getObject()); [EOL] assertEquals(expected, result); [EOL] }
public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { [EOL] if (cal1 == null || cal2 == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public void testParseDateWithLeniency_NullDate() { [EOL] try { [EOL] parseDateWithLeniency(null, Locale.ENGLISH, new String[]{"yyyy-MM-dd"}, true); [EOL] fail("Should have thrown IllegalArgumentException for null date"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } catch (ParseException pe) { [EOL] fail("Should have thrown IllegalArgumentException instead of ParseException"); [EOL] } [EOL] } [EOL] public void testParseDateWithLeniency_NullPatterns() { [EOL] try { [EOL] parseDateWithLeniency("2020-01-01", Locale.ENGLISH, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null patterns"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } catch (ParseException pe) { [EOL] fail("Should have thrown IllegalArgumentException instead of ParseException"); [EOL] } [EOL] } [EOL] public void testParseDateWithLeniency_ValidDateWithoutLeniency() throws ParseException { [EOL] String[] patterns = {"yyyy-MM-dd"}; [EOL] Date date = parseDateWithLeniency("2020-01-01", Locale.ENGLISH, patterns, false); [EOL] assertNotNull("Date should not be null when parsed with correct pattern", date); [EOL] } [EOL] public void testParseDateWithLeniency_ValidDateWithLeniency() throws ParseException { [EOL] String[] patterns = {"yyyy-MM-dd"}; [EOL] Date date = parseDateWithLeniency("2020-01-01", Locale.ENGLISH, patterns, true); [EOL] assertNotNull("Date should not be null when parsed with correct pattern", date); [EOL] } [EOL] public void testParseDateWithLeniency_InvalidDate() { [EOL] String[] patterns = {"yyyy-MM-dd"}; [EOL] try { [EOL] parseDateWithLeniency("invalid-date", Locale.ENGLISH, patterns, true); [EOL] fail("Should have thrown ParseException for invalid date"); [EOL] } catch (ParseException pe) { [EOL] } [EOL] } [EOL] public void testParseDateWithLeniency_PatternWithZZ() throws ParseException { [EOL] String[] patterns = {"yyyy-MM-ddZZ"}; [EOL] Date date = parseDateWithLeniency("2020-01-01+01:00", Locale.ENGLISH, patterns, true); [EOL] assertNotNull("Date should not be null when parsed with ZZ pattern", date); [EOL] } [EOL] public void testParseDateWithLeniency_PatternWithoutZZ() throws ParseException { [EOL] String[] patterns = {"yyyy-MM-dd"}; [EOL] Date date = parseDateWithLeniency("2020-01-01", Locale.ENGLISH, patterns, true); [EOL] assertNotNull("Date should not be null when parsed without ZZ pattern", date); [EOL] } [EOL] public void testParseDateWithLeniency_NullLocale() throws ParseException { [EOL] String[] patterns = {"yyyy-MM-dd"}; [EOL] Date date = parseDateWithLeniency("2020-01-01", null, patterns, true); [EOL] assertNotNull("Date should not be null when parsed with null locale", date); [EOL] }
public static Date addYears(final Date date, final int amount) { [EOL] return add(date, Calendar.YEAR, amount); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };
public void testAddMinutes_nullDate() { [EOL] try { [EOL] Date result = DateUtils.addMinutes(null, 5); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testAddMinutes() { [EOL] final Date date = new Date(); [EOL] final int amount = 5; [EOL] final Date expected = new Date(date.getTime() + amount * 60 * 1000); [EOL] final Date result = DateUtils.addMinutes(date, amount); [EOL] assertEquals(expected, result); [EOL] }
public void testAddSeconds_nullDate() { [EOL] try { [EOL] Date result = DateUtils.addSeconds(null, 5); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testAddSeconds_zero() { [EOL] final Date date = new Date(); [EOL] final Date result = DateUtils.addSeconds(date, 0); [EOL] assertEquals(date, result); [EOL] } [EOL] public void testAddSeconds_positive() { [EOL] final Date date = new Date(); [EOL] final Date result = DateUtils.addSeconds(date, 1); [EOL] assertEquals(new Date(date.getTime() + 1000), result); [EOL] } [EOL] public void testAddSeconds_negative() { [EOL] final Date date = new Date(); [EOL] final Date result = DateUtils.addSeconds(date, -1); [EOL] assertEquals(new Date(date.getTime() - 1000), result); [EOL] }
public static Date setYears(final Date date, final int amount) { [EOL] return set(date, Calendar.YEAR, amount); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }
public static Date setHours(final Date date, final int amount) { [EOL] return set(date, Calendar.HOUR_OF_DAY, amount); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public static Date setMilliseconds(final Date date, final int amount) { [EOL] return set(date, Calendar.MILLISECOND, amount); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }
public void testRound_NullDate_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateUtils.round(null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRound_ValidDateField_RoundsCorrectly() { [EOL] Date date = new Date(); [EOL] Date roundedDate = DateUtils.round(date, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Rounded date should not be null", roundedDate); [EOL] }
public void testRound_ValidDateDifferentField_RoundsCorrectly() { [EOL] Date date = new Date(); [EOL] Date roundedDate = DateUtils.round(date, Calendar.MONTH); [EOL] assertNotNull("Rounded date should not be null", roundedDate); [EOL] }
public void testRoundCalendarWithNullDate() { [EOL] try { [EOL] DateUtils.round((Calendar) null, Calendar.MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRoundCalendarWithValidDateAndField() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.JANUARY, 25, 1, 29, 59); [EOL] cal.set(Calendar.MILLISECOND, 999); [EOL] Calendar rounded = DateUtils.round(cal, Calendar.HOUR); [EOL] assertEquals(2023, rounded.get(Calendar.YEAR)); [EOL] assertEquals(Calendar.JANUARY, rounded.get(Calendar.MONTH)); [EOL] assertEquals(25, rounded.get(Calendar.DATE)); [EOL] assertEquals(2, rounded.get(Calendar.HOUR_OF_DAY)); [EOL] assertEquals(0, rounded.get(Calendar.MINUTE)); [EOL] assertEquals(0, rounded.get(Calendar.SECOND)); [EOL] assertEquals(0, rounded.get(Calendar.MILLISECOND)); [EOL] }
public void testRoundCalendarWithDifferentFields() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.JANUARY, 25, 1, 29, 59); [EOL] cal.set(Calendar.MILLISECOND, 999); [EOL] Calendar roundedMinute = DateUtils.round(cal, Calendar.MINUTE); [EOL] assertEquals(2023, roundedMinute.get(Calendar.YEAR)); [EOL] assertEquals(Calendar.JANUARY, roundedMinute.get(Calendar.MONTH)); [EOL] assertEquals(25, roundedMinute.get(Calendar.DATE)); [EOL] assertEquals(1, roundedMinute.get(Calendar.HOUR_OF_DAY)); [EOL] assertEquals(30, roundedMinute.get(Calendar.MINUTE)); [EOL] assertEquals(0, roundedMinute.get(Calendar.SECOND)); [EOL] assertEquals(0, roundedMinute.get(Calendar.MILLISECOND)); [EOL] Calendar roundedMonth = DateUtils.round(cal, Calendar.MONTH); [EOL] assertEquals(2023, roundedMonth.get(Calendar.YEAR)); [EOL] assertEquals(Calendar.FEBRUARY, roundedMonth.get(Calendar.MONTH)); [EOL] assertEquals(1, roundedMonth.get(Calendar.DATE)); [EOL] assertEquals(0, roundedMonth.get(Calendar.HOUR_OF_DAY)); [EOL] assertEquals(0, roundedMonth.get(Calendar.MINUTE)); [EOL] assertEquals(0, roundedMonth.get(Calendar.SECOND)); [EOL] assertEquals(0, roundedMonth.get(Calendar.MILLISECOND)); [EOL] }
public static Date round(final Object date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] if (date instanceof Date) { [EOL] return round((Date) date, field); [EOL] } else if (date instanceof Calendar) { [EOL] return round((Calendar) date, field).getTime(); [EOL] } else { [EOL] throw new ClassCastException("Could not round " + date); [EOL] } [EOL] }
private static void modify(final Calendar val, final int field, final int modType) { [EOL] if (val.get(Calendar.YEAR) > 280000000) { [EOL] throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL] } [EOL] if (field == Calendar.MILLISECOND) { [EOL] return; [EOL] } [EOL] final Date date = val.getTime(); [EOL] long time = date.getTime(); [EOL] boolean done = false; [EOL] final int millisecs = val.get(Calendar.MILLISECOND); [EOL] if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL] time = time - millisecs; [EOL] } [EOL] if (field == Calendar.SECOND) { [EOL] done = true; [EOL] } [EOL] final int seconds = val.get(Calendar.SECOND); [EOL] if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL] time = time - (seconds * 1000L); [EOL] } [EOL] if (field == Calendar.MINUTE) { [EOL] done = true; [EOL] } [EOL] final int minutes = val.get(Calendar.MINUTE); [EOL] if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL] time = time - (minutes * 60000L); [EOL] } [EOL] if (date.getTime() != time) { [EOL] date.setTime(time); [EOL] val.setTime(date); [EOL] } [EOL] boolean roundUp = false; [EOL] for (final int[] aField : fields) { [EOL] for (final int element : aField) { [EOL] if (element == field) { [EOL] if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL] if (field == DateUtils.SEMI_MONTH) { [EOL] if (val.get(Calendar.DATE) == 1) { [EOL] val.add(Calendar.DATE, 15); [EOL] } else { [EOL] val.add(Calendar.DATE, -15); [EOL] val.add(Calendar.MONTH, 1); [EOL] } [EOL] } else if (field == Calendar.AM_PM) { [EOL] if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL] val.add(Calendar.HOUR_OF_DAY, 12); [EOL] } else { [EOL] val.add(Calendar.HOUR_OF_DAY, -12); [EOL] val.add(Calendar.DATE, 1); [EOL] } [EOL] } else { [EOL] val.add(aField[0], 1); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] int offset = 0; [EOL] boolean offsetSet = false; [EOL] switch(field) { [EOL] case DateUtils.SEMI_MONTH: [EOL] if (aField[0] == Calendar.DATE) { [EOL] offset = val.get(Calendar.DATE) - 1; [EOL] if (offset >= 15) { [EOL] offset -= 15; [EOL] } [EOL] roundUp = offset > 7; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] case Calendar.AM_PM: [EOL] if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL] offset = val.get(Calendar.HOUR_OF_DAY); [EOL] if (offset >= 12) { [EOL] offset -= 12; [EOL] } [EOL] roundUp = offset >= 6; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] } [EOL] if (!offsetSet) { [EOL] final int min = val.getActualMinimum(aField[0]); [EOL] final int max = val.getActualMaximum(aField[0]); [EOL] offset = val.get(aField[0]) - min; [EOL] roundUp = offset > ((max - min) / 2); [EOL] } [EOL] if (offset != 0) { [EOL] val.set(aField[0], val.get(aField[0]) - offset); [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] }
public void testGetFragmentInMillisecondsWithCalendarAndFragment() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] int fragment = Calendar.DAY_OF_MONTH; [EOL] long result = DateUtils.getFragmentInMilliseconds(calendar, fragment); [EOL] }
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { [EOL] return getFragment(calendar, fragment, Calendar.MINUTE); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public static long getFragmentInDays(final Calendar calendar, final int fragment) { [EOL] return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL] if (calendar == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final long millisPerUnit = getMillisPerUnit(unit); [EOL] long result = 0; [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] case Calendar.MONTH: [EOL] result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] } [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] case Calendar.MONTH: [EOL] case Calendar.DAY_OF_YEAR: [EOL] case Calendar.DATE: [EOL] result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL] case Calendar.HOUR_OF_DAY: [EOL] result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL] case Calendar.MINUTE: [EOL] result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL] case Calendar.SECOND: [EOL] result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL] break; [EOL] case Calendar.MILLISECOND: [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL] } [EOL] return result; [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public void testGetMillisPerUnitWithDayOfYear() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.DAY_OF_YEAR); [EOL] assertEquals(DateUtils.MILLIS_PER_DAY, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithDate() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.DATE); [EOL] assertEquals(DateUtils.MILLIS_PER_DAY, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithHourOfDay() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.HOUR_OF_DAY); [EOL] assertEquals(DateUtils.MILLIS_PER_HOUR, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithMinute() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.MINUTE); [EOL] assertEquals(DateUtils.MILLIS_PER_MINUTE, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithSecond() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.SECOND); [EOL] assertEquals(DateUtils.MILLIS_PER_SECOND, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithMillisecond() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.MILLISECOND); [EOL] assertEquals(1, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithInvalidUnit() { [EOL] try { [EOL] DateUtils.getMillisPerUnit(Calendar.YEAR); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testInitials_emptyString() { [EOL] String str = ""; [EOL] char[] delimiters = new char[]{' ', '.'}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("", result); [EOL] } [EOL] public void testInitials_nullString() { [EOL] String str = null; [EOL] char[] delimiters = new char[]{' ', '.'}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertNull(result); [EOL] } [EOL] public void testInitials_noDelimiters() { [EOL] String str = "John Doe"; [EOL] char[] delimiters = new char[]{}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("", result); [EOL] } [EOL] public void testInitials_nullDelimiters() { [EOL] String str = "John Doe"; [EOL] char[] delimiters = null; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("JD", result); [EOL] } [EOL] public void testInitials_typicalCase() { [EOL] String str = "John Doe"; [EOL] char[] delimiters = new char[]{' '}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("JD", result); [EOL] } [EOL] public void testInitials_multipleDelimiters() { [EOL] String str = "John Q. Public"; [EOL] char[] delimiters = new char[]{' ', '.'}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("JQP", result); [EOL] } [EOL] public void testInitials_noGaps() { [EOL] String str = "John"; [EOL] char[] delimiters = new char[]{' ', '.'}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("J", result); [EOL] } [EOL] public void testInitials_allGaps() { [EOL] String str = "   "; [EOL] char[] delimiters = new char[]{' '}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("", result); [EOL] } [EOL] public void testInitials_emptyDelimiters() { [EOL] String str = "John Doe"; [EOL] char[] delimiters = new char[]{}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("", result); [EOL] } [EOL] public void testInitials_specialCharacters() { [EOL] String str = "John-Doe"; [EOL] char[] delimiters = new char[]{'-'}; [EOL] String result = StringUtils.initials(str, delimiters); [EOL] assertEquals("JD", result); [EOL] }
public void testTranslateWithNonZeroConsumption() throws IOException { [EOL] CharSequenceTranslator firstTranslator = mock(CharSequenceTranslator.class); [EOL] CharSequenceTranslator secondTranslator = mock(CharSequenceTranslator.class); [EOL] when(firstTranslator.translate(any(CharSequence.class), anyInt(), any(Writer.class))).thenReturn(0); [EOL] when(secondTranslator.translate(any(CharSequence.class), anyInt(), any(Writer.class))).thenReturn(1); [EOL] AggregateTranslator aggregateTranslator = new AggregateTranslator(firstTranslator, secondTranslator); [EOL] Writer out = new StringWriter(); [EOL] int result = aggregateTranslator.translate("input", 0, out); [EOL] assertEquals(1, result); [EOL] }
public void testTranslateWithZeroConsumption() throws IOException { [EOL] CharSequenceTranslator firstTranslator = mock(CharSequenceTranslator.class); [EOL] CharSequenceTranslator secondTranslator = mock(CharSequenceTranslator.class); [EOL] when(firstTranslator.translate(any(CharSequence.class), anyInt(), any(Writer.class))).thenReturn(0); [EOL] when(secondTranslator.translate(any(CharSequence.class), anyInt(), any(Writer.class))).thenReturn(0); [EOL] AggregateTranslator aggregateTranslator = new AggregateTranslator(firstTranslator, secondTranslator); [EOL] Writer out = new StringWriter(); [EOL] int result = aggregateTranslator.translate("input", 0, out); [EOL] assertEquals(0, result); [EOL] }
public void testLocaleUtilsConstructor() { [EOL] new LocaleUtils(); [EOL] }
public void testToMapWithNullArray() { [EOL] Object[] array = null; [EOL] Map<Object, Object> result = toMap(array); [EOL] assertNull(result); [EOL] }
public void testToMapWithEmptyArray() { [EOL] Object[] array = new Object[0]; [EOL] Map<Object, Object> result = toMap(array); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testToMapWithValidMapEntries() { [EOL] Object[] array = new Object[] { [EOL] new AbstractMap.SimpleEntry<>("key1", "value1"), [EOL] new AbstractMap.SimpleEntry<>("key2", "value2") [EOL] }; [EOL] Map<Object, Object> result = toMap(array); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("value1", result.get("key1")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testToMapWithValidArrayEntries() { [EOL] Object[] array = new Object[] { [EOL] new Object[] {"key1", "value1"}, [EOL] new Object[] {"key2", "value2"} [EOL] }; [EOL] Map<Object, Object> result = toMap(array); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("value1", result.get("key1")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testToMapWithInvalidArrayEntry() { [EOL] Object[] array = new Object[] { [EOL] new Object[] {"key1"} [EOL] }; [EOL] try { [EOL] toMap(array); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToMapWithInvalidElement() { [EOL] Object[] array = new Object[] { [EOL] "InvalidElement" [EOL] }; [EOL] try { [EOL] toMap(array); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToArray_withNull() { [EOL] Object[] result = toArray(null); [EOL] assertNull(result); [EOL] }
public void testToArray_withEmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] String[] result = toArray(emptyArray); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testToArray_withSingleElement() { [EOL] String[] singleElementArray = new String[]{"element"}; [EOL] String[] result = toArray(singleElementArray); [EOL] assertArrayEquals(singleElementArray, result); [EOL] }
public void testToArray_withMultipleElements() { [EOL] String[] multipleElementsArray = new String[]{"element1", "element2", "element3"}; [EOL] String[] result = toArray(multipleElementsArray); [EOL] assertArrayEquals(multipleElementsArray, result); [EOL] }
public void testClone_NullArray() { [EOL] float[] array = null; [EOL] float[] clonedArray = ArrayUtils.clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] float[] array = new float[0]; [EOL] float[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] short[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyInput() { [EOL] short[] emptyArray = new short[0]; [EOL] short[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyInput() { [EOL] short[] nonEmptyArray = new short[]{1, 2, 3}; [EOL] short[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] Boolean[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Boolean[] emptyArray = new Boolean[0]; [EOL] Boolean[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Boolean[] nonEmptyArray = new Boolean[] {true, false, null}; [EOL] Boolean[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testSubarray_NullArray() { [EOL] long[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_NegativeStartIndex() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long[] result = ArrayUtils.subarray(array, -1, 3); [EOL] assertArrayEquals(new long[]{1, 2, 3}, result); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long[] result = ArrayUtils.subarray(array, 1, 10); [EOL] assertArrayEquals(new long[]{2, 3, 4, 5}, result); [EOL] } [EOL] public void testSubarray_ZeroLengthResult() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long[] result = ArrayUtils.subarray(array, 3, 3); [EOL] assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long[] result = ArrayUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new long[]{2, 3, 4}, result); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] byte[] array1 = null; [EOL] byte[] array2 = null; [EOL] assertTrue(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] byte[] array1 = null; [EOL] byte[] array2 = new byte[] {1, 2, 3}; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_SecondArrayNullFirstArrayNotEmpty() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = null; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_ArraysDifferentLengths() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = new byte[] {1, 2}; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_ArraysSameLength() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = new byte[] {4, 5, 6}; [EOL] assertTrue(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] double[] array1 = null; [EOL] double[] array2 = null; [EOL] assertTrue(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] double[] array1 = null; [EOL] double[] array2 = new double[] {1.0, 2.0}; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_SecondArrayNullFirstArrayNotEmpty() { [EOL] double[] array1 = new double[] {1.0, 2.0}; [EOL] double[] array2 = null; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_ArraysDifferentLengths() { [EOL] double[] array1 = new double[] {1.0, 2.0}; [EOL] double[] array2 = new double[] {1.0}; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_ArraysSameLength() { [EOL] double[] array1 = new double[] {1.0, 2.0}; [EOL] double[] array2 = new double[] {3.0, 4.0}; [EOL] assertTrue(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] float[] array1 = null; [EOL] float[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] float[] array1 = null; [EOL] float[] array2 = new float[] {1.0f, 2.0f}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSameLength_SecondArrayNullFirstArrayNotEmpty() { [EOL] float[] array1 = new float[] {1.0f, 2.0f}; [EOL] float[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSameLength_ArraysDifferentLengths() { [EOL] float[] array1 = new float[] {1.0f}; [EOL] float[] array2 = new float[] {1.0f, 2.0f}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSameLength_ArraysSameLength() { [EOL] float[] array1 = new float[] {1.0f, 2.0f}; [EOL] float[] array2 = new float[] {3.0f, 4.0f}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testReverse_NullArray() { [EOL] int[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "The array should remain null after reverse operation."); [EOL] }
public void testReverse_EmptyArray() { [EOL] int[] array = {}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new int[]{}, array, "An empty array should remain unchanged after reverse operation."); [EOL] }
public void testReverse_SingleElementArray() { [EOL] int[] array = {1}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new int[]{1}, array, "A single-element array should remain unchanged after reverse operation."); [EOL] }
public void testReverse_MultipleElementsArray() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new int[]{4, 3, 2, 1}, array, "A multiple-element array should be reversed correctly."); [EOL] }
public void testIndexOf_NullArray() { [EOL] int result = ArrayUtils.indexOf(null, "a"); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ObjectNotInArray() { [EOL] String[] array = new String[] {"b", "c", "d"}; [EOL] int result = ArrayUtils.indexOf(array, "a"); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ObjectInArray() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] int result = ArrayUtils.indexOf(array, "a"); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_ObjectInArrayFromIndex() { [EOL] String[] array = new String[] {"a", "b", "a"}; [EOL] int result = ArrayUtils.indexOf(array, "a", 1); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_NullArray() { [EOL] final Object[] array = null; [EOL] final Object objectToFind = new Object(); [EOL] final int startIndex = 0; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final Object[] array = new Object[] { "a", "b", "c" }; [EOL] final Object objectToFind = "b"; [EOL] final int startIndex = -1; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_NullObjectToFind() { [EOL] final Object[] array = new Object[] { null, "b", null }; [EOL] final Object objectToFind = null; [EOL] final int startIndex = 0; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_ObjectToFindNotPresent() { [EOL] final Object[] array = new Object[] { "a", "b", "c" }; [EOL] final Object objectToFind = "d"; [EOL] final int startIndex = 0; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ObjectToFindPresent() { [EOL] final Object[] array = new Object[] { "a", "b", "c" }; [EOL] final Object objectToFind = "b"; [EOL] final int startIndex = 0; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_ValidStartIndex() { [EOL] final Object[] array = new Object[] { "a", "b", "c", "b" }; [EOL] final Object objectToFind = "b"; [EOL] final int startIndex = 2; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanArrayLength() { [EOL] final Object[] array = new Object[] { "a", "b", "c" }; [EOL] final Object objectToFind = "b"; [EOL] final int startIndex = 4; [EOL] final int result = indexOf(array, objectToFind, startIndex); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_withValuePresent() { [EOL] short[] array = {1, 2, 3, 2, 1}; [EOL] int index = ArrayUtils.lastIndexOf(array, (short) 2); [EOL] assertEquals(3, index); [EOL] }
public void testLastIndexOf_withValueNotPresent() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] int index = ArrayUtils.lastIndexOf(array, (short) 6); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withEmptyArray() { [EOL] short[] array = new short[0]; [EOL] int index = ArrayUtils.lastIndexOf(array, (short) 1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withNullArray() { [EOL] int index = ArrayUtils.lastIndexOf(null, (short) 1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] final short valueToFind = 0; [EOL] final int startIndex = 0; [EOL] final int result = ArrayUtils.lastIndexOf(null, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_StartIndexLessThanZero() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 3; [EOL] final int startIndex = -1; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_StartIndexGreaterThanOrEqualToArrayLength() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 3; [EOL] final int startIndex = 5; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_ValueNotFound() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 6; [EOL] final int startIndex = 4; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_ValueFound() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 3}; [EOL] final short valueToFind = 3; [EOL] final int startIndex = 4; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(4, result); [EOL] }
public void testContains_withEmptyArray() { [EOL] short[] array = {}; [EOL] short valueToFind = 1; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withNullArray() { [EOL] short[] array = null; [EOL] short valueToFind = 1; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withArrayContainingValue() { [EOL] short[] array = {1, 2, 3}; [EOL] short valueToFind = 2; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_withArrayNotContainingValue() { [EOL] short[] array = {1, 2, 3}; [EOL] short valueToFind = 4; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_CharArrayChar_Found() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char valueToFind = 'b'; [EOL] boolean result = StringUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_CharArrayChar_NotFound() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char valueToFind = 'd'; [EOL] boolean result = StringUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_CharArrayChar_EmptyArray() { [EOL] char[] array = {}; [EOL] char valueToFind = 'a'; [EOL] boolean result = StringUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_CharArrayChar_NullArray() { [EOL] char[] array = null; [EOL] char valueToFind = 'a'; [EOL] boolean result = StringUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testIndexOf_NullArray() { [EOL] final byte[] array = null; [EOL] final byte valueToFind = 0x00; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x02; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanLength() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x02; [EOL] int startIndex = 4; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x04; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueFound() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x02; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_withEmptyArray() { [EOL] double[] array = {}; [EOL] double valueToFind = 1.0; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_withValuePresent() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.0; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, tolerance); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_withValueNotPresent() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 4.0; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_withNegativeTolerance() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.0; [EOL] double tolerance = -0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_withValueOnToleranceEdge() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.1; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, tolerance); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_withValueJustOutsideTolerance() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.11; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOfEmptyArray() { [EOL] double[] array = {}; [EOL] double valueToFind = 1.0; [EOL] int startIndex = 0; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex, tolerance); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfNegativeStartIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = -1; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex, tolerance); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOfValidCase() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = 0; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex, tolerance); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOfValueNotFound() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0}; [EOL] double valueToFind = 5.0; [EOL] int startIndex = 0; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex, tolerance); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfWithTolerance() { [EOL] double[] array = {1.0, 2.1, 3.0, 4.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = 0; [EOL] double tolerance = 0.2; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex, tolerance); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOfWithStartIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = 2; [EOL] double tolerance = 0.1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex, tolerance); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_withEmptyArray() { [EOL] boolean[] array = {}; [EOL] int index = ArrayUtils.lastIndexOf(array, true); [EOL] assertEquals(-1, index); [EOL] } [EOL] public void testLastIndexOf_withNullArray() { [EOL] boolean[] array = null; [EOL] int index = ArrayUtils.lastIndexOf(array, true); [EOL] assertEquals(-1, index); [EOL] } [EOL] public void testLastIndexOf_withTrueValue() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.lastIndexOf(array, true); [EOL] assertEquals(3, index); [EOL] } [EOL] public void testLastIndexOf_withFalseValue() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.lastIndexOf(array, false); [EOL] assertEquals(4, index); [EOL] } [EOL] public void testLastIndexOf_withTrueValueAndMaxIndex() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.lastIndexOf(array, true, 2); [EOL] assertEquals(1, index); [EOL] } [EOL] public void testLastIndexOf_withFalseValueAndMaxIndex() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.lastIndexOf(array, false, 2); [EOL] assertEquals(2, index); [EOL] }
public void testLastIndexOf_emptyArray() { [EOL] boolean[] array = {}; [EOL] int index = ArrayUtils.lastIndexOf(array, true, 1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_startIndexNegative() { [EOL] boolean[] array = {true, false, true}; [EOL] int index = ArrayUtils.lastIndexOf(array, true, -1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_startIndexGreaterThanLength() { [EOL] boolean[] array = {false, true, false}; [EOL] int index = ArrayUtils.lastIndexOf(array, true, 5); [EOL] assertEquals(1, index); [EOL] }
public void testLastIndexOf_valueNotFound() { [EOL] boolean[] array = {false, false, false}; [EOL] int index = ArrayUtils.lastIndexOf(array, true, 2); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_valueFound() { [EOL] boolean[] array = {true, false, true}; [EOL] int index = ArrayUtils.lastIndexOf(array, true, 2); [EOL] assertEquals(2, index); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Character[] charObjectArray = null; [EOL] char[] result = ArrayUtils.toPrimitive(charObjectArray); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Character[] charObjectArray = new Character[0]; [EOL] char[] result = ArrayUtils.toPrimitive(charObjectArray); [EOL] assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonEmptyArray() { [EOL] Character[] charObjectArray = new Character[] {'a', 'b', 'c'}; [EOL] char[] result = ArrayUtils.toPrimitive(charObjectArray); [EOL] char[] expected = new char[] {'a', 'b', 'c'}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToObjectWithNullArray() { [EOL] char[] array = null; [EOL] Character[] result = ArrayUtils.toObject(array); [EOL] assertNull(result); [EOL] }
public void testToObjectWithEmptyArray() { [EOL] char[] array = {}; [EOL] Character[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObjectWithNonEmptyArray() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] Character[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(Character.valueOf(array[i]), result[i]); [EOL] } [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Byte[] byteObjectArray = null; [EOL] byte[] result = ArrayUtils.toPrimitive(byteObjectArray); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Byte[] byteObjectArray = new Byte[0]; [EOL] byte[] result = ArrayUtils.toPrimitive(byteObjectArray); [EOL] assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonEmptyArray() { [EOL] Byte[] byteObjectArray = new Byte[] {1, 2, 3}; [EOL] byte[] result = ArrayUtils.toPrimitive(byteObjectArray); [EOL] byte[] expected = new byte[] {1, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] double[] result = ArrayUtils.toPrimitive(null, 0.0); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Double[] emptyArray = new Double[0]; [EOL] double[] result = ArrayUtils.toPrimitive(emptyArray, 0.0); [EOL] assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullElements() { [EOL] Double[] arrayWithValues = new Double[] {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.toPrimitive(arrayWithValues, 0.0); [EOL] double[] expected = new double[] {1.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullElements() { [EOL] Double[] arrayWithNulls = new Double[] {null, 2.0, null}; [EOL] double valueForNull = -1.0; [EOL] double[] result = ArrayUtils.toPrimitive(arrayWithNulls, valueForNull); [EOL] double[] expected = new double[] {-1.0, 2.0, -1.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToObjectWithNullArray() { [EOL] Double[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObjectWithEmptyArray() { [EOL] double[] array = {}; [EOL] Double[] result = ArrayUtils.toObject(array); [EOL] assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, result); [EOL] }
public void testToObjectWithNonEmptyArray() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] Double[] result = ArrayUtils.toObject(array); [EOL] Double[] expected = {1.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToObjectWithNullArray() { [EOL] Float[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObjectWithEmptyArray() { [EOL] float[] array = {}; [EOL] Float[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObjectWithNonEmptyArray() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] Float[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(Float.valueOf(array[i]), result[i]); [EOL] } [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] boolean[] result = ArrayUtils.toPrimitive(null, true); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Boolean[] array = new Boolean[0]; [EOL] boolean[] result = ArrayUtils.toPrimitive(array, true); [EOL] assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndTrueValueForNull() { [EOL] Boolean[] array = new Boolean[] {true, null, false}; [EOL] boolean[] result = ArrayUtils.toPrimitive(array, true); [EOL] boolean[] expected = new boolean[] {true, true, false}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndFalseValueForNull() { [EOL] Boolean[] array = new Boolean[] {true, null, false}; [EOL] boolean[] result = ArrayUtils.toPrimitive(array, false); [EOL] boolean[] expected = new boolean[] {true, false, false}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = ArrayUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] long[] array = {}; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] long[] array = {1, 2, 3}; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = ArrayUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] short[] array = new short[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] short[] array = new short[]{1, 2, 3}; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = StringUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] char[] array = new char[0]; [EOL] boolean result = StringUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] boolean result = StringUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = ArrayUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] byte[] array = new byte[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] byte[] array = new byte[1]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = ArrayUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] double[] array = new double[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] double[] array = new double[]{1.0, 2.0}; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] float[] array = null; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] float[] array = new float[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] float[] array = new float[]{1.0f, 2.0f, 3.0f}; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean[] array = null; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] boolean[] array = new boolean[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] boolean[] array = new boolean[1]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testAddNullArray() { [EOL] char element = 'a'; [EOL] char[] result = ArrayUtils.add(null, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[0]); [EOL] }
public void testAddEmptyArray() { [EOL] char[] array = new char[0]; [EOL] char element = 'b'; [EOL] char[] result = ArrayUtils.add(array, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[0]); [EOL] }
public void testAddNonEmptyArray() { [EOL] char[] array = {'c'}; [EOL] char element = 'd'; [EOL] char[] result = ArrayUtils.add(array, element); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals('c', result[0]); [EOL] assertEquals(element, result[1]); [EOL] }
public void testAdd_NullArray() { [EOL] final double element = 1.0; [EOL] final double[] result = ArrayUtils.add(null, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[0], 0.01); [EOL] } [EOL] public void testAdd_EmptyArray() { [EOL] final double[] array = new double[0]; [EOL] final double element = 2.0; [EOL] final double[] result = ArrayUtils.add(array, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[0], 0.01); [EOL] } [EOL] public void testAdd_PopulatedArray() { [EOL] final double[] array = {1.0, 3.0}; [EOL] final double element = 2.0; [EOL] final double[] result = ArrayUtils.add(array, element); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals(element, result[2], 0.01); [EOL] }
public void testRemoveBooleanArrayAtIndex() { [EOL] boolean[] array = {true, false, true, false}; [EOL] boolean[] result = ArrayUtils.remove(array, 2); [EOL] boolean[] expected = {true, false, false}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveBooleanArrayAtFirstIndex() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.remove(array, 0); [EOL] boolean[] expected = {false, true}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveBooleanArrayAtLastIndex() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.remove(array, array.length - 1); [EOL] boolean[] expected = {true, false}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveBooleanArrayOutOfBounds() { [EOL] boolean[] array = {true, false, true}; [EOL] try { [EOL] ArrayUtils.remove(array, array.length); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveBooleanArrayFromEmpty() { [EOL] boolean[] array = {}; [EOL] try { [EOL] ArrayUtils.remove(array, 0); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveBooleanArrayWithNullInput() { [EOL] boolean[] array = null; [EOL] try { [EOL] ArrayUtils.remove(array, 0); [EOL] fail("Should throw a NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRemove_withValidIndex() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int indexToRemove = 2; [EOL] int[] expected = {1, 2, 4}; [EOL] int[] result = ArrayUtils.remove(array, indexToRemove); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_withFirstIndex() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int indexToRemove = 0; [EOL] int[] expected = {2, 3, 4}; [EOL] int[] result = ArrayUtils.remove(array, indexToRemove); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_withLastIndex() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int indexToRemove = 3; [EOL] int[] expected = {1, 2, 3}; [EOL] int[] result = ArrayUtils.remove(array, indexToRemove); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_withInvalidIndex() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int indexToRemove = 4; [EOL] try { [EOL] ArrayUtils.remove(array, indexToRemove); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_withEmptyArray() { [EOL] int[] array = {}; [EOL] int indexToRemove = 0; [EOL] try { [EOL] ArrayUtils.remove(array, indexToRemove); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_withNullArray() { [EOL] int[] array = null; [EOL] int indexToRemove = 0; [EOL] try { [EOL] ArrayUtils.remove(array, indexToRemove); [EOL] fail("Should have thrown a NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRemoveElements_NullArray() { [EOL] long[] result = ArrayUtils.removeElements(null, 1L, 2L); [EOL] assertNull(result); [EOL] }
public void testRemoveElements_EmptyArray() { [EOL] long[] array = {}; [EOL] long[] result = ArrayUtils.removeElements(array, 1L, 2L); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElements_NoValuesToRemove() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.removeElements(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElements_NoMatch() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.removeElements(array, 4L); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElements_SingleMatch() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.removeElements(array, 2L); [EOL] long[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_MultipleMatches() { [EOL] long[] array = {1, 2, 3, 2, 2}; [EOL] long[] result = ArrayUtils.removeElements(array, 2L); [EOL] long[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_MultipleValues() { [EOL] long[] array = {1, 2, 3, 4, 2, 3}; [EOL] long[] result = ArrayUtils.removeElements(array, 2L, 3L); [EOL] long[] expected = {1, 4}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_MultipleOccurrences() { [EOL] long[] array = {1, 2, 3, 1, 2, 3}; [EOL] long[] result = ArrayUtils.removeElements(array, 1L, 2L, 3L); [EOL] long[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_NullArray() { [EOL] boolean[] result = ArrayUtils.removeAll((boolean[]) null, 1, 2); [EOL] assertNull(result); [EOL] }
public void testRemoveAll_EmptyArray() { [EOL] boolean[] emptyArray = new boolean[0]; [EOL] boolean[] result = ArrayUtils.removeAll(emptyArray, 1, 2); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testRemoveAll_NoIndex() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.removeAll(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_SingleIndex() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.removeAll(array, 1); [EOL] boolean[] expected = {true, true}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_MultipleIndices() { [EOL] boolean[] array = {true, false, true, false}; [EOL] boolean[] result = ArrayUtils.removeAll(array, 0, 2); [EOL] boolean[] expected = {false, false}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_NonConsecutiveIndices() { [EOL] boolean[] array = {true, false, true, false, true}; [EOL] boolean[] result = ArrayUtils.removeAll(array, 1, 3); [EOL] boolean[] expected = {true, true, true}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_AllIndices() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.removeAll(array, 0, 1, 2); [EOL] boolean[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_InvalidIndices() { [EOL] boolean[] array = {true, false, true}; [EOL] try { [EOL] ArrayUtils.removeAll(array, 3); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NegativeIndex() { [EOL] boolean[] array = {true, false, true}; [EOL] try { [EOL] ArrayUtils.removeAll(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetArrayComponentTypeWithClass() { [EOL] Class<?> arrayClass = String[].class; [EOL] Type componentType = getArrayComponentType(arrayClass); [EOL] assertEquals(String.class, componentType); [EOL] }
public void testGetArrayComponentTypeWithNonArrayClass() { [EOL] Class<?> nonArrayClass = String.class; [EOL] Type componentType = getArrayComponentType(nonArrayClass); [EOL] assertNull(componentType); [EOL] }
public void testGetArrayComponentTypeWithGenericArrayType() { [EOL] Type genericArrayType = new GenericArrayType() { [EOL] @Override [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] Type componentType = getArrayComponentType(genericArrayType); [EOL] assertEquals(String.class, componentType); [EOL] }
public void testGetArrayComponentTypeWithNull() { [EOL] Type componentType = getArrayComponentType(null); [EOL] assertNull(componentType); [EOL] }
public void testGetFormattedExceptionMessageWithBaseMessageAndContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] exceptionContext.addContextValue("key2", "value2"); [EOL] String baseMessage = "Base message"; [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] assertTrue(formattedMessage.startsWith(baseMessage)); [EOL] assertTrue(formattedMessage.contains("Exception Context:")); [EOL] assertTrue(formattedMessage.contains("[1:key1=value1]")); [EOL] assertTrue(formattedMessage.contains("[2:key2=value2]")); [EOL] assertTrue(formattedMessage.endsWith("---------------------------------")); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessageAndContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertFalse(formattedMessage.startsWith("null")); [EOL] assertTrue(formattedMessage.contains("Exception Context:")); [EOL] assertTrue(formattedMessage.contains("[1:key1=value1]")); [EOL] assertTrue(formattedMessage.endsWith("---------------------------------")); [EOL] }
public void testGetFormattedExceptionMessageWithBaseMessageAndEmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] String baseMessage = "Base message"; [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] assertEquals(baseMessage, formattedMessage); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessageAndEmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertEquals("", formattedMessage); [EOL] }
public void testGetFormattedExceptionMessageWithExceptionInToString() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Object problematicObject = new Object() { [EOL] @Override [EOL] public String toString() { [EOL] throw new RuntimeException("Exception in toString"); [EOL] } [EOL] }; [EOL] exceptionContext.addContextValue("problematicKey", problematicObject); [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertTrue(formattedMessage.contains("Exception thrown on toString():")); [EOL] }
public void testStrBuilderConstructor() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] assertEquals(CAPACITY, sb.capacity()); [EOL] }
public void testStrBuilderConstructorWithNegativeCapacity() { [EOL] int initialCapacity = -1; [EOL] StrBuilder strBuilder = new StrBuilder(initialCapacity); [EOL] assertEquals(StrBuilder.CAPACITY, strBuilder.capacity()); [EOL] }
public void testStrBuilderConstructorWithZeroCapacity() { [EOL] int initialCapacity = 0; [EOL] StrBuilder strBuilder = new StrBuilder(initialCapacity); [EOL] assertEquals(StrBuilder.CAPACITY, strBuilder.capacity()); [EOL] }
public void testStrBuilderConstructorWithPositiveCapacity() { [EOL] int initialCapacity = 10; [EOL] StrBuilder strBuilder = new StrBuilder(initialCapacity); [EOL] assertEquals(10, strBuilder.capacity()); [EOL] }
public void testStrBuilderConstructorWithNull() { [EOL] StrBuilder sb = new StrBuilder(null); [EOL] assertNotNull(sb); [EOL] assertEquals(StrBuilder.CAPACITY, sb.capacity()); [EOL] }
public void testStrBuilderConstructorWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder(""); [EOL] assertNotNull(sb); [EOL] assertEquals(StrBuilder.CAPACITY, sb.capacity()); [EOL] }
public void testStrBuilderConstructorWithNonEmptyString() { [EOL] String initialString = "test"; [EOL] StrBuilder sb = new StrBuilder(initialString); [EOL] assertNotNull(sb); [EOL] assertEquals(initialString.length() + StrBuilder.CAPACITY, sb.capacity()); [EOL] assertEquals(initialString, sb.toString()); [EOL] }
public void testLength_ZeroSize() { [EOL] YourObject obj = new YourObject(0); // Replace YourObject with the actual class name [EOL] int length = obj.length(); [EOL] assertEquals(0, length); [EOL] }
public void testLength_NonZeroSize() { [EOL] YourObject obj = new YourObject(10); // Replace YourObject with the actual class name and size [EOL] int length = obj.length(); [EOL] assertEquals(10, length); [EOL] }
public void testCapacity_PositiveScenario() { [EOL] StringBuilder buffer = new StringBuilder(10); [EOL] int capacity = buffer.capacity(); [EOL] assertEquals(10, capacity); [EOL] }
public void testEnsureCapacity_WhenCapacityIsLessThanBufferLength() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] int initialCapacity = strBuilder.capacity(); [EOL] int newCapacity = initialCapacity / 2; // ensure newCapacity is less than buffer.length [EOL] StrBuilder result = strBuilder.ensureCapacity(newCapacity); [EOL] assertEquals(strBuilder, result); // assert that the same object is returned [EOL] assertTrue(strBuilder.capacity() >= newCapacity); // assert the capacity is not decreased [EOL] }
public void testEnsureCapacity_WhenCapacityIsGreaterThanBufferLength() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] int initialCapacity = strBuilder.capacity(); [EOL] int newCapacity = initialCapacity * 2; // ensure newCapacity is greater than buffer.length [EOL] StrBuilder result = strBuilder.ensureCapacity(newCapacity); [EOL] assertEquals(strBuilder, result); // assert that the same object is returned [EOL] assertTrue(strBuilder.capacity() >= newCapacity); // assert the capacity is increased as expected [EOL] }
public void testCharAt_ValidIndex() { [EOL] char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] MyClass instance = new MyClass(testBuffer); [EOL] char result = instance.charAt(2); [EOL] assertEquals('c', result); [EOL] } [EOL] public void testCharAt_IndexOutOfBounds_Negative() { [EOL] char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] MyClass instance = new MyClass(testBuffer); [EOL] try { [EOL] instance.charAt(-1); [EOL] fail("Expected an StringIndexOutOfBoundsException to be thrown"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: -1", e.getMessage()); [EOL] } [EOL] } [EOL] public void testCharAt_IndexOutOfBounds_TooLarge() { [EOL] char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] MyClass instance = new MyClass(testBuffer); [EOL] try { [EOL] instance.charAt(testBuffer.length); [EOL] fail("Expected an StringIndexOutOfBoundsException to be thrown"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: " + testBuffer.length, e.getMessage()); [EOL] } [EOL] }
public void testDeleteCharAt_IndexOutOfBounds() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] try { [EOL] strBuilder.deleteCharAt(-1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] try { [EOL] strBuilder.deleteCharAt(3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDeleteCharAt_ValidIndex() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.deleteCharAt(1); [EOL] assertEquals("ac", strBuilder.toString()); [EOL] }
public void testToCharArrayWithEmptyRange() { [EOL] final int startIndex = 5; [EOL] final int endIndex = 5; [EOL] TextStringBuilder builder = new TextStringBuilder("abcdef"); [EOL] char[] result = builder.toCharArray(startIndex, endIndex); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToCharArrayWithValidRange() { [EOL] final int startIndex = 2; [EOL] final int endIndex = 5; [EOL] TextStringBuilder builder = new TextStringBuilder("abcdef"); [EOL] char[] result = builder.toCharArray(startIndex, endIndex); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertArrayEquals(new char[] {'c', 'd', 'e'}, result); [EOL] }
public void testToCharArrayWithInvalidRange() { [EOL] final int startIndex = 7; [EOL] final int endIndex = 10; [EOL] TextStringBuilder builder = new TextStringBuilder("abcdef"); [EOL] try { [EOL] builder.toCharArray(startIndex, endIndex); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Range [7, 10) is out of bounds for length 6", e.getMessage()); [EOL] } [EOL] }
public void testAppendWithNullString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((String) null); [EOL] assertEquals(4, sb.length()); [EOL] assertEquals("null", sb.toString()); [EOL] }
public void testAppendWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(""); [EOL] assertEquals(0, sb.length()); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendWithNonEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append("abc"); [EOL] assertEquals(3, sb.length()); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testAppendStringBuilder_null() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StringBuilder str = null; [EOL] StrBuilder result = strBuilder.append(str); [EOL] assertEquals(strBuilder, result); [EOL] assertEquals(0, strBuilder.length()); [EOL] }
public void testAppendStringBuilder_empty() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder(); [EOL] StrBuilder result = strBuilder.append(str); [EOL] assertEquals(strBuilder, result); [EOL] assertEquals(0, strBuilder.length()); [EOL] }
public void testAppendStringBuilder_nonEmpty() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] StrBuilder result = strBuilder.append(str); [EOL] assertEquals(strBuilder, result); [EOL] assertEquals(3, strBuilder.length()); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testAppendStringBuilderNull() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = null; [EOL] builder.append(str, 0, 0); [EOL] assertEquals("", builder.toString()); [EOL] } [EOL] public void testAppendStringBuilderInvalidStartIndex() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] try { [EOL] builder.append(str, 4, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringBuilderInvalidLength() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] try { [EOL] builder.append(str, 1, 5); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringBuilderValid() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] builder.append(str, 1, 2); [EOL] assertEquals("bc", builder.toString()); [EOL] }
public void testAppendStringBuilderFullLength() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] builder.append(str, 0, str.length()); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testAppendStringBuilderZeroLength() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] builder.append(str, 1, 0); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppend_StrBuilder_null() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((StrBuilder) null); [EOL] assertEquals(0, sb.length()); [EOL] }
public void testAppend_StrBuilder_empty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder(); [EOL] sb.append(toAppend); [EOL] assertEquals(0, sb.length()); [EOL] }
public void testAppend_StrBuilder_nonEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend); [EOL] assertEquals(3, sb.length()); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testAppendlnWithNullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((Object) null); [EOL] assertEquals(sb.toString(), System.lineSeparator()); [EOL] }
public void testAppendlnWithNonNullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] Object obj = new Object() { [EOL] @Override [EOL] public String toString() { [EOL] return "Test"; [EOL] } [EOL] }; [EOL] sb.appendln(obj); [EOL] assertEquals(sb.toString(), "Test" + System.lineSeparator()); [EOL] }
public void testAppendlnWithNullStringBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((StringBuilder) null); [EOL] assertEquals(sb.length(), sb.getNewLineText().length()); [EOL] }
public void testAppendlnWithEmptyStringBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder empty = new StringBuilder(); [EOL] sb.appendln(empty); [EOL] assertEquals(sb.length(), sb.getNewLineText().length()); [EOL] }
public void testAppendlnWithNonEmptyStringBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder nonEmpty = new StringBuilder("Test"); [EOL] sb.appendln(nonEmpty); [EOL] assertEquals(sb.toString(), "Test" + sb.getNewLineText()); [EOL] }
public void testAppendlnWithNullStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((StrBuilder) null); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithNonNullStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.appendln(toAppend); [EOL] assertEquals("abc" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnCharArrayWithValidInput() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] input = {'a', 'b', 'c'}; [EOL] sb.appendln(input, 0, 3); [EOL] assertEquals("abc" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnCharArrayWithStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] input = {'a', 'b', 'c'}; [EOL] sb.appendln(input, 1, 2); [EOL] assertEquals("bc" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnCharArrayWithLengthZero() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] input = {'a', 'b', 'c'}; [EOL] sb.appendln(input, 1, 0); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnCharArrayWithNullInput() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((char[]) null, 0, 0); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithInt() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln(123); [EOL] assertEquals("123" + System.lineSeparator(), sb.toString()); [EOL] }

public void testAppendlnWithLong() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] long value = 12345L; [EOL] sb.appendln(value); [EOL] assertEquals("12345" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithLongNegative() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] long value = -12345L; [EOL] sb.appendln(value); [EOL] assertEquals("-12345" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnFloat() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] float value = 1.0f; [EOL] sb.appendln(value); [EOL] assertEquals("1.0" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnFloatNewLine() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNewLineText("*"); [EOL] float value = 1.0f; [EOL] sb.appendln(value); [EOL] assertEquals("1.0*", sb.toString()); [EOL] }
public void testAppendlnWithDouble() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] double value = 123.456; [EOL] sb.appendln(value); [EOL] assertEquals("123.456" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendSeparator_Char_PositiveLoopIndex() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendSeparator('a', 1); [EOL] assertEquals("a", builder.toString()); [EOL] }
public void testAppendSeparator_Char_ZeroLoopIndex() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendSeparator('a', 0); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendSeparator_Char_NegativeLoopIndex() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendSeparator('a', -1); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_PositiveWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", 5, 'X'); [EOL] assertEquals("XXabc", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_WidthEqualToLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", 3, 'X'); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_NullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNullText("null"); [EOL] sb.appendFixedWidthPadLeft(null, 5, 'X'); [EOL] assertEquals("XXnull", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_NullObjectNoNullText() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(null, 5, 'X'); [EOL] assertEquals("XXXXX", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_NegativeWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", -1, 'X'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_WidthLessThanLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", 2, 'X'); [EOL] assertEquals("bc", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_ValueWithinWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(123, 5, '0'); [EOL] assertEquals("00123", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_ValueExceedsWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(12345, 3, '0'); [EOL] assertEquals("12345", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_NegativeWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(123, -1, '0'); [EOL] assertEquals("123", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_ZeroWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(123, 0, '0'); [EOL] assertEquals("123", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_EmptyStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(0, 3, '0'); [EOL] assertEquals("000", sb.toString()); [EOL] }
public void testDeleteImpl_ValidRange() { [EOL] final int startIndex = 5; [EOL] final int endIndex = 10; [EOL] final int len = endIndex - startIndex; [EOL] final char[] buffer = new char[20]; [EOL] Arrays.fill(buffer, 'a'); [EOL] final int size = buffer.length; [EOL] deleteImpl(startIndex, endIndex, len); [EOL] for (int i = 0; i < startIndex; i++) { [EOL] assertEquals('a', buffer[i]); [EOL] } [EOL] for (int i = startIndex; i < size - len; i++) { [EOL] assertEquals('a', buffer[i]); [EOL] } [EOL] assertEquals(size - len, this.size); [EOL] }
public void testDeleteImpl_StartIndexEqualsEndIndex() { [EOL] final int startIndex = 5; [EOL] final int endIndex = 5; [EOL] final int len = endIndex - startIndex; [EOL] final char[] buffer = new char[20]; [EOL] Arrays.fill(buffer, 'a'); [EOL] final int size = buffer.length; [EOL] deleteImpl(startIndex, endIndex, len); [EOL] for (int i = 0; i < size; i++) { [EOL] assertEquals('a', buffer[i]); [EOL] } [EOL] assertEquals(size, this.size); [EOL] }
public void testDeleteImpl_EndIndexGreaterThanSize() { [EOL] final int startIndex = 5; [EOL] final int endIndex = 25; // Greater than buffer size [EOL] final int len = 5; // Arbitrary length [EOL] final char[] buffer = new char[20]; [EOL] Arrays.fill(buffer, 'a'); [EOL] final int size = buffer.length; [EOL] deleteImpl(startIndex, endIndex, len); [EOL] for (int i = 0; i < startIndex; i++) { [EOL] assertEquals('a', buffer[i]); [EOL] } [EOL] assertEquals(size - len, this.size); [EOL] }
public void testDeleteAll_Null() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.deleteAll(null); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testDeleteAll_Empty() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.deleteAll(""); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testDeleteAll_NotFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.deleteAll("x"); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testDeleteAll_FoundOnce() { [EOL] StrBuilder strBuilder = new StrBuilder("abcabc"); [EOL] strBuilder.deleteAll("a"); [EOL] assertEquals("bcbc", strBuilder.toString()); [EOL] }
public void testDeleteAll_FoundMultiple() { [EOL] StrBuilder strBuilder = new StrBuilder("abcabcabc"); [EOL] strBuilder.deleteAll("abc"); [EOL] assertEquals("", strBuilder.toString()); [EOL] }
public void testReplace_ValidRangeWithNonNullString() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(1, 2, "xyz"); [EOL] assertEquals("axyzc", result.toString()); [EOL] }
public void testReplace_ValidRangeWithNullString() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(1, 2, null); [EOL] assertEquals("ac", result.toString()); [EOL] }
public void testReplace_EntireRangeWithNonNullString() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(0, 3, "xyz"); [EOL] assertEquals("xyz", result.toString()); [EOL] }
public void testReplace_EntireRangeWithNullString() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(0, 3, null); [EOL] assertEquals("", result.toString()); [EOL] }
public void testReplace_RangeBeyondLengthWithNonNullString() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(1, 5, "xyz"); [EOL] assertEquals("axyz", result.toString()); [EOL] }
public void testReplace_RangeBeyondLengthWithNullString() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(1, 5, null); [EOL] assertEquals("a", result.toString()); [EOL] }
public void testReplace_StartIndexGreaterThanEndIndex() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] try { [EOL] builder.replace(2, 1, "xyz"); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_NegativeStartIndex() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] try { [EOL] builder.replace(-1, 2, "xyz"); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_EndIndexGreaterThanLength() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replace(1, 4, "xyz"); [EOL] assertEquals("axyz", result.toString()); [EOL] }
public void testReplaceAll_NoReplacementNeeded() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.replaceAll('d', 'e'); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testReplaceAll_ReplacementNeeded() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.replaceAll('b', 'x'); [EOL] assertEquals("axc", sb.toString()); [EOL] }
public void testReplaceAll_AllCharactersReplaced() { [EOL] StrBuilder sb = new StrBuilder("aaa"); [EOL] sb.replaceAll('a', 'b'); [EOL] assertEquals("bbb", sb.toString()); [EOL] }
public void testReplaceFirst_CharNotFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.replaceFirst('x', 'y'); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testReplaceFirst_CharFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.replaceFirst('a', 'x'); [EOL] assertEquals("xbc", strBuilder.toString()); [EOL] }
public void testReplaceFirst_CharFoundButSame() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.replaceFirst('a', 'a'); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testReverse_EmptyStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder reversed = sb.reverse(); [EOL] assertEquals("", reversed.toString()); [EOL] }
public void testReverse_NonEmptyStrBuilder() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] StrBuilder reversed = sb.reverse(); [EOL] assertEquals("cba", reversed.toString()); [EOL] }
public void testEndsWith_NullString() { [EOL] MyStringBufferUnderTest buffer = new MyStringBufferUnderTest("test"); [EOL] boolean result = buffer.endsWith(null); [EOL] assertFalse(result); [EOL] }
public void testEndsWith_EmptyString() { [EOL] MyStringBufferUnderTest buffer = new MyStringBufferUnderTest("test"); [EOL] boolean result = buffer.endsWith(""); [EOL] assertTrue(result); [EOL] }
public void testEndsWith_LongerString() { [EOL] MyStringBufferUnderTest buffer = new MyStringBufferUnderTest("test"); [EOL] boolean result = buffer.endsWith("longertest"); [EOL] assertFalse(result); [EOL] }
public void testEndsWith_SameLengthDifferentString() { [EOL] MyStringBufferUnderTest buffer = new MyStringBufferUnderTest("test"); [EOL] boolean result = buffer.endsWith("best"); [EOL] assertFalse(result); [EOL] }
public void testEndsWith_SameString() { [EOL] MyStringBufferUnderTest buffer = new MyStringBufferUnderTest("test"); [EOL] boolean result = buffer.endsWith("test"); [EOL] assertTrue(result); [EOL] }
public void testEndsWith_SubstringAtEnd() { [EOL] MyStringBufferUnderTest buffer = new MyStringBufferUnderTest("mytest"); [EOL] boolean result = buffer.endsWith("test"); [EOL] assertTrue(result); [EOL] }
public void testIndexOf_NullString() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; [EOL] int result = indexOf(null, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanSize() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] int startIndex = 4; [EOL] int result = indexOf("a", startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_SingleCharacterString() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; [EOL] int result = indexOf("b", startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_EmptyString() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; [EOL] int result = indexOf("", startIndex); [EOL] assertEquals(startIndex, result); [EOL] }
public void testIndexOf_StringLongerThanBuffer() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; [EOL] int result = indexOf("abcd", startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_StringNotFound() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; [EOL] int result = indexOf("d", startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_StringFound() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; [EOL] int result = indexOf("cd", startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_StartIndexAdjusted() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] int startIndex = -1; [EOL] int result = indexOf("a", startIndex); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOf_CharInBuffer() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] int startIndex = 3; // Choose a start index within the buffer length [EOL] int result = lastIndexOf('c', startIndex); [EOL] assert result == 2; // 'c' is at index 2 [EOL] } [EOL] public void testLastIndexOf_CharNotInBuffer() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] int startIndex = 3; [EOL] int result = lastIndexOf('f', startIndex); [EOL] assert result == -1; // 'f' is not in the buffer [EOL] } [EOL] public void testLastIndexOf_StartIndexOutOfBounds() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] int startIndex = 10; // Start index is greater than buffer length [EOL] int result = lastIndexOf('d', startIndex); [EOL] assert result == 3; // 'd' is at index 3, but startIndex is adjusted to size - 1 [EOL] } [EOL] public void testLastIndexOf_NegativeStartIndex() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] int startIndex = -1; // Negative start index [EOL] int result = lastIndexOf('d', startIndex); [EOL] assert result == -1; // Should return -1 as startIndex is negative [EOL] } [EOL] public void testLastIndexOf_EmptyBuffer() { [EOL] char[] buffer = new char[] {}; [EOL] int size = buffer.length; [EOL] int startIndex = 0; // Any index with an empty buffer [EOL] int result = lastIndexOf('a', startIndex); [EOL] assert result == -1; // Should return -1 as buffer is empty [EOL] }
public void testAsTokenizer() { [EOL] StrTokenizer tokenizer = new StrBuilder().asTokenizer(); [EOL] assertNotNull(tokenizer); [EOL] assertTrue(tokenizer instanceof StrBuilderTokenizer); [EOL] }
public void testEquals_SameObject() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] assertTrue(sb.equals(sb)); [EOL] } [EOL] public void testEquals_DifferentSize() { [EOL] StrBuilder sb1 = new StrBuilder("abc"); [EOL] StrBuilder sb2 = new StrBuilder("abcd"); [EOL] assertFalse(sb1.equals(sb2)); [EOL] } [EOL] public void testEquals_DifferentContent() { [EOL] StrBuilder sb1 = new StrBuilder("abc"); [EOL] StrBuilder sb2 = new StrBuilder("abd"); [EOL] assertFalse(sb1.equals(sb2)); [EOL] } [EOL] public void testEquals_EqualObjects() { [EOL] StrBuilder sb1 = new StrBuilder("abc"); [EOL] StrBuilder sb2 = new StrBuilder("abc"); [EOL] assertTrue(sb1.equals(sb2)); [EOL] }
public void testEqualsWithStrBuilderInstance() { [EOL] StrBuilder sb1 = new StrBuilder("test"); [EOL] StrBuilder sb2 = new StrBuilder("test"); [EOL] StrBuilder sb3 = new StrBuilder("different"); [EOL] assertTrue(sb1.equals(sb2)); [EOL] assertFalse(sb1.equals(sb3)); [EOL] }
public void testEqualsWithNonStrBuilderInstance() { [EOL] StrBuilder sb = new StrBuilder("test"); [EOL] Object obj = new Object(); [EOL] assertFalse(sb.equals(obj)); [EOL] }
public void testHashCodeEmptyBuffer() { [EOL] CharBuffer cb = new CharBuffer(new char[0], 0); [EOL] int expectedHash = 0; [EOL] int actualHash = cb.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testHashCodeSingleElementBuffer() { [EOL] CharBuffer cb = new CharBuffer(new char[]{'a'}, 1); [EOL] int expectedHash = 'a'; [EOL] int actualHash = cb.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testHashCodeMultipleElementsBuffer() { [EOL] CharBuffer cb = new CharBuffer(new char[]{'a', 'b', 'c'}, 3); [EOL] int expectedHash = ((31 + 'a') * 31 + 'b') * 31 + 'c'; [EOL] int actualHash = cb.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testToStringWhenBufferIsEmpty() { [EOL] TextBuffer tb = new TextBuffer(); [EOL] String result = tb.toString(); [EOL] assertEquals("", result); [EOL] }
public void testToStringWhenBufferIsNotEmpty() { [EOL] TextBuffer tb = new TextBuffer(); [EOL] tb.append("test"); [EOL] String result = tb.toString(); [EOL] assertEquals("test", result); [EOL] }
public void testStrBuilderTokenizerConstructor() { [EOL] new StrBuilderTokenizer(); [EOL] }
public void testTokenize_NullChars() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] List<String> tokens = strBuilder.tokenize(null, 0, strBuilder.size()); [EOL] assertNotNull("Token list should not be null", tokens); [EOL] }
public void testTokenize_ValidChars() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] chars = new char[]{'t', 'e', 's', 't'}; [EOL] List<String> tokens = strBuilder.tokenize(chars, 0, chars.length); [EOL] assertNotNull("Token list should not be null", tokens); [EOL] }
public void testGetContentWhenSuperContentIsNull() { [EOL] StrBuilder strBuilder = new StrBuilder() { [EOL] @Override [EOL] public String getContent() { [EOL] return null; [EOL] } [EOL] }; [EOL] assertEquals(strBuilder.toString(), strBuilder.getContent()); [EOL] }
public void testGetContentWhenSuperContentIsNotNull() { [EOL] StrBuilder strBuilder = new StrBuilder() { [EOL] @Override [EOL] public String getContent() { [EOL] return "notNull"; [EOL] } [EOL] }; [EOL] assertEquals("notNull", strBuilder.getContent()); [EOL] }
public void testCreateInstanceWithPatternTimeZoneLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.createInstance(pattern, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] assertNotNull(fdf); [EOL] }
public void testGetInstanceWithPattern() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] }
public void testGetInstanceWithPatternTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetInstanceWithPatternLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetInstanceWithPatternTimeZoneLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateInstanceWithStyle() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateInstanceWithStyleLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateInstanceWithStyleTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateInstanceWithStyleTimeZoneLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testGetTimeInstanceWithStyle() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style); [EOL] assertNotNull(fdf); [EOL] }
public void testGetTimeInstanceWithStyleLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testGetTimeInstanceWithStyleTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] }
public void testGetTimeInstanceWithStyleTimeZoneLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyle() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyleLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyleTimeZone() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyleTimeZoneLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testGetInstanceWithPattern() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] } [EOL] public void testGetInstanceWithPatternAndTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] } [EOL] public void testGetInstanceWithPatternAndLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] } [EOL] public void testGetInstanceWithPatternTimeZoneAndLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] } [EOL] public void testGetInstanceWithoutArguments() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateInstanceWithStyle() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateInstanceWithStyleAndLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateInstanceWithStyleAndTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateInstanceWithStyleTimeZoneAndLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetTimeInstanceWithStyle() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetTimeInstanceWithStyleAndLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetTimeInstanceWithStyleAndTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetTimeInstanceWithStyleTimeZoneAndLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateTimeInstanceWithDateAndTimeStyle() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateTimeInstanceWithDateAndTimeStyleAndLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateTimeInstanceWithDateAndTimeStyleAndTimeZone() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone); [EOL] assertNotNull(fdf); [EOL] } [EOL] public void testGetDateTimeInstanceWithDateAndTimeStyleTimeZoneAndLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
public static FastDateFormat getInstance(final String pattern, final Locale locale) { [EOL] return cache.getInstance(pattern, null, locale); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
public void testFastDateFormatConstructor() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = new FastDateFormat(pattern, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testFastDateFormatGetInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetInstanceWithPattern() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] }
public void testFastDateFormatGetInstanceWithPatternAndTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testFastDateFormatGetInstanceWithPatternAndLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testFastDateFormatGetInstanceWithPatternTimeZoneAndLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testFastDateFormatGetDateInstance() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateInstanceWithLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateInstanceWithTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateInstanceWithTimeZoneAndLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetTimeInstance() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetTimeInstanceWithLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetTimeInstanceWithTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetTimeInstanceWithTimeZoneAndLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateTimeInstance() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateTimeInstanceWithLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateTimeInstanceWithTimeZone() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone); [EOL] assertNotNull(fdf); [EOL] }
public void testFastDateFormatGetDateTimeInstanceWithTimeZoneAndLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] }
@Override [EOL] public Locale getLocale() { [EOL] return printer.getLocale(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }]
public void testGetJavaHome() { [EOL] File javaHome = FileUtils.getJavaHome(); [EOL] assertNotNull(javaHome); [EOL] assertTrue(javaHome.exists()); [EOL] assertEquals(System.getProperty("java.home"), javaHome.getAbsolutePath()); [EOL] }
public void testIsOSMatch_NullOSName() { [EOL] boolean result = isOSMatch(null, "10.0", "Windows", "10"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsOSMatch_NullOSVersion() { [EOL] boolean result = isOSMatch("Windows 10", null, "Windows", "10"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsOSMatch_NullOSNameAndVersion() { [EOL] boolean result = isOSMatch(null, null, "Windows", "10"); [EOL] assertFalse(result); [EOL] }
public void testIsOSMatch_MatchingOSNameAndVersion() { [EOL] boolean result = isOSMatch("Windows 10", "10.0", "Windows", "10"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsOSMatch_NonMatchingOSName() { [EOL] boolean result = isOSMatch("Linux", "10.0", "Windows", "10"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsOSMatch_NonMatchingOSVersion() { [EOL] boolean result = isOSMatch("Windows 10", "8.1", "Windows", "10"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsOSMatch_NonMatchingOSNameAndVersion() { [EOL] boolean result = isOSMatch("Linux", "8.1", "Windows", "10"); [EOL] assertFalse(result); [EOL] }
public void testIsOSNameMatch_NullOSName() { [EOL] boolean result = isOSNameMatch(null, "Windows"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsOSNameMatch_EmptyOSNamePrefix() { [EOL] boolean result = isOSNameMatch("Windows NT", ""); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsOSNameMatch_ValidOSNamePrefix() { [EOL] boolean result = isOSNameMatch("Windows NT", "Windows"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsOSNameMatch_InvalidOSNamePrefix() { [EOL] boolean result = isOSNameMatch("Windows NT", "Linux"); [EOL] assertFalse(result); [EOL] }
public void testMutableTripleOf_withAllNonNullValues() { [EOL] String left = "Left"; [EOL] String middle = "Middle"; [EOL] String right = "Right"; [EOL] MutableTriple<String, String, String> triple = MutableTriple.of(left, middle, right); [EOL] assertNotNull(triple); [EOL] assertEquals(left, triple.getLeft()); [EOL] assertEquals(middle, triple.getMiddle()); [EOL] assertEquals(right, triple.getRight()); [EOL] }
public void testMutableTripleOf_withNullValues() { [EOL] MutableTriple<Object, Object, Object> triple = MutableTriple.of(null, null, null); [EOL] assertNotNull(triple); [EOL] assertNull(triple.getLeft()); [EOL] assertNull(triple.getMiddle()); [EOL] assertNull(triple.getRight()); [EOL] }
public void testMutableTripleConstructor() { [EOL] String left = "left"; [EOL] String middle = "middle"; [EOL] String right = "right"; [EOL] MutableTriple<String, String, String> triple = new MutableTriple<>(left, middle, right); [EOL] assertEquals("left", triple.getLeft()); [EOL] assertEquals("middle", triple.getMiddle()); [EOL] assertEquals("right", triple.getRight()); [EOL] }
public void testGetLeft() { [EOL] L expected = ...; // Replace with the appropriate value [EOL] Pair<L, R> pair = new Pair<>(expected, ...); // Replace '...' with the appropriate right value [EOL] L result = pair.getLeft(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetLeft() { [EOL] Pair<Integer, String> pair = new Pair<>(null, "rightValue"); [EOL] Integer leftValue = 5; [EOL] pair.setLeft(leftValue); [EOL] assertEquals(leftValue, pair.getLeft()); [EOL] }
public void testGetMiddle_WhenMiddleIsSet() { [EOL] Triple<String, Integer, Boolean> triple = new ImmutableTriple<>("Left", 42, true); [EOL] Integer middle = triple.getMiddle(); [EOL] assertEquals(Integer.valueOf(42), middle); [EOL] }
public void testSetMiddle() { [EOL] Triple<String, String, String> triple = new Triple<>("left", "middle", "right"); [EOL] String newMiddle = "newMiddle"; [EOL] triple.setMiddle(newMiddle); [EOL] assertEquals(newMiddle, triple.getMiddle()); [EOL] }
public void testGetRight_ShouldReturnRightValue() { [EOL] Pair<Integer, String> pair = Pair.of(1, "RightValue"); [EOL] String result = pair.getRight(); [EOL] assertEquals("RightValue", result); [EOL] }
public void testSetRight() { [EOL] Pair<String, String> pair = new Pair<>("left", "right"); [EOL] pair.setRight("newRight"); [EOL] assertEquals("newRight", pair.getRight()); [EOL] }
public void testGetFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.getField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The class must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.getField(String.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field name must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetFieldWithExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "CASE_INSENSITIVE_ORDER", false); [EOL] assertNotNull(field); [EOL] assertEquals("CASE_INSENSITIVE_ORDER", field.getName()); [EOL] }
public void testGetFieldWithNonExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "nonExistingField", false); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithPrivateFieldWithoutForceAccess() { [EOL] Field field = FieldUtils.getField(TestClass.class, "privateField", false); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithPrivateFieldWithForceAccess() { [EOL] Field field = FieldUtils.getField(TestClass.class, "privateField", true); [EOL] assertNotNull(field); [EOL] assertEquals("privateField", field.getName()); [EOL] }
public void testGetFieldWithAmbiguousField() { [EOL] try { [EOL] FieldUtils.getField(AmbiguousFieldInterface.class, "AMBIGUOUS_FIELD", false); [EOL] fail("Should have thrown IllegalArgumentException for ambiguous field"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Reference to field AMBIGUOUS_FIELD is ambiguous")); [EOL] } [EOL] }
public void testGetDeclaredFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.getDeclaredField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The class must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetDeclaredFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.getDeclaredField(String.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field name must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetDeclaredFieldWithValidClassAndFieldNameButNoForceAccess() { [EOL] Field field = FieldUtils.getDeclaredField(String.class, "value", false); [EOL] assertNull("Should return null when field is not accessible and forceAccess is false", field); [EOL] }
public void testGetDeclaredFieldWithValidClassAndFieldNameAndForceAccess() { [EOL] Field field = FieldUtils.getDeclaredField(String.class, "value", true); [EOL] assertNotNull("Should return the field when forceAccess is true", field); [EOL] assertEquals("value", field.getName()); [EOL] }
public void testGetDeclaredFieldWithNonExistingField() { [EOL] Field field = FieldUtils.getDeclaredField(String.class, "nonExistingField", true); [EOL] assertNull("Should return null when field does not exist", field); [EOL] }
public void testWriteDeclaredStaticField_ValidField() throws Exception { [EOL] final String fieldName = "staticField"; [EOL] final String newValue = "new value"; [EOL] TestClass.writeDeclaredStaticField(TestClass.class, fieldName, newValue, true); [EOL] assertEquals("Field should be updated to new value", newValue, TestClass.getStaticField()); [EOL] } [EOL] public void testWriteDeclaredStaticField_FieldNotFound() { [EOL] final String fieldName = "nonExistingField"; [EOL] try { [EOL] TestClass.writeDeclaredStaticField(TestClass.class, fieldName, "value", true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testWriteDeclaredStaticField_NoForceAccess() throws Exception { [EOL] final String fieldName = "privateStaticField"; [EOL] final String newValue = "new value"; [EOL] try { [EOL] TestClass.writeDeclaredStaticField(TestClass.class, fieldName, newValue, false); [EOL] fail("Should have thrown IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] } [EOL] public void testWriteDeclaredStaticField_NullClass() { [EOL] try { [EOL] TestClass.writeDeclaredStaticField(null, "field", "value", true); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testWriteDeclaredStaticField_NullFieldName() { [EOL] try { [EOL] TestClass.writeDeclaredStaticField(TestClass.class, null, "value", true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testWriteDeclaredStaticField_NullValue() throws Exception { [EOL] final String fieldName = "staticField"; [EOL] TestClass.writeDeclaredStaticField(TestClass.class, fieldName, null, true); [EOL] assertNull("Field should be updated to null", TestClass.getStaticField()); [EOL] }

public void testWriteFieldWithNullField() throws IllegalAccessException { [EOL] try { [EOL] FieldUtils.writeField(null, new Object(), new Object()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteFieldWithNullTarget() throws IllegalAccessException { [EOL] Field field = String.class.getDeclaredField("value"); [EOL] try { [EOL] FieldUtils.writeField(field, null, new Object()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteFieldWithValidArguments() throws IllegalAccessException, NoSuchFieldException { [EOL] final Object target = new Object() { [EOL] private String field = "initial"; [EOL] }; [EOL] Field field = target.getClass().getDeclaredField("field"); [EOL] FieldUtils.writeField(field, target, "changed"); [EOL] assertEquals("changed", FieldUtils.readField(field, target)); [EOL] }
public void testAddWithNullString() { [EOL] add(null); [EOL] assertTrue(set.isEmpty()); [EOL] }
public void testAddWithEmptyString() { [EOL] add(""); [EOL] assertTrue(set.isEmpty()); [EOL] }
public void testAddWithSingleChar() { [EOL] add("a"); [EOL] assertTrue(set.contains(CharRange.is('a'))); [EOL] }
public void testAddWithSimpleRange() { [EOL] add("a-c"); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] }
public void testAddWithNegatedChar() { [EOL] add("^a"); [EOL] assertTrue(set.contains(CharRange.isNot('a'))); [EOL] }
public void testAddWithNegatedRange() { [EOL] add("^a-c"); [EOL] assertTrue(set.contains(CharRange.isNotIn('a', 'c'))); [EOL] }
public void testAddWithMultipleRanges() { [EOL] add("a-cx-z"); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isIn('x', 'z'))); [EOL] }
public void testAddWithMixedRanges() { [EOL] add("a-c^d-fx"); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isNotIn('d', 'f'))); [EOL] assertTrue(set.contains(CharRange.is('x'))); [EOL] }
public void testContextedExceptionWithMessageAndCause() { [EOL] String message = "Error message"; [EOL] Throwable cause = new Exception("Cause"); [EOL] ContextedException exception = new ContextedException(message, cause); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertNotNull(exception.getContext()); [EOL] }
public void testContextedExceptionWithNullMessageAndNullCause() { [EOL] ContextedException exception = new ContextedException(null, null); [EOL] assertNull(exception.getMessage()); [EOL] assertNull(exception.getCause()); [EOL] assertNotNull(exception.getContext()); [EOL] }
public void testContextedExceptionWithMessageAndCauseAndNullContext() { [EOL] String message = "Error message"; [EOL] Throwable cause = new Exception("Cause"); [EOL] ContextedException exception = new ContextedException(message, cause, null); [EOL] assertEquals("Expected message to be the same as constructor argument", message, exception.getMessage()); [EOL] assertEquals("Expected cause to be the same as constructor argument", cause, exception.getCause()); [EOL] assertNotNull("Expected context to not be null", exception.getContext()); [EOL] }
public void testContextedExceptionWithMessageAndCauseAndNonNullContext() { [EOL] String message = "Error message"; [EOL] Throwable cause = new Exception("Cause"); [EOL] ExceptionContext context = new DefaultExceptionContext(); [EOL] ContextedException exception = new ContextedException(message, cause, context); [EOL] assertEquals("Expected message to be the same as constructor argument", message, exception.getMessage()); [EOL] assertEquals("Expected cause to be the same as constructor argument", cause, exception.getCause()); [EOL] assertEquals("Expected context to be the same as constructor argument", context, exception.getContext()); [EOL] }
public void testAddContextValueWithNullLabel() { [EOL] ContextedException exception = new ContextedException(); [EOL] exception.addContextValue(null, "value"); [EOL] assertEquals("value", exception.getFirstContextValue(null)); [EOL] }
public void testAddContextValueWithNonNullLabel() { [EOL] ContextedException exception = new ContextedException(); [EOL] exception.addContextValue("label", "value"); [EOL] assertEquals("value", exception.getFirstContextValue("label")); [EOL] }
public void testAddContextValueWithNullValue() { [EOL] ContextedException exception = new ContextedException(); [EOL] exception.addContextValue("label", null); [EOL] assertNull(exception.getFirstContextValue("label")); [EOL] }
public void testMutablePairConstructor() { [EOL] MutablePair<Object, Object> mutablePair = new MutablePair<>(); [EOL] assertNull(mutablePair.left); [EOL] assertNull(mutablePair.right); [EOL] }
public void testCharRange_Normal() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('z', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] } [EOL] public void testCharRange_Reversed() { [EOL] CharRange range = new CharRange('z', 'a', false); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('z', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] } [EOL] public void testCharRange_Negated() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('z', range.getEnd()); [EOL] assertTrue(range.isNegated()); [EOL] }
public void testCharRange_SameStartEnd() { [EOL] CharRange range = new CharRange('a', 'a', false); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('a', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] } [EOL] public void testCharRange_SameStartEndNegated() { [EOL] CharRange range = new CharRange('a', 'a', true); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('a', range.getEnd()); [EOL] assertTrue(range.isNegated()); [EOL] }
public void testIsChar() { [EOL] CharRange range = CharRange.is('a'); [EOL] assertNotNull(range); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('a', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] }
public void testIsNotWithSingleChar() { [EOL] CharRange range = CharRange.isNot('a'); [EOL] assertNotNull(range); [EOL] assertTrue(range.contains('b')); [EOL] assertFalse(range.contains('a')); [EOL] }
public void testIsNotWithBoundaryChar() { [EOL] CharRange range = CharRange.isNot(Character.MIN_VALUE); [EOL] assertNotNull(range); [EOL] assertTrue(range.contains(Character.MAX_VALUE)); [EOL] assertFalse(range.contains(Character.MIN_VALUE)); [EOL] }
public void testIsNotWithMaxBoundaryChar() { [EOL] CharRange range = CharRange.isNot(Character.MAX_VALUE); [EOL] assertNotNull(range); [EOL] assertTrue(range.contains(Character.MIN_VALUE)); [EOL] assertFalse(range.contains(Character.MAX_VALUE)); [EOL] }
public void testIsInWithEqualStartAndEnd() { [EOL] CharRange range = CharRange.isIn('a', 'a'); [EOL] assertNotNull(range); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('a', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] }
public void testIsInWithStartLessThanEnd() { [EOL] CharRange range = CharRange.isIn('a', 'b'); [EOL] assertNotNull(range); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('b', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] }
public void testIsInWithStartGreaterThanEnd() { [EOL] CharRange range = CharRange.isIn('b', 'a'); [EOL] assertNotNull(range); [EOL] assertEquals('b', range.getStart()); [EOL] assertEquals('a', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] }
public void testIsNotInRangeWithEqualStartAndEnd() { [EOL] CharRange range = CharRange.isNotIn('a', 'a'); [EOL] assertFalse(range.contains('a')); [EOL] }
public void testIsNotInRangeWithStartLessThanEnd() { [EOL] CharRange range = CharRange.isNotIn('a', 'c'); [EOL] assertFalse(range.contains('a')); [EOL] assertFalse(range.contains('b')); [EOL] assertFalse(range.contains('c')); [EOL] }
public void testIsNotInRangeWithStartGreaterThanEnd() { [EOL] CharRange range = CharRange.isNotIn('c', 'a'); [EOL] assertFalse(range.contains('a')); [EOL] assertFalse(range.contains('b')); [EOL] assertFalse(range.contains('c')); [EOL] }
public void testGetStart() { [EOL] ExampleClass example = new ExampleClass(); [EOL] example.setStart('a'); // Assuming there is a method to set the 'start' field [EOL] char expected = 'a'; [EOL] char actual = example.getStart(); [EOL] assertEquals(expected, actual); [EOL] }
public char getEndTest() { [EOL] Range range = new Range('a', 'z'); [EOL] char result = range.getEnd(); [EOL] assertEquals('z', result); [EOL] }
public void testIsNegatedTrue() { [EOL] MyClass obj = new MyClass(true); [EOL] assertTrue(obj.isNegated()); [EOL] }
public void testIsNegatedFalse() { [EOL] MyClass obj = new MyClass(false); [EOL] assertFalse(obj.isNegated()); [EOL] }
public void testContainsWithNullRange() { [EOL] CharRange range = new CharRange('a', 'z'); [EOL] try { [EOL] range.contains(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testContainsWithNegatedRanges() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] CharRange otherRange = new CharRange('b', 'y', true); [EOL] assertTrue(range.contains(otherRange)); [EOL] }
public void testContainsWithNonNegatedRanges() { [EOL] CharRange range = new CharRange('a', 'z'); [EOL] CharRange otherRange = new CharRange('b', 'y'); [EOL] assertTrue(range.contains(otherRange)); [EOL] }
public void testContainsWithNegatedAndNonNegatedRanges() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] CharRange otherRange = new CharRange('b', 'y'); [EOL] assertFalse(range.contains(otherRange)); [EOL] }
public void testContainsWithNonNegatedAndNegatedRanges() { [EOL] CharRange range = new CharRange('a', 'z'); [EOL] CharRange otherRange = new CharRange('b', 'y', true); [EOL] assertFalse(range.contains(otherRange)); [EOL] }
public void testContainsWithFullRange() { [EOL] CharRange range = new CharRange('a', 'z'); [EOL] CharRange fullRange = new CharRange(Character.MIN_VALUE, Character.MAX_VALUE); [EOL] assertFalse(range.contains(fullRange)); [EOL] }
public void testContainsWithFullNegatedRange() { [EOL] CharRange range = new CharRange('a', 'z'); [EOL] CharRange fullNegatedRange = new CharRange(Character.MIN_VALUE, Character.MAX_VALUE, true); [EOL] assertTrue(range.contains(fullNegatedRange)); [EOL] }
public void testToStringWithNegated() { [EOL] char start = 'a'; [EOL] char end = 'z'; [EOL] RangeCharacter rc = new RangeCharacter(start, end, true); // true for negated [EOL] String expected = "^a-z"; [EOL] String actual = rc.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStringWithoutNegatedSingleChar() { [EOL] char startAndEnd = 'm'; [EOL] RangeCharacter rc = new RangeCharacter(startAndEnd, startAndEnd, false); // false for not negated [EOL] String expected = "m"; [EOL] String actual = rc.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStringWithoutNegatedRange() { [EOL] char start = 'a'; [EOL] char end = 'e'; [EOL] RangeCharacter rc = new RangeCharacter(start, end, false); // false for not negated [EOL] String expected = "a-e"; [EOL] String actual = rc.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testIterator() { [EOL] CharSequence cs = "abc"; [EOL] Iterator<Character> iterator = cs.iterator(); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(Character.valueOf('a'), iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(Character.valueOf('b'), iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(Character.valueOf('c'), iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testCharacterIteratorWithNegatedRangeStartingAtZeroAndEndingAtMax() { [EOL] CharRange range = new CharRange((char) 0, Character.MAX_VALUE, true); [EOL] CharacterIterator iterator = new CharacterIterator(range); [EOL] assertFalse(iterator.hasNext); [EOL] }
public void testCharacterIteratorWithNegatedRangeStartingAtZero() { [EOL] CharRange range = new CharRange((char) 0, (char) (Character.MAX_VALUE - 1), true); [EOL] CharacterIterator iterator = new CharacterIterator(range); [EOL] assertTrue(iterator.hasNext); [EOL] assertEquals((char) (Character.MAX_VALUE), iterator.current); [EOL] }
public void testCharacterIteratorWithNegatedRangeNotStartingAtZero() { [EOL] CharRange range = new CharRange((char) 1, (char) 50, true); [EOL] CharacterIterator iterator = new CharacterIterator(range); [EOL] assertTrue(iterator.hasNext); [EOL] assertEquals((char) 0, iterator.current); [EOL] }
public void testCharacterIteratorWithNonNegatedRange() { [EOL] CharRange range = new CharRange((char) 1, (char) 50, false); [EOL] CharacterIterator iterator = new CharacterIterator(range); [EOL] assertTrue(iterator.hasNext); [EOL] assertEquals((char) 1, iterator.current); [EOL] }
public void testPrepareNext_NegatedAtMaxValue() { [EOL] CharRange range = new CharRange(Character.MAX_VALUE, Character.MAX_VALUE, true); [EOL] CharRangeIterator iterator = new CharRangeIterator(range); [EOL] iterator.prepareNext(); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testPrepareNext_NegatedCurrentPlusOneEqualsStart() { [EOL] CharRange range = new CharRange((char) (Character.MAX_VALUE - 1), Character.MAX_VALUE, true); [EOL] CharRangeIterator iterator = new CharRangeIterator(range); [EOL] iterator.current = (char) (range.start - 1); [EOL] iterator.prepareNext(); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testPrepareNext_NegatedCurrentPlusOneEqualsStartWithNonMaxEnd() { [EOL] CharRange range = new CharRange((char) (Character.MAX_VALUE - 1), (char) (Character.MAX_VALUE - 1), true); [EOL] CharRangeIterator iterator = new CharRangeIterator(range); [EOL] iterator.current = (char) (range.start - 1); [EOL] iterator.prepareNext(); [EOL] assertEquals((char) (range.end + 1), iterator.current); [EOL] }
public void testPrepareNext_NegatedElseBranch() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] CharRangeIterator iterator = new CharRangeIterator(range); [EOL] iterator.current = 'a'; [EOL] iterator.prepareNext(); [EOL] assertEquals('b', iterator.current); [EOL] }
public void testPrepareNext_NotNegatedCurrentLessThanEnd() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] CharRangeIterator iterator = new CharRangeIterator(range); [EOL] iterator.current = 'a'; [EOL] iterator.prepareNext(); [EOL] assertEquals('b', iterator.current); [EOL] }
public void testPrepareNext_NotNegatedCurrentAtEnd() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] CharRangeIterator iterator = new CharRangeIterator(range); [EOL] iterator.current = 'z'; [EOL] iterator.prepareNext(); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testHasNext_True() { [EOL] YourIteratorClass iterator = new YourIteratorClass(); [EOL] iterator.hasNext = true; // Assuming there's a way to set hasNext, like a constructor or a method [EOL] boolean result = iterator.hasNext(); [EOL] assert result; // Assert that the result is true [EOL] } [EOL] public void testHasNext_False() { [EOL] YourIteratorClass iterator = new YourIteratorClass(); [EOL] iterator.hasNext = false; // Assuming there's a way to set hasNext, like a constructor or a method [EOL] boolean result = iterator.hasNext(); [EOL] assert !result; // Assert that the result is false [EOL] }
public void testNext_WhenHasNextIsTrue_ShouldReturnCurrentCharacter() { [EOL] Character result = next(); [EOL] assertEquals(Character.valueOf('a'), result); [EOL] } [EOL] public void testNext_WhenHasNextIsFalse_ShouldThrowException() { [EOL] try { [EOL] next(); [EOL] fail("Expected an NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testCallableBackgroundInitializerWithValidCallable() { [EOL] Callable<String> callable = () -> "Test"; [EOL] CallableBackgroundInitializer<String> initializer = new CallableBackgroundInitializer<>(callable); [EOL] assertNotNull(initializer); [EOL] }
public void testCallableBackgroundInitializerWithNullCallable() { [EOL] try { [EOL] new CallableBackgroundInitializer<>(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testInitializeReturnsCorrectValue() throws Exception { [EOL] Callable<String> callable = () -> "ExpectedValue"; [EOL] Initializable<String> initializable = new Initializable<>(callable); [EOL] String result = initializable.initialize(); [EOL] assertEquals("ExpectedValue", result); [EOL] } [EOL] public void testInitializeThrowsException() { [EOL] Callable<String> callable = () -> { throw new Exception("Initialization failed"); }; [EOL] Initializable<String> initializable = new Initializable<>(callable); [EOL] try { [EOL] initializable.initialize(); [EOL] fail("Exception should have been thrown"); [EOL] } catch (Exception e) { [EOL] assertEquals("Initialization failed", e.getMessage()); [EOL] } [EOL] }
public void testReflectionHashCodeWithVariousParameters() { [EOL] final int initialNonZeroOddNumber = 1; [EOL] final int multiplierNonZeroOddNumber = 31; [EOL] final Object object = new Object(); [EOL] final boolean testTransients = true; [EOL] int result = SomeClass.reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients); [EOL] assertNotEquals(0, result); [EOL] }
public void testReflectionHashCodeWithNullObject() { [EOL] final int initialNonZeroOddNumber = 1; [EOL] final int multiplierNonZeroOddNumber = 31; [EOL] final Object object = null; [EOL] final boolean testTransients = true; [EOL] int result = SomeClass.reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients); [EOL] assertEquals(initialNonZeroOddNumber, result); [EOL] }
public void testReflectionHashCodeWithFalseTestTransients() { [EOL] final int initialNonZeroOddNumber = 1; [EOL] final int multiplierNonZeroOddNumber = 31; [EOL] final Object object = new Object(); [EOL] final boolean testTransients = false; [EOL] int result = SomeClass.reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients); [EOL] assertNotEquals(0, result); [EOL] }
public void testReflectionHashCodeWithNullObject() { [EOL] try { [EOL] Object object = null; [EOL] HashCodeBuilder.reflectionHashCode(1, 3, object, false, null); [EOL] fail("Should have thrown IllegalArgumentException for null object"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReflectionHashCodeWithValidObject() { [EOL] Object object = new Object(); [EOL] int hashCode = HashCodeBuilder.reflectionHashCode(1, 3, object, false, null); [EOL] assertNotNull(hashCode); [EOL] }
public void testReflectionHashCodeWithExcludeFields() { [EOL] Object object = new ExampleObject(); [EOL] int hashCode1 = HashCodeBuilder.reflectionHashCode(1, 3, object, false, null); [EOL] int hashCode2 = HashCodeBuilder.reflectionHashCode(1, 3, object, false, "ignoredField"); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testReflectionHashCodeWithSuperclass() { [EOL] Object object = new ExampleSubObject(); [EOL] int hashCode1 = HashCodeBuilder.reflectionHashCode(1, 3, object, false, ExampleObject.class, null); [EOL] int hashCode2 = HashCodeBuilder.reflectionHashCode(1, 3, object, false, null); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testReflectionHashCodeWithTransients() { [EOL] Object object = new ExampleObjectWithTransients(); [EOL] int hashCode1 = HashCodeBuilder.reflectionHashCode(1, 3, object, false, null); [EOL] int hashCode2 = HashCodeBuilder.reflectionHashCode(1, 3, object, true, null); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testAppendWithNull() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) null); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithLongArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] long[] array = {1L, 2L, 3L}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithIntArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = {'a', 'b', 'c'}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithByteArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] byte[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithDoubleArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithFloatArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithBooleanArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] boolean[] array = {true, false, true}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithObjectArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object[] array = {new Object(), new Object(), new Object()}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithRegularObject() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object obj = new Object(); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(obj); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithNullArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append((Object[]) null); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(new Object[]{}); [EOL] assertEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithNonEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int initialTotal = hcb.hashCode(); [EOL] Object[] array = new Object[]{"element1", "element2", null}; [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendSuper_WithPositiveSuperHashCode() { [EOL] HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(17, 37); [EOL] int superHashCode = 123; [EOL] HashCodeBuilder result = hashCodeBuilder.appendSuper(superHashCode); [EOL] int expectedTotal = 17 * 37 + superHashCode; [EOL] assertEquals(expectedTotal, result.toHashCode()); [EOL] }
public void testAppendSuper_WithNegativeSuperHashCode() { [EOL] HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(17, 37); [EOL] int superHashCode = -123; [EOL] HashCodeBuilder result = hashCodeBuilder.appendSuper(superHashCode); [EOL] int expectedTotal = 17 * 37 + superHashCode; [EOL] assertEquals(expectedTotal, result.toHashCode()); [EOL] }
public void testAppendSuper_WithZeroSuperHashCode() { [EOL] HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(17, 37); [EOL] int superHashCode = 0; [EOL] HashCodeBuilder result = hashCodeBuilder.appendSuper(superHashCode); [EOL] int expectedTotal = 17 * 37 + superHashCode; [EOL] assertEquals(expectedTotal, result.toHashCode()); [EOL] }
public void testSerializationUtilsConstructor() { [EOL] new SerializationUtils(); [EOL] }
public void testClone_NullInput() { [EOL] Serializable result = SerializationUtils.clone(null); [EOL] assertNull(result); [EOL] }
public void testClone_ValidObject() throws Exception { [EOL] Serializable original = new SerializableObject(); [EOL] Serializable cloned = SerializationUtils.clone(original); [EOL] assertNotNull(cloned); [EOL] assertNotSame(original, cloned); [EOL] assertEquals(original, cloned); [EOL] }
public void testClone_ClassNotFoundException() { [EOL] Serializable original = new SerializableObjectThatThrows(new ClassNotFoundException()); [EOL] try { [EOL] SerializationUtils.clone(original); [EOL] fail("Should have thrown SerializationException due to ClassNotFoundException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof ClassNotFoundException); [EOL] } [EOL] }
public void testClone_IOException() { [EOL] Serializable original = new SerializableObjectThatThrows(new IOException()); [EOL] try { [EOL] SerializationUtils.clone(original); [EOL] fail("Should have thrown SerializationException due to IOException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof IOException); [EOL] } [EOL] }
public void testSerialize_withSerializableObject() throws IOException { [EOL] Serializable obj = "Test String"; [EOL] byte[] serializedObject = YourClass.serialize(obj); [EOL] assertNotNull(serializedObject); [EOL] assertTrue(serializedObject.length > 0); [EOL] }
public void testSerialize_withNullObject() throws IOException { [EOL] Serializable obj = null; [EOL] try { [EOL] YourClass.serialize(obj); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The object must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithNullInput() { [EOL] try { [EOL] SerializationUtils.deserialize(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The byte[] must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithValidInput() throws IOException, ClassNotFoundException { [EOL] final byte[] objectData = SerializationUtils.serialize("test"); [EOL] final Object result = SerializationUtils.deserialize(objectData); [EOL] assertEquals("test", result); [EOL] }
public void testClassLoaderAwareObjectInputStreamWithNonNullClassLoader() throws IOException { [EOL] InputStream mockInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ClassLoader mockClassLoader = getClass().getClassLoader(); [EOL] ClassLoaderAwareObjectInputStream objectInputStream = new ClassLoaderAwareObjectInputStream(mockInputStream, mockClassLoader); [EOL] assertNotNull(objectInputStream); [EOL] }
public void testClassLoaderAwareObjectInputStreamWithNullClassLoader() throws IOException { [EOL] InputStream mockInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ClassLoaderAwareObjectInputStream objectInputStream = new ClassLoaderAwareObjectInputStream(mockInputStream, null); [EOL] assertNotNull(objectInputStream); [EOL] }
protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL] final String name = desc.getName(); [EOL] try { [EOL] return Class.forName(name, false, classLoader); [EOL] } catch (final ClassNotFoundException ex) { [EOL] try { [EOL] return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL] } catch (final ClassNotFoundException cnfe) { [EOL] final Class<?> cls = primitiveTypes.get(name); [EOL] if (cls != null) { [EOL] return cls; [EOL] } else { [EOL] throw cnfe; [EOL] } [EOL] } [EOL] } [EOL] }
public void testCharUtilsConstructor() { [EOL] new CharUtils(); [EOL] }
public void testToCharacterObject() { [EOL] char testChar = 'a'; [EOL] Character result = toCharacterObject(testChar); [EOL] assertEquals(Character.valueOf(testChar), result); [EOL] }
public void testToCharacterObjectWithNumericChar() { [EOL] char testChar = '1'; [EOL] Character result = toCharacterObject(testChar); [EOL] assertEquals(Character.valueOf(testChar), result); [EOL] }
public void testToCharacterObjectWithSpecialChar() { [EOL] char testChar = '!'; [EOL] Character result = toCharacterObject(testChar); [EOL] assertEquals(Character.valueOf(testChar), result); [EOL] }
public void testToCharacterObjectWithEmptyString() { [EOL] Character result = StringUtils.toCharacterObject(""); [EOL] assertNull(result); [EOL] } [EOL] public void testToCharacterObjectWithNullString() { [EOL] Character result = StringUtils.toCharacterObject(null); [EOL] assertNull(result); [EOL] } [EOL] public void testToCharacterObjectWithNonEmptyString() { [EOL] Character result = StringUtils.toCharacterObject("abc"); [EOL] assertNotNull(result); [EOL] assertEquals(Character.valueOf('a'), result); [EOL] }
public void testToCharWithNonNullCharacter() { [EOL] char expected = 'a'; [EOL] Character character = Character.valueOf(expected); [EOL] char result = toChar(character); [EOL] assertEquals(expected, result); [EOL] }
public void testToCharWithNullCharacter() { [EOL] try { [EOL] toChar(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testToChar_ValidString() { [EOL] char result = StringUtils.toChar("abc"); [EOL] assertEquals('a', result); [EOL] } [EOL] public void testToChar_EmptyString() { [EOL] try { [EOL] StringUtils.toChar(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The String must not be empty", e.getMessage()); [EOL] } [EOL] } [EOL] public void testToChar_NullString() { [EOL] try { [EOL] StringUtils.toChar(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The String must not be empty", e.getMessage()); [EOL] } [EOL] }
public void testContains_withNullElement() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.contains(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_withElementLessThanMinimum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.contains(0); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_withElementEqualToMinimum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.contains(1); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_withElementGreaterThanMinimumAndLessThanMaximum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.contains(5); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_withElementEqualToMaximum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.contains(10); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_withElementGreaterThanMaximum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.contains(11); [EOL] assertFalse(result); [EOL] }
public void testIsBeforeWithNullElement() { [EOL] ComparableObject comparableObject = new ComparableObject(null); // Assuming ComparableObject is the class that contains isBefore [EOL] boolean result = comparableObject.isBefore(null); [EOL] assertFalse(result); [EOL] }
public void testIsBeforeWithElementBeforeMaximum() { [EOL] ComparableObject comparableObject = new ComparableObject(new MyComparable(10)); // Assuming MyComparable is a comparable class and 10 is less than maximum [EOL] boolean result = comparableObject.isBefore(new MyComparable(20)); // Assuming 20 is greater than maximum [EOL] assertTrue(result); [EOL] }
public void testIsBeforeWithElementAfterMaximum() { [EOL] ComparableObject comparableObject = new ComparableObject(new MyComparable(30)); // Assuming MyComparable is a comparable class and 30 is the maximum [EOL] boolean result = comparableObject.isBefore(new MyComparable(10)); // Assuming 10 is less than maximum [EOL] assertFalse(result); [EOL] }
public void testContainsRange_NullRange() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] boolean result = range.containsRange(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsRange_ContainedRange() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] Range<Integer> otherRange = Range.between(2, 4); [EOL] boolean result = range.containsRange(otherRange); [EOL] assertTrue(result); [EOL] } [EOL] public void testContainsRange_NotContainedRange_MinimumOutOfBound() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] Range<Integer> otherRange = Range.between(0, 4); [EOL] boolean result = range.containsRange(otherRange); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsRange_NotContainedRange_MaximumOutOfBound() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] Range<Integer> otherRange = Range.between(2, 6); [EOL] boolean result = range.containsRange(otherRange); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsRange_NotContainedRange_BothOutOfBound() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] Range<Integer> otherRange = Range.between(0, 6); [EOL] boolean result = range.containsRange(otherRange); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsRange_SameRange() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] Range<Integer> otherRange = Range.between(1, 5); [EOL] boolean result = range.containsRange(otherRange); [EOL] assertTrue(result); [EOL] }
public void testToStringWithValidFormat() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] String result = range.toString("%d to %d"); [EOL] assertEquals("1 to 10", result); [EOL] }
public void testToStringWithNullFormat() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] try { [EOL] range.toString(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetExcludeFieldNamesWithNull() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] builder.setExcludeFieldNames((String[]) null); [EOL] assertNull("Exclude field names should be null", builder.getExcludeFieldNames()); [EOL] }
public void testSetExcludeFieldNamesWithNonNull() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] String[] excludeFieldNames = new String[] {"field1", "field2"}; [EOL] builder.setExcludeFieldNames(excludeFieldNames); [EOL] assertNotNull("Exclude field names should not be null", builder.getExcludeFieldNames()); [EOL] assertTrue("Exclude field names should contain 'field1'", Arrays.asList(builder.getExcludeFieldNames()).contains("field1")); [EOL] assertTrue("Exclude field names should contain 'field2'", Arrays.asList(builder.getExcludeFieldNames()).contains("field2")); [EOL] assertEquals("Exclude field names should be sorted", "field1", builder.getExcludeFieldNames()[0]); [EOL] assertEquals("Exclude field names should be sorted", "field2", builder.getExcludeFieldNames()[1]); [EOL] }
public void testGetValueWhenValueIsZero() { [EOL] MyClass instance = new MyClass(0); [EOL] Long expected = 0L; [EOL] Long actual = instance.getValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetValueWhenValueIsPositive() { [EOL] MyClass instance = new MyClass(123); [EOL] Long expected = 123L; [EOL] Long actual = instance.getValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetValueWhenValueIsNegative() { [EOL] MyClass instance = new MyClass(-123); [EOL] Long expected = -123L; [EOL] Long actual = instance.getValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetValue() { [EOL] MyClass instance = new MyClass(); [EOL] long expectedValue = 123L; [EOL] instance.setValue(expectedValue); [EOL] assertEquals(expectedValue, instance.getValue()); [EOL] }
public void testSetValueWithNull() { [EOL] LongValue longValue = new LongValue(); [EOL] longValue.setValue(null); [EOL] assertNull("Value should be null", longValue.value); [EOL] }
public void testSetValueWithLong() { [EOL] LongValue longValue = new LongValue(); [EOL] longValue.setValue(10L); [EOL] assertEquals("Value should be 10", 10L, longValue.value.longValue()); [EOL] }
public void testSetValueWithInteger() { [EOL] LongValue longValue = new LongValue(); [EOL] longValue.setValue(10); [EOL] assertEquals("Value should be 10", 10L, longValue.value.longValue()); [EOL] }
public void testHashCode() { [EOL] long value1 = 123456789L; [EOL] Long long1 = value1; [EOL] int expectedHashCode1 = (int) (value1 ^ (value1 >>> 32)); [EOL] assertEquals(expectedHashCode1, long1.hashCode()); [EOL] long value2 = -987654321L; [EOL] Long long2 = value2; [EOL] int expectedHashCode2 = (int) (value2 ^ (value2 >>> 32)); [EOL] assertEquals(expectedHashCode2, long2.hashCode()); [EOL] }
public void testSubtract_PositiveOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.subtract(3); [EOL] assertEquals(2, mutableInt.intValue()); [EOL] }
public void testSubtract_NegativeOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.subtract(-3); [EOL] assertEquals(8, mutableInt.intValue()); [EOL] }
public void testSubtract_ZeroOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.subtract(0); [EOL] assertEquals(5, mutableInt.intValue()); [EOL] }
public void testSubtractWithPositiveOperand() { [EOL] MutableInt mutableInt = new MutableInt(10); [EOL] mutableInt.subtract(new Integer(5)); [EOL] assertEquals(5, mutableInt.intValue()); [EOL] }
public void testSubtractWithNegativeOperand() { [EOL] MutableInt mutableInt = new MutableInt(10); [EOL] mutableInt.subtract(new Integer(-5)); [EOL] assertEquals(15, mutableInt.intValue()); [EOL] }
public void testSubtractWithZeroOperand() { [EOL] MutableInt mutableInt = new MutableInt(10); [EOL] mutableInt.subtract(new Integer(0)); [EOL] assertEquals(10, mutableInt.intValue()); [EOL] }
public void testDefaultIfNullWithNonNull() { [EOL] String actual = StringUtils.defaultIfNull("abc", "default"); [EOL] assertEquals("abc", actual); [EOL] }
public void testDefaultIfNullWithNull() { [EOL] String actual = StringUtils.defaultIfNull(null, "default"); [EOL] assertEquals("default", actual); [EOL] }
public void testFirstNonNull_withAllNulls() { [EOL] String[] values = {null, null, null}; [EOL] String result = firstNonNull(values); [EOL] assertNull(result); [EOL] }
public void testFirstNonNull_withFirstNonNull() { [EOL] String[] values = {"first", null, null}; [EOL] String result = firstNonNull(values); [EOL] assertNotNull(result); [EOL] assertEquals("first", result); [EOL] }
public void testFirstNonNull_withMiddleNonNull() { [EOL] String[] values = {null, "middle", null}; [EOL] String result = firstNonNull(values); [EOL] assertNotNull(result); [EOL] assertEquals("middle", result); [EOL] }
public void testFirstNonNull_withLastNonNull() { [EOL] String[] values = {null, null, "last"}; [EOL] String result = firstNonNull(values); [EOL] assertNotNull(result); [EOL] assertEquals("last", result); [EOL] }
public void testFirstNonNull_withMultipleNonNulls() { [EOL] String[] values = {"first", "second", "third"}; [EOL] String result = firstNonNull(values); [EOL] assertNotNull(result); [EOL] assertEquals("first", result); [EOL] }
public void testFirstNonNull_withNoValues() { [EOL] String result = firstNonNull(); [EOL] assertNull(result); [EOL] }
public void testFirstNonNull_withNullArray() { [EOL] String[] values = null; [EOL] String result = firstNonNull(values); [EOL] assertNull(result); [EOL] }
public void testNotEqual_BothObjectsNull() { [EOL] boolean result = ObjectUtils.notEqual(null, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testNotEqual_FirstObjectNull() { [EOL] boolean result = ObjectUtils.notEqual(null, "test"); [EOL] assertTrue(result); [EOL] } [EOL] public void testNotEqual_SecondObjectNull() { [EOL] boolean result = ObjectUtils.notEqual("test", null); [EOL] assertTrue(result); [EOL] } [EOL] public void testNotEqual_BothObjectsNonNullEqual() { [EOL] boolean result = ObjectUtils.notEqual("test", "test"); [EOL] assertFalse(result); [EOL] } [EOL] public void testNotEqual_BothObjectsNonNullNotEqual() { [EOL] boolean result = ObjectUtils.notEqual("test", "different"); [EOL] assertTrue(result); [EOL] }
public void testIdentityToStringWithNonNullObject() throws IOException { [EOL] StringBuilder sb = new StringBuilder(); [EOL] Object obj = new Object(); [EOL] Lang3.identityToString(sb, obj); [EOL] String expected = obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)); [EOL] assertEquals(expected, sb.toString()); [EOL] } [EOL] public void testIdentityToStringWithNullObject() { [EOL] Appendable appendable = new StringBuilder(); [EOL] try { [EOL] Lang3.identityToString(appendable, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Cannot get the toString of a null identity", e.getMessage()); [EOL] } [EOL] }
public void testToStringWithNullObject() { [EOL] String result = StringUtils.toString(null); [EOL] assertEquals("", result); [EOL] }
public void testToStringWithNonNullObject() { [EOL] Object obj = new Object() { [EOL] @Override [EOL] public String toString() { [EOL] return "NonNullObjectToString"; [EOL] } [EOL] }; [EOL] String result = StringUtils.toString(obj); [EOL] assertEquals("NonNullObjectToString", result); [EOL] }
public void testCompareWithNullsFirst() { [EOL] Integer value1 = 1; [EOL] Integer value2 = 2; [EOL] assertTrue(ObjectUtils.compare(value1, value2, true) < 0); [EOL] assertTrue(ObjectUtils.compare(value2, value1, true) > 0); [EOL] assertTrue(ObjectUtils.compare(value1, value1, true) == 0); [EOL] assertTrue(ObjectUtils.compare(null, value2, true) < 0); [EOL] assertTrue(ObjectUtils.compare(value2, null, true) > 0); [EOL] assertTrue(ObjectUtils.compare(null, null, true) == 0); [EOL] }
public void testCompareWithNullsLast() { [EOL] Integer value1 = 1; [EOL] Integer value2 = 2; [EOL] assertTrue(ObjectUtils.compare(value1, value2, false) < 0); [EOL] assertTrue(ObjectUtils.compare(value2, value1, false) > 0); [EOL] assertTrue(ObjectUtils.compare(value1, value1, false) == 0); [EOL] assertTrue(ObjectUtils.compare(null, value2, false) > 0); [EOL] assertTrue(ObjectUtils.compare(value2, null, false) < 0); [EOL] assertTrue(ObjectUtils.compare(null, null, false) == 0); [EOL] }
public void testMedianWithNonEmptyNoNullElements() { [EOL] Integer[] numbers = {2, 4, 5, 1, 3}; [EOL] Integer median = ArrayUtils.median(numbers); [EOL] assertEquals(Integer.valueOf(3), median); [EOL] }
public void testMedianWithEmptyArray() { [EOL] Integer[] numbers = {}; [EOL] try { [EOL] ArrayUtils.median(numbers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMedianWithNullArray() { [EOL] Integer[] numbers = null; [EOL] try { [EOL] ArrayUtils.median(numbers); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testMedianWithNullElement() { [EOL] Integer[] numbers = {1, null, 3}; [EOL] try { [EOL] ArrayUtils.median(numbers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMedianWithSingleElement() { [EOL] Integer[] numbers = {1}; [EOL] Integer median = ArrayUtils.median(numbers); [EOL] assertEquals(Integer.valueOf(1), median); [EOL] }
public void testMedianWithEvenNumberOfElements() { [EOL] Integer[] numbers = {1, 2, 3, 4}; [EOL] Integer median = ArrayUtils.median(numbers); [EOL] assertEquals(Integer.valueOf(2), median); [EOL] }
public void testCloneWithCloneableArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Integer[] clonedArray = ObjectUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testCloneWithPrimitiveArray() { [EOL] int[] array = new int[]{1, 2, 3}; [EOL] int[] clonedArray = ObjectUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testCloneWithNonCloneable() { [EOL] Object obj = new Object(); [EOL] Object clonedObj = ObjectUtils.clone(obj); [EOL] assertNull(clonedObj); [EOL] }
public void testCloneWithCloneable() throws Exception { [EOL] CloneableTestClass testClass = new CloneableTestClass(); [EOL] CloneableTestClass clonedTestClass = ObjectUtils.clone(testClass); [EOL] assertNotNull(clonedTestClass); [EOL] assertNotSame(testClass, clonedTestClass); [EOL] assertEquals(testClass.value, clonedTestClass.value); [EOL] }
public void testCloneWithCloneableThrowingException() { [EOL] CloneableThrowingTestClass testClass = new CloneableThrowingTestClass(); [EOL] try { [EOL] ObjectUtils.clone(testClass); [EOL] fail("Should have thrown CloneFailedException"); [EOL] } catch (CloneFailedException e) { [EOL] } [EOL] } [EOL] class CloneableTestClass implements Cloneable { [EOL] int value = 0; [EOL] @Override [EOL] protected Object clone() throws CloneNotSupportedException { [EOL] CloneableTestClass clone = (CloneableTestClass) super.clone(); [EOL] clone.value = this.value; [EOL] return clone; [EOL] } [EOL] } [EOL] class CloneableThrowingTestClass implements Cloneable { [EOL] @Override [EOL] protected Object clone() throws CloneNotSupportedException { [EOL] throw new CloneNotSupportedException("Cannot clone"); [EOL] } [EOL] }
public void testConstTrue() { [EOL] assertTrue(BooleanUtils.CONST(true)); [EOL] }
public void testConstFalse() { [EOL] assertFalse(BooleanUtils.CONST(false)); [EOL] }
public void testConstByte() { [EOL] byte expected = 10; [EOL] byte result = CONST(expected); [EOL] assertEquals(expected, result); [EOL] }
public void testConstByteWithinRange() { [EOL] final int input = 100; [EOL] byte result = CONST_BYTE(input); [EOL] assertEquals((byte) input, result); [EOL] } [EOL] public void testConstByteBelowMinimum() { [EOL] final int input = Integer.MIN_VALUE; [EOL] try { [EOL] CONST_BYTE(input); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Supplied value must be a valid byte literal between -128 and 127: [" + input + "]", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstByteAboveMaximum() { [EOL] final int input = Integer.MAX_VALUE; [EOL] try { [EOL] CONST_BYTE(input); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Supplied value must be a valid byte literal between -128 and 127: [" + input + "]", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstByteAtMinimum() { [EOL] final int input = Byte.MIN_VALUE; [EOL] byte result = CONST_BYTE(input); [EOL] assertEquals((byte) input, result); [EOL] } [EOL] public void testConstByteAtMaximum() { [EOL] final int input = Byte.MAX_VALUE; [EOL] byte result = CONST_BYTE(input); [EOL] assertEquals((byte) input, result); [EOL] }

public void testCONST() { [EOL] char expected = 'a'; [EOL] char result = CONST(expected); [EOL] assertEquals(expected, result); [EOL] }
public void testConstShort() { [EOL] final short expectedValue = 123; [EOL] short result = CONST(expectedValue); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testConstShortWithinRange() { [EOL] short expected = 100; [EOL] short result = CONST_SHORT(100); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testConstShortBelowMinimum() { [EOL] try { [EOL] CONST_SHORT(Short.MIN_VALUE - 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Supplied value must be a valid byte literal between -32768 and 32767: [" + (Short.MIN_VALUE - 1) + "]", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstShortAboveMaximum() { [EOL] try { [EOL] CONST_SHORT(Short.MAX_VALUE + 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Supplied value must be a valid byte literal between -32768 and 32767: [" + (Short.MAX_VALUE + 1) + "]", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstShortAtMinimum() { [EOL] short expected = Short.MIN_VALUE; [EOL] short result = CONST_SHORT(Short.MIN_VALUE); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testConstShortAtMaximum() { [EOL] short expected = Short.MAX_VALUE; [EOL] short result = CONST_SHORT(Short.MAX_VALUE); [EOL] assertEquals(expected, result); [EOL] }
public void testCONST() { [EOL] int expected = 10; [EOL] int actual = CONST(expected); [EOL] assertEquals(expected, actual); [EOL] }
public void testConst() { [EOL] long expected = 12345L; [EOL] long result = CONST(expected); [EOL] assertEquals(expected, result); [EOL] }
public void testCONST_Float() { [EOL] float expected = 10.0f; [EOL] float result = CONST(expected); [EOL] assertEquals(expected, result, 0.0f); [EOL] }
public void testCONST_PositiveValue() { [EOL] double expected = 10.0; [EOL] double result = CONST(expected); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testCONST_NegativeValue() { [EOL] double expected = -10.0; [EOL] double result = CONST(expected); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testCONST_ZeroValue() { [EOL] double expected = 0.0; [EOL] double result = CONST(expected); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testConstWithNonNull() { [EOL] String constantString = "I am constant"; [EOL] String result = CONST(constantString); [EOL] assertSame(constantString, result); [EOL] }
public void testConstWithNull() { [EOL] Object result = CONST(null); [EOL] assertNull(result); [EOL] }
public void testGet_WhenObjectIsNull_ShouldInitialize() throws ConcurrentException { [EOL] LazyInitializer<Object> lazyInitializer = new LazyInitializer<Object>() { [EOL] private boolean initialized = false; [EOL] @Override [EOL] protected Object initialize() { [EOL] initialized = true; [EOL] return new Object(); [EOL] } [EOL] }; [EOL] Object result = lazyInitializer.get(); [EOL] assertNotNull(result); [EOL] assertTrue(lazyInitializer.initialized); [EOL] }
public void testGet_WhenObjectIsNotNull_ShouldNotInitialize() throws ConcurrentException { [EOL] final Object existingObject = new Object(); [EOL] LazyInitializer<Object> lazyInitializer = new LazyInitializer<Object>() { [EOL] private boolean initialized = false; [EOL] @Override [EOL] protected Object initialize() { [EOL] initialized = true; [EOL] return new Object(); [EOL] } [EOL] @Override [EOL] public Object get() throws ConcurrentException { [EOL] return existingObject; [EOL] } [EOL] }; [EOL] Object result = lazyInitializer.get(); [EOL] assertSame(existingObject, result); [EOL] assertFalse(lazyInitializer.initialized); [EOL] }
public void testValidateConstructor() { [EOL] Validate validate = new Validate(); [EOL] assertNotNull(validate); [EOL] }
public void testIsTrueWithTrueExpression() { [EOL] isTrue(true, "The expression must be true", 1.0); [EOL] }
public void testIsTrueWithFalseExpression() { [EOL] try { [EOL] isTrue(false, "The expression must be true but was %s", 0.0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The expression must be true but was 0.0", e.getMessage()); [EOL] } [EOL] }
public void testNotEmptyArrayIsNull() { [EOL] try { [EOL] Object[] result = Validate.notEmpty(null, "Array cannot be null", new Object[0]); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Array cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testNotEmptyArrayIsEmpty() { [EOL] try { [EOL] Object[] result = Validate.notEmpty(new Object[0], "Array cannot be empty", new Object[0]); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Array cannot be empty", e.getMessage()); [EOL] } [EOL] }
public void testNotEmptyArrayIsValid() { [EOL] Object[] array = new Object[] {1, 2, 3}; [EOL] Object[] result = Validate.notEmpty(array, "Array is valid", new Object[0]); [EOL] assertSame(array, result); [EOL] }
public void testNotEmpty_NullArray_ThrowsException() { [EOL] try { [EOL] ArrayUtils.notEmpty(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals(ArrayUtils.DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE, ex.getMessage()); [EOL] } [EOL] }
public void testNotEmpty_EmptyArray_ThrowsException() { [EOL] try { [EOL] ArrayUtils.notEmpty(new Object[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals(ArrayUtils.DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE, ex.getMessage()); [EOL] } [EOL] }
public void testNotEmpty_NonEmptyArray_ReturnsArray() { [EOL] String[] array = new String[] {"element"}; [EOL] String[] result = ArrayUtils.notEmpty(array); [EOL] assertSame(array, result); [EOL] }
public void testNotEmptyWithNullChars() { [EOL] try { [EOL] String result = notEmpty(null, "Chars must not be null"); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chars must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNotEmptyWithEmptyChars() { [EOL] try { [EOL] String result = notEmpty("", "Chars must not be empty"); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Chars must not be empty", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNotEmptyWithValidChars() { [EOL] String input = "abc"; [EOL] String result = notEmpty(input, "Chars must not be null or empty"); [EOL] assertSame("The returned CharSequence should be the same as the input", input, result); [EOL] }

public void testValidIndex_ValidCase() { [EOL] String input = "abc"; [EOL] int index = 1; [EOL] String message = "Index is out of bounds: %d"; [EOL] String result = Validate.validIndex(input, index, message, index); [EOL] assertEquals("The validIndex method should return the original CharSequence when index is valid.", input, result); [EOL] }
public void testValidIndex_NegativeIndex() { [EOL] String input = "abc"; [EOL] int index = -1; [EOL] String message = "Index is out of bounds: %d"; [EOL] try { [EOL] Validate.validIndex(input, index, message, index); [EOL] fail("Should have thrown IndexOutOfBoundsException for negative index."); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index is out of bounds: -1", e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_IndexEqualToLength() { [EOL] String input = "abc"; [EOL] int index = input.length(); [EOL] String message = "Index is out of bounds: %d"; [EOL] try { [EOL] Validate.validIndex(input, index, message, index); [EOL] fail("Should have thrown IndexOutOfBoundsException when index equals length."); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index is out of bounds: 3", e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_NullChars() { [EOL] String input = null; [EOL] int index = 0; [EOL] String message = "Chars should not be null"; [EOL] try { [EOL] Validate.validIndex(input, index, message); [EOL] fail("Should have thrown NullPointerException for null chars."); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chars should not be null", e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_ValidInput() { [EOL] String input = "abc"; [EOL] int index = 1; [EOL] CharSequence result = StringUtils.validIndex(input, index); [EOL] assertEquals("Method should return the input CharSequence when index is valid", input, result); [EOL] } [EOL] public void testValidIndex_IndexOutOfBounds() { [EOL] try { [EOL] String input = "abc"; [EOL] int index = 4; [EOL] StringUtils.validIndex(input, index); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testValidIndex_NullInput() { [EOL] try { [EOL] String input = null; [EOL] int index = 0; [EOL] StringUtils.validIndex(input, index); [EOL] fail("Should have thrown an IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testValidIndex_NegativeIndex() { [EOL] try { [EOL] String input = "abc"; [EOL] int index = -1; [EOL] StringUtils.validIndex(input, index); [EOL] fail("Should have thrown an IndexOutOfBoundsException for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testExclusiveBetween_WithinBounds() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 3; [EOL] StringUtils.exclusiveBetween(start, end, value); [EOL] } [EOL] public void testExclusiveBetween_BelowLowerBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 0; [EOL] try { [EOL] StringUtils.exclusiveBetween(start, end, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The value 0 is not in the specified exclusive range of 1 to 5", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testExclusiveBetween_AboveUpperBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 6; [EOL] try { [EOL] StringUtils.exclusiveBetween(start, end, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The value 6 is not in the specified exclusive range of 1 to 5", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testExclusiveBetween_AtLowerBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 1; [EOL] try { [EOL] StringUtils.exclusiveBetween(start, end, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The value 1 is not in the specified exclusive range of 1 to 5", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testExclusiveBetween_AtUpperBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 5; [EOL] try { [EOL] StringUtils.exclusiveBetween(start, end, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The value 5 is not in the specified exclusive range of 1 to 5", ex.getMessage()); [EOL] } [EOL] }

public void testIsAssignableFrom_WithAssignableClasses() { [EOL] Class<?> superType = java.util.Collection.class; [EOL] Class<?> type = java.util.List.class; [EOL] isAssignableFrom(superType, type); [EOL] } [EOL] public void testIsAssignableFrom_WithNonAssignableClasses() { [EOL] try { [EOL] Class<?> superType = java.util.List.class; [EOL] Class<?> type = java.util.Collection.class; [EOL] isAssignableFrom(superType, type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIsAssignableFrom_WithNullType() { [EOL] try { [EOL] Class<?> superType = java.util.List.class; [EOL] Class<?> type = null; [EOL] isAssignableFrom(superType, type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIsAssignableFrom_WithNullSuperType() { [EOL] try { [EOL] Class<?> superType = null; [EOL] Class<?> type = java.util.List.class; [EOL] isAssignableFrom(superType, type); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSqueeze_NullInputString() { [EOL] String result = StringUtils.squeeze(null); [EOL] assertNull(result); [EOL] } [EOL] public void testSqueeze_EmptyInputString() { [EOL] String result = StringUtils.squeeze(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSqueeze_NullSet() { [EOL] String result = StringUtils.squeeze("a-b-c-", (String[]) null); [EOL] assertEquals("a-b-c-", result); [EOL] } [EOL] public void testSqueeze_EmptySet() { [EOL] String result = StringUtils.squeeze("a-b-c-", new String[]{}); [EOL] assertEquals("a-b-c-", result); [EOL] } [EOL] public void testSqueeze_ValidInputNoSqueeze() { [EOL] String result = StringUtils.squeeze("a-b-c-", "xyz"); [EOL] assertEquals("a-b-c-", result); [EOL] } [EOL] public void testSqueeze_ValidInputWithSqueeze() { [EOL] String result = StringUtils.squeeze("a--b--c--", "-"); [EOL] assertEquals("a-b-c-", result); [EOL] } [EOL] public void testSqueeze_ValidInputWithSqueezeAtStart() { [EOL] String result = StringUtils.squeeze("--a-b-c--", "-"); [EOL] assertEquals("-a-b-c-", result); [EOL] } [EOL] public void testSqueeze_ValidInputWithSqueezeMultipleChars() { [EOL] String result = StringUtils.squeeze("a-~~b~~c~~", "-", "~"); [EOL] assertEquals("a-~b~c~", result); [EOL] }
public static void printRootCauseStackTrace(final Throwable throwable) { [EOL] printRootCauseStackTrace(throwable, System.err); [EOL] } [EOL] public ExceptionUtils(); [EOL] public static String[] getDefaultCauseMethodNames(); [EOL] public static Throwable getCause(final Throwable throwable); [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames); [EOL] public static Throwable getRootCause(final Throwable throwable); [EOL] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); [EOL] public static int getThrowableCount(final Throwable throwable); [EOL] public static Throwable[] getThrowables(final Throwable throwable); [EOL] public static List<Throwable> getThrowableList(Throwable throwable); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); [EOL] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); [EOL] public static void printRootCauseStackTrace(final Throwable throwable); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); [EOL] public static String[] getRootCauseStackTrace(final Throwable throwable); [EOL] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); [EOL] public static String getStackTrace(final Throwable throwable); [EOL] public static String[] getStackFrames(final Throwable throwable); [EOL] static String[] getStackFrames(final String stackTrace); [EOL] static List<String> getStackFrameList(final Throwable t); [EOL] public static String getMessage(final Throwable th); [EOL] public static String getRootCauseMessage(final Throwable th); [EOL] String WRAPPED_MARKER=Optional[" [wrapped] "]; [EOL] String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public void testGetMessage_NullThrowable() { [EOL] String result = ExceptionUtils.getMessage(null); [EOL] assertEquals("", result); [EOL] }
public void testGetMessage_ThrowableWithNullMessage() { [EOL] Throwable th = new Throwable((String) null); [EOL] String result = ExceptionUtils.getMessage(th); [EOL] assertEquals("Throwable: ", result); [EOL] }
public void testGetMessage_ThrowableWithMessage() { [EOL] Throwable th = new Throwable("Test Message"); [EOL] String result = ExceptionUtils.getMessage(th); [EOL] assertEquals("Throwable: Test Message", result); [EOL] }
public void testGetRootCauseMessage_NullThrowable() { [EOL] String message = ExceptionUtils.getRootCauseMessage(null); [EOL] assertNull("The message should be null because the throwable is null", message); [EOL] }
public void testGetRootCauseMessage_NoRootCause() { [EOL] Throwable throwable = new Throwable("No root cause"); [EOL] String message = ExceptionUtils.getRootCauseMessage(throwable); [EOL] assertEquals("The message should be equal to the throwable's message", "No root cause", message); [EOL] }
public void testGetRootCauseMessage_WithRootCause() { [EOL] Throwable rootCause = new Throwable("Root cause"); [EOL] Throwable wrapperException = new RuntimeException(rootCause); [EOL] String message = ExceptionUtils.getRootCauseMessage(wrapperException); [EOL] assertEquals("The message should be equal to the root cause's message", "Root cause", message); [EOL] }
public void testMutableShortConstructor() { [EOL] MutableShort mutShort = new MutableShort(); [EOL] assertNotNull(mutShort); [EOL] assertEquals(0, mutShort.shortValue()); [EOL] }
public void testGetValueWhenValueIsSet() { [EOL] final short testValue = 10; [EOL] YourClass instance = new YourClass(testValue); [EOL] Short result = instance.getValue(); [EOL] assertEquals(Short.valueOf(testValue), result); [EOL] }
public void testGetValueWhenValueIsMinShort() { [EOL] final short testValue = Short.MIN_VALUE; [EOL] YourClass instance = new YourClass(testValue); [EOL] Short result = instance.getValue(); [EOL] assertEquals(Short.valueOf(testValue), result); [EOL] }
public void testGetValueWhenValueIsMaxShort() { [EOL] final short testValue = Short.MAX_VALUE; [EOL] YourClass instance = new YourClass(testValue); [EOL] Short result = instance.getValue(); [EOL] assertEquals(Short.valueOf(testValue), result); [EOL] }
public void testSetValue() { [EOL] YourClass instance = new YourClass(); [EOL] short expectedValue = 10; [EOL] instance.setValue(expectedValue); [EOL] short actualValue = instance.getValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testSetValueWithNull() { [EOL] MutableShort mutableShort = new MutableShort(); [EOL] mutableShort.setValue(null); [EOL] assertEquals(0, mutableShort.shortValue()); [EOL] }
public void testSetValueWithShort() { [EOL] MutableShort mutableShort = new MutableShort(); [EOL] mutableShort.setValue((short) 10); [EOL] assertEquals(10, mutableShort.shortValue()); [EOL] }
public void testSetValueWithInteger() { [EOL] MutableShort mutableShort = new MutableShort(); [EOL] mutableShort.setValue(10); [EOL] assertEquals(10, mutableShort.shortValue()); [EOL] }
public void testSetValueWithLong() { [EOL] MutableShort mutableShort = new MutableShort(); [EOL] mutableShort.setValue(10L); [EOL] assertEquals(10, mutableShort.shortValue()); [EOL] }
public void testSetValueWithByte() { [EOL] MutableShort mutableShort = new MutableShort(); [EOL] mutableShort.setValue((byte) 10); [EOL] assertEquals(10, mutableShort.shortValue()); [EOL] }
public void testEquals_SameType() { [EOL] MutableShort mutableShort1 = new MutableShort((short) 5); [EOL] MutableShort mutableShort2 = new MutableShort((short) 5); [EOL] MutableShort mutableShort3 = new MutableShort((short) 10); [EOL] assertTrue(mutableShort1.equals(mutableShort2)); [EOL] assertFalse(mutableShort1.equals(mutableShort3)); [EOL] }
public void testEquals_DifferentType() { [EOL] MutableShort mutableShort = new MutableShort((short) 5); [EOL] Object obj = new Object(); [EOL] assertFalse(mutableShort.equals(obj)); [EOL] }
public void testEquals_Null() { [EOL] MutableShort mutableShort = new MutableShort((short) 5); [EOL] Object obj = null; [EOL] assertFalse(mutableShort.equals(obj)); [EOL] }
public void testHashCode() { [EOL] SomeClass instance = new SomeClass(123); [EOL] int expected = 123; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testStopWatchConstructor() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] assertNotNull(stopWatch); [EOL] }
public void testStart_WhenStopped_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_STOPPED; [EOL] try { [EOL] stopwatch.start(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch must be reset before being restarted. ", e.getMessage()); [EOL] } [EOL] }
public void testStart_WhenAlreadyStarted_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_RUNNING; [EOL] try { [EOL] stopwatch.start(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch already started. ", e.getMessage()); [EOL] } [EOL] }
public void testStart_WhenUnstarted_ShouldStartStopwatch() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_UNSTARTED; [EOL] stopwatch.start(); [EOL] assertEquals(Stopwatch.STATE_RUNNING, stopwatch.runningState); [EOL] assertTrue(stopwatch.startTime > 0); [EOL] assertTrue(stopwatch.startTimeMillis > 0); [EOL] }
public void testStopWhenNotRunning() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_STOPPED; [EOL] try { [EOL] stopwatch.stop(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch is not running. ", e.getMessage()); [EOL] } [EOL] } [EOL] public void testStopWhenSuspended() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_SUSPENDED; [EOL] stopwatch.stop(); [EOL] assertEquals(Stopwatch.STATE_STOPPED, stopwatch.runningState); [EOL] } [EOL] public void testStopWhenRunning() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_RUNNING; [EOL] stopwatch.stop(); [EOL] assertTrue(stopwatch.stopTime > 0); [EOL] assertEquals(Stopwatch.STATE_STOPPED, stopwatch.runningState); [EOL] }
public void testSuspend_WhenRunning() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.suspend(); [EOL] assertEquals(Stopwatch.STATE_SUSPENDED, stopwatch.getRunningState()); [EOL] assertTrue(stopwatch.getStopTime() > 0); [EOL] }
public void testSuspend_WhenNotRunning_ThrowsException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.suspend(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch must be running to suspend. ", e.getMessage()); [EOL] } [EOL] }
public void testGetTimeWhenNanoTimeIsPositive() { [EOL] StopWatch stopWatch = new StopWatch() { [EOL] @Override [EOL] public long getNanoTime() { [EOL] return 5000000L; // 5 milliseconds in nanoseconds [EOL] } [EOL] }; [EOL] long expectedTime = 5L; // 5 milliseconds [EOL] long actualTime = stopWatch.getTime(); [EOL] assertEquals(expectedTime, actualTime); [EOL] }
public void testGetTimeWhenNanoTimeIsZero() { [EOL] StopWatch stopWatch = new StopWatch() { [EOL] @Override [EOL] public long getNanoTime() { [EOL] return 0L; // 0 milliseconds in nanoseconds [EOL] } [EOL] }; [EOL] long expectedTime = 0L; // 0 milliseconds [EOL] long actualTime = stopWatch.getTime(); [EOL] assertEquals(expectedTime, actualTime); [EOL] }
public void testGetTimeWhenNanoTimeIsNegative() { [EOL] StopWatch stopWatch = new StopWatch() { [EOL] @Override [EOL] public long getNanoTime() { [EOL] return -5000000L; // -5 milliseconds in nanoseconds [EOL] } [EOL] }; [EOL] long expectedTime = -5L; // -5 milliseconds [EOL] long actualTime = stopWatch.getTime(); [EOL] assertEquals(expectedTime, actualTime); [EOL] }
public void testGetNanoTime_StoppedOrSuspended() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] stopWatch.stop(); [EOL] long expected = stopWatch.getStopTime() - stopWatch.getStartTime(); [EOL] long actual = stopWatch.getNanoTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetNanoTime_Unstarted() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] long expected = 0; [EOL] long actual = stopWatch.getNanoTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetNanoTime_Running() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] assertTrue(stopWatch.getNanoTime() > 0); [EOL] }
public void testGetNanoTime_IllegalState() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] try { [EOL] Field runningStateField = StopWatch.class.getDeclaredField("runningState"); [EOL] runningStateField.setAccessible(true); [EOL] runningStateField.set(stopWatch, Integer.MAX_VALUE); [EOL] stopWatch.getNanoTime(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Illegal running state has occurred.", e.getMessage()); [EOL] } catch (NoSuchFieldException | IllegalAccessException e) { [EOL] fail("Reflection failed to set the illegal state"); [EOL] } [EOL] }
public void testGetWhenReferenceIsInitiallyNull() throws ConcurrentException { [EOL] AtomicReference<T> reference = new AtomicReference<>(null); [EOL] AtomicBoolean factory = new AtomicBoolean(false); [EOL] T expectedValue = ...; // Initialize with a value of type T [EOL] T result = null; [EOL] factory.set(true); [EOL] reference.set(expectedValue); [EOL] result = get(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetWhenReferenceIsNonNull() throws ConcurrentException { [EOL] AtomicReference<T> reference = new AtomicReference<>(null); [EOL] AtomicBoolean factory = new AtomicBoolean(false); [EOL] T expectedValue = ...; // Initialize with a value of type T [EOL] T result = null; [EOL] reference.set(expectedValue); [EOL] result = get(); [EOL] assertEquals(expectedValue, result); [EOL] assertFalse(factory.get()); [EOL] }
public void testReflectionCompareWithNulls() { [EOL] int result = ObjectUtils.reflectionCompare(null, null); [EOL] assertEquals(0, result); [EOL] }
public void testReflectionCompareWithLeftNull() { [EOL] int result = ObjectUtils.reflectionCompare(null, new Object()); [EOL] assertTrue(result < 0); [EOL] }
public void testReflectionCompareWithRightNull() { [EOL] int result = ObjectUtils.reflectionCompare(new Object(), null); [EOL] assertTrue(result > 0); [EOL] }
public void testReflectionCompareWithNonNulls() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] int result = ObjectUtils.reflectionCompare(lhs, rhs); [EOL] assertTrue(result == 0 || result < 0 || result > 0); [EOL] }
public void testReflectionCompare_BothObjectsNull_ThrowsNullPointerException() { [EOL] try { [EOL] int result = reflectionCompare(null, null, true, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_DifferentClasses_ThrowsClassCastException() { [EOL] Object lhs = new Object(); [EOL] String rhs = "test"; [EOL] try { [EOL] int result = reflectionCompare(lhs, rhs, true, null); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_SameObject_ReturnsZero() { [EOL] Object obj = new Object(); [EOL] int result = reflectionCompare(obj, obj, true, null); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testReflectionCompare_BothObjectsNonNullButOneIsNull_ThrowsNullPointerException() { [EOL] Object lhs = new Object(); [EOL] try { [EOL] int result = reflectionCompare(lhs, null, true, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] try { [EOL] int result = reflectionCompare(null, lhs, true, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_ValidComparison() { [EOL] ComparableTestObject lhs = new ComparableTestObject(1); [EOL] ComparableTestObject rhs = new ComparableTestObject(2); [EOL] int result = reflectionCompare(lhs, rhs, true, null); [EOL] assertTrue(result < 0); [EOL] } [EOL] public void testReflectionCompare_ReflectUpToClass() { [EOL] ComparableTestObject lhs = new ComparableTestObject(1); [EOL] ComparableTestObject rhs = new ComparableTestObject(1); [EOL] int result = reflectionCompare(lhs, rhs, true, ComparableTestObject.class.getSuperclass()); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testReflectionCompare_ExcludeFields() { [EOL] ComparableTestObject lhs = new ComparableTestObject(1); [EOL] ComparableTestObject rhs = new ComparableTestObject(1); [EOL] int result = reflectionCompare(lhs, rhs, true, null, "excludedFieldName"); [EOL] assertEquals(0, result); [EOL] }

public void testAppendSuper_WithNonZeroComparison() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.appendSuper(1); // Set comparison to non-zero [EOL] compareToBuilder.appendSuper(2); // Try to append another super [EOL] assertEquals(1, compareToBuilder.toComparison()); // Assert the comparison remains unchanged [EOL] }
public void testAppendSuper_WithZeroComparison() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.appendSuper(0); // Set comparison to zero [EOL] compareToBuilder.appendSuper(1); // Now append a non-zero super [EOL] assertEquals(1, compareToBuilder.toComparison()); // Assert the comparison changes to the new value [EOL] }
public void testAppend_BothValuesNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, null, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_LeftValueNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, "rhs", null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] } [EOL] public void testAppend_RightValueNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("lhs", null, null); [EOL] assertTrue(builder.toComparison() > 0); [EOL] } [EOL] public void testAppend_BothValuesNonNullAndEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("lhs", "lhs", null); [EOL] assertEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_BothValuesNonNullAndNotEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("lhs", "rhs", null); [EOL] assertNotEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_WithComparator() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Comparator<String> comparator = Comparator.naturalOrder(); [EOL] builder.append("lhs", "rhs", comparator); [EOL] assertEquals(comparator.compare("lhs", "rhs"), builder.toComparison()); [EOL] } [EOL] public void testAppend_Arrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] long[] lhsArray = {1L, 2L}; [EOL] long[] rhsArray = {1L, 2L}; [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_ArraysNotEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhsArray = {1, 2}; [EOL] int[] rhsArray = {3, 4}; [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertNotEquals(0, builder.toComparison()); [EOL] }
public void testAppend_ArraysDifferentTypes() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhsArray = {1, 2}; [EOL] byte[] rhsArray = {3, 4}; [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertNotEquals(0, builder.toComparison()); [EOL] }
public void testAppend_ComparisonAlreadySet() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("lhs", "rhs", null); [EOL] int initialComparison = builder.toComparison(); [EOL] builder.append("lhs", "rhs", null); [EOL] assertEquals(initialComparison, builder.toComparison()); [EOL] }
public void testAppend_byteEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte lhs = 10; [EOL] byte rhs = 10; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_byteLessThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte lhs = 9; [EOL] byte rhs = 10; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppend_byteGreaterThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte lhs = 11; [EOL] byte rhs = 10; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppend_byteComparisonNonZero() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append((byte) 10, (byte) 9); [EOL] builder.append((byte) 10, (byte) 10); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppend_BothArraysNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhs = null; [EOL] byte[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_LeftArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhs = null; [EOL] byte[] rhs = new byte[] {1}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] } [EOL] public void testAppend_RightArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhs = new byte[] {1}; [EOL] byte[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] } [EOL] public void testAppend_ArraysWithDifferentLength() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhs = new byte[] {1}; [EOL] byte[] rhs = new byte[] {1, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] } [EOL] public void testAppend_ArraysWithSameLengthButDifferentElements() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhs = new byte[] {1}; [EOL] byte[] rhs = new byte[] {2}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] } [EOL] public void testAppend_ArraysWithSameLengthAndSameElements() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] byte[] lhs = new byte[] {1}; [EOL] byte[] rhs = new byte[] {1}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_ComparisonAlreadySet() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] byte[] lhs = new byte[] {1}; [EOL] byte[] rhs = new byte[] {1}; [EOL] builder.append(lhs, rhs); // This should not change the comparison since it's already set [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testTrimToEmpty_NullInput() { [EOL] String result = StringUtils.trimToEmpty(null); [EOL] assertEquals("", result); [EOL] }
public void testTrimToEmpty_NonNullInput() { [EOL] String input = "  test string  "; [EOL] String result = StringUtils.trimToEmpty(input); [EOL] assertEquals("test string", result); [EOL] }
public void testTrimToEmpty_EmptyInput() { [EOL] String input = ""; [EOL] String result = StringUtils.trimToEmpty(input); [EOL] assertEquals("", result); [EOL] }
public void testTrimToEmpty_WhitespaceInput() { [EOL] String input = "   "; [EOL] String result = StringUtils.trimToEmpty(input); [EOL] assertEquals("", result); [EOL] }
public void testEquals_BothCharSequencesNull() { [EOL] assertTrue(StringUtils.equals(null, null)); [EOL] }
public void testEquals_FirstCharSequenceNull() { [EOL] assertFalse(StringUtils.equals(null, "abc")); [EOL] }
public void testEquals_SecondCharSequenceNull() { [EOL] assertFalse(StringUtils.equals("abc", null)); [EOL] }
public void testEquals_BothCharSequencesSameObject() { [EOL] CharSequence cs = "abc"; [EOL] assertTrue(StringUtils.equals(cs, cs)); [EOL] }
public void testEquals_BothCharSequencesEqualStrings() { [EOL] assertTrue(StringUtils.equals("abc", "abc")); [EOL] }
public void testEquals_DifferentCharSequences() { [EOL] assertFalse(StringUtils.equals("abc", "abcd")); [EOL] }
public void testEquals_BothCharSequencesNonString() { [EOL] CharSequence cs1 = new StringBuilder("abc"); [EOL] CharSequence cs2 = new StringBuilder("abc"); [EOL] assertTrue(StringUtils.equals(cs1, cs2)); [EOL] }
public void testEquals_CharSequencesDifferentTypes() { [EOL] CharSequence cs1 = new StringBuilder("abc"); [EOL] CharSequence cs2 = "abc"; [EOL] assertTrue(StringUtils.equals(cs1, cs2)); [EOL] }
public void testOrdinalIndexOf_nullInputs() { [EOL] final int result = ordinalIndexOf(null, null, 1, false); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testOrdinalIndexOf_negativeOrdinal() { [EOL] final int result = ordinalIndexOf("a", "a", -1, false); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testOrdinalIndexOf_emptySearchStr() { [EOL] final int result = ordinalIndexOf("a", "", 1, false); [EOL] assertEquals(0, result); [EOL] }
public void testOrdinalIndexOf_emptySearchStrLastIndex() { [EOL] final int result = ordinalIndexOf("a", "", 1, true); [EOL] assertEquals(1, result); [EOL] }
public void testOrdinalIndexOf_notFound() { [EOL] final int result = ordinalIndexOf("a", "b", 1, false); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testOrdinalIndexOf_foundFirstOccurrence() { [EOL] final int result = ordinalIndexOf("abab", "b", 1, false); [EOL] assertEquals(1, result); [EOL] }
public void testOrdinalIndexOf_foundSecondOccurrence() { [EOL] final int result = ordinalIndexOf("abab", "b", 2, false); [EOL] assertEquals(3, result); [EOL] }
public void testOrdinalIndexOf_lastIndex() { [EOL] final int result = ordinalIndexOf("abab", "b", 1, true); [EOL] assertEquals(3, result); [EOL] }
public void testOrdinalIndexOf_lastIndexSecondOccurrence() { [EOL] final int result = ordinalIndexOf("abab", "b", 2, true); [EOL] assertEquals(1, result); [EOL] }
public void testLastOrdinalIndexOf_NullStr() { [EOL] int result = StringUtils.lastOrdinalIndexOf(null, "a", 1); [EOL] assertEquals(-1, result); [EOL] }
public void testLastOrdinalIndexOf_NullSearchStr() { [EOL] int result = StringUtils.lastOrdinalIndexOf("a", null, 1); [EOL] assertEquals(-1, result); [EOL] }
public void testLastOrdinalIndexOf_InvalidOrdinal() { [EOL] int result = StringUtils.lastOrdinalIndexOf("a", "a", 0); [EOL] assertEquals(-1, result); [EOL] }
public void testLastOrdinalIndexOf_ValidCase() { [EOL] int result = StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 1); [EOL] assertEquals(7, result); [EOL] }
public void testLastOrdinalIndexOf_ValidCaseDifferentOrdinal() { [EOL] int result = StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 2); [EOL] assertEquals(5, result); [EOL] }
public void testLastOrdinalIndexOf_ValidCaseDifferentSearchStr() { [EOL] int result = StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 1); [EOL] assertEquals(4, result); [EOL] }
public void testLastOrdinalIndexOf_ValidCaseNoMatch() { [EOL] int result = StringUtils.lastOrdinalIndexOf("aabaabaa", "z", 1); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOfIgnoreCase_NullInputs() { [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(null, null, 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_StartPosGreaterThanLength() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "def"; [EOL] final int startPos = 10; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_StartPosLessThanZero() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "abc"; [EOL] final int startPos = -1; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_EmptySearchStr() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = ""; [EOL] final int startPos = 2; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_NonEmptySearchStrFound() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "bcd"; [EOL] final int startPos = 2; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_NonEmptySearchStrNotFound() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "xyz"; [EOL] final int startPos = 5; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testContains_NullSeq() { [EOL] boolean result = StringUtils.contains(null, "abc"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_NullSearchSeq() { [EOL] boolean result = StringUtils.contains("abc", null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_BothNull() { [EOL] boolean result = StringUtils.contains(null, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_SeqContainsSearchSeq() { [EOL] boolean result = StringUtils.contains("abcdef", "bcd"); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_SeqDoesNotContainSearchSeq() { [EOL] boolean result = StringUtils.contains("abcdef", "xyz"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_EmptySearchSeq() { [EOL] boolean result = StringUtils.contains("abcdef", ""); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_EmptySeq() { [EOL] boolean result = StringUtils.contains("", "abc"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_BothEmpty() { [EOL] boolean result = StringUtils.contains("", ""); [EOL] assertTrue(result); [EOL] }
public void testContainsWhitespace_NullInput() { [EOL] boolean result = StringUtils.containsWhitespace(null); [EOL] assertFalse(result); [EOL] }
public void testContainsWhitespace_EmptyString() { [EOL] boolean result = StringUtils.containsWhitespace(""); [EOL] assertFalse(result); [EOL] }
public void testContainsWhitespace_WithoutWhitespace() { [EOL] boolean result = StringUtils.containsWhitespace("ABC"); [EOL] assertFalse(result); [EOL] }
public void testContainsWhitespace_WithWhitespace() { [EOL] boolean result = StringUtils.containsWhitespace("A BC"); [EOL] assertTrue(result); [EOL] }
public void testIndexOfAnyBut_EmptyCs() { [EOL] final int result = StringUtils.indexOfAnyBut("", 'a', 'b'); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", new char[]{}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_NotFound() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", 'd', 'e'); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_Found() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", 'a', 'b'); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairs() { [EOL] final int result = StringUtils.indexOfAnyBut("a\uD83D\uDE00bc", 'a', '\uD83D', '\uDE00'); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOfAnyBut_SurrogatePairsNotFound() { [EOL] final int result = StringUtils.indexOfAnyBut("a\uD83D\uDE00bc", '\uD83D', '\uDE00'); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOfAny_StrIsNull() { [EOL] int result = StringUtils.lastIndexOfAny(null, new CharSequence[]{"a", "b", "c"}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfAny_SearchStrsIsNull() { [EOL] int result = StringUtils.lastIndexOfAny("abc", (CharSequence[]) null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfAny_BothInputsNull() { [EOL] int result = StringUtils.lastIndexOfAny(null, (CharSequence[]) null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfAny_EmptySearchStrs() { [EOL] int result = StringUtils.lastIndexOfAny("abc", new CharSequence[]{}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfAny_SearchStrsContainsNull() { [EOL] int result = StringUtils.lastIndexOfAny("abc", new CharSequence[]{null, "b", null}); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testLastIndexOfAny_ValidInput() { [EOL] int result = StringUtils.lastIndexOfAny("abc", new CharSequence[]{"c", "b"}); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOfAny_NoMatch() { [EOL] int result = StringUtils.lastIndexOfAny("abc", new CharSequence[]{"d", "e"}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfAny_SearchStrsContainsEmpty() { [EOL] int result = StringUtils.lastIndexOfAny("abc", new CharSequence[]{"", "b"}); [EOL] assertEquals(2, result); [EOL] }
public void testMid_NullString() { [EOL] String result = StringUtils.mid(null, 0, 4); [EOL] assertNull(result); [EOL] }
public void testMid_NegativeLen() { [EOL] String result = StringUtils.mid("abc", 0, -1); [EOL] assertEquals("", result); [EOL] }
public void testMid_PosGreaterThanLength() { [EOL] String result = StringUtils.mid("abc", 4, 2); [EOL] assertEquals("", result); [EOL] }
public void testMid_NegativePos() { [EOL] String result = StringUtils.mid("abc", -1, 2); [EOL] assertEquals("ab", result); [EOL] }
public void testMid_LenLongerThanRemaining() { [EOL] String result = StringUtils.mid("abc", 1, 5); [EOL] assertEquals("bc", result); [EOL] }
public void testMid_ExactSubstring() { [EOL] String result = StringUtils.mid("abc", 1, 1); [EOL] assertEquals("b", result); [EOL] }
public void testSubstringBefore_NullStringInput_ShouldReturnNull() { [EOL] String result = StringUtils.substringBefore(null, "separator"); [EOL] assertNull(result); [EOL] }
public void testSubstringBefore_NullSeparator_ShouldReturnOriginalString() { [EOL] String result = StringUtils.substringBefore("string", null); [EOL] assertEquals("string", result); [EOL] }
public void testSubstringBefore_EmptySeparator_ShouldReturnEmpty() { [EOL] String result = StringUtils.substringBefore("string", ""); [EOL] assertEquals("", result); [EOL] }
public void testSubstringBefore_SeparatorNotFound_ShouldReturnOriginalString() { [EOL] String result = StringUtils.substringBefore("string", "notfound"); [EOL] assertEquals("string", result); [EOL] }
public void testSubstringBefore_SeparatorFound_ShouldReturnSubstringBeforeSeparator() { [EOL] String result = StringUtils.substringBefore("string", "in"); [EOL] assertEquals("str", result); [EOL] }
public void testSplit_NullString() { [EOL] String[] result = StringUtils.split(null, ","); [EOL] assertNull(result); [EOL] }
public void testSplit_EmptyString() { [EOL] String[] result = StringUtils.split("", ","); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplit_NullSeparator() { [EOL] String[] result = StringUtils.split("a.b.c", null); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplit_EmptySeparator() { [EOL] String[] result = StringUtils.split("a.b.c", ""); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a.b.c", result[0]); [EOL] }
public void testSplit_SingleCharSeparator() { [EOL] String[] result = StringUtils.split("a.b.c", "."); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplit_MultiCharSeparator() { [EOL] String[] result = StringUtils.split("a,,b,c", ",,"); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b,c", result[1]); [EOL] }
public void testSplit_NullString() { [EOL] String[] result = StringUtils.split(null, ",", 2); [EOL] assertNull(result); [EOL] }
public void testSplit_EmptyString() { [EOL] String[] result = StringUtils.split("", ",", 2); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplit_NoMax() { [EOL] String[] result = StringUtils.split("a,b,c", ",", -1); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplit_LimitedMax() { [EOL] String[] result = StringUtils.split("a,b,c", ",", 2); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b,c", result[1]); [EOL] }
public void testSplit_NoSeparator() { [EOL] String[] result = StringUtils.split("abc", null, 2); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("abc", result[0]); [EOL] }
public void testSplit_EmptySeparator() { [EOL] String[] result = StringUtils.split("a,b,c", "", 2); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitByWholeSeparator_NullString() { [EOL] String[] result = StringUtils.splitByWholeSeparator(null, ",", 2); [EOL] assertNull(result); [EOL] }
public void testSplitByWholeSeparator_NullSeparator() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a.b.c", null, 3); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a.b.c", result[0]); [EOL] }
public void testSplitByWholeSeparator_EmptySeparator() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a.b.c", "", 3); [EOL] assertEquals(5, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("c", result[4]); [EOL] }
public void testSplitByWholeSeparator_MaxLessThanZero() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a.b.c", ".", -1); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitByWholeSeparator_MaxEqualToOne() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a.b.c", ".", 1); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a.b.c", result[0]); [EOL] }
public void testSplitByWholeSeparator_RegularUse() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a.b.c", ".", 2); [EOL] assertEquals(2, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b.c", result[1]); [EOL] }
public void testSplitByWholeSeparatorWorker_nullString() { [EOL] String[] result = splitByWholeSeparatorWorker(null, ",", 2, true); [EOL] assertNull(result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_emptyString() { [EOL] String[] result = splitByWholeSeparatorWorker("", ",", 2, true); [EOL] assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_nullSeparator() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", null, 2, true); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_emptySeparator() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", "", 2, true); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_normalCase() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", ",", 3, false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_preserveAllTokens() { [EOL] String[] result = splitByWholeSeparatorWorker("a,,c", ",", 3, true); [EOL] assertArrayEquals(new String[]{"a", "", "c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_maxSplit() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", ",", 2, false); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_noSeparatorFound() { [EOL] String[] result = splitByWholeSeparatorWorker("abc", ",", 3, false); [EOL] assertArrayEquals(new String[]{"abc"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_separatorAtEnd() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,", ",", 3, false); [EOL] assertArrayEquals(new String[]{"a", "b", ""}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_preserveAllTokensWithMaxSplit() { [EOL] String[] result = splitByWholeSeparatorWorker("a,,c", ",", 2, true); [EOL] assertArrayEquals(new String[]{"a", ",c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_emptyTokenInMiddle() { [EOL] String[] result = splitByWholeSeparatorWorker("a,,c", ",", -1, true); [EOL] assertArrayEquals(new String[]{"a", "", "c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_separatorOnly() { [EOL] String[] result = splitByWholeSeparatorWorker(",", ",", -1, true); [EOL] assertArrayEquals(new String[]{"", ""}, result); [EOL] }
public void testSplitPreserveAllTokens_NullString() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(null, ","); [EOL] assertNull(result); [EOL] }
public void testSplitPreserveAllTokens_EmptyString() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("", ","); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitPreserveAllTokens_NullSeparator() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", null); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_EmptySeparator() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", ""); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals(".", result[1]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals(".", result[3]); [EOL] assertEquals("c", result[4]); [EOL] }
public void testSplitPreserveAllTokens_RegularSeparator() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", "."); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_MultipleCharactersSeparator() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a,,b,c", ","); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("", result[1]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("c", result[3]); [EOL] }
public void testSplitPreserveAllTokens_NullString() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(null, ",", 2); [EOL] assertNull(result); [EOL] }
public void testSplitPreserveAllTokens_EmptyString() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("", ",", 2); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitPreserveAllTokens_NoSeparator() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("abc def", null, 2); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("abc", result[0]); [EOL] assertEquals("def", result[1]); [EOL] }
public void testSplitPreserveAllTokens_RegularUse() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", ".", 3); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_MaxLessThanEqualZero() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", ".", 0); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_MaxGreaterThanAvailableTokens() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", ".", 5); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_SeparatorCharsIsEmpty() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a.b.c", "", 3); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a.b.c", result[0]); [EOL] }
public void testSplitPreserveAllTokens_PreserveAllTokens() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a..b.c", ".", 4); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("", result[1]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("c", result[3]); [EOL] }
public void testSplitWorker_nullString() { [EOL] String[] result = splitWorker(null, ",", 2, true); [EOL] assertNull(result); [EOL] }
public void testSplitWorker_emptyString() { [EOL] String[] result = splitWorker("", ",", 2, true); [EOL] assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL] }
public void testSplitWorker_nullSeparator() { [EOL] String[] result = splitWorker("a b c", null, -1, false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokens() { [EOL] String[] result = splitWorker("a b c", null, -1, true); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_singleCharSeparator() { [EOL] String[] result = splitWorker("a,b,c", ",", -1, false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_maxParameter() { [EOL] String[] result = splitWorker("a,b,c", ",", 2, false); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] }
public void testSplitWorker_multiCharSeparator() { [EOL] String[] result = splitWorker("a||b||c", "||", -1, false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokensWithSeparator() { [EOL] String[] result = splitWorker("a||b||c", "||", -1, true); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokensWithMax() { [EOL] String[] result = splitWorker("a||b||c", "||", 2, true); [EOL] assertArrayEquals(new String[]{"a", "b||c"}, result); [EOL] }
public void testSplitWorker_emptyTokens() { [EOL] String[] result = splitWorker("a||b||c||", "||", -1, true); [EOL] assertArrayEquals(new String[]{"a", "b", "c", ""}, result); [EOL] }
public void testSplitWorker_noPreserveAllTokensWithEmptyTokens() { [EOL] String[] result = splitWorker("a||b||c||", "||", -1, false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testJoin_WithNullArray() { [EOL] byte[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] }
public void testJoin_WithEmptyArray() { [EOL] byte[] array = new byte[0]; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] }
public void testJoin_WithSingleElementArray() { [EOL] byte[] array = new byte[]{65}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("65", result); [EOL] }
public void testJoin_WithMultipleElementsArray() { [EOL] byte[] array = new byte[]{65, 66, 67}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("65,66,67", result); [EOL] }
public void testJoin_CharArrayWithSeparator_NullArray() { [EOL] char[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] }
public void testJoin_CharArrayWithSeparator_EmptyArray() { [EOL] char[] array = new char[0]; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] }
public void testJoin_CharArrayWithSeparator_SingleElement() { [EOL] char[] array = new char[]{'a'}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("a", result); [EOL] }
public void testJoin_CharArrayWithSeparator_MultipleElements() { [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("a,b,c", result); [EOL] }
public void testJoinArrayNull() { [EOL] String result = StringUtils.join((byte[]) null, ',', 0, 10); [EOL] assertNull(result); [EOL] } [EOL] public void testJoinArrayEmpty() { [EOL] String result = StringUtils.join(new byte[0], ',', 0, 10); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoinArrayValid() { [EOL] byte[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 0, 3); [EOL] assertEquals("1,2,3", result); [EOL] } [EOL] public void testJoinArrayPartial() { [EOL] byte[] array = {1, 2, 3, 4, 5}; [EOL] String result = StringUtils.join(array, ',', 1, 4); [EOL] assertEquals("2,3,4", result); [EOL] } [EOL] public void testJoinArraySingleElement() { [EOL] byte[] array = {1}; [EOL] String result = StringUtils.join(array, ',', 0, 1); [EOL] assertEquals("1", result); [EOL] } [EOL] public void testJoinArrayEndIndexExceeds() { [EOL] byte[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 0, 5); [EOL] assertEquals("1,2,3", result); [EOL] } [EOL] public void testJoinArrayNegativeStartIndex() { [EOL] byte[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', -1, 2); [EOL] assertEquals("1,2", result); [EOL] } [EOL] public void testJoinArrayStartIndexGreaterThanEndIndex() { [EOL] byte[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 3, 2); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoinArrayStartIndexEqualsEndIndex() { [EOL] byte[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 2, 2); [EOL] assertEquals("", result); [EOL] }
public void testJoin_CharArrayCharIntInt_NullArray() { [EOL] String result = StringUtils.join(null, ',', 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_CharArrayCharIntInt_EmptyArray() { [EOL] char[] array = new char[0]; [EOL] String result = StringUtils.join(array, ',', 0, 0); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_CharArrayCharIntInt_ValidArray() { [EOL] char[] array = new char[] {'a', 'b', 'c'}; [EOL] String result = StringUtils.join(array, ',', 0, 3); [EOL] assertEquals("a,b,c", result); [EOL] } [EOL] public void testJoin_CharArrayCharIntInt_PartialArray() { [EOL] char[] array = new char[] {'a', 'b', 'c'}; [EOL] String result = StringUtils.join(array, ',', 1, 3); [EOL] assertEquals("b,c", result); [EOL] } [EOL] public void testJoin_CharArrayCharIntInt_SingleElement() { [EOL] char[] array = new char[] {'a', 'b', 'c'}; [EOL] String result = StringUtils.join(array, ',', 1, 2); [EOL] assertEquals("b", result); [EOL] } [EOL] public void testJoin_CharArrayCharIntInt_StartIndexGreaterThanEndIndex() { [EOL] char[] array = new char[] {'a', 'b', 'c'}; [EOL] String result = StringUtils.join(array, ',', 2, 1); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_CharArrayCharIntInt_StartIndexEqualsEndIndex() { [EOL] char[] array = new char[] {'a', 'b', 'c'}; [EOL] String result = StringUtils.join(array, ',', 1, 1); [EOL] assertEquals("", result); [EOL] }
public void testJoin_IterableNull() { [EOL] String result = StringUtils.join((Iterable<?>) null, ","); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_IterableEmpty() { [EOL] List<String> emptyList = Collections.emptyList(); [EOL] String result = StringUtils.join(emptyList, ","); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_IterableSingleElement() { [EOL] List<String> singleElementList = Collections.singletonList("one"); [EOL] String result = StringUtils.join(singleElementList, ","); [EOL] assertEquals("one", result); [EOL] } [EOL] public void testJoin_IterableMultipleElements() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] String result = StringUtils.join(list, ","); [EOL] assertEquals("one,two,three", result); [EOL] } [EOL] public void testJoin_IterableWithNullElement() { [EOL] List<String> listWithNull = Arrays.asList("one", null, "three"); [EOL] String result = StringUtils.join(listWithNull, ","); [EOL] assertEquals("one,,three", result); [EOL] } [EOL] public void testJoin_IterableWithSeparatorNull() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] String result = StringUtils.join(list, null); [EOL] assertEquals("onetwothree", result); [EOL] }

public void testRemove_NullString() { [EOL] String result = StringUtils.remove(null, "remove"); [EOL] assertNull(result); [EOL] } [EOL] public void testRemove_EmptyString() { [EOL] String result = StringUtils.remove("", "remove"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRemove_NullRemove() { [EOL] String result = StringUtils.remove("string", null); [EOL] assertEquals("string", result); [EOL] } [EOL] public void testRemove_EmptyRemove() { [EOL] String result = StringUtils.remove("string", ""); [EOL] assertEquals("string", result); [EOL] } [EOL] public void testRemove_NonEmptyStringAndRemove() { [EOL] String result = StringUtils.remove("string", "ring"); [EOL] assertEquals("st", result); [EOL] }
public void testRemove_StringWithoutRemove() { [EOL] String result = StringUtils.remove("string", "xyz"); [EOL] assertEquals("string", result); [EOL] }
public void testReplace_NullText() { [EOL] String result = StringUtils.replace(null, "searchString", "replacement"); [EOL] assertNull(result); [EOL] }
public void testReplace_EmptyText() { [EOL] String result = StringUtils.replace("", "searchString", "replacement"); [EOL] assertEquals("", result); [EOL] }
public void testReplace_NullSearchString() { [EOL] String result = StringUtils.replace("text", null, "replacement"); [EOL] assertEquals("text", result); [EOL] }
public void testReplace_NullReplacement() { [EOL] String result = StringUtils.replace("text", "searchString", null); [EOL] assertEquals("text", result); [EOL] }
public void testReplace_NonMatchingSearchString() { [EOL] String result = StringUtils.replace("text", "search", "replacement"); [EOL] assertEquals("text", result); [EOL] }
public void testReplace_MatchingSearchString() { [EOL] String result = StringUtils.replace("text", "ex", "ab"); [EOL] assertEquals("tabt", result); [EOL] }
public void testReplace_NullText() { [EOL] String result = StringUtils.replace(null, "a", "b", 1); [EOL] assertNull(result); [EOL] } [EOL] public void testReplace_EmptyText() { [EOL] String result = StringUtils.replace("", "a", "b", 1); [EOL] assertEquals("", result); [EOL] } [EOL] public void testReplace_NullSearchString() { [EOL] String result = StringUtils.replace("any", null, "b", 1); [EOL] assertEquals("any", result); [EOL] } [EOL] public void testReplace_NullReplacement() { [EOL] String result = StringUtils.replace("any", "a", null, 1); [EOL] assertEquals("any", result); [EOL] } [EOL] public void testReplace_ZeroMax() { [EOL] String result = StringUtils.replace("any", "a", "b", 0); [EOL] assertEquals("any", result); [EOL] } [EOL] public void testReplace_NegativeMax() { [EOL] String result = StringUtils.replace("any", "a", "b", -1); [EOL] assertEquals("bny", result); [EOL] } [EOL] public void testReplace_NoOccurrence() { [EOL] String result = StringUtils.replace("any", "z", "b", 2); [EOL] assertEquals("any", result); [EOL] } [EOL] public void testReplace_OneOccurrence() { [EOL] String result = StringUtils.replace("any", "a", "b", 1); [EOL] assertEquals("bny", result); [EOL] } [EOL] public void testReplace_MultipleOccurrencesLimited() { [EOL] String result = StringUtils.replace("banana", "a", "o", 2); [EOL] assertEquals("bonona", result); [EOL] } [EOL] public void testReplace_MultipleOccurrencesUnlimited() { [EOL] String result = StringUtils.replace("banana", "a", "o", -1); [EOL] assertEquals("bonono", result); [EOL] } [EOL] public void testReplace_MultipleOccurrencesMoreThanAvailable() { [EOL] String result = StringUtils.replace("banana", "a", "o", 10); [EOL] assertEquals("bonono", result); [EOL] } [EOL] public void testReplace_LongReplacement() { [EOL] String result = StringUtils.replace("banana", "a", "longreplacement", 2); [EOL] assertEquals("banlongreplacementnlongreplacement", result); [EOL] } [EOL] public void testReplace_ShortReplacement() { [EOL] String result = StringUtils.replace("banana", "a", "b", 2); [EOL] assertEquals("bnbnna", result); [EOL] } [EOL] public void testReplace_EmptySearchString() { [EOL] String result = StringUtils.replace("banana", "", "b", 2); [EOL] assertEquals("banana", result); [EOL] } [EOL] public void testReplace_EmptyReplacement() { [EOL] String result = StringUtils.replace("banana", "a", "", 2); [EOL] assertEquals("bnna", result); [EOL] } [EOL] public void testReplace_MaxInt() { [EOL] String result = StringUtils.replace("banana", "a", "o", Integer.MAX_VALUE); [EOL] assertEquals("bonono", result); [EOL] } [EOL] public void testReplace_MaxIntOccurrences() { [EOL] String result = StringUtils.replace("banana", "a", "o", Integer.MAX_VALUE); [EOL] assertEquals("bonono", result); [EOL] }
public void testReplaceEach_NullText() { [EOL] String result = StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"}); [EOL] assertNull(result); [EOL] }
public void testReplaceEach_EmptyText() { [EOL] String result = StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}); [EOL] assertEquals("", result); [EOL] }
public void testReplaceEach_NoSearchStrings() { [EOL] String result = StringUtils.replaceEach("text", null, new String[]{"b"}); [EOL] assertEquals("text", result); [EOL] }
public void testReplaceEach_NoReplacementStrings() { [EOL] String result = StringUtils.replaceEach("text", new String[]{"a"}, null); [EOL] assertEquals("text", result); [EOL] }
public void testReplaceEach_EmptySearchStrings() { [EOL] String result = StringUtils.replaceEach("text", new String[]{}, new String[]{"b"}); [EOL] assertEquals("text", result); [EOL] }
public void testReplaceEach_EmptyReplacementStrings() { [EOL] String result = StringUtils.replaceEach("text", new String[]{"a"}, new String[]{}); [EOL] assertEquals("text", result); [EOL] }
public void testReplaceEach_NonMatching() { [EOL] String result = StringUtils.replaceEach("text", new String[]{"a"}, new String[]{"b"}); [EOL] assertEquals("text", result); [EOL] }
public void testReplaceEach_SimpleReplace() { [EOL] String result = StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"A", "B"}); [EOL] assertEquals("ABc", result); [EOL] }
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL] if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL] return text; [EOL] } [EOL] if (timeToLive < 0) { [EOL] throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL] } [EOL] final int searchLength = searchList.length; [EOL] final int replacementLength = replacementList.length; [EOL] if (searchLength != replacementLength) { [EOL] throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL] } [EOL] final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL] int textIndex = -1; [EOL] int replaceIndex = -1; [EOL] int tempIndex = -1; [EOL] for (int i = 0; i < searchLength; i++) { [EOL] if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL] continue; [EOL] } [EOL] tempIndex = text.indexOf(searchList[i]); [EOL] if (tempIndex == -1) { [EOL] noMoreMatchesForReplIndex[i] = true; [EOL] } else { [EOL] if (textIndex == -1 || tempIndex < textIndex) { [EOL] textIndex = tempIndex; [EOL] replaceIndex = i; [EOL] } [EOL] } [EOL] } [EOL] if (textIndex == -1) { [EOL] return text; [EOL] } [EOL] int start = 0; [EOL] int increase = 0; [EOL] for (int i = 0; i < searchList.length; i++) { [EOL] if (searchList[i] == null || replacementList[i] == null) { [EOL] continue; [EOL] } [EOL] final int greater = replacementList[i].length() - searchList[i].length(); [EOL] if (greater > 0) { [EOL] increase += 3 * greater; [EOL] } [EOL] } [EOL] increase = Math.min(increase, text.length() / 5); [EOL] final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL] while (textIndex != -1) { [EOL] for (int i = start; i < textIndex; i++) { [EOL] buf.append(text.charAt(i)); [EOL] } [EOL] buf.append(replacementList[replaceIndex]); [EOL] start = textIndex + searchList[replaceIndex].length(); [EOL] textIndex = -1; [EOL] replaceIndex = -1; [EOL] tempIndex = -1; [EOL] for (int i = 0; i < searchLength; i++) { [EOL] if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL] continue; [EOL] } [EOL] tempIndex = text.indexOf(searchList[i], start); [EOL] if (tempIndex == -1) { [EOL] noMoreMatchesForReplIndex[i] = true; [EOL] } else { [EOL] if (textIndex == -1 || tempIndex < textIndex) { [EOL] textIndex = tempIndex; [EOL] replaceIndex = i; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] final int textLength = text.length(); [EOL] for (int i = start; i < textLength; i++) { [EOL] buf.append(text.charAt(i)); [EOL] } [EOL] final String result = buf.toString(); [EOL] if (!repeat) { [EOL] return result; [EOL] } [EOL] return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] }
public void testReplaceChars_StringIsNull() { [EOL] String input = null; [EOL] char searchChar = 'a'; [EOL] char replaceChar = 'b'; [EOL] String result = StringUtils.replaceChars(input, searchChar, replaceChar); [EOL] assertNull(result); [EOL] }
public void testReplaceChars_NoMatch() { [EOL] String input = "abcdef"; [EOL] char searchChar = 'x'; [EOL] char replaceChar = 'y'; [EOL] String result = StringUtils.replaceChars(input, searchChar, replaceChar); [EOL] assertEquals("abcdef", result); [EOL] }
public void testReplaceChars_Match() { [EOL] String input = "abcabc"; [EOL] char searchChar = 'a'; [EOL] char replaceChar = 'x'; [EOL] String result = StringUtils.replaceChars(input, searchChar, replaceChar); [EOL] assertEquals("xbcxbc", result); [EOL] }
public void testReplaceChars_StringEmpty() { [EOL] assertEquals("Empty string should return empty", "", StringUtils.replaceChars("", "abc", "def")); [EOL] } [EOL] public void testReplaceChars_StringNull() { [EOL] assertNull("Null string should return null", StringUtils.replaceChars(null, "abc", "def")); [EOL] } [EOL] public void testReplaceChars_SearchCharsEmpty() { [EOL] assertEquals("Empty searchChars should return the original string", "original", StringUtils.replaceChars("original", "", "def")); [EOL] } [EOL] public void testReplaceChars_SearchCharsNull() { [EOL] assertEquals("Null searchChars should return the original string", "original", StringUtils.replaceChars("original", null, "def")); [EOL] } [EOL] public void testReplaceChars_ReplaceCharsNull() { [EOL] assertEquals("Null replaceChars should remove the searchChars", "origil", StringUtils.replaceChars("original", "na", null)); [EOL] } [EOL] public void testReplaceChars_NoCharsToReplace() { [EOL] assertEquals("No matching chars should return the original string", "original", StringUtils.replaceChars("original", "xyz", "abc")); [EOL] } [EOL] public void testReplaceChars_ReplaceSingleChar() { [EOL] assertEquals("Replace single char", "jriginal", StringUtils.replaceChars("original", "o", "j")); [EOL] } [EOL] public void testReplaceChars_ReplaceMultipleChars() { [EOL] assertEquals("Replace multiple chars", "jriginjl", StringUtils.replaceChars("original", "oa", "ji")); [EOL] } [EOL] public void testReplaceChars_ReplaceWithLongerString() { [EOL] assertEquals("Replace with longer string", "jrigjnal", StringUtils.replaceChars("original", "oa", "jix")); [EOL] } [EOL] public void testReplaceChars_ReplaceWithShorterString() { [EOL] assertEquals("Replace with shorter string", "jrig", StringUtils.replaceChars("original", "oal", "ji")); [EOL] }
public void testReplaceChars_ReplaceWithEmptyString() { [EOL] assertEquals("Replace with empty string should remove searchChars", "origin", StringUtils.replaceChars("original", "al", "")); [EOL] }
public void testRepeat_NullString() { [EOL] String result = StringUtils.repeat(null, 2); [EOL] assertNull(result); [EOL] }
public void testRepeat_NegativeRepeat() { [EOL] String result = StringUtils.repeat("abc", -1); [EOL] assertEquals("", result); [EOL] }
public void testRepeat_ZeroRepeat() { [EOL] String result = StringUtils.repeat("abc", 0); [EOL] assertEquals("", result); [EOL] }
public void testRepeat_OneRepeat() { [EOL] String result = StringUtils.repeat("abc", 1); [EOL] assertEquals("abc", result); [EOL] }
public void testRepeat_EmptyString() { [EOL] String result = StringUtils.repeat("", 3); [EOL] assertEquals("", result); [EOL] }
public void testRepeat_SingleCharacterString() { [EOL] String result = StringUtils.repeat("a", 3); [EOL] assertEquals("aaa", result); [EOL] }
public void testRepeat_TwoCharacterString() { [EOL] String result = StringUtils.repeat("ab", 3); [EOL] assertEquals("ababab", result); [EOL] }
public void testRepeat_LongString() { [EOL] String result = StringUtils.repeat("abc", 3); [EOL] assertEquals("abcabcabc", result); [EOL] }
public void testRightPad_NullString() { [EOL] String padded = StringUtils.rightPad(null, 5); [EOL] assertNull(padded); [EOL] }
public void testRightPad_EmptyString() { [EOL] String padded = StringUtils.rightPad("", 5); [EOL] assertEquals("     ", padded); [EOL] }
public void testRightPad_NoPaddingNeeded() { [EOL] String str = "abc"; [EOL] String padded = StringUtils.rightPad(str, 3); [EOL] assertSame(str, padded); [EOL] }
public void testRightPad_WithPadding() { [EOL] String padded = StringUtils.rightPad("bat", 5); [EOL] assertEquals("bat  ", padded); [EOL] }
public void testRightPad_WithNegativeSize() { [EOL] String padded = StringUtils.rightPad("bat", -1); [EOL] assertEquals("bat", padded); [EOL] }
public void testRightPad_NullString() { [EOL] String padded = StringUtils.rightPad(null, 5, ' '); [EOL] assertNull(padded); [EOL] }
public void testRightPad_NoPaddingNeeded() { [EOL] String original = "abc"; [EOL] String padded = StringUtils.rightPad(original, 3, ' '); [EOL] assertSame("No padding should be added", original, padded); [EOL] }
public void testRightPad_UsualCase() { [EOL] String original = "abc"; [EOL] String padded = StringUtils.rightPad(original, 5, 'x'); [EOL] assertEquals("abcxx", padded); [EOL] }
public void testRightPad_PadLimitExceeded() { [EOL] String original = "abc"; [EOL] String padded = StringUtils.rightPad(original, 100000, 'x'); [EOL] assertTrue("Should return a right padded string", padded.length() == 100000); [EOL] }
public void testRightPad_NullString() { [EOL] assertNull(StringUtils.rightPad(null, 5, " ")); [EOL] } [EOL] public void testRightPad_EmptyPadString() { [EOL] assertEquals("abc  ", StringUtils.rightPad("abc", 5, "")); [EOL] } [EOL] public void testRightPad_PadWithSpaces() { [EOL] assertEquals("abc  ", StringUtils.rightPad("abc", 5, " ")); [EOL] } [EOL] public void testRightPad_PadWithSingleChar() { [EOL] assertEquals("abcxx", StringUtils.rightPad("abc", 5, "x")); [EOL] } [EOL] public void testRightPad_PadWithMultipleChars() { [EOL] assertEquals("abcxyabc", StringUtils.rightPad("abc", 8, "xy")); [EOL] } [EOL] public void testRightPad_NoPaddingNeeded() { [EOL] assertEquals("abc", StringUtils.rightPad("abc", 3, " ")); [EOL] } [EOL] public void testRightPad_NegativePadLength() { [EOL] assertEquals("abc", StringUtils.rightPad("abc", -1, " ")); [EOL] } [EOL] public void testRightPad_PadLimitBoundary() { [EOL] String padStr = StringUtils.repeat('x', StringUtils.PAD_LIMIT); [EOL] String expected = "abc" + padStr; [EOL] assertEquals(expected, StringUtils.rightPad("abc", expected.length(), "x")); [EOL] } [EOL] public void testRightPad_LongPadString() { [EOL] String padStr = StringUtils.repeat('x', StringUtils.PAD_LIMIT + 1); [EOL] String expected = "abc" + padStr; [EOL] assertEquals(expected, StringUtils.rightPad("abc", expected.length(), "x")); [EOL] }

public void testLeftPad_NullString() { [EOL] String padded = StringUtils.leftPad(null, 5, "*"); [EOL] assertNull(padded); [EOL] }
public void testLeftPad_EmptyPadString() { [EOL] String padded = StringUtils.leftPad("abc", 5, ""); [EOL] assertEquals("  abc", padded); [EOL] }
public void testLeftPad_Normal() { [EOL] String padded = StringUtils.leftPad("abc", 5, "*"); [EOL] assertEquals("**abc", padded); [EOL] }
public void testLeftPad_NoPaddingNeeded() { [EOL] String padded = StringUtils.leftPad("abc", 3, "*"); [EOL] assertEquals("abc", padded); [EOL] }
public void testLeftPad_SingleCharPad() { [EOL] String padded = StringUtils.leftPad("abc", 5, "#"); [EOL] assertEquals("##abc", padded); [EOL] }
public void testLeftPad_PadLengthEqualsPads() { [EOL] String padded = StringUtils.leftPad("abc", 6, "123"); [EOL] assertEquals("123abc", padded); [EOL] }
public void testLeftPad_PadLengthLessThanPads() { [EOL] String padded = StringUtils.leftPad("abc", 5, "12345"); [EOL] assertEquals("12abc", padded); [EOL] }
public void testLeftPad_PadLengthMoreThanPads() { [EOL] String padded = StringUtils.leftPad("abc", 10, "123"); [EOL] assertEquals("1231231abc", padded); [EOL] }
public void testCenter_NullStr() { [EOL] String centered = StringUtils.center(null, 10, "*"); [EOL] assertNull(centered); [EOL] }
public void testCenter_NegativeSize() { [EOL] String centered = StringUtils.center("abc", -1, "*"); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_ZeroSize() { [EOL] String centered = StringUtils.center("abc", 0, "*"); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_EmptyPadStr() { [EOL] String centered = StringUtils.center("abc", 5, ""); [EOL] assertEquals(" abc ", centered); [EOL] }
public void testCenter_NullPadStr() { [EOL] String centered = StringUtils.center("abc", 5, null); [EOL] assertEquals(" abc ", centered); [EOL] }
public void testCenter_NoPaddingNeeded() { [EOL] String centered = StringUtils.center("abc", 3, "*"); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_PaddingNeeded() { [EOL] String centered = StringUtils.center("abc", 5, "*"); [EOL] assertEquals("*abc*", centered); [EOL] }
public void testCenter_PaddingWithLongPadStr() { [EOL] String centered = StringUtils.center("abc", 7, "de"); [EOL] assertEquals("dedabcd", centered); [EOL] }
public void testIsAlpha_NullInput() { [EOL] boolean result = StringUtils.isAlpha(null); [EOL] assertFalse(result); [EOL] }
public void testIsAlpha_EmptyString() { [EOL] boolean result = StringUtils.isAlpha(""); [EOL] assertFalse(result); [EOL] }
public void testIsAlpha_AlphaString() { [EOL] boolean result = StringUtils.isAlpha("abc"); [EOL] assertTrue(result); [EOL] }
public void testIsAlpha_NonAlphaString() { [EOL] boolean result = StringUtils.isAlpha("abc123"); [EOL] assertFalse(result); [EOL] }
public void testIsAlpha_SpecialCharsString() { [EOL] boolean result = StringUtils.isAlpha("abc!"); [EOL] assertFalse(result); [EOL] }
public void testIsAsciiPrintable_NullInput() { [EOL] boolean result = StringUtils.isAsciiPrintable(null); [EOL] assertFalse(result); [EOL] }
public void testIsAsciiPrintable_EmptyString() { [EOL] boolean result = StringUtils.isAsciiPrintable(""); [EOL] assertTrue(result); [EOL] }
public void testIsAsciiPrintable_AsciiPrintableString() { [EOL] boolean result = StringUtils.isAsciiPrintable("abc123"); [EOL] assertTrue(result); [EOL] }
public void testIsAsciiPrintable_NonAsciiPrintableString() { [EOL] boolean result = StringUtils.isAsciiPrintable("abc123\u007F"); [EOL] assertFalse(result); [EOL] }
public void testDefaultStringWithNullInput() { [EOL] String result = StringUtils.defaultString(null); [EOL] assertEquals("", result); [EOL] }
public void testDefaultStringWithNonNullInput() { [EOL] String input = "test"; [EOL] String result = StringUtils.defaultString(input); [EOL] assertEquals("test", result); [EOL] }
public void testReverse_NullInput() { [EOL] String input = null; [EOL] String result = StringUtils.reverse(input); [EOL] assertNull(result); [EOL] }
public void testReverse_EmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.reverse(input); [EOL] assertEquals("", result); [EOL] }
public void testReverse_SingleCharacter() { [EOL] String input = "a"; [EOL] String result = StringUtils.reverse(input); [EOL] assertEquals("a", result); [EOL] }
public void testReverse_MultipleCharacters() { [EOL] String input = "abcd"; [EOL] String result = StringUtils.reverse(input); [EOL] assertEquals("dcba", result); [EOL] }
public void testDifference_BothStringsNull() { [EOL] String result = StringUtils.difference(null, null); [EOL] assertNull(result); [EOL] }
public void testDifference_FirstStringNull() { [EOL] String result = StringUtils.difference(null, "abc"); [EOL] assertEquals("abc", result); [EOL] }
public void testDifference_SecondStringNull() { [EOL] String result = StringUtils.difference("abc", null); [EOL] assertEquals("abc", result); [EOL] }
public void testDifference_NoDifference() { [EOL] String result = StringUtils.difference("abc", "abc"); [EOL] assertEquals("", result); [EOL] }
public void testDifference_DifferenceAtStart() { [EOL] String result = StringUtils.difference("abc", "dbc"); [EOL] assertEquals("dbc", result); [EOL] }
public void testDifference_DifferenceInMiddle() { [EOL] String result = StringUtils.difference("abc", "adc"); [EOL] assertEquals("dc", result); [EOL] }
public void testDifference_DifferenceAtEnd() { [EOL] String result = StringUtils.difference("ab", "abc"); [EOL] assertEquals("c", result); [EOL] }
public void testIndexOfDifference_SameCharSequences() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = "abc"; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOfDifference_FirstCharSequenceNull() { [EOL] CharSequence cs1 = null; [EOL] CharSequence cs2 = "abc"; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_SecondCharSequenceNull() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = null; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_DifferentCharSequences() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = "abd"; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOfDifference_OneCharSequenceShorter() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = "ab"; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOfDifference_EmptyAndNonEmptyCharSequence() { [EOL] CharSequence cs1 = ""; [EOL] CharSequence cs2 = "abc"; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_NonEmptyAndEmptyCharSequence() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = ""; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_BothCharSequencesEmpty() { [EOL] CharSequence cs1 = ""; [EOL] CharSequence cs2 = ""; [EOL] int result = StringUtils.indexOfDifference(cs1, cs2); [EOL] assertEquals(-1, result); [EOL] }
public void testPrependIfMissingWithNullStr() { [EOL] String result = StringUtils.prependIfMissing(null, "prefix"); [EOL] assertNull(result); [EOL] }
public void testPrependIfMissingWithEmptyStr() { [EOL] String result = StringUtils.prependIfMissing("", "prefix"); [EOL] assertEquals("prefix", result); [EOL] }
public void testPrependIfMissingWithNullPrefix() { [EOL] String result = StringUtils.prependIfMissing("str", null); [EOL] assertEquals("str", result); [EOL] }
public void testPrependIfMissingWithExistingPrefix() { [EOL] String result = StringUtils.prependIfMissing("prefixStr", "prefix"); [EOL] assertEquals("prefixStr", result); [EOL] }
public void testPrependIfMissingWithNonExistingPrefix() { [EOL] String result = StringUtils.prependIfMissing("Str", "prefix"); [EOL] assertEquals("prefixStr", result); [EOL] }
public void testPrependIfMissingWithMultiplePrefixes() { [EOL] String result = StringUtils.prependIfMissing("Str", "prefix", "pre", "px"); [EOL] assertEquals("prefixStr", result); [EOL] }
public void testPrependIfMissingWithExistingMultiplePrefixes() { [EOL] String result = StringUtils.prependIfMissing("preStr", "prefix", "pre", "px"); [EOL] assertEquals("preStr", result); [EOL] }
public void testMutableDoubleConstructor() { [EOL] MutableDouble md = new MutableDouble(); [EOL] assertNotNull(md); [EOL] assertEquals(0.0d, md.doubleValue(), 0.0d); [EOL] }
public void testMutableDoubleConstructor() { [EOL] double expectedValue = 10.0; [EOL] MutableDouble mutableDouble = new MutableDouble(expectedValue); [EOL] assertEquals(expectedValue, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testMutableDoubleWithNull() { [EOL] try { [EOL] new MutableDouble(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableDoubleWithDoubleObject() { [EOL] Double doubleValue = 1.0; [EOL] MutableDouble mutableDouble = new MutableDouble(doubleValue); [EOL] assertEquals(1.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testMutableDoubleWithIntegerObject() { [EOL] Integer integerValue = 1; [EOL] MutableDouble mutableDouble = new MutableDouble(integerValue); [EOL] assertEquals(1.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testMutableDoubleWithValidString() { [EOL] String validString = "10.5"; [EOL] MutableDouble mutableDouble = new MutableDouble(validString); [EOL] assertEquals(10.5, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testMutableDoubleWithInvalidString() { [EOL] String invalidString = "invalid"; [EOL] try { [EOL] new MutableDouble(invalidString); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetValueWhenValueIsSet() { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = 5.0; // Assuming 'value' is a field of type double [EOL] Double result = instance.getValue(); [EOL] assertEquals(Double.valueOf(5.0), result); [EOL] }
public void testSetValue() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name [EOL] double expectedValue = 10.0; [EOL] instance.setValue(expectedValue); [EOL] double actualValue = instance.getValue(); // Assuming there's a method to retrieve the value [EOL] assertEquals(expectedValue, actualValue, 0.0); [EOL] }
public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL] int max = longest; [EOL] if (index + longest > input.length()) { [EOL] max = input.length() - index; [EOL] } [EOL] for (int i = max; i >= shortest; i--) { [EOL] final CharSequence subSeq = input.subSequence(index, index + i); [EOL] final CharSequence result = lookupMap.get(subSeq.toString()); [EOL] if (result != null) { [EOL] out.write(result.toString()); [EOL] return i; [EOL] } [EOL] } [EOL] return 0; [EOL] }
static Map<Object, Object> getRegistry() { [EOL] return REGISTRY.get(); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testIsRegisteredWithNonNullRegistryAndKeyPresent() { [EOL] ToStringStyle.register("key"); [EOL] boolean result = ToStringStyle.isRegistered("key"); [EOL] assertTrue(result); [EOL] ToStringStyle.unregister("key"); [EOL] }
public void testIsRegisteredWithNonNullRegistryAndKeyNotPresent() { [EOL] ToStringStyle.unregister("key"); [EOL] boolean result = ToStringStyle.isRegistered("key"); [EOL] assertFalse(result); [EOL] }
public void testIsRegisteredWithNullRegistry() { [EOL] ToStringStyle.REGISTRY.remove(); [EOL] boolean result = ToStringStyle.isRegistered("key"); [EOL] assertFalse(result); [EOL] }
static void register(final Object value) { [EOL] if (value != null) { [EOL] final Map<Object, Object> m = getRegistry(); [EOL] if (m == null) { [EOL] REGISTRY.set(new WeakHashMap<Object, Object>()); [EOL] } [EOL] getRegistry().put(value, null); [EOL] } [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
static void unregister(final Object value) { [EOL] if (value != null) { [EOL] final Map<Object, Object> m = getRegistry(); [EOL] if (m != null) { [EOL] m.remove(value); [EOL] if (m.isEmpty()) { [EOL] REGISTRY.remove(); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected ToStringStyle() { [EOL] super(); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendStartWithNonNullObject() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendStart(buffer, object); [EOL] assertNotNull(buffer.toString()); [EOL] assertTrue(buffer.toString().contains(object.getClass().getName())); [EOL] assertTrue(buffer.toString().contains(Integer.toHexString(System.identityHashCode(object)))); [EOL] }
public void testAppendStartWithFieldSeparatorAtStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldSeparatorAtStart(true); [EOL] style.appendStart(buffer, object); [EOL] assertNotNull(buffer.toString()); [EOL] assertTrue(buffer.toString().startsWith(style.getFieldSeparator())); [EOL] }
public void testAppendStartWithNullObject() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendStart(buffer, null); [EOL] assertEquals(0, buffer.length()); [EOL] }
public void testAppendEndWithFieldSeparatorAtEndFalse() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldSeparatorAtEnd(false); [EOL] style.appendEnd(buffer, object); [EOL] assertTrue(buffer.length() > 0); // Assuming removeLastFieldSeparator and appendContentEnd do some modifications [EOL] assertFalse(ToStringStyle.isRegistered(object)); // Assuming unregister works correctly [EOL] }
public void testAppendEndWithFieldSeparatorAtEndTrue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldSeparatorAtEnd(true); [EOL] style.appendEnd(buffer, object); [EOL] assertTrue(buffer.length() > 0); // Assuming appendContentEnd does some modifications [EOL] assertFalse(ToStringStyle.isRegistered(object)); // Assuming unregister works correctly [EOL] }
protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] final int len = buffer.length(); [EOL] final int sepLen = fieldSeparator.length(); [EOL] if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL] boolean match = true; [EOL] for (int i = 0; i < sepLen; i++) { [EOL] if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL] match = false; [EOL] break; [EOL] } [EOL] } [EOL] if (match) { [EOL] buffer.setLength(len - sepLen); [EOL] } [EOL] } [EOL] }
public void testAppendWithNullValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] Object value = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, value, fullDetail); [EOL] } [EOL] public void testAppendWithNonNullValueFullDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] Object value = new Object(); [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, value, fullDetail); [EOL] } [EOL] public void testAppendWithNonNullValueNotFullDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] Object value = new Object(); [EOL] Boolean fullDetail = false; [EOL] append(buffer, fieldName, value, fullDetail); [EOL] }
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL] appendCyclicObject(buffer, fieldName, value); [EOL] return; [EOL] } [EOL] register(value); [EOL] try { [EOL] if (value instanceof Collection<?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Collection<?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL] } [EOL] } else if (value instanceof Map<?, ?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL] } [EOL] } else if (value instanceof long[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (long[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (long[]) value); [EOL] } [EOL] } else if (value instanceof int[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (int[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (int[]) value); [EOL] } [EOL] } else if (value instanceof short[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (short[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (short[]) value); [EOL] } [EOL] } else if (value instanceof byte[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (byte[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (byte[]) value); [EOL] } [EOL] } else if (value instanceof char[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (char[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (char[]) value); [EOL] } [EOL] } else if (value instanceof double[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (double[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (double[]) value); [EOL] } [EOL] } else if (value instanceof float[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (float[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (float[]) value); [EOL] } [EOL] } else if (value instanceof boolean[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (boolean[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (boolean[]) value); [EOL] } [EOL] } else if (value.getClass().isArray()) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Object[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (Object[]) value); [EOL] } [EOL] } else { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, value); [EOL] } [EOL] } [EOL] } finally { [EOL] unregister(value); [EOL] } [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL] buffer.append(coll); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL] buffer.append(map); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}"];
protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] buffer.append(summaryObjectStartText); [EOL] buffer.append(getShortClassName(value.getClass())); [EOL] buffer.append(summaryObjectEndText); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL] buffer.append(value); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] appendSummarySize(buffer, fieldName, array.length); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL] appendFieldStart(buffer, fieldName); [EOL] if (array == null) { [EOL] appendNullText(buffer, fieldName); [EOL] } else if (isFullDetail(fullDetail)) { [EOL] appendDetail(buffer, fieldName, array); [EOL] } else { [EOL] appendSummary(buffer, fieldName, array); [EOL] } [EOL] appendFieldEnd(buffer, fieldName); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendDetailWithEmptyArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "arrayField"; [EOL] boolean[] array = new boolean[0]; [EOL] appendDetail(buffer, fieldName, array); [EOL] assertEquals("arrayField={}", buffer.toString()); [EOL] } [EOL] public void testAppendDetailWithNonEmptyArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "arrayField"; [EOL] boolean[] array = {true, false, true}; [EOL] appendDetail(buffer, fieldName, array); [EOL] assertEquals("arrayField={true,false,true}", buffer.toString()); [EOL] } [EOL] public void testAppendDetailWithNullArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "arrayField"; [EOL] boolean[] array = null; [EOL] appendDetail(buffer, fieldName, array); [EOL] assertEquals("arrayField=<null>", buffer.toString()); [EOL] }
public void testAppendClassNameWithNonNullObjectAndUseClassNameTrueAndUseShortClassNameTrue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] setUseClassName(true); [EOL] setUseShortClassName(true); [EOL] appendClassName(buffer, object); [EOL] assertTrue(buffer.toString().equals(getShortClassName(object.getClass()))); [EOL] } [EOL] public void testAppendClassNameWithNonNullObjectAndUseClassNameTrueAndUseShortClassNameFalse() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] setUseClassName(true); [EOL] setUseShortClassName(false); [EOL] appendClassName(buffer, object); [EOL] assertTrue(buffer.toString().equals(object.getClass().getName())); [EOL] } [EOL] public void testAppendClassNameWithNullObject() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = null; [EOL] setUseClassName(true); [EOL] appendClassName(buffer, object); [EOL] assertTrue(buffer.length() == 0); [EOL] } [EOL] public void testAppendClassNameWithNonNullObjectAndUseClassNameFalse() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] setUseClassName(false); [EOL] appendClassName(buffer, object); [EOL] assertTrue(buffer.length() == 0); [EOL] }

protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL] if (this.isUseIdentityHashCode() && object != null) { [EOL] register(object); [EOL] buffer.append('@'); [EOL] buffer.append(Integer.toHexString(System.identityHashCode(object))); [EOL] } [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendContentStart(final StringBuffer buffer) { [EOL] buffer.append(contentStart); [EOL] }
protected void appendContentEnd(final StringBuffer buffer) { [EOL] buffer.append(contentEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL] buffer.append(nullText); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendFieldSeparator(final StringBuffer buffer) { [EOL] buffer.append(fieldSeparator); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] if (useFieldNames && fieldName != null) { [EOL] buffer.append(fieldName); [EOL] buffer.append(fieldNameValueSeparator); [EOL] } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}"];
protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL] appendFieldSeparator(buffer); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendSummarySize() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "sizeField"; [EOL] int size = 10; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSizeStartText("<size="); [EOL] style.setSizeEndText(">"); [EOL] style.appendSummarySize(buffer, fieldName, size); [EOL] assertEquals("<size=10>", buffer.toString()); [EOL] }
public void testAppendSummarySizeWithEmptyFieldName() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = ""; [EOL] int size = 10; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSizeStartText("<size="); [EOL] style.setSizeEndText(">"); [EOL] style.appendSummarySize(buffer, fieldName, size); [EOL] assertEquals("<size=10>", buffer.toString()); [EOL] }
public void testAppendSummarySizeWithNegativeSize() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "sizeField"; [EOL] int size = -1; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSizeStartText("<size="); [EOL] style.setSizeEndText(">"); [EOL] style.appendSummarySize(buffer, fieldName, size); [EOL] assertEquals("<size=-1>", buffer.toString()); [EOL] }
protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL] if (fullDetailRequest == null) { [EOL] return defaultFullDetail; [EOL] } [EOL] return fullDetailRequest.booleanValue(); [EOL] }
protected String getShortClassName(final Class<?> cls) { [EOL] return ClassUtils.getShortClassName(cls); [EOL] } [EOL] protected ToStringStyle() { [EOL] } [EOL] DefaultToStringStyle() { [EOL] } [EOL] NoFieldNameToStringStyle() { [EOL] } [EOL] ShortPrefixToStringStyle() { [EOL] } [EOL] SimpleToStringStyle() { [EOL] } [EOL] MultiLineToStringStyle() { [EOL] } [EOL] static Map<Object, Object> getRegistry() { [EOL] } [EOL] static boolean isRegistered(final Object value) { [EOL] } [EOL] static void register(final Object value) { [EOL] } [EOL] static void unregister(final Object value) { [EOL] } [EOL] public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL] } [EOL] public void appendToString(final StringBuffer buffer, final String toString) { [EOL] } [EOL] public void appendStart(final StringBuffer buffer, final Object object) { [EOL] } [EOL] public void appendEnd(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) { [EOL] } [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] } [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendContentStart(final StringBuffer buffer) { [EOL] } [EOL] protected void appendContentEnd(final StringBuffer buffer) { [EOL] } [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL] } [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL] } [EOL] protected String getShortClassName(final Class<?> cls) { [EOL] } [EOL] protected boolean isUseClassName() { [EOL] } [EOL] protected void setUseClassName(final boolean useClassName) { [EOL] } [EOL] protected boolean isUseShortClassName() { [EOL] } [EOL] protected void setUseShortClassName(final boolean useShortClassName) { [EOL] } [EOL] protected boolean isUseIdentityHashCode() { [EOL] } [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL] } [EOL] protected boolean isUseFieldNames() { [EOL] } [EOL] protected void setUseFieldNames(final boolean useFieldNames) { [EOL] } [EOL] protected boolean isDefaultFullDetail() { [EOL] } [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL] } [EOL] protected boolean isArrayContentDetail() { [EOL] } [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL] } [EOL] protected String getArrayStart() { [EOL] } [EOL] protected void setArrayStart(String arrayStart) { [EOL] } [EOL] protected String getArrayEnd() { [EOL] } [EOL] protected void setArrayEnd(String arrayEnd) { [EOL] } [EOL] protected String getArraySeparator() { [EOL] } [EOL] protected void setArraySeparator(String arraySeparator) { [EOL] } [EOL] protected String getContentStart() { [EOL] } [EOL] protected void setContentStart(String contentStart) { [EOL] } [EOL] protected String getContentEnd() { [EOL] } [EOL] protected void setContentEnd(String contentEnd) { [EOL] } [EOL] protected String getFieldNameValueSeparator() { [EOL] } [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL] } [EOL] protected String getFieldSeparator() { [EOL] } [EOL] protected void setFieldSeparator(String fieldSeparator) { [EOL] } [EOL] protected boolean isFieldSeparatorAtStart() { [EOL] } [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL] } [EOL] protected boolean isFieldSeparatorAtEnd() { [EOL] } [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { [EOL] } [EOL] protected String getNullText() { [EOL] } [EOL] protected void setNullText(String nullText) { [EOL] } [EOL] protected String getSizeStartText() { [EOL] } [EOL] protected void setSizeStartText(String sizeStartText) { [EOL] } [EOL] protected String getSizeEndText() { [EOL] } [EOL] protected void setSizeEndText(String sizeEndText) { [EOL] } [EOL] protected String getSummaryObjectStartText() { [EOL] } [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText) { [EOL] } [EOL] protected String getSummaryObjectEndText() { [EOL] } [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
```java [EOL] protected boolean isUseIdentityHashCode() { [EOL] return useIdentityHashCode; [EOL] } [EOL] protected ToStringStyle() { [EOL] } [EOL] DefaultToStringStyle() { [EOL] } [EOL] NoFieldNameToStringStyle() { [EOL] } [EOL] ShortPrefixToStringStyle() { [EOL] } [EOL] SimpleToStringStyle() { [EOL] } [EOL] MultiLineToStringStyle() { [EOL] } [EOL] static Map<Object, Object> getRegistry() { [EOL] } [EOL] static boolean isRegistered(final Object value) { [EOL] } [EOL] static void register(final Object value) { [EOL] } [EOL] static void unregister(final Object value) { [EOL] } [EOL] public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL] } [EOL] public void appendToString(final StringBuffer buffer, final String toString) { [EOL] } [EOL] public void appendStart(final StringBuffer buffer, final Object object) { [EOL] } [EOL] public void appendEnd(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) { [EOL] } [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] } [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendContentStart(final StringBuffer buffer) { [EOL] } [EOL] protected void appendContentEnd(final StringBuffer buffer) { [EOL] } [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL] } [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL] } [EOL] protected String getShortClassName(final Class<?> cls) { [EOL] } [EOL] protected boolean isUseClassName() { [EOL] } [EOL] protected void setUseClassName(final boolean useClassName) { [EOL] } [EOL] protected boolean isUseShortClassName() { [EOL] } [EOL] protected void setUseShortClassName(final boolean useShortClassName) { [EOL] } [EOL] protected boolean isUseFieldNames() { [EOL] } [EOL] protected void setUseFieldNames(final boolean useFieldNames) { [EOL] } [EOL] protected boolean isDefaultFullDetail() { [EOL] } [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL] } [EOL] protected boolean isArrayContentDetail() { [EOL] } [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL] } [EOL] protected String getArrayStart() { [EOL] } [EOL] protected void setArrayStart(String arrayStart) { [EOL] } [EOL] protected String getArrayEnd() { [EOL] } [EOL] protected void setArrayEnd(String arrayEnd) { [EOL] } [EOL] protected String getArraySeparator() { [EOL] } [EOL] protected void setArraySeparator(String arraySeparator) { [EOL] } [EOL] protected String getContentStart() { [EOL] } [EOL] protected void setContentStart(String contentStart) { [EOL] } [EOL] protected String getContentEnd() { [EOL] } [EOL] protected void setContentEnd(String contentEnd) { [EOL] } [EOL] protected String getFieldNameValueSeparator() { [EOL] } [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL] } [EOL] protected String getFieldSeparator() { [EOL] } [EOL] protected void setFieldSeparator(String fieldSeparator) { [EOL] } [EOL] protected boolean isFieldSeparatorAtStart() { [EOL] } [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL] } [EOL] protected boolean isFieldSeparatorAtEnd() { [EOL] } [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { [EOL] } [EOL] protected String getNullText() { [EOL] } [EOL] protected void setNullText(String nullText) { [EOL] } [EOL] protected String getSizeStartText() { [EOL] } [EOL] protected void setSizeStartText(String sizeStartText) { [EOL] } [EOL] protected String getSizeEndText() { [EOL] } [EOL] protected void setSizeEndText(String sizeEndText) { [EOL] } [EOL] protected String getSummaryObjectStartText() { [EOL] } [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText) { [EOL] } [EOL] protected String getSummaryObjectEndText() { [EOL] } [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional
protected String getSummaryObjectEndText() { [EOL] return summaryObjectEndText; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetSummaryObjectEndText_NullInput() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSummaryObjectEndText(null); [EOL] assertEquals("", style.getSummaryObjectEndText()); [EOL] } [EOL] public void testSetSummaryObjectEndText_NonNullInput() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSummaryObjectEndText("]"); [EOL] assertEquals("]", style.getSummaryObjectEndText()); [EOL] }
public void testGet_WhenReferenceIsNull_ShouldInitialize() throws ConcurrentException { [EOL] final AtomicReference<Object> reference = new AtomicReference<>(null); [EOL] final Object expected = new Object(); [EOL] LazyInitializer<Object> lazyInitializer = new LazyInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() { [EOL] return expected; [EOL] } [EOL] }; [EOL] Object result = lazyInitializer.get(); [EOL] assertEquals(expected, result); [EOL] assertEquals(expected, reference.get()); [EOL] }
public void testGet_WhenReferenceIsNotNull_ShouldReturnExisting() throws ConcurrentException { [EOL] final Object existing = new Object(); [EOL] final AtomicReference<Object> reference = new AtomicReference<>(existing); [EOL] LazyInitializer<Object> lazyInitializer = new LazyInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() { [EOL] fail("Should not initialize"); [EOL] return null; [EOL] } [EOL] }; [EOL] Object result = lazyInitializer.get(); [EOL] assertEquals(existing, result); [EOL] }
public void testGet_WhenReferenceIsUpdatedConcurrently_ShouldReturnNewReference() throws ConcurrentException { [EOL] final AtomicReference<Object> reference = new AtomicReference<>(null); [EOL] final Object first = new Object(); [EOL] final Object second = new Object(); [EOL] LazyInitializer<Object> lazyInitializer = new LazyInitializer<Object>() { [EOL] private boolean initialized = false; [EOL] @Override [EOL] protected Object initialize() { [EOL] if (!initialized) { [EOL] initialized = true; [EOL] reference.set(second); [EOL] } [EOL] return first; [EOL] } [EOL] }; [EOL] Object result = lazyInitializer.get(); [EOL] assertNotEquals(first, result); [EOL] assertEquals(second, result); [EOL] }
public void testHexDigitMsb0ToInt_0() { [EOL] int result = ClassName.hexDigitMsb0ToInt('0'); [EOL] assertEquals(0x0, result); [EOL] }
public void testHexDigitMsb0ToInt_1() { [EOL] int result = ClassName.hexDigitMsb0ToInt('1'); [EOL] assertEquals(0x8, result); [EOL] }
public void testHexDigitMsb0ToInt_2() { [EOL] int result = ClassName.hexDigitMsb0ToInt('2'); [EOL] assertEquals(0x4, result); [EOL] }
public void testHexDigitMsb0ToInt_3() { [EOL] int result = ClassName.hexDigitMsb0ToInt('3'); [EOL] assertEquals(0xC, result); [EOL] }
public void testHexDigitMsb0ToInt_4() { [EOL] int result = ClassName.hexDigitMsb0ToInt('4'); [EOL] assertEquals(0x2, result); [EOL] }
public void testHexDigitMsb0ToInt_5() { [EOL] int result = ClassName.hexDigitMsb0ToInt('5'); [EOL] assertEquals(0xA, result); [EOL] }
public void testHexDigitMsb0ToInt_6() { [EOL] int result = ClassName.hexDigitMsb0ToInt('6'); [EOL] assertEquals(0x6, result); [EOL] }
public void testHexDigitMsb0ToInt_7() { [EOL] int result = ClassName.hexDigitMsb0ToInt('7'); [EOL] assertEquals(0xE, result); [EOL] }
public void testHexDigitMsb0ToInt_8() { [EOL] int result = ClassName.hexDigitMsb0ToInt('8'); [EOL] assertEquals(0x1, result); [EOL] }
public void testHexDigitMsb0ToInt_9() { [EOL] int result = ClassName.hexDigitMsb0ToInt('9'); [EOL] assertEquals(0x9, result); [EOL] }
public void testHexDigitMsb0ToInt_A() { [EOL] int result = ClassName.hexDigitMsb0ToInt('A'); [EOL] assertEquals(0x5, result); [EOL] }
public void testHexDigitMsb0ToInt_a() { [EOL] int result = ClassName.hexDigitMsb0ToInt('a'); [EOL] assertEquals(0x5, result); [EOL] }
public void testHexDigitMsb0ToInt_B() { [EOL] int result = ClassName.hexDigitMsb0ToInt('B'); [EOL] assertEquals(0xD, result); [EOL] }
public void testHexDigitMsb0ToInt_b() { [EOL] int result = ClassName.hexDigitMsb0ToInt('b'); [EOL] assertEquals(0xD, result); [EOL] }
public void testHexDigitMsb0ToInt_C() { [EOL] int result = ClassName.hexDigitMsb0ToInt('C'); [EOL] assertEquals(0x3, result); [EOL] }
public void testHexDigitMsb0ToInt_c() { [EOL] int result = ClassName.hexDigitMsb0ToInt('c'); [EOL] assertEquals(0x3, result); [EOL] }
public void testHexDigitMsb0ToInt_D() { [EOL] int result = ClassName.hexDigitMsb0ToInt('D'); [EOL] assertEquals(0xB, result); [EOL] }
public void testHexDigitMsb0ToInt_d() { [EOL] int result = ClassName.hexDigitMsb0ToInt('d'); [EOL] assertEquals(0xB, result); [EOL] }
public void testHexDigitMsb0ToInt_E() { [EOL] int result = ClassName.hexDigitMsb0ToInt('E'); [EOL] assertEquals(0x7, result); [EOL] }
public void testHexDigitMsb0ToInt_e() { [EOL] int result = ClassName.hexDigitMsb0ToInt('e'); [EOL] assertEquals(0x7, result); [EOL] }
public void testHexDigitMsb0ToInt_F() { [EOL] int result = ClassName.hexDigitMsb0ToInt('F'); [EOL] assertEquals(0xF, result); [EOL] }
public void testHexDigitMsb0ToInt_f() { [EOL] int result = ClassName.hexDigitMsb0ToInt('f'); [EOL] assertEquals(0xF, result); [EOL] }
public void testHexDigitMsb0ToInt_Invalid() { [EOL] try { [EOL] ClassName.hexDigitMsb0ToInt('g'); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Cannot interpret 'g' as a hexadecimal digit", e.getMessage()); [EOL] } [EOL] }
public void testHexDigitToBinary_0() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('0'); [EOL] assertArrayEquals(new boolean[]{false, false, false, false}, result); [EOL] }
public void testHexDigitToBinary_1() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('1'); [EOL] assertArrayEquals(new boolean[]{true, false, false, false}, result); [EOL] }
public void testHexDigitToBinary_2() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('2'); [EOL] assertArrayEquals(new boolean[]{false, true, false, false}, result); [EOL] }
public void testHexDigitToBinary_3() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('3'); [EOL] assertArrayEquals(new boolean[]{true, true, false, false}, result); [EOL] }
public void testHexDigitToBinary_4() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('4'); [EOL] assertArrayEquals(new boolean[]{false, false, true, false}, result); [EOL] }
public void testHexDigitToBinary_5() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('5'); [EOL] assertArrayEquals(new boolean[]{true, false, true, false}, result); [EOL] }
public void testHexDigitToBinary_6() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('6'); [EOL] assertArrayEquals(new boolean[]{false, true, true, false}, result); [EOL] }
public void testHexDigitToBinary_7() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('7'); [EOL] assertArrayEquals(new boolean[]{true, true, true, false}, result); [EOL] }
public void testHexDigitToBinary_8() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('8'); [EOL] assertArrayEquals(new boolean[]{false, false, false, true}, result); [EOL] }
public void testHexDigitToBinary_9() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('9'); [EOL] assertArrayEquals(new boolean[]{true, false, false, true}, result); [EOL] }
public void testHexDigitToBinary_A() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('A'); [EOL] assertArrayEquals(new boolean[]{false, true, false, true}, result); [EOL] }
public void testHexDigitToBinary_B() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('B'); [EOL] assertArrayEquals(new boolean[]{true, true, false, true}, result); [EOL] }
public void testHexDigitToBinary_C() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('C'); [EOL] assertArrayEquals(new boolean[]{false, false, true, true}, result); [EOL] }
public void testHexDigitToBinary_D() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('D'); [EOL] assertArrayEquals(new boolean[]{true, false, true, true}, result); [EOL] }
public void testHexDigitToBinary_E() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('E'); [EOL] assertArrayEquals(new boolean[]{false, true, true, true}, result); [EOL] }
public void testHexDigitToBinary_F() { [EOL] boolean[] result = SomeClass.hexDigitToBinary('F'); [EOL] assertArrayEquals(new boolean[]{true, true, true, true}, result); [EOL] }
public void testHexDigitToBinary_Invalid() { [EOL] try { [EOL] SomeClass.hexDigitToBinary('G'); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToHexDigitMsb0_4bits_NullArray() { [EOL] try { [EOL] Utils.binaryToHexDigitMsb0_4bits(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testBinaryToHexDigitMsb0_4bits_EmptyArray() { [EOL] boolean[] src = new boolean[0]; [EOL] try { [EOL] Utils.binaryToHexDigitMsb0_4bits(src); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testBinaryToHexDigitMsb0_4bits_ValidArray() { [EOL] boolean[] src = {true, false, true, false}; // binary representation of 5 [EOL] char result = Utils.binaryToHexDigitMsb0_4bits(src); [EOL] assertEquals('5', result); [EOL] } [EOL] public void testBinaryToHexDigitMsb0_4bits_ValidArrayWithMoreThan4Bits() { [EOL] boolean[] src = {true, true, true, true, false, true, false}; // only the first 4 bits should be considered [EOL] char result = Utils.binaryToHexDigitMsb0_4bits(src); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ThrowsIllegalArgumentExceptionForSrcLengthGreaterThan8() { [EOL] boolean[] src = new boolean[9]; [EOL] int srcPos = 0; [EOL] try { [EOL] binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("src.length>8: src.length=9", e.getMessage()); [EOL] } [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ThrowsIllegalArgumentExceptionForSrcLengthMinusSrcPosLessThan4() { [EOL] boolean[] src = new boolean[8]; [EOL] int srcPos = 5; [EOL] try { [EOL] binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("src.length-srcPos<4: src.length=8, srcPos=5", e.getMessage()); [EOL] } [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ReturnsCorrectHexDigit() { [EOL] boolean[] src = {true, true, true, true}; [EOL] int srcPos = 0; [EOL] char result = binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ReturnsCorrectHexDigitForDifferentValues() { [EOL] boolean[][] testCases = { [EOL] {false, false, false, false}, // '0' [EOL] {false, false, false, true},  // '1' [EOL] {false, false, true, false},  // '2' [EOL] {true, true, true, false}     // 'e' [EOL] }; [EOL] char[] expectedResults = {'0', '1', '2', /* ... */ 'e'}; [EOL] for (int i = 0; i < testCases.length; i++) { [EOL] char result = binaryToHexDigitMsb0_4bits(testCases[i], 0); [EOL] assertEquals(expectedResults[i], result); [EOL] } [EOL] }
public void testLongToHex_ZeroHexs() { [EOL] String result = longToHex(0x123456789ABCDEFL, 0, "initial", 0, 0); [EOL] assertEquals("initial", result); [EOL] } [EOL] public void testLongToHex_IllegalArgumentException() { [EOL] try { [EOL] longToHex(0x123456789ABCDEFL, 0, "initial", 0, 17); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testLongToHex_AppendHexDigit() { [EOL] String result = longToHex(0x123456789ABCDEFL, 0, "initial", 7, 1); [EOL] assertEquals("initialD", result); [EOL] } [EOL] public void testLongToHex_SetCharAtHexDigit() { [EOL] String result = longToHex(0x123456789ABCDEFL, 0, "initial", 0, 2); [EOL] assertEquals("89itial", result); [EOL] } [EOL] public void testLongToHex_MultipleHexDigits() { [EOL] String result = longToHex(0x123456789ABCDEFL, 4, "initial", 0, 4); [EOL] assertEquals("5678itial", result); [EOL] }
public void testLongToHex_SrcPosGreaterThanZero() { [EOL] String result = longToHex(0x123456789ABCDEFL, 8, "initial", 0, 2); [EOL] assertEquals("9Aitial", result); [EOL] } [EOL] public void testLongToHex_DstPosGreaterThanZero() { [EOL] String result = longToHex(0x123456789ABCDEFL, 0, "initial", 2, 2); [EOL] assertEquals("in89tial", result); [EOL] } [EOL] public void testLongToHex_NHexsGreaterThanDstLength() { [EOL] String result = longToHex(0x123456789ABCDEFL, 0, "init", 0, 6); [EOL] assertEquals("89ABCDEFinit", result); [EOL] }
public void testShortToHex_ZeroHexs() { [EOL] String result = shortToHex((short)0xABCD, 0, "Initial", 0, 0); [EOL] assertEquals("Initial", result); [EOL] } [EOL] public void testShortToHex_IllegalArgumentException() { [EOL] try { [EOL] shortToHex((short)0xABCD, 0, "Initial", 0, 5); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testShortToHex_AppendHexDigit() { [EOL] String result = shortToHex((short)0xABCD, 0, "Initial", 7, 1); [EOL] assertEquals("InitialB", result); [EOL] } [EOL] public void testShortToHex_SetCharAtHexDigit() { [EOL] String result = shortToHex((short)0xABCD, 0, "Initial", 0, 1); [EOL] assertEquals("Bnitial", result); [EOL] } [EOL] public void testShortToHex_MultipleHexDigits() { [EOL] String result = shortToHex((short)0xABCD, 0, "Initial", 0, 4); [EOL] assertEquals("BCDInitial", result); [EOL] }
public void testEscapeJava_withNullInput() { [EOL] String result = StringEscapeUtils.escapeJava(null); [EOL] assertNull(result); [EOL] } [EOL] public void testEscapeJava_withEmptyString() { [EOL] String result = StringEscapeUtils.escapeJava(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testEscapeJava_withTextWithoutSpecialCharacters() { [EOL] String input = "This is a normal string."; [EOL] String result = StringEscapeUtils.escapeJava(input); [EOL] assertEquals(input, result); [EOL] } [EOL] public void testEscapeJava_withTextWithSpecialCharacters() { [EOL] String input = "String with \"quotes\" and \\backslashes\\."; [EOL] String expected = "String with \\\"quotes\\\" and \\\\backslashes\\\\."; [EOL] String result = StringEscapeUtils.escapeJava(input); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testEscapeJava_withControlCharacters() { [EOL] String input = "String with control chars: \b \n \t \f \r"; [EOL] String expected = "String with control chars: \\b \\n \\t \\f \\r"; [EOL] String result = StringEscapeUtils.escapeJava(input); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testEscapeJava_withUnicodeCharacters() { [EOL] String input = "Unicode test: \u20AC"; [EOL] String expected = "Unicode test: \\u20AC"; [EOL] String result = StringEscapeUtils.escapeJava(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeHtml4WithNullInput() { [EOL] String result = StringEscapeUtils.escapeHtml4(null); [EOL] assertNull(result); [EOL] } [EOL] public void testEscapeHtml4WithEmptyString() { [EOL] String result = StringEscapeUtils.escapeHtml4(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testEscapeHtml4WithText() { [EOL] String result = StringEscapeUtils.escapeHtml4("text"); [EOL] assertEquals("text", result); [EOL] } [EOL] public void testEscapeHtml4WithSpecialChars() { [EOL] String result = StringEscapeUtils.escapeHtml4("\"<>&'"); [EOL] assertEquals("&quot;&lt;&gt;&amp;&#39;", result); [EOL] }
public void testEscapeHtml4WithIso8859_1Chars() { [EOL] String result = StringEscapeUtils.escapeHtml4(""); [EOL] assertEquals("&Agrave;&Aacute;&Acirc;&Atilde;&Auml;&Aring;&AElig;&Ccedil;&Egrave;&Eacute;&Ecirc;&Euml;&Igrave;&Iacute;&Icirc;&Iuml;", result); [EOL] } [EOL] public void testEscapeHtml4WithHtml40ExtendedChars() { [EOL] String result = StringEscapeUtils.escapeHtml4(""); [EOL] assertEquals("&Alpha;&Beta;&Gamma;&Delta;&Epsilon;&Zeta;&Eta;&Theta;", result); [EOL] }
public static final String unescapeHtml4(final String input) { [EOL] return UNESCAPE_HTML4.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
public void testGetParser() { [EOL] Format format = new Format(); [EOL] assertNull(format.getParser()); [EOL] }
public void testGetFormatter() { [EOL] YourClass instance = new YourClass(); [EOL] Format expected = ...; // Initialize with the expected formatter [EOL] instance.formatter = expected; [EOL] Format result = instance.getFormatter(); [EOL] assertEquals(expected, result); [EOL] }
