public void testLowerCamelCaseSeparatorNamingPolicyWithEmptySeparator() { [EOL] String separatorString = ""; [EOL] LowerCamelCaseSeparatorNamingPolicy policy = new LowerCamelCaseSeparatorNamingPolicy(separatorString); [EOL] assertNotNull(policy); [EOL] }
public void testLowerCamelCaseSeparatorNamingPolicyWithNonEmptySeparator() { [EOL] String separatorString = "_"; [EOL] LowerCamelCaseSeparatorNamingPolicy policy = new LowerCamelCaseSeparatorNamingPolicy(separatorString); [EOL] assertNotNull(policy); [EOL] }
public void testGetActualTypeWithClass() { [EOL] Type result = getActualType(String.class, null, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithParameterizedType() { [EOL] Type typeToEvaluate = new ParameterizedTypeImpl(List.class, new Type[]{String.class}, null); [EOL] Type result = getActualType(typeToEvaluate, null, List.class); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedResult = (ParameterizedType) result; [EOL] assertEquals(List.class, parameterizedResult.getRawType()); [EOL] assertArrayEquals(new Type[]{String.class}, parameterizedResult.getActualTypeArguments()); [EOL] }
public void testGetActualTypeWithGenericArrayType() { [EOL] Type componentType = new GenericArrayTypeImpl(String.class); [EOL] Type typeToEvaluate = new GenericArrayTypeImpl(componentType); [EOL] Type result = getActualType(typeToEvaluate, null, null); [EOL] assertTrue(result instanceof GenericArrayType); [EOL] GenericArrayType arrayResult = (GenericArrayType) result; [EOL] assertEquals(componentType, arrayResult.getGenericComponentType()); [EOL] }
public void testGetActualTypeWithTypeVariable() { [EOL] TypeVariable<Class<TypeVariableDummy>> typeVariable = TypeVariableDummy.class.getTypeParameters()[0]; [EOL] Type parentType = new ParameterizedTypeImpl(TypeVariableDummy.class, new Type[]{String.class}, null); [EOL] Type result = getActualType(typeVariable, parentType, TypeVariableDummy.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithWildcardType() { [EOL] WildcardType wildcardType = new WildcardTypeImpl(new Type[]{String.class}, new Type[]{}); [EOL] Type result = getActualType(wildcardType, null, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithUnsupportedType() { [EOL] Type unsupportedType = new UnsupportedTypeImpl(); [EOL] try { [EOL] getActualType(unsupportedType, null, null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] private static class ParameterizedTypeImpl implements ParameterizedType { [EOL] } [EOL] private static class GenericArrayTypeImpl implements GenericArrayType { [EOL] } [EOL] private static class WildcardTypeImpl implements WildcardType { [EOL] } [EOL] private static class UnsupportedTypeImpl implements Type { [EOL] } [EOL] private static class TypeVariableDummy<T> { [EOL] }
public void testExtractTypeForHierarchyWithClass() { [EOL] Type parentType = String.class; [EOL] TypeVariable<?> typeToEvaluate = String.class.getTypeParameters()[0]; [EOL] Type result = extractTypeForHierarchy(parentType, typeToEvaluate); [EOL] assertNull(result); [EOL] }
public void testExtractTypeForHierarchyWithParameterizedType() { [EOL] Type parentType = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {String.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] TypeVariable<?> typeToEvaluate = List.class.getTypeParameters()[0]; [EOL] Type result = extractTypeForHierarchy(parentType, typeToEvaluate); [EOL] assertEquals(String.class, result); [EOL] }
public void testExtractTypeForHierarchyWithMismatchedTypeVariable() { [EOL] Type parentType = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {String.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] TypeVariable<?> typeToEvaluate = Comparable.class.getTypeParameters()[0]; [EOL] Type result = extractTypeForHierarchy(parentType, typeToEvaluate); [EOL] assertNull(result); [EOL] }
public void testExtractTypeForHierarchyWithRecursiveParameterizedType() { [EOL] Type parentType = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {Integer.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] TypeVariable<?> typeToEvaluate = List.class.getTypeParameters()[0]; [EOL] Type result = extractTypeForHierarchy(parentType, typeToEvaluate); [EOL] assertEquals(Integer.class, result); [EOL] }
public void testGetIndex_TypeVariablePresent() { [EOL] TypeVariable<Class<TypeVariableDummy>>[] typeVariables = TypeVariableDummy.class.getTypeParameters(); [EOL] TypeVariable<Class<TypeVariableDummy>> typeVariable = typeVariables[0]; [EOL] int index = getIndex(typeVariables, typeVariable); [EOL] assertEquals(0, index); [EOL] } [EOL] public void testGetIndex_TypeVariableNotPresent() { [EOL] TypeVariable<Class<TypeVariableDummy>>[] typeVariables = TypeVariableDummy.class.getTypeParameters(); [EOL] TypeVariable<Class<TypeVariableDummy>> typeVariable = AnotherTypeVariableDummy.class.getTypeParameters()[0]; [EOL] try { [EOL] getIndex(typeVariables, typeVariable); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("How can the type variable not be present in the class declaration!", e.getMessage()); [EOL] } [EOL] } [EOL] class TypeVariableDummy<T> { [EOL] } [EOL] class AnotherTypeVariableDummy<T> { [EOL] }
public void testVisitArrayFieldWithNullFieldAndSerializeNullsTrue() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContextDefault context = new JsonSerializationContextDefault(true, false, false, false, false, false, false, false, false, false, false); [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] verify(context).addChildAsElement(eq(f), any(JsonNull.class)); [EOL] }
public void testVisitArrayFieldWithNonNullField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] Object array = new Object(); [EOL] JsonSerializationContextDefault context = new JsonSerializationContextDefault(false, false, false, false, false, false, false, false, false, false, false); [EOL] when(context.getFieldValue(f, obj)).thenReturn(array); [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] verify(context).addAsChildOfObject(eq(f), any(ObjectTypePair.class)); [EOL] }
public void testVisitArrayFieldWithNullFieldAndSerializeNullsFalse() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContextDefault context = new JsonSerializationContextDefault(false, false, false, false, false, false, false, false, false, false, false); [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] verify(context, never()).addChildAsElement(eq(f), any(JsonNull.class)); [EOL] }
public void testVisitArrayFieldThrowsCircularReferenceException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContextDefault context = new JsonSerializationContextDefault(false, false, false, false, false, false, false, false, false, false, false); [EOL] CircularReferenceException cre = new CircularReferenceException(); [EOL] doThrow(cre).when(context).getFieldValue(f, obj); [EOL] try { [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] assertEquals(cre.createDetailedException(f), e); [EOL] } [EOL] }
public void testVisitObjectFieldWithNullFieldAndSerializeNullsTrue() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] public boolean serializeNulls = true; [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public boolean isSerializeNulls() { [EOL] return serializeNulls; [EOL] } [EOL] }; [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldWithNonNullField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] public boolean serializeNulls = false; [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public boolean isSerializeNulls() { [EOL] return serializeNulls; [EOL] } [EOL] }; [EOL] when(context.isFieldNull(f, obj)).thenReturn(false); [EOL] when(context.getFieldValue(f, obj)).thenReturn(new Object()); [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldWithNullFieldAndSerializeNullsFalse() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] public boolean serializeNulls = false; [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public boolean isSerializeNulls() { [EOL] return serializeNulls; [EOL] } [EOL] }; [EOL] when(context.isFieldNull(f, obj)).thenReturn(true); [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldThrowsCircularReferenceException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public boolean isSerializeNulls() { [EOL] return false; [EOL] } [EOL] }; [EOL] doThrow(new CircularReferenceException()).when(context).getFieldValue(f, obj); [EOL] try { [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair) { [EOL] JsonElement childElement = getJsonElementForChild(fieldValuePair); [EOL] addChildAsElement(f, childElement); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndSerializeNulls() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = true; [EOL] when(f.get(parent)).thenReturn(null); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndNotNullField() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] Object fieldValue = new Object(); [EOL] when(f.get(parent)).thenReturn(fieldValue); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(null); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndCustomSerializer() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] Object fieldValue = new Object(); [EOL] JsonElement customSerializedElement = new JsonObject(); [EOL] when(f.get(parent)).thenReturn(fieldValue); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(customSerializedElement); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithNonJsonObjectRoot() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonArray(); // This is not a JsonObject, should trigger the exception [EOL] boolean serializeNulls = false; [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandlerWithIllegalAccessException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] when(f.get(parent)).thenThrow(IllegalAccessException.class); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandlerWithCircularReferenceException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] CircularReferenceException circularReferenceException = new CircularReferenceException(); [EOL] when(f.get(parent)).thenThrow(circularReferenceException); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
public void testIsFieldNullWithNonNullField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Object obj = new Object(); [EOL] when(f.get(obj)).thenReturn(new Object()); [EOL] boolean result = isFieldNull(f, obj); [EOL] assertFalse(result); [EOL] }
public void testIsFieldNullWithNullField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Object obj = new Object(); [EOL] when(f.get(obj)).thenReturn(null); [EOL] boolean result = isFieldNull(f, obj); [EOL] assertTrue(result); [EOL] }
public void testGetFieldValueWithAccessibleField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Object obj = new Object(); [EOL] Object expectedValue = new Object(); [EOL] when(f.get(obj)).thenReturn(expectedValue); [EOL] Object actualValue = getFieldValue(f, obj); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetFieldValueWithInaccessibleField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Object obj = new Object(); [EOL] when(f.get(obj)).thenThrow(new IllegalAccessException()); [EOL] try { [EOL] getFieldValue(f, obj); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertTrue(e.getCause() instanceof IllegalAccessException); [EOL] } [EOL] }
public void testValueWithNull() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] JsonWriter returnedWriter = writer.value((String) null); [EOL] assertNull(returnedWriter); [EOL] }
public void testValueWithNonNull() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] String testValue = "Test String"; [EOL] JsonWriter returnedWriter = writer.value(testValue); [EOL] assertNotNull(returnedWriter); [EOL] assertSame(writer, returnedWriter); [EOL] }
public void testNullValue() throws IOException { [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL] jsonWriter.nullValue(); [EOL] assertEquals("null", stringWriter.toString()); [EOL] }
public void testValueTrue() throws IOException { [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL] JsonWriter result = jsonWriter.value(true); [EOL] assertEquals("true", stringWriter.toString()); [EOL] assertSame(jsonWriter, result); [EOL] }
public void testValueFalse() throws IOException { [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL] JsonWriter result = jsonWriter.value(false); [EOL] assertEquals("false", stringWriter.toString()); [EOL] assertSame(jsonWriter, result); [EOL] }
public void testValueWithFiniteNumber() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] double finiteValue = 123.456; [EOL] writer.value(finiteValue); [EOL] String result = writer.getOutput(); [EOL] assertEquals("123.456", result); [EOL] }
public void testValueWithNaN() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] double nanValue = Double.NaN; [EOL] try { [EOL] writer.value(nanValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testValueWithPositiveInfinity() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] double infinityValue = Double.POSITIVE_INFINITY; [EOL] try { [EOL] writer.value(infinityValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testValueWithNegativeInfinity() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] double negativeInfinityValue = Double.NEGATIVE_INFINITY; [EOL] try { [EOL] writer.value(negativeInfinityValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testValueWithPositiveLong() throws IOException { [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL] long testValue = 123456789L; [EOL] jsonWriter.value(testValue); [EOL] assertEquals("123456789", stringWriter.toString()); [EOL] }
public void testValueWithNegativeLong() throws IOException { [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL] long testValue = -987654321L; [EOL] jsonWriter.value(testValue); [EOL] assertEquals("-987654321", stringWriter.toString()); [EOL] }
public void testValueWithZero() throws IOException { [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL] long testValue = 0L; [EOL] jsonWriter.value(testValue); [EOL] assertEquals("0", stringWriter.toString()); [EOL] }
public void testValueWithNull() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer = writer.value((Number) null); [EOL] assertNull(writer); [EOL] }
public void testValueWithNegativeInfinity() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.NEGATIVE_INFINITY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Numeric values must be finite, but was -Infinity", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testValueWithPositiveInfinity() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.POSITIVE_INFINITY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Numeric values must be finite, but was Infinity", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testValueWithNaN() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.NaN); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Numeric values must be finite, but was NaN", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testValueWithFiniteNumber() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer = writer.value(123); [EOL] assertNotNull(writer); [EOL] assertEquals("123", writer.getBuffer().toString()); [EOL] }
public void testStringWithSpecialCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.string("a\"b\\c\td\be\nf\rg\fh"); [EOL] assertEquals("\"a\\\"b\\\\c\\td\\be\\nf\\rg\\fh\"", writer.toString()); [EOL] }
public void testStringWithHtmlCharactersHtmlSafe() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.setHtmlSafe(true); [EOL] jsonWriter.string("a<b>c&d='e"); [EOL] assertEquals("\"a\\u003cb\\u003ec\\u0026d=\\u0027e\"", writer.toString()); [EOL] }
public void testStringWithHtmlCharactersNotHtmlSafe() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.setHtmlSafe(false); [EOL] jsonWriter.string("a<b>c&d='e"); [EOL] assertEquals("\"a<b>c&d='e\"", writer.toString()); [EOL] }
public void testStringWithControlCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.string("a\u001Fb"); [EOL] assertEquals("\"a\\u001fb\"", writer.toString()); [EOL] }
public void testStringWithNonControlCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.string("a\u0020b"); [EOL] assertEquals("\"a b\"", writer.toString()); [EOL] }
public void testBeforeNameWithNonEmptyObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] writer.beforeName(); [EOL] assertEquals(JsonScope.DANGLING_NAME, writer.getStack().peek()); [EOL] }
public void testBeforeNameWithEmptyObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.beforeName(); [EOL] assertEquals(JsonScope.DANGLING_NAME, writer.getStack().peek()); [EOL] }
public void testBeforeNameWithInvalidContext() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.beforeName(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Nesting problem: " + writer.getStack(), e.getMessage()); [EOL] } [EOL] }
public void testBeforeValueWithEmptyDocumentAndLenient() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndRoot() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndNotRoot() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must start with an array or an object.", e.getMessage()); [EOL] } [EOL] }
public void testBeforeValueWithEmptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.beforeValue(false); [EOL] }
public void testBeforeValueWithNonemptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.value(1); [EOL] writer.beforeValue(false); [EOL] }
public void testBeforeValueWithDanglingName() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] writer.beforeValue(false); [EOL] }
public void testBeforeValueWithNonemptyDocument() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must have only one top-level value.", e.getMessage()); [EOL] } [EOL] }
public void testBeforeValueWithNestingProblem() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains("Nesting problem: ")); [EOL] } [EOL] }
public void testSyntheticFieldExclusionStrategyTrue() { [EOL] SyntheticFieldExclusionStrategy strategy = new SyntheticFieldExclusionStrategy(true); [EOL] assertTrue(strategy.skipSyntheticFields); [EOL] }
public void testSyntheticFieldExclusionStrategyFalse() { [EOL] SyntheticFieldExclusionStrategy strategy = new SyntheticFieldExclusionStrategy(false); [EOL] assertFalse(strategy.skipSyntheticFields); [EOL] }
public void testModifierBasedExclusionStrategyWithNullModifiers() { [EOL] ModifierBasedExclusionStrategy strategy = new ModifierBasedExclusionStrategy((int[]) null); [EOL] assertNotNull(strategy); [EOL] assertTrue(strategy.modifiers.isEmpty()); [EOL] }
public void testModifierBasedExclusionStrategyWithEmptyModifiers() { [EOL] ModifierBasedExclusionStrategy strategy = new ModifierBasedExclusionStrategy(new int[]{}); [EOL] assertNotNull(strategy); [EOL] assertTrue(strategy.modifiers.isEmpty()); [EOL] }
public void testModifierBasedExclusionStrategyWithSingleModifier() { [EOL] int modifier = Modifier.PUBLIC; [EOL] ModifierBasedExclusionStrategy strategy = new ModifierBasedExclusionStrategy(modifier); [EOL] assertNotNull(strategy); [EOL] assertEquals(1, strategy.modifiers.size()); [EOL] assertTrue(strategy.modifiers.contains(modifier)); [EOL] }
public void testModifierBasedExclusionStrategyWithMultipleModifiers() { [EOL] int[] modifiers = {Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED}; [EOL] ModifierBasedExclusionStrategy strategy = new ModifierBasedExclusionStrategy(modifiers); [EOL] assertNotNull(strategy); [EOL] assertEquals(modifiers.length, strategy.modifiers.size()); [EOL] for (int modifier : modifiers) { [EOL] assertTrue(strategy.modifiers.contains(modifier)); [EOL] } [EOL] }
public void testEscapeJsonString_noSpecialCharacters() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("normalString", out); [EOL] assertEquals("normalString", out.toString()); [EOL] }
public void testEscapeJsonString_withNewLine() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\nNewLine", out); [EOL] assertEquals("stringWith\\nNewLine", out.toString()); [EOL] }
public void testEscapeJsonString_withTab() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\tTab", out); [EOL] assertEquals("stringWith\\tTab", out.toString()); [EOL] }
public void testEscapeJsonString_withBackspace() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\bBackspace", out); [EOL] assertEquals("stringWith\\bBackspace", out.toString()); [EOL] }
public void testEscapeJsonString_withFormFeed() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\fFormFeed", out); [EOL] assertEquals("stringWith\\fFormFeed", out.toString()); [EOL] }
public void testEscapeJsonString_withCarriageReturn() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\rCarriageReturn", out); [EOL] assertEquals("stringWith\\rCarriageReturn", out.toString()); [EOL] }
public void testEscapeJsonString_withBackslash() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\\Backslash", out); [EOL] assertEquals("stringWith\\\\Backslash", out.toString()); [EOL] }
public void testEscapeJsonString_withForwardSlash() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith/ForwardSlash", out); [EOL] assertEquals("stringWith\\/ForwardSlash", out.toString()); [EOL] }
public void testEscapeJsonString_withDoubleQuote() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\"DoubleQuote", out); [EOL] assertEquals("stringWith\\\"DoubleQuote", out.toString()); [EOL] }
public void testEscapeJsonString_withControlCharacter() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\u0001ControlChar", out); [EOL] assertEquals("stringWith\\u0001ControlChar", out.toString()); [EOL] }
public void testEscapeJsonString_withNonControlNonSpecialCharacter() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\u007fDelete", out); [EOL] assertEquals("stringWith\\u007fDelete", out.toString()); [EOL] }
public boolean isLenient() { [EOL] return lenient; [EOL] }
public void testQuickPeekEmptyDocumentLenient() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.beginArray(); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertTrue(token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT); [EOL] }
public void testQuickPeekEmptyDocumentNotLenient() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(false); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testQuickPeekEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); [EOL] assertEquals(JsonToken.END_ARRAY, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekNonEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[true]")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextBoolean(); [EOL] assertEquals(JsonToken.END_ARRAY, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekEmptyObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.beginObject(); [EOL] assertEquals(JsonToken.END_OBJECT, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekDanglingName() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"name\":}")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testQuickPeekNonEmptyObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] jsonReader.nextBoolean(); [EOL] assertEquals(JsonToken.END_OBJECT, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekNonEmptyDocument() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.setLenient(true); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekClosed() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.close(); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testQuickPeekDefaultCase() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")) { [EOL] @Override [EOL] private JsonScope peekStack() { [EOL] return null; // Force default case [EOL] } [EOL] }; [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected AssertionError"); [EOL] } catch (AssertionError e) { [EOL] } [EOL] }
public void testNextNonWhitespaceWithWhitespaceCharacters() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader(" \r\n\t")); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSlash() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/")); [EOL] reader.setLenient(true); [EOL] assertEquals('/', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithAsteriskComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/* comment */")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should throw syntax error for unterminated comment"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testNextNonWhitespaceWithDoubleSlashComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("// comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSharp() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("# comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithEOF() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should throw EOFException"); [EOL] } catch (EOFException e) { [EOL] } [EOL] }
public void testSkipToEndOfLineWithNoEolChars() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("Test without EOL chars")); [EOL] jsonReader.skipToEndOfLine(); [EOL] }
public void testSkipToEndOfLineWithRChar() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("Test with \r EOL char")); [EOL] jsonReader.skipToEndOfLine(); [EOL] }
public void testSkipToEndOfLineWithNChar() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("Test with \n EOL char")); [EOL] jsonReader.skipToEndOfLine(); [EOL] }
public void testSkipToEndOfLineWithRnChars() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("Test with \r\n EOL chars")); [EOL] jsonReader.skipToEndOfLine(); [EOL] }
private boolean skipTo(String toFind) throws IOException { [EOL] outer: for (; pos + toFind.length() < limit || fillBuffer(toFind.length()); pos++) { [EOL] for (int c = 0; c < toFind.length(); c++) { [EOL] if (buffer[pos + c] != toFind.charAt(c)) { [EOL] continue outer; [EOL] } [EOL] } [EOL] return true; [EOL] } [EOL] return false; [EOL] }
public void testJsonObjectDeserializationVisitorWithValidInput() { [EOL] JsonElement json = new JsonObject(); [EOL] Type type = new TypeToken<Map<String, Object>>() {}.getType(); [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(); [EOL] ObjectConstructor objectConstructor = new ObjectConstructor() { [EOL] @Override [EOL] public <T> T construct(Type type) { [EOL] return (T) new HashMap<String, Object>(); [EOL] } [EOL] }; [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(deserializers); [EOL] JsonObjectDeserializationVisitor visitor = new JsonObjectDeserializationVisitor( [EOL] json, type, factory, objectConstructor, deserializers, context [EOL] ); [EOL] assertNotNull(visitor); [EOL] }
public void testConstructTarget() { [EOL] final ObjectConstructor objectConstructor = mock(ObjectConstructor.class); [EOL] final Type targetType = String.class; [EOL] when(objectConstructor.construct(targetType)).thenReturn("Test String"); [EOL] new TypeToken<String>() { [EOL] @Override [EOL] protected String constructTarget() { [EOL] return (String) objectConstructor.construct(targetType); [EOL] } [EOL] }.constructTarget(); [EOL] verify(objectConstructor).construct(targetType); [EOL] }
public void testStartVisitingObjectWithNull() { [EOL] ObjectVisitor visitor = new ObjectVisitor(); [EOL] try { [EOL] visitor.startVisitingObject(null); [EOL] } catch (Exception e) { [EOL] } [EOL] } [EOL] public void testStartVisitingObjectWithValidObject() { [EOL] ObjectVisitor visitor = new ObjectVisitor(); [EOL] Object node = new Object(); // Replace with a valid object expected by the method [EOL] visitor.startVisitingObject(node); [EOL] }
public void testGetFieldNameWithIdentityFieldNamingPolicy() { [EOL] FieldNamingStrategy2Factory factory = new FieldNamingStrategy2Factory(); [EOL] factory.setFieldNamingPolicy(new FieldNamingStrategy2() { [EOL] @Override [EOL] public String translateName(FieldAttributes f) { [EOL] return f.getName(); [EOL] } [EOL] }); [EOL] MyClass myClass = new MyClass(factory); [EOL] FieldAttributes fieldAttributes = new FieldAttributes(MyClass.class, MyClass.class.getDeclaredField("someField")); [EOL] String fieldName = myClass.getFieldName(fieldAttributes); [EOL] assertEquals("someField", fieldName); [EOL] }
public void testGetFieldNameWithUpperCaseFieldNamingPolicy() { [EOL] FieldNamingStrategy2Factory factory = new FieldNamingStrategy2Factory(); [EOL] factory.setFieldNamingPolicy(new FieldNamingStrategy2() { [EOL] @Override [EOL] public String translateName(FieldAttributes f) { [EOL] return f.getName().toUpperCase(); [EOL] } [EOL] }); [EOL] MyClass myClass = new MyClass(factory); [EOL] FieldAttributes fieldAttributes = new FieldAttributes(MyClass.class, MyClass.class.getDeclaredField("someField")); [EOL] String fieldName = myClass.getFieldName(fieldAttributes); [EOL] assertEquals("SOMEFIELD", fieldName); [EOL] }
public void testVisitFieldUsingCustomHandler_JsonParseException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement json = new JsonPrimitive("not a json object"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(json, null); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_NullChild() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", JsonNull.INSTANCE); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), null); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_NoMatchingHandler() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("fieldName", "value"); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), null); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandler_SuccessfulSet() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("fieldName", "value"); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] Map<Type, JsonDeserializer<?>> deserializers = new HashMap<>(); [EOL] deserializers.put(declaredTypeOfField, (JsonDeserializer<Object>) (json, typeOfT, context) -> "deserializedValue"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), deserializers); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_IllegalAccessException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("fieldName", "value"); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] doThrow(new IllegalAccessException()).when(f).set(any(), any()); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), null); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown RuntimeException"); [EOL] } catch (RuntimeException expected) { [EOL] } [EOL] }
public void testFieldNamingStrategy2AdapterWithNonNullAdaptee() { [EOL] FieldNamingStrategy mockAdaptee = mock(FieldNamingStrategy.class); [EOL] FieldNamingStrategy2Adapter adapter = new FieldNamingStrategy2Adapter(mockAdaptee); [EOL] assertNotNull(adapter); [EOL] }
public void testFieldNamingStrategy2AdapterWithNullAdaptee() { [EOL] try { [EOL] new FieldNamingStrategy2Adapter(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testTranslateNameNonNullField() { [EOL] FieldNamingStrategy2 adaptee = mock(FieldNamingStrategy2.class); [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Field field = SomeClass.class.getDeclaredField("someField"); [EOL] when(f.getFieldObject()).thenReturn(field); [EOL] when(adaptee.translateName(field)).thenReturn("translatedName"); [EOL] SerializedNameAnnotationInterceptingNamingPolicy policy = new SerializedNameAnnotationInterceptingNamingPolicy(adaptee); [EOL] String result = policy.translateName(f); [EOL] assertEquals("translatedName", result); [EOL] }
public void testTranslateNameWithNullField() { [EOL] FieldNamingStrategy2 adaptee = mock(FieldNamingStrategy2.class); [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getFieldObject()).thenReturn(null); [EOL] SerializedNameAnnotationInterceptingNamingPolicy policy = new SerializedNameAnnotationInterceptingNamingPolicy(adaptee); [EOL] try { [EOL] policy.translateName(f); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testCreateDefaultSerializers() { [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> map = createDefaultSerializers(); [EOL] assertNotNull(map.getHandlerFor(Enum.class, false)); [EOL] assertNotNull(map.getHandlerFor(URL.class, false)); [EOL] assertNotNull(map.getHandlerFor(URI.class, false)); [EOL] assertNotNull(map.getHandlerFor(UUID.class, false)); [EOL] assertNotNull(map.getHandlerFor(Locale.class, false)); [EOL] assertNotNull(map.getHandlerFor(Collection.class, false)); [EOL] assertNotNull(map.getHandlerFor(Map.class, false)); [EOL] assertNotNull(map.getHandlerFor(Date.class, false)); [EOL] assertNotNull(map.getHandlerFor(java.sql.Date.class, false)); [EOL] assertNotNull(map.getHandlerFor(Timestamp.class, false)); [EOL] assertNotNull(map.getHandlerFor(Time.class, false)); [EOL] assertNotNull(map.getHandlerFor(Calendar.class, false)); [EOL] assertNotNull(map.getHandlerFor(GregorianCalendar.class, false)); [EOL] assertNotNull(map.getHandlerFor(BigDecimal.class, false)); [EOL] assertNotNull(map.getHandlerFor(BigInteger.class, false)); [EOL] assertNotNull(map.getHandlerFor(Boolean.class, false)); [EOL] assertNotNull(map.getHandlerFor(boolean.class, false)); [EOL] assertNotNull(map.getHandlerFor(Byte.class, false)); [EOL] assertNotNull(map.getHandlerFor(byte.class, false)); [EOL] assertNotNull(map.getHandlerFor(Character.class, false)); [EOL] assertNotNull(map.getHandlerFor(char.class, false)); [EOL] assertNotNull(map.getHandlerFor(Integer.class, false)); [EOL] assertNotNull(map.getHandlerFor(int.class, false)); [EOL] assertNotNull(map.getHandlerFor(Number.class, false)); [EOL] assertNotNull(map.getHandlerFor(Short.class, false)); [EOL] assertNotNull(map.getHandlerFor(short.class, false)); [EOL] assertNotNull(map.getHandlerFor(String.class, false)); [EOL] try { [EOL] map.register(Object.class, null); [EOL] fail("Expected UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException expected) { [EOL] } [EOL] }
public void testCreateDefaultDeserializers() { [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> map = createDefaultDeserializers(); [EOL] assertNotNull(map.getHandlerFor(Enum.class, false)); [EOL] assertNotNull(map.getHandlerFor(URL.class, false)); [EOL] assertNotNull(map.getHandlerFor(URI.class, false)); [EOL] assertNotNull(map.getHandlerFor(UUID.class, false)); [EOL] assertNotNull(map.getHandlerFor(Locale.class, false)); [EOL] assertNotNull(map.getHandlerFor(Collection.class, false)); [EOL] assertNotNull(map.getHandlerFor(Map.class, false)); [EOL] assertNotNull(map.getHandlerFor(Date.class, false)); [EOL] assertNotNull(map.getHandlerFor(java.sql.Date.class, false)); [EOL] assertNotNull(map.getHandlerFor(Timestamp.class, false)); [EOL] assertNotNull(map.getHandlerFor(Time.class, false)); [EOL] assertNotNull(map.getHandlerFor(Calendar.class, false)); [EOL] assertNotNull(map.getHandlerFor(GregorianCalendar.class, false)); [EOL] assertNotNull(map.getHandlerFor(BigDecimal.class, false)); [EOL] assertNotNull(map.getHandlerFor(BigInteger.class, false)); [EOL] assertNotNull(map.getHandlerFor(Boolean.class, false)); [EOL] assertNotNull(map.getHandlerFor(boolean.class, false)); [EOL] assertNotNull(map.getHandlerFor(Byte.class, false)); [EOL] assertNotNull(map.getHandlerFor(byte.class, false)); [EOL] assertNotNull(map.getHandlerFor(Character.class, false)); [EOL] assertNotNull(map.getHandlerFor(char.class, false)); [EOL] assertNotNull(map.getHandlerFor(Double.class, false)); [EOL] assertNotNull(map.getHandlerFor(double.class, false)); [EOL] assertNotNull(map.getHandlerFor(Float.class, false)); [EOL] assertNotNull(map.getHandlerFor(float.class, false)); [EOL] assertNotNull(map.getHandlerFor(Integer.class, false)); [EOL] assertNotNull(map.getHandlerFor(int.class, false)); [EOL] assertNotNull(map.getHandlerFor(Long.class, false)); [EOL] assertNotNull(map.getHandlerFor(long.class, false)); [EOL] assertNotNull(map.getHandlerFor(Number.class, false)); [EOL] assertNotNull(map.getHandlerFor(Short.class, false)); [EOL] assertNotNull(map.getHandlerFor(short.class, false)); [EOL] assertNotNull(map.getHandlerFor(String.class, false)); [EOL] assertTrue(map.isUnmodifiable()); [EOL] }
public void testCreateDefaultInstanceCreators() { [EOL] ParameterizedTypeHandlerMap<InstanceCreator<?>> map = createDefaultInstanceCreators(); [EOL] assertTrue(map.hasSpecificHandlerFor(Map.class)); [EOL] assertTrue(map.hasSpecificHandlerFor(Collection.class)); [EOL] assertTrue(map.hasSpecificHandlerFor(Set.class)); [EOL] assertTrue(map.hasSpecificHandlerFor(SortedSet.class)); [EOL] assertTrue(map.hasSpecificHandlerFor(Properties.class)); [EOL] assertFalse(map.isModifiable()); [EOL] }
public void testWrapDeserializerWithNonNullDeserializer() { [EOL] JsonDeserializer<?> originalDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> wrappedDeserializer = wrapDeserializer(originalDeserializer); [EOL] assertNotNull(wrappedDeserializer); [EOL] assertTrue(wrappedDeserializer instanceof JsonDeserializerExceptionWrapper); [EOL] }
public void testWrapDeserializerWithNullDeserializer() { [EOL] JsonDeserializer<?> wrappedDeserializer = wrapDeserializer(null); [EOL] assertNull(wrappedDeserializer); [EOL] }
public void testGetDefaultSerializersWithFalseAndDefaultPolicy() { [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> result = GsonBuilder.getDefaultSerializers(false, LongSerializationPolicy.DEFAULT); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetDefaultSerializersWithTrueAndDefaultPolicy() { [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> result = GsonBuilder.getDefaultSerializers(true, LongSerializationPolicy.DEFAULT); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testDefaultDateTypeAdapter() { [EOL] DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(); [EOL] assertNotNull(adapter.format); [EOL] }
public void testDefaultJavaSqlDateTypeAdapter() { [EOL] DefaultJavaSqlDateTypeAdapter adapter = new DefaultJavaSqlDateTypeAdapter(); [EOL] assertNotNull(adapter); [EOL] assertEquals("MMM d, yyyy", adapter.format.toPattern()); [EOL] }
public void testDefaultTimeTypeAdapter() { [EOL] DefaultTimeTypeAdapter adapter = new DefaultTimeTypeAdapter(); [EOL] assertNotNull(adapter.format); [EOL] assertEquals("hh:mm:ss a", adapter.format.toPattern()); [EOL] }
public void testDeserializeValidUUID() { [EOL] JsonElement json = new JsonPrimitive("123e4567-e89b-12d3-a456-426614174000"); [EOL] Type typeOfT = UUID.class; [EOL] JsonDeserializationContext context = new JsonDeserializationContext() { [EOL] }; [EOL] UUID result = deserialize(json, typeOfT, context); [EOL] assertEquals(UUID.fromString("123e4567-e89b-12d3-a456-426614174000"), result); [EOL] } [EOL] public void testDeserializeInvalidUUID() { [EOL] JsonElement json = new JsonPrimitive("invalid-uuid"); [EOL] Type typeOfT = UUID.class; [EOL] JsonDeserializationContext context = new JsonDeserializationContext() { [EOL] }; [EOL] try { [EOL] UUID result = deserialize(json, typeOfT, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserialize_SingleElementLocale() { [EOL] JsonElement json = new JsonPrimitive("en"); [EOL] Type typeOfT = Locale.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Locale result = deserialize(json, typeOfT, context); [EOL] assertEquals("en", result.getLanguage()); [EOL] assertEquals("", result.getCountry()); [EOL] assertEquals("", result.getVariant()); [EOL] }
public void testDeserialize_LocaleWithCountry() { [EOL] JsonElement json = new JsonPrimitive("en_US"); [EOL] Type typeOfT = Locale.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Locale result = deserialize(json, typeOfT, context); [EOL] assertEquals("en", result.getLanguage()); [EOL] assertEquals("US", result.getCountry()); [EOL] assertEquals("", result.getVariant()); [EOL] }
public void testDeserialize_LocaleWithCountryAndVariant() { [EOL] JsonElement json = new JsonPrimitive("en_US_POSIX"); [EOL] Type typeOfT = Locale.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Locale result = deserialize(json, typeOfT, context); [EOL] assertEquals("en", result.getLanguage()); [EOL] assertEquals("US", result.getCountry()); [EOL] assertEquals("POSIX", result.getVariant()); [EOL] }
public void testSerializeWithNullCollection() { [EOL] Collection src = null; [EOL] Type typeOfSrc = null; // Assuming Type is a generic type for the purpose of this test [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testSerializeWithEmptyCollection() { [EOL] Collection src = new ArrayList(); [EOL] Type typeOfSrc = null; // Assuming Type is a generic type for the purpose of this test [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(0, result.getAsJsonArray().size()); [EOL] }
public void testSerializeWithNonParameterizedType() { [EOL] Collection src = Arrays.asList("string1", "string2"); [EOL] Type typeOfSrc = String.class; // Non-parameterized type [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(any(), any())).thenReturn(new JsonPrimitive("mockedValue")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(2, result.getAsJsonArray().size()); [EOL] for (JsonElement element : result.getAsJsonArray()) { [EOL] assertEquals("mockedValue", element.getAsString()); [EOL] } [EOL] }
public void testSerializeWithParameterizedType() { [EOL] Collection src = Arrays.asList("string1", "string2"); [EOL] Type typeOfSrc = new TypeToken<ArrayList<String>>() {}.getType(); // Parameterized type [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(any(), any())).thenReturn(new JsonPrimitive("mockedValue")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(2, result.getAsJsonArray().size()); [EOL] for (JsonElement element : result.getAsJsonArray()) { [EOL] assertEquals("mockedValue", element.getAsString()); [EOL] } [EOL] }
public void testSerializeWithCollectionContainingNull() { [EOL] Collection src = Arrays.asList("string1", null, "string2"); [EOL] Type typeOfSrc = new TypeToken<ArrayList<String>>() {}.getType(); // Parameterized type [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(any(), any())).thenReturn(new JsonPrimitive("mockedValue")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] JsonArray array = result.getAsJsonArray(); [EOL] assertEquals(3, array.size()); [EOL] assertEquals("mockedValue", array.get(0).getAsString()); [EOL] assertTrue(array.get(1).isJsonNull()); [EOL] assertEquals("mockedValue", array.get(2).getAsString()); [EOL] }
public Collection createInstance(Type type) { [EOL] return new LinkedList(); [EOL] }
public void testDeserializeWithBigInteger() { [EOL] JsonElement json = new JsonPrimitive(new BigInteger("12345678901234567890")); [EOL] BigInteger result = deserialize(json, BigInteger.class, null); [EOL] assertEquals(new BigInteger("12345678901234567890"), result); [EOL] }
public void testDeserializeWithNumberFormatException() { [EOL] JsonElement json = new JsonPrimitive("not a number"); [EOL] try { [EOL] deserialize(json, BigInteger.class, null); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithNullJsonElement() { [EOL] try { [EOL] deserialize(null, BigInteger.class, null); [EOL] fail("NullPointerException expected"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testToString() { [EOL] LongDeserializer longDeserializer = new LongDeserializer(); [EOL] String result = longDeserializer.toString(); [EOL] assertEquals("LongDeserializer", result); [EOL] }
public void testSerializeWithFiniteDouble() { [EOL] Double src = 123.45; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(src, result.getAsDouble()); [EOL] }
public void testSerializeWithNaN() { [EOL] Double src = Double.NaN; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.serialize(src, typeOfSrc, context); [EOL] fail("Expected IllegalArgumentException for NaN"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(src + " is not a valid double value as per JSON specification. To override this" + [EOL] " behavior, use GsonBuilder.serializeSpecialDoubleValues() method.", e.getMessage()); [EOL] } [EOL] }
public void testSerializeWithPositiveInfinity() { [EOL] Double src = Double.POSITIVE_INFINITY; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.serialize(src, typeOfSrc, context); [EOL] fail("Expected IllegalArgumentException for positive infinity"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(src + " is not a valid double value as per JSON specification. To override this" + [EOL] " behavior, use GsonBuilder.serializeSpecialDoubleValues() method.", e.getMessage()); [EOL] } [EOL] }
public void testSerializeWithNegativeInfinity() { [EOL] Double src = Double.NEGATIVE_INFINITY; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.serialize(src, typeOfSrc, context); [EOL] fail("Expected IllegalArgumentException for negative infinity"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(src + " is not a valid double value as per JSON specification. To override this" + [EOL] " behavior, use GsonBuilder.serializeSpecialDoubleValues() method.", e.getMessage()); [EOL] } [EOL] }
public void testSerializeWithSpecialFloatingPointValuesAllowed() { [EOL] Double src = Double.NaN; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(src, result.getAsDouble()); [EOL] }
public void testDeserializeCharacter() { [EOL] JsonElement jsonElement = new JsonPrimitive('a'); [EOL] Character result = deserialize(jsonElement, Character.class, null); [EOL] assertEquals(Character.valueOf('a'), result); [EOL] }
public void testDeserializeCharacterWithNullJsonElement() { [EOL] try { [EOL] Character result = deserialize(null, Character.class, null); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeCharacterWithNonCharacterJsonElement() { [EOL] JsonElement jsonElement = new JsonPrimitive(1); [EOL] try { [EOL] Character result = deserialize(jsonElement, Character.class, null); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSerializeWithNonNullString() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.serialize("Test String", String.class, null); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("Test String", result.getAsString()); [EOL] }
public void testSerializeWithNullString() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.serialize(null, String.class, null); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(JsonNull.INSTANCE, result); [EOL] }
public void testTypeInfoMapWithPropertiesSubclass() { [EOL] Type mapType = Properties.class; [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(String.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithParameterizedType() { [EOL] Type mapType = new TypeToken<Map<String, Integer>>(){}.getType(); [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(Integer.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithInvalidType() { [EOL] Type mapType = String.class; [EOL] try { [EOL] new TypeInfoMap(mapType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStartVisitingObjectWithNonNullObject() { [EOL] Object node = new Object(); [EOL] try { [EOL] startVisitingObject(node); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Expecting array but found object: " + node.toString(), e.getMessage()); [EOL] } [EOL] }
public void testParseString() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\"testString\"")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("testString", result.getAsString()); [EOL] }
public void testParseNumber() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("12345")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(12345, result.getAsInt()); [EOL] }
public void testParseBoolean() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertTrue(result.getAsBoolean()); [EOL] }
public void testParseNull() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("null")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testParseArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[\"testString\", 12345, true]")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonArray()); [EOL] JsonArray array = result.getAsJsonArray(); [EOL] assertEquals("testString", array.get(0).getAsString()); [EOL] assertEquals(12345, array.get(1).getAsInt()); [EOL] assertTrue(array.get(2).getAsBoolean()); [EOL] }
public void testParseObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key1\":\"value1\",\"key2\":123,\"key3\":false}")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonObject()); [EOL] JsonObject object = result.getAsJsonObject(); [EOL] assertEquals("value1", object.get("key1").getAsString()); [EOL] assertEquals(123, object.get("key2").getAsInt()); [EOL] assertFalse(object.get("key3").getAsBoolean()); [EOL] }
public void testParseEndDocument() { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] try { [EOL] parse(reader); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testParseInvalidToken() { [EOL] JsonReader reader = new JsonReader(new StringReader("invalid")); [EOL] try { [EOL] parse(reader); [EOL] fail("Should have thrown JsonSyntaxException"); [EOL] } catch (JsonSyntaxException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testWriteNullElementWithSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, true, writer); [EOL] verify(writer).nullValue(); [EOL] }
public void testWriteNullElementWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, false, writer); [EOL] verify(writer, never()).nullValue(); [EOL] }
public void testWriteJsonPrimitiveNumber() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(10); [EOL] write(element, true, writer); [EOL] verify(writer).value(10); [EOL] }
public void testWriteJsonPrimitiveBoolean() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(true); [EOL] write(element, true, writer); [EOL] verify(writer).value(true); [EOL] }
public void testWriteJsonPrimitiveString() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] write(element, true, writer); [EOL] verify(writer).value("test"); [EOL] }
public void testWriteJsonArray() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(1); [EOL] jsonArray.add("string"); [EOL] JsonElement element = jsonArray; [EOL] write(element, true, writer); [EOL] verify(writer).beginArray(); [EOL] verify(writer).value(1); [EOL] verify(writer).value("string"); [EOL] verify(writer).endArray(); [EOL] }
public void testWriteJsonObject() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key1", 1); [EOL] jsonObject.addProperty("key2", "value2"); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).value(1); [EOL] verify(writer).name("key2"); [EOL] verify(writer).value("value2"); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueAndSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, false, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer, never()).name("key1"); [EOL] verify(writer, never()).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteIllegalArgument() { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = mock(JsonElement.class); [EOL] when(element.isJsonNull()).thenReturn(false); [EOL] when(element.isJsonPrimitive()).thenReturn(false); [EOL] when(element.isJsonArray()).thenReturn(false); [EOL] when(element.isJsonObject()).thenReturn(false); [EOL] try { [EOL] write(element, true, writer); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testJsonArrayConstructor() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] assertNotNull(jsonArray); [EOL] assertEquals(0, jsonArray.size()); [EOL] }
public void testAddWithNonNullElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonElement jsonElement = new JsonPrimitive("Test"); [EOL] jsonArray.add(jsonElement); [EOL] assertEquals(1, jsonArray.size()); [EOL] assertEquals(jsonElement, jsonArray.get(0)); [EOL] } [EOL] public void testAddWithNullElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(null); [EOL] assertEquals(1, jsonArray.size()); [EOL] assertTrue(jsonArray.get(0).isJsonNull()); [EOL] }
public void testIterator_EmptyList() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] Iterator<JsonElement> iterator = jsonArray.iterator(); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIterator_NonEmptyList() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(1)); [EOL] jsonArray.add(new JsonPrimitive(2)); [EOL] Iterator<JsonElement> iterator = jsonArray.iterator(); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(new JsonPrimitive(1), iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(new JsonPrimitive(2), iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testGetAsDouble_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(10.5)); [EOL] double result = jsonArray.getAsDouble(); [EOL] assertEquals(10.5, result, 0.0); [EOL] }
public void testGetAsDouble_EmptyArrayThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] try { [EOL] jsonArray.getAsDouble(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsDouble_MultipleElementsThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(10.5)); [EOL] jsonArray.add(new JsonPrimitive(20.5)); [EOL] try { [EOL] jsonArray.getAsDouble(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsLong_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(10L)); [EOL] long result = jsonArray.getAsLong(); [EOL] assertEquals(10L, result); [EOL] }
public void testGetAsLong_MultipleElementsThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(10L)); [EOL] jsonArray.add(new JsonPrimitive(20L)); [EOL] try { [EOL] jsonArray.getAsLong(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsLong_EmptyArrayThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] try { [EOL] jsonArray.getAsLong(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsInt_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(42)); [EOL] int result = jsonArray.getAsInt(); [EOL] assertEquals(42, result); [EOL] }
public void testGetAsInt_Empty() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] try { [EOL] jsonArray.getAsInt(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsInt_MultipleElements() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(42)); [EOL] jsonArray.add(new JsonPrimitive(100)); [EOL] try { [EOL] jsonArray.getAsInt(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testRegisterForTypeHierarchyWithNonNullValues() { [EOL] TypeAdapterRuntimeTypeWrapperTest testInstance = new TypeAdapterRuntimeTypeWrapperTest(); [EOL] Class<?> typeOfT = Object.class; [EOL] Object value = new Object(); [EOL] testInstance.registerForTypeHierarchy(typeOfT, value); [EOL] }
public void testRegisterForTypeHierarchyWithNullType() { [EOL] TypeAdapterRuntimeTypeWrapperTest testInstance = new TypeAdapterRuntimeTypeWrapperTest(); [EOL] Class<?> typeOfT = null; [EOL] Object value = new Object(); [EOL] try { [EOL] testInstance.registerForTypeHierarchy(typeOfT, value); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testRegisterForTypeHierarchyWithNullValue() { [EOL] TypeAdapterRuntimeTypeWrapperTest testInstance = new TypeAdapterRuntimeTypeWrapperTest(); [EOL] Class<?> typeOfT = Object.class; [EOL] Object value = null; [EOL] testInstance.registerForTypeHierarchy(typeOfT, value); [EOL] }
public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) { [EOL] if (!modifiable) { [EOL] throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL] } [EOL] int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first); [EOL] if (index >= 0) { [EOL] logger.log(Level.WARNING, "Overriding the existing type handler for {0}", pair.first); [EOL] typeHierarchyList.remove(index); [EOL] } [EOL] index = getIndexOfAnOverriddenHandler(pair.first); [EOL] if (index >= 0) { [EOL] throw new IllegalArgumentException("The specified type handler for type " + pair.first + " hides the previously registered type hierarchy handler for " + typeHierarchyList.get(index).first + ". Gson does not allow this."); [EOL] } [EOL] typeHierarchyList.add(0, pair); [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithEmptyTypeHierarchyList() { [EOL] TypeHierarchyList<Pair<Class<?>, T>> typeHierarchyList = new TypeHierarchyList<>(); [EOL] int index = getIndexOfAnOverriddenHandler(Object.class); [EOL] assertEquals(-1, index); [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithNonEmptyTypeHierarchyList_NotFound() { [EOL] TypeHierarchyList<Pair<Class<?>, T>> typeHierarchyList = new TypeHierarchyList<>(); [EOL] typeHierarchyList.add(new Pair<>(String.class, null)); [EOL] int index = getIndexOfAnOverriddenHandler(Object.class); [EOL] assertEquals(-1, index); [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithNonEmptyTypeHierarchyList_Found() { [EOL] TypeHierarchyList<Pair<Class<?>, T>> typeHierarchyList = new TypeHierarchyList<>(); [EOL] typeHierarchyList.add(new Pair<>(Number.class, null)); [EOL] typeHierarchyList.add(new Pair<>(Integer.class, null)); [EOL] int index = getIndexOfAnOverriddenHandler(Integer.class); [EOL] assertEquals(1, index); [EOL] }
public void testRegisterWithModifiableMap() { [EOL] Type typeOfT = new TypeToken<String>() {}.getType(); [EOL] String value = "testValue"; [EOL] CustomTypeAdapterMap customMap = new CustomTypeAdapterMap(true); [EOL] customMap.register(typeOfT, value); [EOL] assertEquals(value, customMap.getMap().get(typeOfT)); [EOL] }
public void testRegisterWithUnmodifiableMap() { [EOL] Type typeOfT = new TypeToken<String>() {}.getType(); [EOL] String value = "testValue"; [EOL] CustomTypeAdapterMap customMap = new CustomTypeAdapterMap(false); [EOL] try { [EOL] customMap.register(typeOfT, value); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Attempted to modify an unmodifiable map.", e.getMessage()); [EOL] } [EOL] }
public void testRegisterWithOverridingHandler() { [EOL] Type typeOfT = new TypeToken<String>() {}.getType(); [EOL] String value1 = "testValue1"; [EOL] String value2 = "testValue2"; [EOL] CustomTypeAdapterMap customMap = new CustomTypeAdapterMap(true); [EOL] customMap.register(typeOfT, value1); [EOL] customMap.register(typeOfT, value2); [EOL] assertEquals(value2, customMap.getMap().get(typeOfT)); [EOL] }
public void testRegisterIfAbsentWithUnmodifiableMap() { [EOL] ParameterizedTypeHandlerMap<Object> map = new ParameterizedTypeHandlerMap<>(); [EOL] map.makeUnmodifiable(); [EOL] ParameterizedTypeHandlerMap<Object> other = new ParameterizedTypeHandlerMap<>(); [EOL] try { [EOL] map.registerIfAbsent(other); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] }
public void testRegisterIfAbsentWithNewEntries() { [EOL] ParameterizedTypeHandlerMap<Object> map = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<Object> other = new ParameterizedTypeHandlerMap<>(); [EOL] other.register(TypeToken.get(String.class).getType(), new Object()); [EOL] int initialSize = map.map.size(); [EOL] map.registerIfAbsent(other); [EOL] assertEquals(initialSize + 1, map.map.size()); [EOL] }
public void testRegisterIfAbsentWithExistingEntries() { [EOL] ParameterizedTypeHandlerMap<Object> map = new ParameterizedTypeHandlerMap<>(); [EOL] Object handler = new Object(); [EOL] map.register(TypeToken.get(String.class).getType(), handler); [EOL] int initialSize = map.map.size(); [EOL] ParameterizedTypeHandlerMap<Object> other = new ParameterizedTypeHandlerMap<>(); [EOL] other.register(TypeToken.get(String.class).getType(), new Object()); [EOL] map.registerIfAbsent(other); [EOL] assertEquals(initialSize, map.map.size()); [EOL] assertSame(handler, map.getHandlerFor(TypeToken.get(String.class).getType())); [EOL] }
public void testRegisterIfAbsentWithTypeHierarchy() { [EOL] ParameterizedTypeHandlerMap<Object> map = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<Object> other = new ParameterizedTypeHandlerMap<>(); [EOL] other.registerForTypeHierarchy(Pair.of((Class<?>) Number.class, new Object())); [EOL] int initialSize = map.typeHierarchyList.size(); [EOL] map.registerIfAbsent(other); [EOL] assertEquals(initialSize + 1, map.typeHierarchyList.size()); [EOL] }
public void testRegisterIfAbsentWithExistingTypeHierarchy() { [EOL] ParameterizedTypeHandlerMap<Object> map = new ParameterizedTypeHandlerMap<>(); [EOL] Object handler = new Object(); [EOL] map.registerForTypeHierarchy(Pair.of((Class<?>) Number.class, handler)); [EOL] int initialSize = map.typeHierarchyList.size(); [EOL] ParameterizedTypeHandlerMap<Object> other = new ParameterizedTypeHandlerMap<>(); [EOL] other.registerForTypeHierarchy(Pair.of((Class<?>) Integer.class, new Object())); [EOL] map.registerIfAbsent(other); [EOL] assertEquals(initialSize, map.typeHierarchyList.size()); [EOL] assertSame(handler, map.getHandlerForTypeHierarchy(Number.class)); [EOL] }
public void testRegisterIfAbsentWithModifiableMap() { [EOL] TypeToken<Integer> typeOfT = TypeToken.get(Integer.class); [EOL] Integer value = 123; [EOL] CustomTypeAdapterFactory factory = new CustomTypeAdapterFactory(true); [EOL] factory.registerIfAbsent(typeOfT.getType(), value); [EOL] assertEquals(value, factory.getInstance(typeOfT.getType())); [EOL] }
public void testRegisterIfAbsentWithUnmodifiableMap() { [EOL] TypeToken<Integer> typeOfT = TypeToken.get(Integer.class); [EOL] Integer value = 123; [EOL] CustomTypeAdapterFactory factory = new CustomTypeAdapterFactory(false); [EOL] try { [EOL] factory.registerIfAbsent(typeOfT.getType(), value); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Attempted to modify an unmodifiable map.", e.getMessage()); [EOL] } [EOL] }
public void testRegisterIfAbsentWithExistingKey() { [EOL] TypeToken<Integer> typeOfT = TypeToken.get(Integer.class); [EOL] Integer value = 123; [EOL] Integer newValue = 456; [EOL] CustomTypeAdapterFactory factory = new CustomTypeAdapterFactory(true); [EOL] factory.register(typeOfT.getType(), value); [EOL] factory.registerIfAbsent(typeOfT.getType(), newValue); [EOL] assertEquals(value, factory.getInstance(typeOfT.getType())); [EOL] }
public void testGetHandlerForWithExistingType() { [EOL] TypeTokenHandlerRegistry registry = new TypeTokenHandlerRegistry(); [EOL] Type type = String.class; [EOL] TypeHandler<String> expectedHandler = new DefaultTypeHandler<>(); [EOL] registry.register(type, expectedHandler); [EOL] TypeHandler<?> actualHandler = registry.getHandlerFor(type); [EOL] assertSame(expectedHandler, actualHandler); [EOL] }
public void testGetHandlerForWithNonExistingTypeAndNoHierarchy() { [EOL] TypeTokenHandlerRegistry registry = new TypeTokenHandlerRegistry(); [EOL] Type type = String.class; [EOL] TypeHandler<?> actualHandler = registry.getHandlerFor(type); [EOL] assertNull(actualHandler); [EOL] }
public void testGetHandlerForWithNonExistingTypeAndHierarchy() { [EOL] TypeTokenHandlerRegistry registry = new TypeTokenHandlerRegistry(); [EOL] Type type = List.class; [EOL] TypeHandler<?> expectedHandler = new DefaultTypeHandler<>(); [EOL] registry.register(TypeUtils.toRawClass(type), expectedHandler); [EOL] TypeHandler<?> actualHandler = registry.getHandlerFor(type); [EOL] assertSame(expectedHandler, actualHandler); [EOL] }
public void testGetHandlerForTypeHierarchyWithDirectMatch() { [EOL] Class<?> directMatchType = String.class; [EOL] T expectedHandler = createMockHandler(); // createMockHandler() should be a method that creates a mock T instance [EOL] Pair<Class<?>, T> directMatchEntry = new Pair<>(String.class, expectedHandler); [EOL] typeHierarchyList.add(directMatchEntry); [EOL] T actualHandler = getHandlerForTypeHierarchy(directMatchType); [EOL] assertEquals(expectedHandler, actualHandler); [EOL] }
public void testGetHandlerForTypeHierarchyWithInheritedMatch() { [EOL] Class<?> inheritedMatchType = Integer.class; [EOL] T expectedHandler = createMockHandler(); [EOL] Pair<Class<?>, T> inheritedMatchEntry = new Pair<>(Number.class, expectedHandler); [EOL] typeHierarchyList.add(inheritedMatchEntry); [EOL] T actualHandler = getHandlerForTypeHierarchy(inheritedMatchType); [EOL] assertEquals(expectedHandler, actualHandler); [EOL] }
public void testGetHandlerForTypeHierarchyWithNoMatch() { [EOL] Class<?> noMatchType = Boolean.class; [EOL] Pair<Class<?>, T> nonMatchingEntry = new Pair<>(String.class, createMockHandler()); [EOL] typeHierarchyList.add(nonMatchingEntry); [EOL] T actualHandler = getHandlerForTypeHierarchy(noMatchType); [EOL] assertNull(actualHandler); [EOL] }
public synchronized boolean hasSpecificHandlerFor(Type type) { [EOL] return map.containsKey(type); [EOL] }
public void testGetIndexOfSpecificHandlerForTypeHierarchy_WithExistingType() { [EOL] Class<?> specificType = String.class; // Assuming String class for simplicity [EOL] Pair<Class<?>, Object> pair = new Pair<>(specificType, new Object()); [EOL] typeHierarchyList.add(pair); [EOL] int index = getIndexOfSpecificHandlerForTypeHierarchy(specificType); [EOL] assertEquals(typeHierarchyList.size() - 1, index); [EOL] }
public void testGetIndexOfSpecificHandlerForTypeHierarchy_WithNonExistingType() { [EOL] Class<?> specificType = String.class; // Assuming String class for simplicity [EOL] Class<?> nonExistingType = Integer.class; // Assuming Integer class for simplicity [EOL] Pair<Class<?>, Object> pair = new Pair<>(specificType, new Object()); [EOL] typeHierarchyList.add(pair); [EOL] int index = getIndexOfSpecificHandlerForTypeHierarchy(nonExistingType); [EOL] assertEquals(-1, index); [EOL] }
public void testCopyOfEmptyMap() { [EOL] ParameterizedTypeHandlerMap<Object> original = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<Object> copy = original.copyOf(); [EOL] assertTrue(copy.map.isEmpty()); [EOL] assertTrue(copy.typeHierarchyList.isEmpty()); [EOL] }
public void testCopyOfMapWithEntries() { [EOL] ParameterizedTypeHandlerMap<Object> original = new ParameterizedTypeHandlerMap<>(); [EOL] original.register(String.class, new Object()); [EOL] original.register(Integer.class, new Object()); [EOL] ParameterizedTypeHandlerMap<Object> copy = original.copyOf(); [EOL] assertEquals(original.map.size(), copy.map.size()); [EOL] for (Map.Entry<Type, Object> entry : original.map.entrySet()) { [EOL] assertEquals(entry.getValue(), copy.map.get(entry.getKey())); [EOL] } [EOL] }
public void testCopyOfMapWithTypeHierarchy() { [EOL] ParameterizedTypeHandlerMap<Object> original = new ParameterizedTypeHandlerMap<>(); [EOL] original.registerForTypeHierarchy(new Pair<Class<?>, Object>(Number.class, new Object())); [EOL] ParameterizedTypeHandlerMap<Object> copy = original.copyOf(); [EOL] assertEquals(original.typeHierarchyList.size(), copy.typeHierarchyList.size()); [EOL] for (int i = 0; i < original.typeHierarchyList.size(); i++) { [EOL] Pair<Class<?>, Object> originalEntry = original.typeHierarchyList.get(i); [EOL] Pair<Class<?>, Object> copyEntry = copy.typeHierarchyList.get(i); [EOL] assertEquals(originalEntry.first, copyEntry.first); [EOL] assertEquals(originalEntry.second, copyEntry.second); [EOL] } [EOL] }
public void testParseValidJsonString() { [EOL] String json = "{\"key\":\"value\"}"; [EOL] JsonElement result = new JsonParser().parse(json); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] assertEquals("value", result.getAsJsonObject().get("key").getAsString()); [EOL] }
public void testParseEmptyJsonString() { [EOL] String json = "{}"; [EOL] JsonElement result = new JsonParser().parse(json); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] assertEquals(0, result.getAsJsonObject().size()); [EOL] }
public void testParseInvalidJsonString() { [EOL] String json = "{key:\"value\""; // Missing closing bracket [EOL] try { [EOL] new JsonParser().parse(json); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public JsonElement parse_validReaderInput_returnsJsonElement() throws JsonParseException { [EOL] Reader json = new StringReader("{\"key\":\"value\"}"); [EOL] JsonElement result = parse(json); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] assertEquals("value", result.getAsJsonObject().get("key").getAsString()); [EOL] } [EOL] public JsonElement parse_nullReader_throwsException() { [EOL] Reader json = null; [EOL] try { [EOL] parse(json); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] } [EOL] public JsonElement parse_emptyReader_throwsException() { [EOL] Reader json = new StringReader(""); [EOL] try { [EOL] parse(json); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] } [EOL] public JsonElement parse_invalidJson_throwsException() { [EOL] Reader json = new StringReader("{invalid json}"); [EOL] try { [EOL] parse(json); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testParseWithNonLenientJsonReader() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.setLenient(false); [EOL] JsonParser parser = new JsonParser(); [EOL] JsonElement result = parser.parse(jsonReader); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] } [EOL] public void testParseWithLenientJsonReader() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.setLenient(true); [EOL] JsonParser parser = new JsonParser(); [EOL] JsonElement result = parser.parse(jsonReader); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] } [EOL] public void testParseThrowsStackOverflowError() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")) { [EOL] @Override [EOL] public JsonElement parse(JsonReader json) throws JsonParseException { [EOL] throw new StackOverflowError(); [EOL] } [EOL] }; [EOL] JsonParser parser = new JsonParser(); [EOL] try { [EOL] parser.parse(jsonReader); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] assertEquals("Failed parsing JSON source: " + jsonReader + " to Json", expected.getMessage()); [EOL] } [EOL] } [EOL] public void testParseThrowsOutOfMemoryError() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")) { [EOL] @Override [EOL] public JsonElement parse(JsonReader json) throws JsonParseException { [EOL] throw new OutOfMemoryError(); [EOL] } [EOL] }; [EOL] JsonParser parser = new JsonParser(); [EOL] try { [EOL] parser.parse(jsonReader); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] assertEquals("Failed parsing JSON source: " + jsonReader + " to Json", expected.getMessage()); [EOL] } [EOL] } [EOL] public void testParseThrowsJsonParseExceptionWithEOFException() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")) { [EOL] @Override [EOL] public JsonElement parse(JsonReader json) throws JsonParseException { [EOL] throw new JsonParseException("EOF Exception", new EOFException()); [EOL] } [EOL] }; [EOL] JsonParser parser = new JsonParser(); [EOL] JsonElement result = parser.parse(jsonReader); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonNull()); [EOL] } [EOL] public void testParseThrowsJsonParseExceptionWithoutEOFException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")) { [EOL] @Override [EOL] public JsonElement parse(JsonReader json) throws JsonParseException { [EOL] throw new JsonParseException("Some error"); [EOL] } [EOL] }; [EOL] JsonParser parser = new JsonParser(); [EOL] try { [EOL] parser.parse(jsonReader); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] assertEquals("Some error", expected.getMessage()); [EOL] } [EOL] }
public void testParameterizedTypeImplWithNonNullValues() { [EOL] Type rawType = String.class; [EOL] Type[] actualTypeArguments = new Type[] { Integer.class }; [EOL] Type owner = Double.class; [EOL] ParameterizedTypeImpl parameterizedType = new ParameterizedTypeImpl(rawType, actualTypeArguments, owner); [EOL] assertNotNull(parameterizedType.rawType); [EOL] assertNotNull(parameterizedType.actualTypeArguments); [EOL] assertNotNull(parameterizedType.owner); [EOL] assertEquals(rawType, parameterizedType.rawType); [EOL] assertEquals(actualTypeArguments, parameterizedType.actualTypeArguments); [EOL] assertEquals(owner, parameterizedType.owner); [EOL] } [EOL] public void testParameterizedTypeImplWithNullValues() { [EOL] ParameterizedTypeImpl parameterizedType = new ParameterizedTypeImpl(null, null, null); [EOL] assertNull(parameterizedType.rawType); [EOL] assertNull(parameterizedType.actualTypeArguments); [EOL] assertNull(parameterizedType.owner); [EOL] }
public void testGsonConstructorWithAllParameters() { [EOL] ExclusionStrategy mockSerializationStrategy = mock(ExclusionStrategy.class); [EOL] ExclusionStrategy mockDeserializationStrategy = mock(ExclusionStrategy.class); [EOL] FieldNamingStrategy2 mockFieldNamingPolicy = mock(FieldNamingStrategy2.class); [EOL] MappedObjectConstructor mockObjectConstructor = mock(MappedObjectConstructor.class); [EOL] boolean serializeNulls = true; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> mockSerializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> mockDeserializers = new ParameterizedTypeHandlerMap<>(); [EOL] boolean generateNonExecutableGson = true; [EOL] boolean htmlSafe = true; [EOL] boolean prettyPrinting = true; [EOL] Gson gson = new Gson(mockSerializationStrategy, mockDeserializationStrategy, mockFieldNamingPolicy, mockObjectConstructor, serializeNulls, mockSerializers, mockDeserializers, generateNonExecutableGson, htmlSafe, prettyPrinting); [EOL] assertNotNull(gson); [EOL] assertEquals(mockSerializationStrategy, gson.serializationStrategy); [EOL] assertEquals(mockDeserializationStrategy, gson.deserializationStrategy); [EOL] assertEquals(mockFieldNamingPolicy, gson.fieldNamingPolicy); [EOL] assertEquals(mockObjectConstructor, gson.objectConstructor); [EOL] assertEquals(serializeNulls, gson.serializeNulls); [EOL] assertEquals(mockSerializers, gson.serializers); [EOL] assertEquals(mockDeserializers, gson.deserializers); [EOL] assertEquals(generateNonExecutableGson, gson.generateNonExecutableJson); [EOL] assertEquals(htmlSafe, gson.htmlSafe); [EOL] assertEquals(prettyPrinting, gson.prettyPrinting); [EOL] }
public void testGsonConstructorWithDefaultParameters() { [EOL] Gson gson = new Gson(); [EOL] assertNotNull(gson); [EOL] assertNull(gson.serializationStrategy); [EOL] assertNull(gson.deserializationStrategy); [EOL] assertNotNull(gson.fieldNamingPolicy); [EOL] assertNotNull(gson.objectConstructor); [EOL] assertFalse(gson.serializeNulls); [EOL] assertNotNull(gson.serializers); [EOL] assertNotNull(gson.deserializers); [EOL] assertFalse(gson.generateNonExecutableJson); [EOL] assertFalse(gson.htmlSafe); [EOL] assertFalse(gson.prettyPrinting); [EOL] }
private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) { [EOL] return new ObjectNavigatorFactory(strategy, fieldNamingPolicy); [EOL] } [EOL] public Gson(); [EOL] Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); [EOL] private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); [EOL] private static ExclusionStrategy createExclusionStrategy(double version); [EOL] public JsonElement toJsonTree(Object src); [EOL] public JsonElement toJsonTree(Object src, Type typeOfSrc); [EOL] public String toJson(Object src); [EOL] public String toJson(Object src, Type typeOfSrc); [EOL] public void toJson(Object src, Appendable writer); [EOL] public void toJson(Object src, Type typeOfSrc, Appendable writer); [EOL] public void toJson(Object src, Type typeOfSrc, JsonWriter writer); [EOL] public String toJson(JsonElement jsonElement); [EOL] public void toJson(JsonElement jsonElement, Appendable writer); [EOL] public void toJson(JsonElement jsonElement, JsonWriter writer); [EOL] public T fromJson(String json, Class<T> classOfT) throws JsonParseException; [EOL] public T fromJson(String json, Type typeOfT) throws JsonParseException; [EOL] public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; [EOL] public T fromJson(Reader json, Type typeOfT) throws JsonParseException; [EOL] public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; [EOL] public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; [EOL] public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; [EOL] private void writeOutNullString(Appendable writer) throws IOException; [EOL] public String toString(); [EOL] String NULL_STRING=Optional["null"]; [EOL] boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; [EOL] AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; [EOL] SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; [EOL] ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; [EOL] FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; [EOL] ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; [EOL] String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}???
private static ExclusionStrategy createExclusionStrategy(double version) { [EOL] List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL] strategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY); [EOL] strategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY); [EOL] strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY); [EOL] if (version != VersionConstants.IGNORE_VERSIONS) { [EOL] strategies.add(new VersionExclusionStrategy(version)); [EOL] } [EOL] return new DisjunctionExclusionStrategy(strategies); [EOL] }
public void testFromJsonWithValidInput() throws JsonParseException { [EOL] Gson gson = new Gson(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] MyClass result = gson.fromJson(json, MyClass.class); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.getKey()); [EOL] }
public void testFromJsonWithInvalidInput() { [EOL] Gson gson = new Gson(); [EOL] String json = "invalid json"; [EOL] try { [EOL] MyClass result = gson.fromJson(json, MyClass.class); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonWithNullInput() { [EOL] Gson gson = new Gson(); [EOL] String json = null; [EOL] try { [EOL] MyClass result = gson.fromJson(json, MyClass.class); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonWithNullClass() { [EOL] Gson gson = new Gson(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] try { [EOL] MyClass result = gson.fromJson(json, null); [EOL] fail("NullPointerException expected"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFromJsonWithNullString() { [EOL] Gson gson = new Gson(); [EOL] String json = null; [EOL] Type typeOfT = String.class; [EOL] String result = gson.fromJson(json, typeOfT); [EOL] assertNull(result); [EOL] }
public void testFromJsonWithEmptyString() { [EOL] Gson gson = new Gson(); [EOL] String json = ""; [EOL] Type typeOfT = String.class; [EOL] String result = gson.fromJson(json, typeOfT); [EOL] assertEquals("", result); [EOL] }
public void testFromJsonWithValidString() { [EOL] Gson gson = new Gson(); [EOL] String json = "\"test\""; [EOL] Type typeOfT = String.class; [EOL] String result = gson.fromJson(json, typeOfT); [EOL] assertEquals("test", result); [EOL] }
public void testFromJsonWithType() { [EOL] Gson gson = new Gson(); [EOL] String json = "{\"name\":\"test\"}"; [EOL] Type typeOfT = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Map<String, String> result = gson.fromJson(json, typeOfT); [EOL] assertNotNull(result); [EOL] assertEquals("test", result.get("name")); [EOL] }
public void testFromJsonReaderType() throws JsonParseException { [EOL] Gson gson = new Gson(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] Type type = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Reader reader = new StringReader(json); [EOL] Map<String, String> result = gson.fromJson(reader, type); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testFromJsonReaderTypeThrowsException() { [EOL] Gson gson = new Gson(); [EOL] String json = "invalid json"; [EOL] Type type = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Reader reader = new StringReader(json); [EOL] try { [EOL] gson.fromJson(reader, type); [EOL] fail("fromJson should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] } [EOL] }
public void testFromJsonWithJsonReaderAndType() throws JsonParseException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key\":\"value\"}")); [EOL] Type typeOfT = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Gson gson = new Gson(); [EOL] Map<String, String> result = gson.fromJson(reader, typeOfT); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] assertTrue(reader.isLenient()); [EOL] }
public void testFromJsonWithJsonReaderAndTypeLeniencyReset() throws JsonParseException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key\":\"value\"}")); [EOL] reader.setLenient(false); [EOL] Type typeOfT = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Gson gson = new Gson(); [EOL] try { [EOL] gson.fromJson(reader, typeOfT); [EOL] } catch (JsonParseException e) { [EOL] } finally { [EOL] assertFalse(reader.isLenient()); [EOL] } [EOL] }
public void testFromJsonWithNullJsonElement() { [EOL] Gson gson = new Gson(); [EOL] JsonElement jsonElement = null; [EOL] Type typeOfT = String.class; [EOL] Object result = gson.fromJson(jsonElement, typeOfT); [EOL] assertNull(result); [EOL] }
public void testFromJsonWithNonNullJsonElement() { [EOL] Gson gson = new Gson(); [EOL] JsonElement jsonElement = new JsonPrimitive("test"); [EOL] Type typeOfT = String.class; [EOL] Object result = gson.fromJson(jsonElement, typeOfT); [EOL] assertNotNull(result); [EOL] assertEquals("test", result); [EOL] }
public void testAddWithNonNullValues() { [EOL] Map<Class<?>, Class<?>> forward = new HashMap<>(); [EOL] Map<Class<?>, Class<?>> backward = new HashMap<>(); [EOL] Class<?> key = String.class; [EOL] Class<?> value = Integer.class; [EOL] add(forward, backward, key, value); [EOL] assertEquals("Forward map should contain the key-value pair", value, forward.get(key)); [EOL] assertEquals("Backward map should contain the value-key pair", key, backward.get(value)); [EOL] }
public void testCompositionFieldNamingPolicyWithNull() { [EOL] try { [EOL] new CompositionFieldNamingPolicy(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("naming policies can not be null.", e.getMessage()); [EOL] } [EOL] }
public void testCompositionFieldNamingPolicyWithEmpty() { [EOL] CompositionFieldNamingPolicy policy = new CompositionFieldNamingPolicy(new RecursiveFieldNamingPolicy[0]); [EOL] assertNotNull(policy); [EOL] }
public void testCompositionFieldNamingPolicyWithValidPolicies() { [EOL] RecursiveFieldNamingPolicy policy1 = mock(RecursiveFieldNamingPolicy.class); [EOL] RecursiveFieldNamingPolicy policy2 = mock(RecursiveFieldNamingPolicy.class); [EOL] CompositionFieldNamingPolicy policy = new CompositionFieldNamingPolicy(policy1, policy2); [EOL] assertNotNull(policy); [EOL] }
public void testTypeInfoCollectionWithParameterizedType() { [EOL] Type collectionType = new TypeToken<ArrayList<String>>(){}.getType(); [EOL] TypeInfoCollection typeInfoCollection = new TypeInfoCollection(collectionType); [EOL] assertNotNull(typeInfoCollection); [EOL] assertTrue(typeInfoCollection.collectionType instanceof ParameterizedType); [EOL] }
public void testTypeInfoCollectionWithNonParameterizedType() { [EOL] try { [EOL] Type collectionType = String.class; [EOL] new TypeInfoCollection(collectionType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Collection objects need to be parameterized unless you use a custom serializer. Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType.", e.getMessage()); [EOL] } [EOL] }
public void testGetElementTypeWithParameterizedType() { [EOL] TypeToken<List<String>> typeToken = new TypeToken<List<String>>() {}; [EOL] Type elementType = typeToken.getType().getElementType(); [EOL] assertTrue(elementType instanceof ParameterizedType); [EOL] ParameterizedType parameterizedType = (ParameterizedType) elementType; [EOL] assertEquals(String.class, parameterizedType.getActualTypeArguments()[0]); [EOL] }
public void testGetElementTypeWithGenericArrayType() { [EOL] TypeToken<List<String>[]> typeToken = new TypeToken<List<String>[]>() {}; [EOL] Type elementType = typeToken.getType().getElementType(); [EOL] assertTrue(elementType instanceof GenericArrayType); [EOL] GenericArrayType genericArrayType = (GenericArrayType) elementType; [EOL] assertEquals(String.class, ((ParameterizedType) genericArrayType.getGenericComponentType()).getActualTypeArguments()[0]); [EOL] }
public void testGetElementTypeWithWildcardType() { [EOL] TypeToken<List<? extends Number>> typeToken = new TypeToken<List<? extends Number>>() {}; [EOL] Type elementType = typeToken.getType().getElementType(); [EOL] assertTrue(elementType instanceof WildcardType); [EOL] WildcardType wildcardType = (WildcardType) elementType; [EOL] assertEquals(Number.class, wildcardType.getUpperBounds()[0]); [EOL] }
public void testGetElementTypeWithClassType() { [EOL] TypeToken<List<Integer>> typeToken = new TypeToken<List<Integer>>() {}; [EOL] Type elementType = typeToken.getType().getElementType(); [EOL] assertTrue(elementType instanceof Class); [EOL] assertEquals(Integer.class, elementType); [EOL] }
public void testJsonDeserializationContextDefaultWithValidArguments() { [EOL] ObjectNavigatorFactory navigatorFactory = mock(ObjectNavigatorFactory.class); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] MappedObjectConstructor objectConstructor = mock(MappedObjectConstructor.class); [EOL] JsonDeserializationContextDefault context = new JsonDeserializationContextDefault(navigatorFactory, deserializers, objectConstructor); [EOL] assertNotNull(context); [EOL] assertSame(navigatorFactory, context.navigatorFactory); [EOL] assertSame(deserializers, context.deserializers); [EOL] assertSame(objectConstructor, context.objectConstructor); [EOL] }
public void testGetObjectConstructor() { [EOL] MyClass instance = new MyClass(); [EOL] ObjectConstructor expected = instance.objectConstructor; [EOL] ObjectConstructor result = instance.getObjectConstructor(); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithNullJson() { [EOL] JsonElement json = null; [EOL] Type typeOfT = String.class; [EOL] Object result = deserialize(json, typeOfT); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithJsonNull() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] Type typeOfT = String.class; [EOL] Object result = deserialize(json, typeOfT); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add("element1"); [EOL] jsonArray.add("element2"); [EOL] Type typeOfT = new TypeToken<List<String>>() {}.getType(); [EOL] Object result = deserialize(jsonArray, typeOfT); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof List); [EOL] List<String> resultList = (List<String>) result; [EOL] assertEquals(2, resultList.size()); [EOL] assertEquals("element1", resultList.get(0)); [EOL] assertEquals("element2", resultList.get(1)); [EOL] }
public void testDeserializeWithJsonObject() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key1", "value1"); [EOL] jsonObject.addProperty("key2", "value2"); [EOL] Type typeOfT = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Object result = deserialize(jsonObject, typeOfT); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Map); [EOL] Map<String, String> resultMap = (Map<String, String>) result; [EOL] assertEquals(2, resultMap.size()); [EOL] assertEquals("value1", resultMap.get("key1")); [EOL] assertEquals("value2", resultMap.get("key2")); [EOL] }
public void testDeserializeWithJsonPrimitive() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("stringValue"); [EOL] Type typeOfT = String.class; [EOL] Object result = deserialize(jsonPrimitive, typeOfT); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof String); [EOL] assertEquals("stringValue", result); [EOL] }
public void testDeserializeWithInvalidJsonElement() { [EOL] JsonElement json = new JsonElement() { [EOL] }; [EOL] Type typeOfT = String.class; [EOL] try { [EOL] deserialize(json, typeOfT); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonObjectWithValidInput() { [EOL] Type typeOfT = new TypeToken<MyClass>(){}.getType(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key", "value"); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] MyClass result = fromJsonObject(typeOfT, jsonObject, context); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.getKey()); [EOL] } [EOL] public void testFromJsonObjectWithNullType() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key", "value"); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] MyClass result = fromJsonObject(null, jsonObject, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testFromJsonObjectWithNullJsonObject() { [EOL] Type typeOfT = new TypeToken<MyClass>(){}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] MyClass result = fromJsonObject(typeOfT, null, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testFromJsonObjectWithNullContext() { [EOL] Type typeOfT = new TypeToken<MyClass>(){}.getType(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key", "value"); [EOL] try { [EOL] MyClass result = fromJsonObject(typeOfT, jsonObject, null); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonPrimitiveWithValidType() throws JsonParseException { [EOL] Type typeOfT = String.class; [EOL] JsonPrimitive json = new JsonPrimitive("test"); [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] Object result = fromJsonPrimitive(typeOfT, json, context); [EOL] assertTrue(result instanceof String); [EOL] assertEquals("test", result); [EOL] }
public void testFromJsonPrimitiveWithInvalidType() { [EOL] Type typeOfT = String.class; [EOL] JsonPrimitive json = new JsonPrimitive(123); [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] try { [EOL] fromJsonPrimitive(typeOfT, json, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testGenericArrayTypeImplWithNonNullComponentType() { [EOL] Type expectedComponentType = String.class; [EOL] GenericArrayTypeImpl genericArrayType = new GenericArrayTypeImpl(expectedComponentType); [EOL] assertEquals(expectedComponentType, genericArrayType.getGenericComponentType()); [EOL] }
public void testGenericArrayTypeImplWithNullComponentType() { [EOL] GenericArrayTypeImpl genericArrayType = new GenericArrayTypeImpl(null); [EOL] assertNull(genericArrayType.getGenericComponentType()); [EOL] }
public void testJsonDeserializationVisitorWithNonNullParameters() { [EOL] JsonElement json = new JsonPrimitive("test"); [EOL] Type targetType = String.class; [EOL] ObjectNavigatorFactory factory = mock(ObjectNavigatorFactory.class); [EOL] ObjectConstructor objectConstructor = mock(ObjectConstructor.class); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] JsonDeserializationVisitor visitor = new JsonDeserializationVisitor( [EOL] json, targetType, factory, objectConstructor, deserializers, context [EOL] ); [EOL] assertNotNull(visitor); [EOL] }
public void testGetTarget_NotConstructed() { [EOL] MyClass myClass = new MyClass(); [EOL] T expected = myClass.constructTarget(); [EOL] T result = myClass.getTarget(); [EOL] assertEquals(expected, result); [EOL] assertTrue(myClass.constructed); [EOL] }
public void testGetTarget_AlreadyConstructed() { [EOL] MyClass myClass = new MyClass(); [EOL] myClass.target = myClass.constructTarget(); [EOL] myClass.constructed = true; [EOL] T expected = myClass.target; [EOL] T result = myClass.getTarget(); [EOL] assertEquals(expected, result); [EOL] }
It appears that the provided input text does not contain any actual implementation within the method body for the `start` method. The method body is empty, as indicated by `{ [EOL] }`. Without any logic or statements inside the method, there is no executable code to cover with unit tests. [EOL] In a typical scenario, to achieve maximum line coverage, we would create test cases that exercise all possible execution paths within the method. However, with an empty method body, there is only one execution path, which is the method entry and exit without doing anything. [EOL] If the method were to contain logic, we would create test cases to cover that logic. Since there is no logic to cover, there is no meaningful unit test case to generate for this method as it stands. If you provide a method with an actual implementation, I can generate meaningful unit test cases for it.
It appears that the provided method `end(ObjectTypePair node)` is empty and does not contain any executable code. Since there are no lines of code within the method, there is no possibility of achieving line coverage through unit tests. Therefore, no unit test cases can be generated for this method as it stands. [EOL] If the method had contained logic or code to execute, I would have provided test cases to cover those lines of code. However, in this case, there is nothing to test. If you have another method with executable code, please provide it, and I can generate the corresponding unit test cases.
public void testVisitUsingCustomHandlerWithNoMatchingHandler() { [EOL] ObjectTypePair objTypePair = mock(ObjectTypePair.class); [EOL] when(objTypePair.getMatchingHandler(anyMap())).thenReturn(null); [EOL] CustomDeserializationVisitor visitor = new CustomDeserializationVisitor(); [EOL] boolean result = visitor.visitUsingCustomHandler(objTypePair); [EOL] assertFalse(result); [EOL] }
public void testVisitUsingCustomHandlerWithMatchingHandler() { [EOL] ObjectTypePair objTypePair = mock(ObjectTypePair.class); [EOL] Pair<JsonDeserializer<?>, ObjectTypePair> handlerPair = new Pair<>(mock(JsonDeserializer.class), objTypePair); [EOL] when(objTypePair.getMatchingHandler(anyMap())).thenReturn(handlerPair); [EOL] when(handlerPair.getFirst()).thenReturn(mock(JsonDeserializer.class)); [EOL] CustomDeserializationVisitor visitor = new CustomDeserializationVisitor(); [EOL] boolean result = visitor.visitUsingCustomHandler(objTypePair); [EOL] assertTrue(result); [EOL] assertTrue(visitor.constructed); [EOL] assertNotNull(visitor.target); [EOL] }
public void testInvokeCustomDeserializerWithNullElement() { [EOL] JsonElement element = null; [EOL] Pair<JsonDeserializer<?>, ObjectTypePair> pair = new Pair<>(mock(JsonDeserializer.class), new ObjectTypePair(null, null, false)); [EOL] Object result = invokeCustomDeserializer(element, pair); [EOL] assertNull(result); [EOL] }
public void testInvokeCustomDeserializerWithJsonNull() { [EOL] JsonElement element = JsonNull.INSTANCE; [EOL] Pair<JsonDeserializer<?>, ObjectTypePair> pair = new Pair<>(mock(JsonDeserializer.class), new ObjectTypePair(null, null, false)); [EOL] Object result = invokeCustomDeserializer(element, pair); [EOL] assertNull(result); [EOL] }
public void testInvokeCustomDeserializerWithNonNullElement() { [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] ObjectTypePair objectTypePair = new ObjectTypePair(new TypeToken<String>(){}.getType(), null, false); [EOL] Pair<JsonDeserializer<?>, ObjectTypePair> pair = new Pair<>(deserializer, objectTypePair); [EOL] when(deserializer.deserialize(eq(element), any(Type.class), any(JsonDeserializationContext.class))).thenReturn("DeserializedResult"); [EOL] Object result = invokeCustomDeserializer(element, pair); [EOL] assertNotNull(result); [EOL] assertEquals("DeserializedResult", result); [EOL] }
public void testConstructWithInstanceCreator() { [EOL] TypeToken<String> typeOfT = TypeToken.get(String.class); [EOL] InstanceCreator<String> creator = type -> "Created"; [EOL] InstanceCreatorMap instanceCreatorMap = new InstanceCreatorMap(); [EOL] instanceCreatorMap.register(typeOfT.getType(), creator); [EOL] ConstructorConstructor constructorConstructor = new ConstructorConstructor(instanceCreatorMap); [EOL] String result = constructorConstructor.construct(typeOfT.getType()); [EOL] assertEquals("Created", result); [EOL] }
public void testConstructWithNoArgConstructor() { [EOL] TypeToken<Integer> typeOfT = TypeToken.get(Integer.class); [EOL] InstanceCreatorMap instanceCreatorMap = new InstanceCreatorMap(); [EOL] ConstructorConstructor constructorConstructor = new ConstructorConstructor(instanceCreatorMap); [EOL] Integer result = constructorConstructor.construct(typeOfT.getType()); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.intValue()); [EOL] }
public void testConstructWithNoArgConstructor_Success() { [EOL] Type typeOfT = MyNoArgClass.class; [EOL] MyNoArgClass result = constructWithNoArgConstructor(typeOfT); [EOL] assertNotNull(result); [EOL] } [EOL] public void testConstructWithNoArgConstructor_NoConstructor() { [EOL] Type typeOfT = MyNoConstructorClass.class; [EOL] try { [EOL] constructWithNoArgConstructor(typeOfT); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("No-args constructor for " + typeOfT + " does not exist. Register an InstanceCreator with Gson for this type to fix this problem.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstructWithNoArgConstructor_InstantiationException() { [EOL] Type typeOfT = MyAbstractClass.class; [EOL] try { [EOL] constructWithNoArgConstructor(typeOfT); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Unable to invoke no-args constructor for " + typeOfT + ". Register an InstanceCreator with Gson for this type may fix this problem.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstructWithNoArgConstructor_IllegalAccessException() { [EOL] Type typeOfT = MyPrivateConstructorClass.class; [EOL] try { [EOL] constructWithNoArgConstructor(typeOfT); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Unable to invoke no-args constructor for " + typeOfT + ". Register an InstanceCreator with Gson for this type may fix this problem.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testConstructWithNoArgConstructor_InvocationTargetException() { [EOL] Type typeOfT = MyConstructorThrowsExceptionClass.class; [EOL] try { [EOL] constructWithNoArgConstructor(typeOfT); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Unable to invoke no-args constructor for " + typeOfT + ". Register an InstanceCreator with Gson for this type may fix this problem.", e.getMessage()); [EOL] } [EOL] }
public void testGetNoArgsConstructorWithClassHavingDefaultConstructor() throws NoSuchMethodException { [EOL] Constructor<String> constructor = getNoArgsConstructor(String.class); [EOL] assertNotNull(constructor); [EOL] assertEquals(0, constructor.getParameterTypes().length); [EOL] } [EOL] public void testGetNoArgsConstructorWithClassNotHavingDefaultConstructor() { [EOL] Constructor<Thread> constructor = getNoArgsConstructor(Thread.class); [EOL] assertNull(constructor); [EOL] } [EOL] public void testGetNoArgsConstructorWithPrimitiveType() { [EOL] Constructor<Integer> constructor = getNoArgsConstructor(int.class); [EOL] assertNull(constructor); [EOL] } [EOL] public void testGetNoArgsConstructorWithArrayType() { [EOL] Constructor<int[]> constructor = getNoArgsConstructor(int[].class); [EOL] assertNull(constructor); [EOL] } [EOL] public void testGetNoArgsConstructorWithInterface() { [EOL] Constructor<Runnable> constructor = getNoArgsConstructor(Runnable.class); [EOL] assertNull(constructor); [EOL] }
public void testGsonBuilderDefaultConstructor() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] assertNotNull(builder); [EOL] assertTrue(builder.exclusionStrategies.contains(Gson.DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY)); [EOL] assertTrue(builder.exclusionStrategies.contains(Gson.DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY)); [EOL] assertEquals(VersionConstants.IGNORE_VERSIONS, builder.ignoreVersionsAfter); [EOL] assertTrue(builder.serializeInnerClasses); [EOL] assertFalse(builder.prettyPrinting); [EOL] assertTrue(builder.escapeHtmlChars); [EOL] assertEquals(Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY, builder.modifierBasedExclusionStrategy); [EOL] assertFalse(builder.excludeFieldsWithoutExposeAnnotation); [EOL] assertEquals(LongSerializationPolicy.DEFAULT, builder.longSerializationPolicy); [EOL] assertEquals(Gson.DEFAULT_NAMING_POLICY, builder.fieldNamingPolicy); [EOL] assertNotNull(builder.instanceCreators); [EOL] assertNotNull(builder.serializers); [EOL] assertNotNull(builder.deserializers); [EOL] assertFalse(builder.serializeNulls); [EOL] assertEquals(DateFormat.DEFAULT, builder.dateStyle); [EOL] assertEquals(DateFormat.DEFAULT, builder.timeStyle); [EOL] assertFalse(builder.serializeSpecialFloatingPointValues); [EOL] assertFalse(builder.generateNonExecutableJson); [EOL] }
public void testSerializeSpecialFloatingPointValues() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.serializeSpecialFloatingPointValues(); [EOL] assertNotNull(returnedBuilder); [EOL] assertTrue(returnedBuilder.serializeSpecialFloatingPointValues); [EOL] }
public void testCreateWithDefaultSettings() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithNoSerializationForInnerClasses() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.disableInnerClassSerialization(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithVersionExclusion() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setVersion(1.0); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithExcludeFieldsWithoutExposeAnnotation() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.excludeFieldsWithoutExposeAnnotation(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testCreateWithCustomDatePattern() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setDateFormat("yyyy-MM-dd"); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithCustomDateStyle() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setDateFormat(DateFormat.LONG); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithCustomTimeStyle() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setDateFormat(DateFormat.LONG, DateFormat.LONG); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testCreateWithSerializeSpecialFloatingPointValues() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeSpecialFloatingPointValues(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithLongSerializationPolicy() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setLongSerializationPolicy(LongSerializationPolicy.STRING); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testCreateWithGenerateNonExecutableJson() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.generateNonExecutableJson(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithEscapeHtmlChars() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.disableHtmlEscaping(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithPrettyPrinting() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setPrettyPrinting(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testAddTypeAdaptersForDateWithPattern() { [EOL] String datePattern = "yyyy-MM-dd"; [EOL] int dateStyle = DateFormat.DEFAULT; [EOL] int timeStyle = DateFormat.DEFAULT; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers); [EOL] assertTrue(serializers.hasSpecificHandlerFor(Date.class)); [EOL] assertTrue(deserializers.hasSpecificHandlerFor(Date.class)); [EOL] }
public void testAddTypeAdaptersForDateWithStyle() { [EOL] String datePattern = null; [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers); [EOL] assertTrue(serializers.hasSpecificHandlerFor(Date.class)); [EOL] assertTrue(deserializers.hasSpecificHandlerFor(Date.class)); [EOL] }
public void testAddTypeAdaptersForDateWithDefaultStyle() { [EOL] String datePattern = null; [EOL] int dateStyle = DateFormat.DEFAULT; [EOL] int timeStyle = DateFormat.DEFAULT; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers); [EOL] assertFalse(serializers.hasSpecificHandlerFor(Date.class)); [EOL] assertFalse(deserializers.hasSpecificHandlerFor(Date.class)); [EOL] }
public void testTranslateNameWithLowerCase() { [EOL] String target = "TestCase"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = null; // Assuming annotations is not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("testcase", result); [EOL] } [EOL] public void testTranslateNameWithUpperCase() { [EOL] String target = "TESTCASE"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = null; // Assuming annotations is not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("testcase", result); [EOL] } [EOL] public void testTranslateNameWithMixedCase() { [EOL] String target = "TestCaSe"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = null; // Assuming annotations is not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("testcase", result); [EOL] } [EOL] public void testTranslateNameWithNumbers() { [EOL] String target = "Test123"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = null; // Assuming annotations is not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("test123", result); [EOL] } [EOL] public void testTranslateNameWithSpecialCharacters() { [EOL] String target = "Test-Case_Example!"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = null; // Assuming annotations is not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("test-case_example!", result); [EOL] }
public void testVersionExclusionStrategyWithValidVersion() { [EOL] double validVersion = 1.0; [EOL] VersionExclusionStrategy strategy = new VersionExclusionStrategy(validVersion); [EOL] assertEquals(validVersion, strategy.version, 0.0); [EOL] }
public void testVersionExclusionStrategyWithZeroVersion() { [EOL] double zeroVersion = 0.0; [EOL] VersionExclusionStrategy strategy = new VersionExclusionStrategy(zeroVersion); [EOL] assertEquals(zeroVersion, strategy.version, 0.0); [EOL] }
public void testVersionExclusionStrategyWithNegativeVersion() { [EOL] double negativeVersion = -1.0; [EOL] try { [EOL] new VersionExclusionStrategy(negativeVersion); [EOL] fail("Expected IllegalArgumentException for negative version"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testShouldSkipField_NoAnnotations() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getAnnotation(Since.class)).thenReturn(null); [EOL] when(f.getAnnotation(Until.class)).thenReturn(null); [EOL] boolean result = shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_WithValidSinceAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Since sinceAnnotation = mock(Since.class); [EOL] when(sinceAnnotation.value()).thenReturn(1.0); [EOL] when(f.getAnnotation(Since.class)).thenReturn(sinceAnnotation); [EOL] when(f.getAnnotation(Until.class)).thenReturn(null); [EOL] boolean result = shouldSkipField(f); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_WithInvalidSinceAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Since sinceAnnotation = mock(Since.class); [EOL] when(sinceAnnotation.value()).thenReturn(Double.MAX_VALUE); [EOL] when(f.getAnnotation(Since.class)).thenReturn(sinceAnnotation); [EOL] when(f.getAnnotation(Until.class)).thenReturn(null); [EOL] boolean result = shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_WithValidUntilAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Until untilAnnotation = mock(Until.class); [EOL] when(untilAnnotation.value()).thenReturn(Double.MAX_VALUE); [EOL] when(f.getAnnotation(Since.class)).thenReturn(null); [EOL] when(f.getAnnotation(Until.class)).thenReturn(untilAnnotation); [EOL] boolean result = shouldSkipField(f); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_WithInvalidUntilAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Until untilAnnotation = mock(Until.class); [EOL] when(untilAnnotation.value()).thenReturn(1.0); [EOL] when(f.getAnnotation(Since.class)).thenReturn(null); [EOL] when(f.getAnnotation(Until.class)).thenReturn(untilAnnotation); [EOL] boolean result = shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_WithBothValidAnnotations() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Since sinceAnnotation = mock(Since.class); [EOL] Until untilAnnotation = mock(Until.class); [EOL] when(sinceAnnotation.value()).thenReturn(1.0); [EOL] when(untilAnnotation.value()).thenReturn(Double.MAX_VALUE); [EOL] when(f.getAnnotation(Since.class)).thenReturn(sinceAnnotation); [EOL] when(f.getAnnotation(Until.class)).thenReturn(untilAnnotation); [EOL] boolean result = shouldSkipField(f); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_WithBothInvalidAnnotations() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Since sinceAnnotation = mock(Since.class); [EOL] Until untilAnnotation = mock(Until.class); [EOL] when(sinceAnnotation.value()).thenReturn(Double.MAX_VALUE); [EOL] when(untilAnnotation.value()).thenReturn(1.0); [EOL] when(f.getAnnotation(Since.class)).thenReturn(sinceAnnotation); [EOL] when(f.getAnnotation(Until.class)).thenReturn(untilAnnotation); [EOL] boolean result = shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipClass_NoAnnotations() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(NoAnnotations.class); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipClass_WithValidSinceAnnotation() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(WithValidSince.class); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipClass_WithInvalidSinceAnnotation() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(WithInvalidSince.class); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipClass_WithValidUntilAnnotation() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(WithValidUntil.class); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipClass_WithInvalidUntilAnnotation() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(WithInvalidUntil.class); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipClass_WithValidSinceAndUntilAnnotations() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(WithValidSinceAndUntil.class); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipClass_WithInvalidSinceAndUntilAnnotations() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(WithInvalidSinceAndUntil.class); [EOL] assertTrue(result); [EOL] }
private boolean isValidSince(Since since) { [EOL] return since == null || since.value() <= version; [EOL] } [EOL] private boolean isValidUntil(Until until) { [EOL] return until == null || until.value() > version; [EOL] } [EOL] private double version = 1.0; [EOL] public void testIsValidVersionBothValid() { [EOL] Since since = new Since(1.0); [EOL] Until until = new Until(2.0); [EOL] boolean result = isValidVersion(since, until); [EOL] assert result; [EOL] } [EOL] public void testIsValidVersionSinceInvalid() { [EOL] Since since = new Since(2.0); [EOL] Until until = new Until(2.0); [EOL] boolean result = isValidVersion(since, until); [EOL] assert !result; [EOL] } [EOL] public void testIsValidVersionUntilInvalid() { [EOL] Since since = new Since(1.0); [EOL] Until until = new Until(1.0); [EOL] boolean result = isValidVersion(since, until); [EOL] assert !result; [EOL] } [EOL] public void testIsValidVersionBothNull() { [EOL] Since since = null; [EOL] Until until = null; [EOL] boolean result = isValidVersion(since, until); [EOL] assert result; [EOL] } [EOL] public void testIsValidVersionSinceNull() { [EOL] Since since = null; [EOL] Until until = new Until(2.0); [EOL] boolean result = isValidVersion(since, until); [EOL] assert result; [EOL] } [EOL] public void testIsValidVersionUntilNull() { [EOL] Since since = new Since(1.0); [EOL] Until until = null; [EOL] boolean result = isValidVersion(since, until); [EOL] assert result; [EOL] }
public void testIsValidSinceWithNullAnnotation() { [EOL] double version = 1.0; // Example version [EOL] boolean result = isValidSince(null); [EOL] assert result == true; [EOL] } [EOL] public void testIsValidSinceWithAnnotationVersionLessThanClassVersion() { [EOL] double version = 1.0; [EOL] Since annotation = new Since(0.5); // Assuming Since is an annotation with a 'value' method [EOL] boolean result = isValidSince(annotation); [EOL] assert result == true; [EOL] } [EOL] public void testIsValidSinceWithAnnotationVersionEqualToClassVersion() { [EOL] double version = 1.0; [EOL] Since annotation = new Since(1.0); [EOL] boolean result = isValidSince(annotation); [EOL] assert result == true; [EOL] } [EOL] public void testIsValidSinceWithAnnotationVersionGreaterThanClassVersion() { [EOL] double version = 1.0; [EOL] Since annotation = new Since(1.5); [EOL] boolean result = isValidSince(annotation); [EOL] assert result == false; [EOL] }
public void testIsValidUntilWithNullAnnotation() { [EOL] final double version = 1.0; [EOL] ExclusionStrategy underTest = new CustomExclusionStrategy(version); [EOL] boolean result = underTest.isValidUntil(null); [EOL] assertTrue(result); [EOL] }
public void testIsValidUntilWithValidAnnotation() { [EOL] final double version = 1.0; [EOL] final double annotationValue = 1.5; [EOL] Until annotation = new Until(annotationValue); [EOL] ExclusionStrategy underTest = new CustomExclusionStrategy(version); [EOL] boolean result = underTest.isValidUntil(annotation); [EOL] assertTrue(result); [EOL] }
public void testIsValidUntilWithInvalidAnnotation() { [EOL] final double version = 1.0; [EOL] final double annotationValue = 0.5; [EOL] Until annotation = new Until(annotationValue); [EOL] ExclusionStrategy underTest = new CustomExclusionStrategy(version); [EOL] boolean result = underTest.isValidUntil(annotation); [EOL] assertFalse(result); [EOL] }
public void testCamelCaseSeparatorNamingPolicyWithNonNullSeparator() { [EOL] String separator = "_"; [EOL] CamelCaseSeparatorNamingPolicy policy = new CamelCaseSeparatorNamingPolicy(separator); [EOL] assertNotNull(policy); [EOL] }
public void testCamelCaseSeparatorNamingPolicyWithNullSeparator() { [EOL] try { [EOL] new CamelCaseSeparatorNamingPolicy(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testCamelCaseSeparatorNamingPolicyWithEmptySeparator() { [EOL] try { [EOL] new CamelCaseSeparatorNamingPolicy(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testGetWrappedClassWithPrimitiveType() { [EOL] TypeToken<Integer> typeToken = TypeToken.get(int.class); [EOL] Class<?> wrappedClass = typeToken.getWrappedClass(); [EOL] assertEquals(Integer.class, wrappedClass); [EOL] }
public void testGetWrappedClassWithNonPrimitiveType() { [EOL] TypeToken<String> typeToken = TypeToken.get(String.class); [EOL] Class<?> wrappedClass = typeToken.getWrappedClass(); [EOL] assertEquals(String.class, wrappedClass); [EOL] }
public void testFieldAttributesWithValidInput() { [EOL] Class<?> declaringClazz = String.class; [EOL] Field f = declaringClazz.getDeclaredFields()[0]; [EOL] FieldAttributes fieldAttributes = new FieldAttributes(declaringClazz, f); [EOL] assertNotNull(fieldAttributes); [EOL] assertEquals(declaringClazz, fieldAttributes.getDeclaringClass()); [EOL] assertEquals(f.getName(), fieldAttributes.getName()); [EOL] assertEquals(f.getType(), fieldAttributes.getDeclaredType()); [EOL] assertEquals(f.isSynthetic(), fieldAttributes.isSynthetic()); [EOL] assertEquals(f.getModifiers(), fieldAttributes.getModifiers()); [EOL] }
public void testFieldAttributesWithNullDeclaringClass() { [EOL] try { [EOL] new FieldAttributes(null, String.class.getDeclaredFields()[0]); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFieldAttributesWithNullField() { [EOL] try { [EOL] new FieldAttributes(String.class, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetMaxCacheSizeWithValidSystemProperty() { [EOL] System.setProperty(MAX_CACHE_PROPERTY_NAME, "3000"); [EOL] int maxCacheSize = getMaxCacheSize(); [EOL] assertEquals(3000, maxCacheSize); [EOL] System.clearProperty(MAX_CACHE_PROPERTY_NAME); [EOL] }
public void testGetMaxCacheSizeWithInvalidSystemProperty() { [EOL] System.setProperty(MAX_CACHE_PROPERTY_NAME, "invalid"); [EOL] int maxCacheSize = getMaxCacheSize(); [EOL] assertEquals(2000, maxCacheSize); [EOL] System.clearProperty(MAX_CACHE_PROPERTY_NAME); [EOL] }
public void testGetMaxCacheSizeWithNoSystemProperty() { [EOL] System.clearProperty(MAX_CACHE_PROPERTY_NAME); [EOL] int maxCacheSize = getMaxCacheSize(); [EOL] assertEquals(2000, maxCacheSize); [EOL] }
public void testGetName_WhenNameIsSet() { [EOL] MyClass instance = new MyClass("TestName"); [EOL] String expected = "TestName"; [EOL] String actual = instance.getName(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetName_WhenNameIsNull() { [EOL] MyClass instance = new MyClass(null); [EOL] String expected = null; [EOL] String actual = instance.getName(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAnnotationWithValidAnnotation() { [EOL] Class<MyAnnotation> annotationClass = MyAnnotation.class; [EOL] MyAnnotation result = obj.getAnnotation(annotationClass); [EOL] assertNotNull(result); [EOL] assertEquals("expectedValue", result.value()); [EOL] }
public void testGetAnnotationWithInvalidAnnotation() { [EOL] Class<OtherAnnotation> annotationClass = OtherAnnotation.class; [EOL] OtherAnnotation result = obj.getAnnotation(annotationClass); [EOL] assertNull(result); [EOL] }
public void testGetAnnotationWithNull() { [EOL] try { [EOL] obj.getAnnotation(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testGetAnnotations_CacheMiss() { [EOL] Field field = MyClass.class.getDeclaredField("myField"); [EOL] ReflectionCache reflectionCache = new ReflectionCache(); [EOL] ReflectionAccessor accessor = reflectionCache.get(field); [EOL] Collection<Annotation> result = accessor.getAnnotations(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(Arrays.asList(field.getAnnotations()), new ArrayList<>(result)); [EOL] }
public void testGetAnnotations_CacheHit() { [EOL] Field field = MyClass.class.getDeclaredField("myField"); [EOL] ReflectionCache reflectionCache = new ReflectionCache(); [EOL] ReflectionAccessor accessor = reflectionCache.get(field); [EOL] accessor.getAnnotations(); // Call once to cache the annotations [EOL] Collection<Annotation> result = accessor.getAnnotations(); // Call again to hit the cache [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(Arrays.asList(field.getAnnotations()), new ArrayList<>(result)); [EOL] }
public void testSetWithValidInstanceAndValue() throws IllegalAccessException { [EOL] Field field = MyClass.class.getDeclaredField("myField"); [EOL] field.setAccessible(true); [EOL] MyClass instance = new MyClass(); [EOL] Object value = "newValue"; [EOL] field.set(instance, value); [EOL] assertEquals("newValue", instance.getMyField()); [EOL] }
public void testSetWithNullInstance() { [EOL] Field field = MyClass.class.getDeclaredField("myField"); [EOL] field.setAccessible(true); [EOL] Object value = "newValue"; [EOL] try { [EOL] field.set(null, value); [EOL] fail("Expected IllegalAccessException to be thrown"); [EOL] } catch (IllegalAccessException expected) { [EOL] } [EOL] }
public void testSetWithInaccessibleField() { [EOL] Field field = MyClass.class.getDeclaredField("myField"); [EOL] MyClass instance = new MyClass(); [EOL] Object value = "newValue"; [EOL] try { [EOL] field.set(instance, value); [EOL] fail("Expected IllegalAccessException to be thrown"); [EOL] } catch (IllegalAccessException expected) { [EOL] } [EOL] }
public void testIsSyntheticTrue() { [EOL] FieldAttributes fieldAttributes = new FieldAttributes(SomeClass.class, SomeClass.class.getDeclaredField("syntheticField")); [EOL] assertTrue(fieldAttributes.isSynthetic()); [EOL] }
public void testIsSyntheticFalse() { [EOL] FieldAttributes fieldAttributes = new FieldAttributes(SomeClass.class, SomeClass.class.getDeclaredField("regularField")); [EOL] assertFalse(fieldAttributes.isSynthetic()); [EOL] }
public void testGetFieldObject() { [EOL] MyClass instance = new MyClass(); [EOL] Field expected = instance.field; // Assuming 'field' is accessible here, otherwise use reflection or other means to set it [EOL] Field result = instance.getFieldObject(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAnnotationFromArrayWithMatchingAnnotation() { [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] Override overrideAnnotation = MyClass.class.getMethod("myMethod").getAnnotation(Override.class); [EOL] annotations.add(overrideAnnotation); [EOL] Override result = getAnnotationFromArray(annotations, Override.class); [EOL] assertNotNull(result); [EOL] }
public void testGetAnnotationFromArrayWithNoMatchingAnnotation() { [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] Override overrideAnnotation = MyClass.class.getMethod("myMethod").getAnnotation(Override.class); [EOL] annotations.add(overrideAnnotation); [EOL] Deprecated result = getAnnotationFromArray(annotations, Deprecated.class); [EOL] assertNull(result); [EOL] }
public void testGetAnnotationFromArrayWithEmptyCollection() { [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] Override result = getAnnotationFromArray(annotations, Override.class); [EOL] assertNull(result); [EOL] }
public void testJsonPrimitiveWithNumber() { [EOL] Number numberValue = 10; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(numberValue); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] assertEquals(numberValue, jsonPrimitive.getAsNumber()); [EOL] }
public void testJsonPrimitiveWithBoolean() { [EOL] Boolean boolValue = true; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(boolValue); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] assertEquals(boolValue, jsonPrimitive.getAsBoolean()); [EOL] }
public void testJsonPrimitiveWithString() { [EOL] String stringValue = "test"; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(stringValue); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals(stringValue, jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithCharacter() { [EOL] Character charValue = 'a'; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(charValue); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals(Character.toString(charValue), jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithNullNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Number) null); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] assertNull(jsonPrimitive.getAsNumber()); [EOL] }
public void testJsonPrimitiveWithNullBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Boolean) null); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] assertNull(jsonPrimitive.getAsBooleanWrapper()); [EOL] }
public void testJsonPrimitiveWithNullString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((String) null); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] assertNull(jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithNullCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Character) null); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] assertNull(jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveHashCode() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] int hashCode = jsonPrimitive.hashCode(); [EOL] assertNotNull(hashCode); [EOL] }
public void testJsonPrimitiveEquals() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive3 = new JsonPrimitive(20); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive3)); [EOL] }
public void testJsonPrimitiveIsIntegral() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] }
public void testJsonPrimitiveIsFloatingPoint() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10.5); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] }
public void testGetAsNumber_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] Number result = jsonPrimitive.getAsNumber(); [EOL] assertEquals(10, result.intValue()); [EOL] }
public void testGetAsNumber_withStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("10"); [EOL] Number result = jsonPrimitive.getAsNumber(); [EOL] assertEquals(10, result.intValue()); [EOL] }
public void testGetAsNumber_withBoolean_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsNumber(); [EOL] fail("Expected exception to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testGetAsNumber_withCharacter_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsNumber(); [EOL] fail("Expected exception to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testHashCodeWithNullValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((String) null); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals(31, result); [EOL] }
public void testHashCodeWithIntegralValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123); [EOL] int result = jsonPrimitive.hashCode(); [EOL] long value = jsonPrimitive.getAsNumber().longValue(); [EOL] int expected = (int) (value ^ (value >>> 32)); [EOL] assertEquals(expected, result); [EOL] }
public void testHashCodeWithFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.456); [EOL] int result = jsonPrimitive.hashCode(); [EOL] long value = Double.doubleToLongBits(jsonPrimitive.getAsNumber().doubleValue()); [EOL] int expected = (int) (value ^ (value >>> 32)); [EOL] assertEquals(expected, result); [EOL] }
public void testHashCodeWithStringValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals("test".hashCode(), result); [EOL] }
public void testHashCodeWithBooleanValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals(Boolean.TRUE.hashCode(), result); [EOL] }
public void testHashCodeWithCharacterValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals(Character.valueOf('a').hashCode(), result); [EOL] }
public void testEquals_Reflexive() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.equals(jsonPrimitive)); [EOL] }
public void testEquals_Null() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.equals(new Object())); [EOL] }
public void testEquals_SameValueDifferentType() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitiveString = new JsonPrimitive("10"); [EOL] assertFalse(jsonPrimitiveInt.equals(jsonPrimitiveString)); [EOL] }
public void testEquals_SameIntegralValue() { [EOL] JsonPrimitive jsonPrimitiveInt1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitiveInt2 = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitiveInt1.equals(jsonPrimitiveInt2)); [EOL] }
public void testEquals_DifferentIntegralValue() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitiveLong = new JsonPrimitive(10L); [EOL] assertTrue(jsonPrimitiveInt.equals(jsonPrimitiveLong)); [EOL] }
public void testEquals_SameFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitiveDouble1 = new JsonPrimitive(10.0); [EOL] JsonPrimitive jsonPrimitiveDouble2 = new JsonPrimitive(10.0); [EOL] assertTrue(jsonPrimitiveDouble1.equals(jsonPrimitiveDouble2)); [EOL] }
public void testEquals_DifferentFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitiveFloat = new JsonPrimitive(10.0f); [EOL] JsonPrimitive jsonPrimitiveDouble = new JsonPrimitive(10.0); [EOL] assertTrue(jsonPrimitiveFloat.equals(jsonPrimitiveDouble)); [EOL] }
public void testEquals_DifferentValue() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(20); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testEquals_NullValue() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive((Number)null); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive((Number)null); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testEquals_NullAndNonNullValue() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive((Number)null); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testIsIntegralWithBigInteger() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(new BigInteger("123")); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithLong() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123L); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithInteger() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithShort() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((short) 123); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithByte() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((byte) 123); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithFloat() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.0f); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithDouble() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.0d); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("123"); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testGetAsBigIntegerThrowsException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] try { [EOL] jsonPrimitive.getAsBigInteger(); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testValidateWithNullFieldName() { [EOL] try { [EOL] validate(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testValidateWithEmptyFieldName() { [EOL] try { [EOL] validate(""); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(" is not a valid JSON field name.", e.getMessage()); [EOL] } [EOL] }
public void testValidateWithOnlySpacesFieldName() { [EOL] try { [EOL] validate("   "); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("    is not a valid JSON field name.", e.getMessage()); [EOL] } [EOL] }
public void testValidateWithInvalidFieldName() { [EOL] try { [EOL] validate("123"); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("123 is not a valid JSON field name.", e.getMessage()); [EOL] } [EOL] }
public void testValidateWithValidFieldName() { [EOL] String validFieldName = "validFieldName"; [EOL] String result = validate(validFieldName); [EOL] assertEquals(validFieldName, result); [EOL] }
public void testAddWithNonNullPropertyAndValue() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] String property = "key"; [EOL] JsonElement value = new JsonPrimitive("value"); [EOL] jsonObject.add(property, value); [EOL] assertEquals(value, jsonObject.get(property)); [EOL] }
public void testAddWithNonNullPropertyAndNullValue() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] String property = "key"; [EOL] JsonElement value = null; [EOL] jsonObject.add(property, value); [EOL] assertTrue(jsonObject.get(property).isJsonNull()); [EOL] }
public void testAddWithNullProperty() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] String property = null; [EOL] JsonElement value = new JsonPrimitive("value"); [EOL] try { [EOL] jsonObject.add(property, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRemove_existingProperty() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("property1", "value1"); [EOL] JsonElement removedElement = jsonObject.remove("property1"); [EOL] assertNotNull(removedElement); [EOL] assertEquals("value1", removedElement.getAsString()); [EOL] assertFalse(jsonObject.has("property1")); [EOL] }
public void testRemove_nonExistingProperty() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("property1", "value1"); [EOL] JsonElement removedElement = jsonObject.remove("property2"); [EOL] assertNull(removedElement); [EOL] assertTrue(jsonObject.has("property1")); [EOL] }
public void testHas_withExistingMember() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("existingMember", new JsonPrimitive("value")); [EOL] boolean result = jsonObject.has("existingMember"); [EOL] assertTrue(result); [EOL] }
public void testHas_withNonExistingMember() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] boolean result = jsonObject.has("nonExistingMember"); [EOL] assertFalse(result); [EOL] }
public void testGetWithExistingNonNullMember() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] String memberName = "member1"; [EOL] JsonElement memberElement = new JsonPrimitive("value"); [EOL] jsonObject.add(memberName, memberElement); [EOL] JsonElement result = jsonObject.get(memberName); [EOL] assertSame(memberElement, result); [EOL] }
public void testGetWithExistingNullMember() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] String memberName = "member2"; [EOL] jsonObject.add(memberName, JsonNull.INSTANCE); [EOL] JsonElement result = jsonObject.get(memberName); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testGetWithNonExistingMember() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] String memberName = "member3"; [EOL] JsonElement result = jsonObject.get(memberName); [EOL] assertNull(result); [EOL] }
public void testToStringWithEmptyObject() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{}", sb.toString()); [EOL] }
public void testToStringWithSingleMember() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key", new JsonPrimitive("value")); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{\"key\":\"value\"}", sb.toString()); [EOL] }
public void testToStringWithMultipleMembers() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", new JsonPrimitive("value1")); [EOL] jsonObject.add("key2", new JsonPrimitive("value2")); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{\"key1\":\"value1\",\"key2\":\"value2\"}", sb.toString()); [EOL] }
