public void testComputeValueFunctionLast() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LAST); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionLast", result, functionLast(context)); [EOL] }
public void testComputeValueFunctionPosition() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_POSITION); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionPosition", result, functionPosition(context)); [EOL] }
public void testComputeValueFunctionCount() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_COUNT); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionCount", result, functionCount(context)); [EOL] }
public void testComputeValueFunctionLang() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LANG); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionLang", result, functionLang(context)); [EOL] }
public void testComputeValueFunctionID() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_ID); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionID", result, functionID(context)); [EOL] }
public void testComputeValueFunctionLocalName() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LOCAL_NAME); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionLocalName", result, functionLocalName(context)); [EOL] }
public void testComputeValueFunctionNamespaceURI() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NAMESPACE_URI); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionNamespaceURI", result, functionNamespaceURI(context)); [EOL] }
public void testComputeValueFunctionName() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NAME); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionName", result, functionName(context)); [EOL] }
public void testComputeValueFunctionString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_STRING); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionString", result, functionString(context)); [EOL] }
public void testComputeValueFunctionConcat() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_CONCAT); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionConcat", result, functionConcat(context)); [EOL] }
public void testComputeValueFunctionStartsWith() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_STARTS_WITH); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionStartsWith", result, functionStartsWith(context)); [EOL] }
public void testComputeValueFunctionContains() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_CONTAINS); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionContains", result, functionContains(context)); [EOL] }
public void testComputeValueFunctionSubstringBefore() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUBSTRING_BEFORE); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionSubstringBefore", result, functionSubstringBefore(context)); [EOL] }
public void testComputeValueFunctionSubstringAfter() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUBSTRING_AFTER); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionSubstringAfter", result, functionSubstringAfter(context)); [EOL] }
public void testComputeValueFunctionSubstring() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUBSTRING); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionSubstring", result, functionSubstring(context)); [EOL] }
public void testComputeValueFunctionStringLength() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_STRING_LENGTH); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionStringLength", result, functionStringLength(context)); [EOL] }
public void testComputeValueFunctionNormalizeSpace() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NORMALIZE_SPACE); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionNormalizeSpace", result, functionNormalizeSpace(context)); [EOL] }
public void testComputeValueFunctionTranslate() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_TRANSLATE); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionTranslate", result, functionTranslate(context)); [EOL] }
public void testComputeValueFunctionBoolean() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_BOOLEAN); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionBoolean", result, functionBoolean(context)); [EOL] }
public void testComputeValueFunctionNot() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NOT); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionNot", result, functionNot(context)); [EOL] }
public void testComputeValueFunctionTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_TRUE); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionTrue", result, functionTrue(context)); [EOL] }
public void testComputeValueFunctionFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FALSE); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionFalse", result, functionFalse(context)); [EOL] }
public void testComputeValueFunctionNull() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NULL); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionNull", result, functionNull(context)); [EOL] }
public void testComputeValueFunctionNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NUMBER); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionNumber", result, functionNumber(context)); [EOL] }
public void testComputeValueFunctionSum() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUM); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionSum", result, functionSum(context)); [EOL] }
public void testComputeValueFunctionFloor() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FLOOR); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionFloor", result, functionFloor(context)); [EOL] }
public void testComputeValueFunctionCeiling() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_CEILING); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionCeiling", result, functionCeiling(context)); [EOL] }
public void testComputeValueFunctionRound() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_ROUND); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionRound", result, functionRound(context)); [EOL] }
public void testComputeValueFunctionKey() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_KEY); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionKey", result, functionKey(context)); [EOL] }
public void testComputeValueFunctionFormatNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FORMAT_NUMBER); [EOL] Object result = computeValue(context); [EOL] assertEquals("Expected result from functionFormatNumber", result, functionFormatNumber(context)); [EOL] }
public void testFunctionKeyWithValidArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JXPathContext jxpathContext = mock(JXPathContext.class); [EOL] NodePointer pointer = mock(NodePointer.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] when(context.getJXPathContext()).thenReturn(jxpathContext); [EOL] when(jxpathContext.getContextPointer()).thenReturn(pointer); [EOL] when(getArg1()).thenReturn(arg1); [EOL] when(getArg2()).thenReturn(arg2); [EOL] when(arg1.computeValue(context)).thenReturn("keyValue"); [EOL] when(arg2.computeValue(context)).thenReturn("valueValue"); [EOL] when(pointer.getPointerByKey(jxpathContext, "keyValue", "valueValue")).thenReturn(new Object()); [EOL] Object result = functionKey(context); [EOL] assertNotNull(result); [EOL] }
public void testFunctionKeyWithNullContext() { [EOL] EvalContext context = null; [EOL] try { [EOL] functionKey(context); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Expected exception message", e.getMessage()); [EOL] } [EOL] }
public void testDOMNamespaceIteratorWithNullParent() { [EOL] DOMNamespaceIterator iterator = new DOMNamespaceIterator(null); [EOL] assertNull("Parent node should be null", iterator.parent); [EOL] assertNotNull("Attributes list should not be null", iterator.attributes); [EOL] assertTrue("Attributes list should be empty", iterator.attributes.isEmpty()); [EOL] }
public void testDOMNamespaceIteratorWithNonNullParent() { [EOL] NodePointer mockParent = mock(NodePointer.class); [EOL] Node mockNode = mock(Node.class); [EOL] when(mockParent.getNode()).thenReturn(mockNode); [EOL] DOMNamespaceIterator iterator = new DOMNamespaceIterator(mockParent); [EOL] assertEquals("Parent node should be the one passed in constructor", mockParent, iterator.parent); [EOL] assertNotNull("Attributes list should not be null", iterator.attributes); [EOL] }
public void testCollectNamespacesWithParentNode() { [EOL] List attributes = new ArrayList(); [EOL] Node node = mock(Node.class); [EOL] Node parentNode = mock(Node.class); [EOL] when(node.getParentNode()).thenReturn(parentNode); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(parentNode.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] when(node.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] Attr attr = mock(Attr.class); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(attr.getPrefix()).thenReturn("xmlns"); [EOL] when(attr.getLocalName()).thenReturn("localName"); [EOL] collectNamespaces(attributes, node); [EOL] assertTrue(attributes.contains(attr)); [EOL] }
public void testCollectNamespacesWithDocumentNode() { [EOL] List attributes = new ArrayList(); [EOL] Node node = mock(Node.class); [EOL] Document document = mock(Document.class); [EOL] Element documentElement = mock(Element.class); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] when(((Document) node).getDocumentElement()).thenReturn(documentElement); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] when(documentElement.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] Attr attr = mock(Attr.class); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(attr.getPrefix()).thenReturn(null); [EOL] when(attr.getLocalName()).thenReturn("xmlns"); [EOL] collectNamespaces(attributes, node); [EOL] assertTrue(attributes.contains(attr)); [EOL] }
public void testCollectNamespacesWithElementNodeNoNamespace() { [EOL] List attributes = new ArrayList(); [EOL] Node node = mock(Node.class); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] when(node.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] Attr attr = mock(Attr.class); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(attr.getPrefix()).thenReturn("notXmlns"); [EOL] when(attr.getLocalName()).thenReturn("notXmlns"); [EOL] collectNamespaces(attributes, node); [EOL] assertFalse(attributes.contains(attr)); [EOL] }
public void testGetNodePointer_PositionIsZero_SetPositionFails() { [EOL] setInitialPosition(0); [EOL] mockSetPosition(1, false); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionIsZero_SetPositionSucceeds() { [EOL] setInitialPosition(0); [EOL] mockSetPosition(1, true); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PositionIsNegative() { [EOL] setInitialPosition(-1); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PrefixIsXmlns() { [EOL] setInitialPosition(1); // Assuming position starts at 1 for the first attribute [EOL] addAttributeWithPrefix("xmlns", "someValue"); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PrefixIsNotXmlns() { [EOL] setInitialPosition(1); // Assuming position starts at 1 for the first attribute [EOL] addAttributeWithPrefix("notXmlns", "someValue"); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testSetPositionWithinRange() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.addAttribute("attribute1"); [EOL] instance.addAttribute("attribute2"); [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue(result); [EOL] assertEquals(1, instance.getPosition()); [EOL] }
public void testSetPositionBelowRange() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.addAttribute("attribute1"); [EOL] boolean result = instance.setPosition(0); [EOL] assertFalse(result); [EOL] assertNotEquals(0, instance.getPosition()); [EOL] }
public void testSetPositionAboveRange() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.addAttribute("attribute1"); [EOL] boolean result = instance.setPosition(2); [EOL] assertFalse(result); [EOL] assertNotEquals(2, instance.getPosition()); [EOL] }
public void testCreateNodePointerWithDynamicBean() { [EOL] QName name = new QName("test"); [EOL] Object dynamicBean = new DynamicBean(); // Assuming DynamicBean is a class that is dynamic [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, dynamicBean, locale); [EOL] assertNotNull("Expected a non-null DynamicPointer", result); [EOL] assertTrue("Expected result to be instance of DynamicPointer", result instanceof DynamicPointer); [EOL] }
public void testCreateNodePointerWithStaticBean() { [EOL] QName name = new QName("test"); [EOL] Object staticBean = new StaticBean(); // Assuming StaticBean is a class that is not dynamic [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, staticBean, locale); [EOL] assertNull("Expected a null result for static bean", result); [EOL] }
public void testCreateNodePointerWithNullBean() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class available in the context [EOL] QName name = new QName("test"); // Assuming QName is a class available in the context [EOL] Object bean = null; [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof NullPointer); [EOL] }
public void testCreateNodePointerWithDynamicBean() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class available in the context [EOL] QName name = new QName("test"); // Assuming QName is a class available in the context [EOL] Object bean = new DynamicBean(); // Assuming DynamicBean is a dynamic bean class available in the context [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof DynamicPointer); [EOL] }
public void testCreateNodePointerWithNonDynamicBean() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class available in the context [EOL] QName name = new QName("test"); // Assuming QName is a class available in the context [EOL] Object bean = new NonDynamicBean(); // Assuming NonDynamicBean is a non-dynamic bean class available in the context [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public void testNamespaceIterator() { [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(new org.jdom2.Element("testElement")); [EOL] NodeIterator iterator = nodePointer.namespaceIterator(); [EOL] assertNotNull(iterator); [EOL] assertTrue(iterator instanceof JDOMNamespaceIterator); [EOL] }
public void testGetValueWithElement() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getTextTrim()).thenReturn("ElementText"); [EOL] Object result = getValue(node); [EOL] assertEquals("ElementText", result); [EOL] }
public void testGetValueWithCommentAndNonNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn("CommentText"); [EOL] Object result = getValue(node); [EOL] assertEquals("CommentText", result); [EOL] }
public void testGetValueWithCommentAndNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithText() { [EOL] Node node = mock(Text.class); [EOL] when(((Text) node).getTextTrim()).thenReturn("TextContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("TextContent", result); [EOL] }
public void testGetValueWithCdata() { [EOL] Node node = mock(CDATA.class); [EOL] when(((CDATA) node).getTextTrim()).thenReturn("CdataContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("CdataContent", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNonNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn("InstructionData"); [EOL] Object result = getValue(node); [EOL] assertEquals("InstructionData", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithUnknownNodeType() { [EOL] Node node = mock(Node.class); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testSetValueWithTextNodeAndNonEmptyString() { [EOL] Object value = "Non-empty string"; [EOL] Text textNode = new Text(); [EOL] YourClass instance = new YourClass(textNode); [EOL] instance.setValue(value); [EOL] assertEquals("Non-empty string", textNode.getText()); [EOL] }
public void testSetValueWithTextNodeAndEmptyString() { [EOL] Object value = ""; [EOL] Text textNode = new Text(); [EOL] YourClass instance = new YourClass(textNode); [EOL] Element parent = new Element("parent"); [EOL] parent.addContent(textNode); [EOL] instance.setValue(value); [EOL] assertFalse(parent.getContent().contains(textNode)); [EOL] }
public void testSetValueWithElementAndElementValue() { [EOL] Object value = new Element("valueElement"); [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertTrue(elementNode.getContent().contains(value)); [EOL] }
public void testSetValueWithElementAndDocumentValue() { [EOL] Object value = new Document(new Element("root")); [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertEquals(value.getContent(), elementNode.getContent()); [EOL] }
public void testSetValueWithElementAndTextValue() { [EOL] Object value = new Text("textValue"); [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertEquals("textValue", ((Text)elementNode.getContent().get(0)).getText()); [EOL] }
public void testSetValueWithElementAndCDATAValue() { [EOL] Object value = new CDATA("cdataValue"); [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertEquals("cdataValue", ((Text)elementNode.getContent().get(0)).getText()); [EOL] }
public void testSetValueWithElementAndProcessingInstructionValue() { [EOL] Object value = new ProcessingInstruction("target", "data"); [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertTrue(elementNode.getContent().get(0) instanceof ProcessingInstruction); [EOL] }
public void testSetValueWithElementAndCommentValue() { [EOL] Object value = new Comment("commentValue"); [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertTrue(elementNode.getContent().get(0) instanceof Comment); [EOL] }
public void testSetValueWithElementAndNonEmptyStringValue() { [EOL] Object value = "Non-empty string"; [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertEquals("Non-empty string", ((Text)elementNode.getContent().get(0)).getText()); [EOL] }
public void testSetValueWithElementAndNullValue() { [EOL] Object value = null; [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertTrue(elementNode.getContent().isEmpty()); [EOL] }
public void testSetValueWithElementAndEmptyStringValue() { [EOL] Object value = ""; [EOL] Element elementNode = new Element("element"); [EOL] YourClass instance = new YourClass(elementNode); [EOL] instance.setValue(value); [EOL] assertTrue(elementNode.getContent().isEmpty()); [EOL] }
public void testNodeWithNullTest() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] assertTrue(JxPath.testNode(mockPointer, mockNode, null)); [EOL] }
public void testNodeWithNodeNameTestAndElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Element mockElement = mock(Element.class); [EOL] NodeNameTest mockNodeNameTest = mock(NodeNameTest.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockNodeNameTest.getNodeName()).thenReturn(mockQName); [EOL] when(mockNodeNameTest.isWildcard()).thenReturn(false); [EOL] when(mockQName.getName()).thenReturn("testName"); [EOL] when(JDOMNodePointer.getLocalName(mockElement)).thenReturn("testName"); [EOL] when(mockNodeNameTest.getNamespaceURI()).thenReturn("testURI"); [EOL] when(JDOMNodePointer.getNamespaceURI(mockElement)).thenReturn("testURI"); [EOL] assertTrue(JxPath.testNode(mockPointer, mockElement, mockNodeNameTest)); [EOL] }
public void testNodeWithNodeNameTestAndNonElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] NodeNameTest mockNodeNameTest = mock(NodeNameTest.class); [EOL] assertFalse(JxPath.testNode(mockPointer, mockNode, mockNodeNameTest)); [EOL] }
public void testNodeWithNodeTypeTestAndElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Element mockElement = mock(Element.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] assertTrue(JxPath.testNode(mockPointer, mockElement, mockNodeTypeTest)); [EOL] }
public void testNodeWithNodeTypeTestAndTextNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Text mockText = mock(Text.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] assertTrue(JxPath.testNode(mockPointer, mockText, mockNodeTypeTest)); [EOL] }
public void testNodeWithNodeTypeTestAndCommentNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Comment mockComment = mock(Comment.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] assertTrue(JxPath.testNode(mockPointer, mockComment, mockNodeTypeTest)); [EOL] }
public void testNodeWithNodeTypeTestAndPINode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockPI = mock(ProcessingInstruction.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] assertTrue(JxPath.testNode(mockPointer, mockPI, mockNodeTypeTest)); [EOL] }
public void testNodeWithProcessingInstructionTest() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockPI = mock(ProcessingInstruction.class); [EOL] ProcessingInstructionTest mockPITest = mock(ProcessingInstructionTest.class); [EOL] when(mockPITest.getTarget()).thenReturn("testTarget"); [EOL] when(mockPI.getTarget()).thenReturn("testTarget"); [EOL] assertTrue(JxPath.testNode(mockPointer, mockPI, mockPITest)); [EOL] }
public void testNodeWithProcessingInstructionTestAndNonPINode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] ProcessingInstructionTest mockPITest = mock(ProcessingInstructionTest.class); [EOL] assertFalse(JxPath.testNode(mockPointer, mockNode, mockPITest)); [EOL] }
public void testGetPrefixWithElementHavingPrefix() { [EOL] Element mockElement = mock(Element.class); [EOL] when(mockElement.getNamespacePrefix()).thenReturn("prefix"); [EOL] String result = ClassName.getPrefix(mockElement); [EOL] assertEquals("prefix", result); [EOL] } [EOL] public void testGetPrefixWithElementHavingNoPrefix() { [EOL] Element mockElement = mock(Element.class); [EOL] when(mockElement.getNamespacePrefix()).thenReturn(""); [EOL] String result = ClassName.getPrefix(mockElement); [EOL] assertNull(result); [EOL] } [EOL] public void testGetPrefixWithElementHavingNullPrefix() { [EOL] Element mockElement = mock(Element.class); [EOL] when(mockElement.getNamespacePrefix()).thenReturn(null); [EOL] String result = ClassName.getPrefix(mockElement); [EOL] assertNull(result); [EOL] }
public void testGetPrefixWithAttributeHavingPrefix() { [EOL] Attribute mockAttribute = mock(Attribute.class); [EOL] when(mockAttribute.getNamespacePrefix()).thenReturn("prefix"); [EOL] String result = ClassName.getPrefix(mockAttribute); [EOL] assertEquals("prefix", result); [EOL] } [EOL] public void testGetPrefixWithAttributeHavingNoPrefix() { [EOL] Attribute mockAttribute = mock(Attribute.class); [EOL] when(mockAttribute.getNamespacePrefix()).thenReturn(""); [EOL] String result = ClassName.getPrefix(mockAttribute); [EOL] assertNull(result); [EOL] } [EOL] public void testGetPrefixWithAttributeHavingNullPrefix() { [EOL] Attribute mockAttribute = mock(Attribute.class); [EOL] when(mockAttribute.getNamespacePrefix()).thenReturn(null); [EOL] String result = ClassName.getPrefix(mockAttribute); [EOL] assertNull(result); [EOL] }
public void testGetPrefixWithNonElementOrAttribute() { [EOL] Object nonElementOrAttribute = new Object(); [EOL] String result = ClassName.getPrefix(nonElementOrAttribute); [EOL] assertNull(result); [EOL] }
public void testGetLocalNameWithElement() { [EOL] Element element = mock(Element.class); [EOL] when(element.getName()).thenReturn("elementName"); [EOL] String result = getLocalName(element); [EOL] assertEquals("elementName", result); [EOL] }
public void testGetLocalNameWithAttribute() { [EOL] Attribute attribute = mock(Attribute.class); [EOL] when(attribute.getName()).thenReturn("attributeName"); [EOL] String result = getLocalName(attribute); [EOL] assertEquals("attributeName", result); [EOL] }
public void testGetLocalNameWithNonRelevantObject() { [EOL] Object nonRelevantObject = new Object(); [EOL] String result = getLocalName(nonRelevantObject); [EOL] assertNull(result); [EOL] }
public void testNodeParentWithElementHavingElementParent() { [EOL] Element mockElement = mock(Element.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockElement.getParent()).thenReturn(mockParent); [EOL] when(mockParent instanceof Element).thenReturn(true); [EOL] Element result = nodeParent(mockElement); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithElementHavingNonElementParent() { [EOL] Element mockElement = mock(Element.class); [EOL] when(mockElement.getParent()).thenReturn(new Object()); [EOL] Element result = nodeParent(mockElement); [EOL] assertNull(result); [EOL] }
public void testNodeParentWithText() { [EOL] Text mockText = mock(Text.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockText.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockText); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithCDATA() { [EOL] CDATA mockCdata = mock(CDATA.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockCdata.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockCdata); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithProcessingInstruction() { [EOL] ProcessingInstruction mockInstruction = mock(ProcessingInstruction.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockInstruction.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockInstruction); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithComment() { [EOL] Comment mockComment = mock(Comment.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockComment.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockComment); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithUnrecognizedObject() { [EOL] Object mockObject = new Object(); [EOL] Element result = nodeParent(mockObject); [EOL] assertNull(result); [EOL] }
public void testCreateChildWithWholeCollectionIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = mock(NodePointer.class); [EOL] when(testNodePointer.getAbstractFactory(context)).thenReturn(mock(AbstractFactory.class)); [EOL] when(testNodePointer.getAbstractFactory(context).createObject(context, testNodePointer, testNodePointer.node, name.toString(), 0)).thenReturn(true); [EOL] when(context.getNamespaceURI(null)).thenReturn("namespace"); [EOL] when(context.getDefaultNamespaceURI()).thenReturn("defaultNamespace"); [EOL] NodeIterator nodeIterator = mock(NodeIterator.class); [EOL] when(testNodePointer.childIterator(any(NodeTest.class), eq(false), isNull())).thenReturn(nodeIterator); [EOL] when(nodeIterator.setPosition(1)).thenReturn(true); [EOL] NodePointer resultNodePointer = mock(NodePointer.class); [EOL] when(nodeIterator.getNodePointer()).thenReturn(resultNodePointer); [EOL] NodePointer result = testNodePointer.createChild(context, name, NodePointer.WHOLE_COLLECTION); [EOL] assertNotNull(result); [EOL] }
public void testCreateChildWithNonWholeCollectionIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = mock(NodePointer.class); [EOL] when(testNodePointer.getAbstractFactory(context)).thenReturn(mock(AbstractFactory.class)); [EOL] when(testNodePointer.getAbstractFactory(context).createObject(context, testNodePointer, testNodePointer.node, name.toString(), 1)).thenReturn(true); [EOL] when(context.getNamespaceURI(null)).thenReturn("namespace"); [EOL] when(context.getDefaultNamespaceURI()).thenReturn("defaultNamespace"); [EOL] NodeIterator nodeIterator = mock(NodeIterator.class); [EOL] when(testNodePointer.childIterator(any(NodeTest.class), eq(false), isNull())).thenReturn(nodeIterator); [EOL] when(nodeIterator.setPosition(2)).thenReturn(true); [EOL] NodePointer resultNodePointer = mock(NodePointer.class); [EOL] when(nodeIterator.getNodePointer()).thenReturn(resultNodePointer); [EOL] NodePointer result = testNodePointer.createChild(context, name, 1); [EOL] assertNotNull(result); [EOL] }
public void testCreateChildFailure() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = mock(NodePointer.class); [EOL] when(testNodePointer.getAbstractFactory(context)).thenReturn(mock(AbstractFactory.class)); [EOL] when(testNodePointer.getAbstractFactory(context).createObject(context, testNodePointer, testNodePointer.node, name.toString(), 1)).thenReturn(false); [EOL] try { [EOL] testNodePointer.createChild(context, name, 1); [EOL] fail("JXPathAbstractFactoryException expected"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] } [EOL] }
public void testCreateChildWithValidArguments() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testNamespace", "testName"); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockNodePointer.createChild(any(JXPathContext.class), any(QName.class), anyInt())).thenReturn(mockNodePointer); [EOL] NodePointer result = createChild(context, name, index, value); [EOL] verify(mockNodePointer).setValue(value); [EOL] assertEquals(mockNodePointer, result); [EOL] }
public void testCreateChildWithNullValue() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testNamespace", "testName"); [EOL] int index = 1; [EOL] Object value = null; [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockNodePointer.createChild(any(JXPathContext.class), any(QName.class), anyInt())).thenReturn(mockNodePointer); [EOL] NodePointer result = createChild(context, name, index, value); [EOL] verify(mockNodePointer).setValue(value); [EOL] assertEquals(mockNodePointer, result); [EOL] }
public void testCreateAttributeWithNonElementNode() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = new NodePointer() { [EOL] @Override [EOL] public boolean isLeaf() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean isCollection() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public Object getBaseValue() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Object getImmediateNode() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void setValue(Object value) { [EOL] } [EOL] @Override [EOL] public NodePointer createAttribute(JXPathContext context, QName name) { [EOL] return this; // Simulate super.createAttribute [EOL] } [EOL] }; [EOL] NodePointer result = testNodePointer.createAttribute(context, name); [EOL] assertSame("Expected the same NodePointer instance", testNodePointer, result); [EOL] }
public void testCreateAttributeWithElementNodeAndKnownNamespace() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] QName name = new QName("ns", "test"); [EOL] Element element = mock(Element.class); [EOL] Namespace ns = mock(Namespace.class); [EOL] when(element.getNamespace("ns")).thenReturn(ns); [EOL] when(element.getAttribute("test", ns)).thenReturn(null); [EOL] NodePointer testNodePointer = new NodePointer() { [EOL] @Override [EOL] public boolean isLeaf() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean isCollection() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public Object getBaseValue() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Object getImmediateNode() { [EOL] return element; [EOL] } [EOL] @Override [EOL] public void setValue(Object value) { [EOL] } [EOL] @Override [EOL] public NodeIterator attributeIterator(QName name) { [EOL] NodeIterator iterator = mock(NodeIterator.class); [EOL] when(iterator.getNodePointer()).thenReturn(this); [EOL] return iterator; [EOL] } [EOL] }; [EOL] NodePointer result = testNodePointer.createAttribute(context, name); [EOL] verify(element).setAttribute("test", "", ns); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] }
public void testCreateAttributeWithElementNodeAndUnknownNamespace() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] QName name = new QName("unknown", "test"); [EOL] Element element = mock(Element.class); [EOL] when(element.getNamespace("unknown")).thenReturn(null); [EOL] NodePointer testNodePointer = new NodePointer() { [EOL] @Override [EOL] public boolean isLeaf() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean isCollection() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public Object getBaseValue() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Object getImmediateNode() { [EOL] return element; [EOL] } [EOL] @Override [EOL] public void setValue(Object value) { [EOL] } [EOL] }; [EOL] try { [EOL] testNodePointer.createAttribute(context, name); [EOL] fail("JXPathException expected for unknown namespace prefix"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Unknown namespace prefix: unknown", e.getMessage()); [EOL] } [EOL] }
public void testCreateAttributeWithElementNodeAndNoNamespace() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] QName name = new QName("test"); [EOL] Element element = mock(Element.class); [EOL] when(element.getAttribute("test")).thenReturn(null); [EOL] NodePointer testNodePointer = new NodePointer() { [EOL] @Override [EOL] public boolean isLeaf() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean isCollection() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public Object getBaseValue() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Object getImmediateNode() { [EOL] return element; [EOL] } [EOL] @Override [EOL] public void setValue(Object value) { [EOL] } [EOL] @Override [EOL] public NodeIterator attributeIterator(QName name) { [EOL] NodeIterator iterator = mock(NodeIterator.class); [EOL] when(iterator.getNodePointer()).thenReturn(this); [EOL] return iterator; [EOL] } [EOL] }; [EOL] NodePointer result = testNodePointer.createAttribute(context, name); [EOL] verify(element).setAttribute("test", ""); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] }
public void testRemove_WithNonNullParent() { [EOL] Node mockNode = mock(Node.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(nodeParent(mockNode)).thenReturn(mockParent); [EOL] Content mockContent = mock(Content.class); [EOL] when(mockParent.getContent()).thenReturn(mockContent); [EOL] remove(mockNode); [EOL] verify(mockContent).remove(mockNode); [EOL] }
public void testRemove_WithNullParent() { [EOL] Node mockNode = mock(Node.class); [EOL] when(nodeParent(mockNode)).thenReturn(null); [EOL] try { [EOL] remove(mockNode); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot remove root JDOM node", e.getMessage()); [EOL] } [EOL] }
public void testAsPathWithIdNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setId("someId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id('someId')", result); [EOL] }
public void testAsPathWithParentNotNullElementNode() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setParent(new YourParentClass()); [EOL] instance.setNode(new Element()); [EOL] when(instance.getNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(instance.getRelativePositionByName()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/elementName[1]")); [EOL] }
public void testAsPathWithParentNotNullTextNode() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setParent(new YourParentClass()); [EOL] instance.setNode(new Text()); [EOL] when(instance.getRelativePositionOfTextNode()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/text()[1]")); [EOL] }
public void testAsPathWithParentNotNullProcessingInstruction() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setParent(new YourParentClass()); [EOL] instance.setNode(new ProcessingInstruction("target")); [EOL] when(instance.getRelativePositionOfPI("target")).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/processing-instruction('target')[1]")); [EOL] }
public void testAsPathWithParentNotNullElementNodeWithDifferentNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setParent(new YourParentClass()); [EOL] instance.setNode(new Element()); [EOL] when(instance.getNamespaceURI()).thenReturn("differentNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getPrefix("differentNamespaceURI")).thenReturn("prefix"); [EOL] when(instance.getRelativePositionByName()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("prefix:elementName[1]")); [EOL] }
public void testAsPathWithParentNotNullElementNodeWithNoNamespacePrefix() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setParent(new YourParentClass()); [EOL] instance.setNode(new Element()); [EOL] when(instance.getNamespaceURI()).thenReturn("differentNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getPrefix("differentNamespaceURI")).thenReturn(null); [EOL] when(instance.getRelativePositionOfElement()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("node()[1]")); [EOL] }
public void testGetRelativePositionOfTextNodeWithTextNode() { [EOL] Text textNode = mock(Text.class); [EOL] Element parentElement = mock(Element.class); [EOL] when(textNode.getParent()).thenReturn(parentElement); [EOL] List contentList = new ArrayList(); [EOL] contentList.add(textNode); [EOL] when(parentElement.getContent()).thenReturn(contentList); [EOL] int position = getRelativePositionOfTextNode(textNode); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfTextNodeWithTextNodeAndSiblings() { [EOL] Text textNode = mock(Text.class); [EOL] CDATA cdataNode = mock(CDATA.class); [EOL] Element parentElement = mock(Element.class); [EOL] when(textNode.getParent()).thenReturn(parentElement); [EOL] List contentList = new ArrayList(); [EOL] contentList.add(cdataNode); [EOL] contentList.add(textNode); [EOL] when(parentElement.getContent()).thenReturn(contentList); [EOL] int position = getRelativePositionOfTextNode(textNode); [EOL] assertEquals(2, position); [EOL] }
public void testGetRelativePositionOfTextNodeWithCdataNode() { [EOL] CDATA cdataNode = mock(CDATA.class); [EOL] Element parentElement = mock(Element.class); [EOL] when(cdataNode.getParent()).thenReturn(parentElement); [EOL] List contentList = new ArrayList(); [EOL] contentList.add(cdataNode); [EOL] when(parentElement.getContent()).thenReturn(contentList); [EOL] int position = getRelativePositionOfTextNode(cdataNode); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfTextNodeWithNullParent() { [EOL] Text textNode = mock(Text.class); [EOL] when(textNode.getParent()).thenReturn(null); [EOL] int position = getRelativePositionOfTextNode(textNode); [EOL] assertEquals(1, position); [EOL] }
public void testGetAbstractFactoryWithNonNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] AbstractFactory expectedFactory = new AbstractFactory() { [EOL] }; [EOL] context.setFactory(expectedFactory); [EOL] AbstractFactory actualFactory = getAbstractFactory(context); [EOL] assertEquals("Expected factory should be returned", expectedFactory, actualFactory); [EOL] }
public void testGetAbstractFactoryWithNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] try { [EOL] getAbstractFactory(context); [EOL] fail("JXPathException should be thrown when factory is null"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Factory is not set on the JXPathContext - cannot create path: /", e.getMessage()); [EOL] } [EOL] }
public void testSetCompilerWithNonNullCompiler() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Compiler compiler = new CustomCompiler(); [EOL] context.setCompiler(compiler); [EOL] assertEquals("Compiler should be set", compiler, context.getCompiler()); [EOL] }
public void testSetCompilerWithNullCompiler() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setCompiler(null); [EOL] assertNull("Compiler should be null", context.getCompiler()); [EOL] }
public void testNCNameWithNCNameToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NCName; [EOL] token.image = "expectedImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("expectedImage", result); [EOL] }
public void testNCNameWithNodeToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NODE; [EOL] token.image = "nodeImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("nodeImage", result); [EOL] }
public void testNCNameWithTextToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = TEXT; [EOL] token.image = "textImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("textImage", result); [EOL] }
public void testNCNameWithCommentToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = COMMENT; [EOL] token.image = "commentImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("commentImage", result); [EOL] }
public void testNCNameWithPIToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = PI; [EOL] token.image = "piImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("piImage", result); [EOL] }
public void testNCNameWithFunctionLastToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_LAST; [EOL] token.image = "functionLastImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("functionLastImage", result); [EOL] }
public void testNCNameWithFunctionPositionToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_POSITION; [EOL] token.image = "functionPositionImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("functionPositionImage", result); [EOL] }
public void testNCNameWithFunctionCountToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_COUNT; [EOL] token.image = "functionCountImage"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("functionCountImage", result); [EOL] }
public void testNCNameWithInvalidToken() { [EOL] Token token = new Token(); [EOL] token.kind = -1; [EOL] Parser parser = new Parser(token); [EOL] assertThrows(ParseException.class, parser::NCName); [EOL] }
public void testCoreFunctionNameWithFunctionLast() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LAST; [EOL] int expectedCode = Compiler.FUNCTION_LAST; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionPosition() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_POSITION; [EOL] int expectedCode = Compiler.FUNCTION_POSITION; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCount() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_COUNT; [EOL] int expectedCode = Compiler.FUNCTION_COUNT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionId() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ID; [EOL] int expectedCode = Compiler.FUNCTION_ID; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLocalName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LOCAL_NAME; [EOL] int expectedCode = Compiler.FUNCTION_LOCAL_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNamespaceUri() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAMESPACE_URI; [EOL] int expectedCode = Compiler.FUNCTION_NAMESPACE_URI; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAME; [EOL] int expectedCode = Compiler.FUNCTION_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionString() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING; [EOL] int expectedCode = Compiler.FUNCTION_STRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionConcat() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONCAT; [EOL] int expectedCode = Compiler.FUNCTION_CONCAT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStartsWith() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STARTS_WITH; [EOL] int expectedCode = Compiler.FUNCTION_STARTS_WITH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionContains() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONTAINS; [EOL] int expectedCode = Compiler.FUNCTION_CONTAINS; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringBefore() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_BEFORE; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringAfter() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_AFTER; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstring() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStringLength() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING_LENGTH; [EOL] int expectedCode = Compiler.FUNCTION_STRING_LENGTH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNormalizeSpace() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NORMALIZE_SPACE; [EOL] int expectedCode = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTranslate() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRANSLATE; [EOL] int expectedCode = Compiler.FUNCTION_TRANSLATE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionBoolean() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_BOOLEAN; [EOL] int expectedCode = Compiler.FUNCTION_BOOLEAN; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNot() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NOT; [EOL] int expectedCode = Compiler.FUNCTION_NOT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTrue() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRUE; [EOL] int expectedCode = Compiler.FUNCTION_TRUE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFalse() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FALSE; [EOL] int expectedCode = Compiler.FUNCTION_FALSE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNull() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NULL; [EOL] int expectedCode = Compiler.FUNCTION_NULL; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLang() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LANG; [EOL] int expectedCode = Compiler.FUNCTION_LANG; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSum() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUM; [EOL] int expectedCode = Compiler.FUNCTION_SUM; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFloor() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FLOOR; [EOL] int expectedCode = Compiler.FUNCTION_FLOOR; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCeiling() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CEILING; [EOL] int expectedCode = Compiler.FUNCTION_CEILING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionRound() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ROUND; [EOL] int expectedCode = Compiler.FUNCTION_ROUND; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionKey() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_KEY; [EOL] int expectedCode = Compiler.FUNCTION_KEY; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFormatNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FORMAT_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithInvalidKind() { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = INVALID_KIND; // Assuming INVALID_KIND is a constant representing an invalid kind [EOL] try { [EOL] CoreFunctionName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object testParseExpressionValidInput() throws ParseException { [EOL] Parser parser = new Parser(); [EOL] Object result = parser.parseExpression(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testParseExpressionThrowsError() { [EOL] Parser parser = new Parser(); [EOL] try { [EOL] parser.parseExpression(); [EOL] fail("Expected an Error to be thrown due to missing return statement"); [EOL] } catch (Error e) { [EOL] assertEquals("Missing return statement in function", e.getMessage()); [EOL] } [EOL] }
public Object testLocationPathWithRelativeLocationPath() throws ParseException { [EOL] jj_nt.kind = OR; // OR is one of the kinds that lead to RelativeLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming RelativeLocationPath returns a non-null object [EOL] return result; [EOL] }
public Object testLocationPathWithAbsoluteLocationPath() throws ParseException { [EOL] jj_nt.kind = SLASH; // SLASH is one of the kinds that lead to AbsoluteLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming AbsoluteLocationPath returns a non-null object [EOL] return result; [EOL] }
public void testLocationPathWithParseException() { [EOL] jj_nt.kind = 999; // An invalid kind that is not handled by the switch [EOL] assertThrows(ParseException.class, () -> { [EOL] LocationPath(); [EOL] }); [EOL] }
public void testNodeTestWithNodeType() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NODE; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithProcessingInstruction() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.PI; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithWildcardName() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NCName; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithSelfAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 82; // Assuming 82 corresponds to the AXIS_SELF [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParentAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 83; // Assuming 83 corresponds to the AXIS_PARENT [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithPredicate() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 84; // Assuming 84 corresponds to a Predicate [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParseException() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = -1; // Invalid kind to trigger ParseException [EOL] try { [EOL] jjParser.NodeTest(steps); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testAxisSpecifierWithAxisSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithDefault() throws ParseException { [EOL] jj_nt.kind = SOME_OTHER_KIND; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AbbreviatedAxisSpecifier(), result); [EOL] }
public void testAxisNameSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_SELF, result); [EOL] }
public void testAxisNameChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAxisNameParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PARENT, result); [EOL] }
public void testAxisNameAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR, result); [EOL] }
public void testAxisNameAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testAxisNameNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_NAMESPACE, result); [EOL] }
public void testAxisNamePreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING, result); [EOL] }
public void testAxisNameFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING, result); [EOL] }
public void testAxisNameDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT, result); [EOL] }
public void testAxisNameAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR_OR_SELF, result); [EOL] }
public void testAxisNameFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING_SIBLING, result); [EOL] }
public void testAxisNamePrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING_SIBLING, result); [EOL] }
public void testAxisNameDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT_OR_SELF, result); [EOL] }
public void testAxisNameInvalid() { [EOL] jj_nt.kind = INVALID_AXIS; // Assuming INVALID_AXIS is a constant for an invalid axis [EOL] try { [EOL] AxisName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testExpressionReturnsCorrectObject() throws ParseException { [EOL] JXPathParser parser = new JXPathParser(new StringReader("expression")); [EOL] Object result = parser.Expression(); [EOL] assertNotNull("Expression should not return null", result); [EOL] assertTrue("Result should be an instance of OrExpression", result instanceof OrExpression); [EOL] }
public void testPrimaryExprWithVariable() throws ParseException { [EOL] jj_nt.kind = VARIABLE; [EOL] Object expected = new Object(); [EOL] when(this.VariableReference()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithLiteral() throws ParseException { [EOL] jj_nt.kind = Literal; [EOL] token.image = "\"literal\""; [EOL] Object expected = new Object(); [EOL] when(compiler.literal("literal")).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithNumber() throws ParseException { [EOL] jj_nt.kind = Number; [EOL] token.image = "123"; [EOL] Object expected = new Object(); [EOL] when(compiler.number("123")).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithParentheses() throws ParseException { [EOL] jj_nt.kind = 80; [EOL] Object expected = new Object(); [EOL] when(Expression()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] verify(this, times(2)).jj_consume_token(anyInt()); [EOL] }
public void testPrimaryExprWithCoreFunctionCall() throws ParseException { [EOL] jj_nt.kind = -1; // A kind that triggers the default case [EOL] Object expected = new Object(); [EOL] when(jj_2_5(2147483647)).thenReturn(true); [EOL] when(CoreFunctionCall()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithFunctionCall() throws ParseException { [EOL] jj_nt.kind = FUNCTION_COUNT; // One of the function call kinds [EOL] Object expected = new Object(); [EOL] when(FunctionCall()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithParseException() { [EOL] jj_nt.kind = -1; // A kind that triggers the default case [EOL] when(jj_2_5(2147483647)).thenReturn(false); [EOL] assertThrows(ParseException.class, () -> { [EOL] PrimaryExpr(); [EOL] }); [EOL] }
public Object testUnionExpr_SinglePathExpr() throws ParseException { [EOL] Object result = UnionExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnionExpr_MultiplePathExpr() throws ParseException { [EOL] jj_nt.kind = UNION; [EOL] Object result = UnionExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testPathExprWithFilterExpr() throws ParseException { [EOL] mock_jj_2_6(true); [EOL] Object expected = new Object(); [EOL] mockFilterExpr(expected); [EOL] Object result = PathExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testPathExprWithLocationPath() throws ParseException { [EOL] mock_jj_nt_kind(SLASH); // Replace SLASH with actual constant value [EOL] Object expected = new Object(); [EOL] mockLocationPath(expected); [EOL] Object result = PathExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testPathExprWithParseException() throws ParseException { [EOL] mock_jj_nt_kind(INVALID_KIND); // Replace INVALID_KIND with a value that is not covered by the switch cases [EOL] try { [EOL] PathExpr(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object testFilterExprWithNoPath() throws ParseException { [EOL] Object result = filterExprInstance.FilterExpr(); [EOL] assertNotNull(result); [EOL] }
public Object testFilterExprWithPath() throws ParseException { [EOL] Object result = filterExprInstance.FilterExpr(); [EOL] assertNotNull(result); [EOL] }
public Object testFilterExprWithPredicate() throws ParseException { [EOL] Object result = filterExprInstance.FilterExpr(); [EOL] assertNotNull(result); [EOL] }
public Object testFilterExprWithLocationStep() throws ParseException { [EOL] Object result = filterExprInstance.FilterExpr(); [EOL] assertNotNull(result); [EOL] }
final public Object OrExpr() throws ParseException { [EOL] Object ex, r; [EOL] ArrayList list = null; [EOL] ex = AndExpr(); [EOL] label_8: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case OR: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[24] = jj_gen; [EOL] break label_8; [EOL] } [EOL] jj_consume_token(OR); [EOL] r = AndExpr(); [EOL] if (list == null) { [EOL] list = new ArrayList(); [EOL] list.add(ex); [EOL] } [EOL] list.add(r); [EOL] } [EOL] if (list != null) { [EOL] ex = compiler.or(list.toArray()); [EOL] } [EOL] { [EOL] if (true) [EOL] return ex; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testAndExprWithNoAnd() throws ParseException { [EOL] Object result = AndExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testAndExprWithSingleAnd() throws ParseException { [EOL] Object result = AndExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testAndExprWithMultipleAnd() throws ParseException { [EOL] Object result = AndExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testEqualityExprWithEQ() throws ParseException { [EOL] jj_nt.kind = EQ; [EOL] Object expected = new Object(); // Expected result after calling compiler.equal() [EOL] when(RelationalExpr()).thenReturn(new Object()); [EOL] when(compiler.equal(any(), any())).thenReturn(expected); [EOL] Object result = EqualityExpr(); [EOL] assertEquals(expected, result); [EOL] verify(jj_consume_token(EQ)); [EOL] verify(RelationalExpr(), times(2)); // Called twice, once before the loop and once inside the loop [EOL] verify(compiler.equal(any(), any())).once(); [EOL] }
public Object testEqualityExprWithNEQ() throws ParseException { [EOL] jj_nt.kind = NEQ; [EOL] Object expected = new Object(); // Expected result after calling compiler.notEqual() [EOL] when(RelationalExpr()).thenReturn(new Object()); [EOL] when(compiler.notEqual(any(), any())).thenReturn(expected); [EOL] Object result = EqualityExpr(); [EOL] assertEquals(expected, result); [EOL] verify(jj_consume_token(NEQ)); [EOL] verify(RelationalExpr(), times(2)); // Called twice, once before the loop and once inside the loop [EOL] verify(compiler.notEqual(any(), any())).once(); [EOL] }
public Object testEqualityExprWithInvalidToken() throws ParseException { [EOL] jj_nt.kind = INVALID_TOKEN; // INVALID_TOKEN is a placeholder for any token that is not EQ or NEQ [EOL] doThrow(new ParseException()).when(jj_consume_token(-1)); [EOL] assertThrows(ParseException.class, () -> { [EOL] EqualityExpr(); [EOL] }); [EOL] verify(jj_consume_token(-1)).once(); [EOL] }
public Object testRelationalExprWithLT() throws ParseException { [EOL] initParserWithTokenKind(LT); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isLessThanCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithLTE() throws ParseException { [EOL] initParserWithTokenKind(LTE); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isLessThanOrEqualCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithGT() throws ParseException { [EOL] initParserWithTokenKind(GT); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isGreaterThanCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithGTE() throws ParseException { [EOL] initParserWithTokenKind(GTE); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isGreaterThanOrEqualCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithInvalidToken() { [EOL] initParserWithInvalidToken(); [EOL] try { [EOL] parser.RelationalExpr(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] return null; [EOL] }
public Object testAdditiveExprWithNoPlus() throws ParseException { [EOL] Object result = AdditiveExpr(); [EOL] assertNotNull(result, "The result should not be null when jj_nt.kind is not PLUS"); [EOL] }
public Object testAdditiveExprWithPlus() throws ParseException { [EOL] Object result = AdditiveExpr(); [EOL] assertNotNull(result, "The result should not be null when jj_nt.kind is PLUS"); [EOL] }
public void testSubtractiveExprWithMinus() throws ParseException { [EOL] jj_nt.kind = MINUS; // Assuming MINUS is a static field representing the kind of token [EOL] Object result = SubtractiveExpr(); [EOL] assertNotNull(result); [EOL] }
public void testSubtractiveExprWithoutMinus() throws ParseException { [EOL] jj_nt.kind = SOME_OTHER_KIND; // SOME_OTHER_KIND is a placeholder for any kind that is not MINUS [EOL] jj_gen = 0; // Assuming jj_gen is an integer field [EOL] Object result = SubtractiveExpr(); [EOL] assertNotNull(result); [EOL] assertEquals(0, jj_la1[31]); [EOL] }
public Object MultiplicativeExpr() throws ParseException { [EOL] Object ex, r; [EOL] ex = UnaryExpr(); [EOL] label_14: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case MOD: [EOL] case DIV: [EOL] case 88: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[32] = jj_gen; [EOL] break label_14; [EOL] } [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] r = UnaryExpr(); [EOL] ex = compiler.multiply(ex, r); [EOL] break; [EOL] case DIV: [EOL] jj_consume_token(DIV); [EOL] r = UnaryExpr(); [EOL] ex = compiler.divide(ex, r); [EOL] break; [EOL] case MOD: [EOL] jj_consume_token(MOD); [EOL] r = UnaryExpr(); [EOL] ex = compiler.mod(ex, r); [EOL] break; [EOL] default: [EOL] jj_la1[33] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] } [EOL] { [EOL] if (true) [EOL] return ex; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testUnaryExprWithSlash() throws ParseException { [EOL] initParser("/"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithMinus() throws ParseException { [EOL] initParser("-"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testUnaryExprWithInvalidToken() { [EOL] initParser("InvalidToken"); [EOL] try { [EOL] parser.UnaryExpr(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object WildcardName() throws ParseException { [EOL] Object qn; [EOL] String nc1, nc2 = null; [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] break; [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] NCName(); [EOL] break; [EOL] default: [EOL] jj_la1[35] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] nc1 = token.image; [EOL] switch(jj_nt.kind) { [EOL] case 79: [EOL] jj_consume_token(79); [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] break; [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] NCName(); [EOL] break; [EOL] default: [EOL] jj_la1[36] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] nc2 = token.image; [EOL] break; [EOL] default: [EOL] jj_la1[37] = jj_gen; [EOL] ; [EOL] } [EOL] if (nc2 != null) { [EOL] qn = compiler.qname(nc1, nc2); [EOL] } else { [EOL] qn = compiler.qname(null, nc1); [EOL] } [EOL] { [EOL] if (true) [EOL] return qn; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public void testJj_2_6WithTrueCondition() { [EOL] int xla = 0; // Assuming 0 triggers the true condition in jj_3_6 [EOL] JxPathParser parser = new JxPathParser(); // Assuming JxPathParser contains the jj_2_6 method [EOL] parser.token = new Token(); // Assuming Token is a valid class and token is a field of JxPathParser [EOL] boolean result = parser.jj_2_6(xla); [EOL] assertTrue(result); [EOL] }
public void testJj_2_6WithFalseCondition() { [EOL] int xla = 1; // Assuming 1 triggers the false condition in jj_3_6 [EOL] JxPathParser parser = new JxPathParser(); // Assuming JxPathParser contains the jj_2_6 method [EOL] parser.token = new Token(); // Assuming Token is a valid class and token is a field of JxPathParser [EOL] boolean result = parser.jj_2_6(xla); [EOL] assertFalse(result); [EOL] }
final private boolean jj_3R_18() { [EOL] Token xsp; [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_62()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_63()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_64()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_65()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_66()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_67()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_68()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_69()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_70()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_71()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_72()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_73()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_74()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_75()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_76()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_77()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_78()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_79()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_80()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_81()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_82()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_83()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_84()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_85()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_86()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_87()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_88()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_89()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_90()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_91()) [EOL] return true; [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] return false; [EOL] }
public void testJj_3R_153_Token86() { [EOL] when(jj_scan_token(86)).thenReturn(true); [EOL] boolean result = jj_3R_153(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_153_EndOfLookahead() { [EOL] when(jj_scan_token(86)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_153(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_153_NotEndOfLookahead() { [EOL] when(jj_scan_token(86)).thenReturn(false); [EOL] jj_la = 1; [EOL] jj_scanpos = new Object(); [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_153(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningTrue() { [EOL] boolean result = jj_3R_130(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningFalseAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_130(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningFalseAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_130(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_116_Token84() { [EOL] boolean result = jj_3R_116(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_116_JjLaAndJjScanposEqualJjLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_116(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_116_Jj3R104() { [EOL] boolean result = jj_3R_116(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_116_Token85() { [EOL] boolean result = jj_3R_116(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_116_AllConditionsFalse() { [EOL] boolean result = jj_3R_116(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_32_WithFunctionStringToken() { [EOL] boolean result = jj_3R_32(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_32_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_32(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_32_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_32(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_31_WithFunctionNameToken() { [EOL] boolean result = jj_3R_31(); [EOL] assert(result); [EOL] }
public void testJj_3R_31_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assuming these are variables that can be set [EOL] boolean result = jj_3R_31(); [EOL] assert(!result); [EOL] }
public void testJj_3R_31_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero value [EOL] jj_scanpos = 1; // Arbitrary value [EOL] jj_lastpos = 2; // Different from jj_scanpos [EOL] boolean result = jj_3R_31(); [EOL] assert(!result); [EOL] }
public void testJj_3R_28_WithFunctionIdToken() { [EOL] boolean result = jj_3R_28(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_28_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_28(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_28_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_28(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_147_WithTokenAxisFollowing() { [EOL] initTokenStreamWithToken(AXIS_FOLLOWING); [EOL] boolean result = jj_3R_147(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_147_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_147(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_147_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] boolean result = jj_3R_147(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_1() { [EOL] setupJj_3R_15(); [EOL] boolean result = jj_3R_15(); [EOL] assert result == false; [EOL] }
public void testJj_3R_15_2() { [EOL] setupJj_3R_20(); [EOL] boolean result = jj_3R_15(); [EOL] assert result == false; [EOL] }
public void testJj_3R_15_3() { [EOL] setupJj_3R_21(); [EOL] boolean result = jj_3R_15(); [EOL] assert result == false; [EOL] }
public void testJj_3R_15_last() { [EOL] setupJj_3R_54(); [EOL] boolean result = jj_3R_15(); [EOL] assert result == true; [EOL] }
public void testJj_3R_129_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] when(jj_3R_140()).thenReturn(false); [EOL] when(jj_3R_141()).thenReturn(false); [EOL] when(jj_3R_142()).thenReturn(false); [EOL] when(jj_3R_143()).thenReturn(false); [EOL] when(jj_3R_144()).thenReturn(false); [EOL] when(jj_3R_145()).thenReturn(false); [EOL] when(jj_3R_146()).thenReturn(false); [EOL] when(jj_3R_147()).thenReturn(false); [EOL] when(jj_3R_148()).thenReturn(false); [EOL] when(jj_3R_149()).thenReturn(false); [EOL] when(jj_3R_150()).thenReturn(false); [EOL] when(jj_3R_151()).thenReturn(false); [EOL] when(jj_3R_152()).thenReturn(false); [EOL] boolean result = jj_3R_129(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_FirstTrueRestFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] when(jj_3R_140()).thenReturn(true); [EOL] when(jj_3R_141()).thenReturn(false); [EOL] when(jj_3R_142()).thenReturn(false); [EOL] when(jj_3R_143()).thenReturn(false); [EOL] when(jj_3R_144()).thenReturn(false); [EOL] when(jj_3R_145()).thenReturn(false); [EOL] when(jj_3R_146()).thenReturn(false); [EOL] when(jj_3R_147()).thenReturn(false); [EOL] when(jj_3R_148()).thenReturn(false); [EOL] when(jj_3R_149()).thenReturn(false); [EOL] when(jj_3R_150()).thenReturn(false); [EOL] when(jj_3R_151()).thenReturn(false); [EOL] when(jj_3R_152()).thenReturn(false); [EOL] boolean result = jj_3R_129(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_LastTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] when(jj_3R_140()).thenReturn(false); [EOL] when(jj_3R_141()).thenReturn(false); [EOL] when(jj_3R_142()).thenReturn(false); [EOL] when(jj_3R_143()).thenReturn(false); [EOL] when(jj_3R_144()).thenReturn(false); [EOL] when(jj_3R_145()).thenReturn(false); [EOL] when(jj_3R_146()).thenReturn(false); [EOL] when(jj_3R_147()).thenReturn(false); [EOL] when(jj_3R_148()).thenReturn(false); [EOL] when(jj_3R_149()).thenReturn(false); [EOL] when(jj_3R_150()).thenReturn(false); [EOL] when(jj_3R_151()).thenReturn(false); [EOL] when(jj_3R_152()).thenReturn(true); [EOL] boolean result = jj_3R_129(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_159_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_159()); [EOL] } [EOL] public void testJj_3R_159_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_164()).thenReturn(true); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] assertFalse(jj_3R_159()); [EOL] } [EOL] public void testJj_3R_159_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(true); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] assertFalse(jj_3R_159()); [EOL] } [EOL] public void testJj_3R_159_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(true); [EOL] when(jj_3R_167()).thenReturn(false); [EOL] assertFalse(jj_3R_159()); [EOL] } [EOL] public void testJj_3R_159_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] when(jj_3R_167()).thenReturn(true); [EOL] assertTrue(jj_3R_159()); [EOL] }
public void testJj_3R_166_TokenLTE() { [EOL] assertTrue(jj_3R_166()); [EOL] }
public void testJj_3R_166_EndOfLookahead() { [EOL] assertFalse(jj_3R_166()); [EOL] }
public void testJj_3R_166_Rule158True() { [EOL] assertTrue(jj_3R_166()); [EOL] }
public void testJj_3R_166_AlwaysFalse() { [EOL] assertFalse(jj_3R_166()); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningTrue() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] when(mockJj_3R_160()).thenReturn(true); [EOL] when(mockJj_3R_161()).thenReturn(false); [EOL] boolean result = jj_3R_157(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningFalseAndLaEqualsZero() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] jj_lastpos = mockJj_scanpos; // Ensure jj_scanpos == jj_lastpos [EOL] jj_la = 0; [EOL] when(mockJj_3R_160()).thenReturn(false); [EOL] boolean result = jj_3R_157(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningTrueAndJj_3R_161ReturningTrue() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] when(mockJj_3R_160()).thenReturn(true); [EOL] when(mockJj_3R_161()).thenReturn(true); [EOL] boolean result = jj_3R_157(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningTrueAndJj_3R_161ReturningFalseAndLaNotZero() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] jj_lastpos = mockJj_scanpos; // Ensure jj_scanpos == jj_lastpos [EOL] jj_la = 1; // Ensure jj_la != 0 [EOL] when(mockJj_3R_160()).thenReturn(true); [EOL] when(mockJj_3R_161()).thenReturn(false); [EOL] boolean result = jj_3R_157(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_160_TokenEq() { [EOL] boolean result = jj_3R_160(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_160_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_160(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_160_Rule156True() { [EOL] boolean result = jj_3R_160(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_160_DefaultFalse() { [EOL] boolean result = jj_3R_160(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_102_WhenJj_3R_116ReturnsTrue() { [EOL] setJj_3R_116Condition(true); [EOL] boolean result = jj_3R_102(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_102_WhenJj_3R_116ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_116Condition(false); [EOL] setJjLa(0); [EOL] setScanposEqualsLastpos(); [EOL] boolean result = jj_3R_102(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_102_WhenJj_3R_116ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_116Condition(false); [EOL] setJjLaNonZeroOrScanposNotEqualsLastpos(); [EOL] boolean result = jj_3R_102(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsTrue() { [EOL] when(jj_3R_156()).thenReturn(true); [EOL] boolean result = jj_3R_134(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_156()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_134(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsFalseAndJj_3R_157ReturnsTrue() { [EOL] when(jj_3R_156()).thenReturn(false); [EOL] when(jj_3R_157()).thenReturn(true); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); // Ensure jj_scanpos is not equal to jj_lastpos [EOL] boolean result = jj_3R_134(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsFalseAndJj_3R_157NeverReturnsTrue() { [EOL] when(jj_3R_156()).thenReturn(false); [EOL] when(jj_3R_157()).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); // Ensure jj_scanpos is not equal to jj_lastpos [EOL] boolean result = jj_3R_134(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_135_WithTrueToken() { [EOL] when(jj_scan_token(AND)).thenReturn(true); [EOL] boolean result = jj_3R_135(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_135_WithFalseTokenAndLaEqualsZero() { [EOL] when(jj_scan_token(AND)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_135(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_135_WithFalseTokenAndLaNotZero() { [EOL] when(jj_scan_token(AND)).thenReturn(false); [EOL] jj_la = 1; // any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object [EOL] jj_lastpos = new Object(); // and different from jj_scanpos [EOL] boolean result = jj_3R_135(); [EOL] assertFalse(result); // Assuming jj_3R_134() returns false, otherwise need to mock jj_3R_134() as well [EOL] }
public void testJj_3R_135_WithFalseTokenAndJj_3R_134True() { [EOL] when(jj_scan_token(AND)).thenReturn(false); [EOL] when(jj_3R_134()).thenReturn(true); [EOL] boolean result = jj_3R_135(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99ReturnsFalseAndJj_3R_100ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(true); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99AndJj_3R_100ReturnFalseAndJj_3R_101ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(true); [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenAllConditionsReturnFalseAndJj_3R_102ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(true); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenAllConditionsReturnFalseAndJj_3R_102ReturnsFalse() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsTrue() { [EOL] setupJj_3R_134ToReturnTrue(); [EOL] boolean result = jj_3R_125(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsFalseAndScanposEqualsLastpos() { [EOL] setupJj_3R_134ToReturnFalse(); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_125(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsFalseAndJj_3R_135IsTrue() { [EOL] setupJj_3R_134ToReturnFalse(); [EOL] setupJj_3R_135ToReturnTrueEventually(); [EOL] boolean result = jj_3R_125(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsFalseAndJj_3R_135NeverTrue() { [EOL] setupJj_3R_134ToReturnFalse(); [EOL] setupJj_3R_135ToNeverReturnTrue(); [EOL] setupJj_laAndScanposToExitLoop(); [EOL] boolean result = jj_3R_125(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_55_SlashToken() { [EOL] boolean result = jj_3R_55(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_55_EndOfLookahead() { [EOL] boolean result = jj_3R_55(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_55_NotEndOfLookahead() { [EOL] boolean result = jj_3R_55(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_126_WhenJjScanTokenOrReturnsTrue() { [EOL] when(jj_scan_token(OR)).thenReturn(true); [EOL] boolean result = jj_3R_126(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_126_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] when(jj_scan_token(OR)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_126(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_126_WhenJj3R_125ReturnsTrue() { [EOL] when(jj_scan_token(OR)).thenReturn(false); [EOL] jj_la = 1; [EOL] when(jj_3R_125()).thenReturn(true); [EOL] boolean result = jj_3R_126(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_126_WhenAllConditionsFail() { [EOL] when(jj_scan_token(OR)).thenReturn(false); [EOL] jj_la = 1; [EOL] when(jj_3R_125()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = new Object(); [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_126(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_16_WhenJj_3R_55TrueAndJj_3R_56True() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure jj_la is not 0 to avoid early return [EOL] when(jj_3R_55()).thenReturn(true); [EOL] when(jj_3R_56()).thenReturn(true); [EOL] boolean result = jj_3R_16(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_16_WhenJj_3R_55TrueAndJj_3R_56FalseAndJj_3R_57True() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure jj_la is not 0 to avoid early return [EOL] when(jj_3R_55()).thenReturn(true); [EOL] when(jj_3R_56()).thenReturn(false); [EOL] when(jj_3R_57()).thenReturn(true); [EOL] boolean result = jj_3R_16(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_16_WhenJj_3R_55FalseAndJj_3R_57True() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure jj_la is not 0 to avoid early return [EOL] when(jj_3R_55()).thenReturn(false); [EOL] when(jj_3R_57()).thenReturn(true); [EOL] boolean result = jj_3R_16(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_16_WhenAllConditionsFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; // Set jj_la to 0 to simulate end of input [EOL] when(jj_3R_55()).thenReturn(false); [EOL] when(jj_3R_56()).thenReturn(false); [EOL] when(jj_3R_57()).thenReturn(false); [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_16(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningTrue() { [EOL] when(jj_3R_125()).thenReturn(true); [EOL] boolean result = jj_3R_118(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_125()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_118(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningFalseAndJj_3R_126ReturningTrue() { [EOL] when(jj_3R_125()).thenReturn(false); [EOL] when(jj_3R_126()).thenReturn(true).thenReturn(false); // Assuming a loop might call it again [EOL] jj_la = 1; // Ensure that the loop continues [EOL] jj_scanpos = new Token(); // Dummy Token instance [EOL] jj_lastpos = new Token(); // Another dummy Token instance [EOL] boolean result = jj_3R_118(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningFalseAndJj_3R_126NeverReturningTrue() { [EOL] when(jj_3R_125()).thenReturn(false); [EOL] when(jj_3R_126()).thenReturn(false); [EOL] jj_la = 1; // Ensure that the loop continues [EOL] jj_scanpos = new Token(); // Dummy Token instance [EOL] jj_lastpos = new Token(); // Another dummy Token instance, not equal to jj_scanpos [EOL] boolean result = jj_3R_118(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_6_WhenJj_3R_19ReturnsTrue() { [EOL] when(this.jj_3R_19()).thenReturn(true); [EOL] boolean result = jj_3_6(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_6_WhenJj_3R_19ReturnsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] when(this.jj_3R_19()).thenReturn(false); [EOL] this.jj_la = 0; [EOL] this.jj_scanpos = this.jj_lastpos; [EOL] boolean result = jj_3_6(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_6_WhenJj_3R_19ReturnsFalseAndJj_laIsNotZeroOrJj_scanposNotEqualsJj_lastpos() { [EOL] when(this.jj_3R_19()).thenReturn(false); [EOL] this.jj_la = 1; [EOL] boolean result = jj_3_6(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_103_WithTokenVariable() { [EOL] boolean result = jj_3R_103(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_103_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_103(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_103_WithJj_3R_117ReturningTrue() { [EOL] boolean result = jj_3R_103(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_103_WithAllConditionsFalse() { [EOL] boolean result = jj_3R_103(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_90_WithFunctionKeyToken() { [EOL] boolean result = jj_3R_90(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_90_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_90(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_90_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_90(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_95_NumberToken() { [EOL] setScannerStateWithNumberToken(); [EOL] boolean result = jj_3R_95(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_95_EndOfLookahead() { [EOL] setScannerStateEndOfLookahead(); [EOL] boolean result = jj_3R_95(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_95_OtherToken() { [EOL] setScannerStateWithOtherToken(); [EOL] boolean result = jj_3R_95(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_94_WithLiteralToken() { [EOL] boolean result = jj_3R_94(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_94_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_94(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_94_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] boolean result = jj_3R_94(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_93_Token80() { [EOL] initToken(80); [EOL] boolean result = jj_3R_93(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_93_EndOfLookahead() { [EOL] initLookahead(0, true); [EOL] boolean result = jj_3R_93(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_93_Rule104() { [EOL] initRule104(true); [EOL] boolean result = jj_3R_93(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_93_Token81() { [EOL] initToken(81); [EOL] boolean result = jj_3R_93(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_93_False() { [EOL] initToken(82); // Assuming token 82 will not trigger any of the conditions [EOL] boolean result = jj_3R_93(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_92_WhenJj_3R_103ReturnsTrue() { [EOL] setJj_3R_103(true); [EOL] boolean result = jj_3R_92(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_92_WhenJj_3R_103ReturnsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] setJj_3R_103(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_92(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_92_WhenJj_3R_103ReturnsFalseAndJj_laIsNotZeroOrJj_scanposNotEqualsJj_lastpos() { [EOL] setJj_3R_103(false); [EOL] jj_la = 1; [EOL] boolean result = jj_3R_92(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_19_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_FifthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_SixthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_69_TokenIsFunctionString() { [EOL] boolean result = jj_3R_69(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_69_TokenIsNotFunctionStringAndLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_69(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_69_TokenIsNotFunctionStringAndLaIsNotZero() { [EOL] boolean result = jj_3R_69(); [EOL] assertFalse(result); [EOL] }
public void testReInitWithNonNullReader() { [EOL] Parser parser = new Parser(); [EOL] java.io.StringReader reader = new java.io.StringReader("some input"); [EOL] parser.ReInit(reader); [EOL] }
public void testReInitWithNullReader() { [EOL] Parser parser = new Parser(); [EOL] try { [EOL] parser.ReInit(null); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testConsumeTokenWithCorrectKind() throws ParseException { [EOL] int expectedKind = 1; [EOL] Token expectedToken = new Token(); [EOL] expectedToken.kind = expectedKind; [EOL] token_source.setNextToken(expectedToken); [EOL] token = new Token(); [EOL] token.next = null; [EOL] jj_nt = token; [EOL] Token result = jj_consume_token(expectedKind); [EOL] assertEquals(expectedToken, result); [EOL] assertEquals(expectedKind, result.kind); [EOL] }
public void testConsumeTokenWithIncorrectKind() throws ParseException { [EOL] int expectedKind = 1; [EOL] int incorrectKind = 2; [EOL] Token expectedToken = new Token(); [EOL] expectedToken.kind = incorrectKind; [EOL] token_source.setNextToken(expectedToken); [EOL] token = new Token(); [EOL] token.next = null; [EOL] jj_nt = token; [EOL] try { [EOL] jj_consume_token(expectedKind); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] assertEquals(incorrectKind, jj_kind); [EOL] }
public void testConsumeTokenWithGarbageCollectionTrigger() throws ParseException { [EOL] int expectedKind = 1; [EOL] Token expectedToken = new Token(); [EOL] expectedToken.kind = expectedKind; [EOL] token_source.setNextToken(expectedToken); [EOL] token = new Token(); [EOL] token.next = null; [EOL] jj_nt = token; [EOL] jj_gc = 100; // Set to threshold to trigger garbage collection [EOL] Token result = jj_consume_token(expectedKind); [EOL] assertEquals(expectedToken, result); [EOL] assertEquals(0, jj_gc); // Garbage collection should have reset the counter [EOL] }
public void testJjScanTokenWithScanposEqualsLastposAndNextNull() { [EOL] TokenSource tokenSource = mock(TokenSource.class); [EOL] Token initialToken = new Token(); [EOL] when(tokenSource.getNextToken()).thenReturn(initialToken); [EOL] ParserTokenManager tokenManager = new ParserTokenManager(tokenSource); [EOL] tokenManager.jj_scanpos = new Token(); [EOL] tokenManager.jj_lastpos = tokenManager.jj_scanpos; [EOL] tokenManager.jj_scanpos.next = null; [EOL] boolean result = tokenManager.jj_scan_token(42); [EOL] assertEquals(initialToken, tokenManager.jj_scanpos); [EOL] assertEquals(tokenManager.jj_scanpos, tokenManager.jj_lastpos); [EOL] assertFalse(result); // Assuming kind 42 is not the kind of the initialToken [EOL] }
public void testJjScanTokenWithScanposEqualsLastposAndNextNotNull() { [EOL] Token nextToken = new Token(); [EOL] nextToken.kind = 42; [EOL] ParserTokenManager tokenManager = new ParserTokenManager(null); [EOL] tokenManager.jj_scanpos = new Token(); [EOL] tokenManager.jj_lastpos = tokenManager.jj_scanpos; [EOL] tokenManager.jj_scanpos.next = nextToken; [EOL] boolean result = tokenManager.jj_scan_token(42); [EOL] assertEquals(nextToken, tokenManager.jj_scanpos); [EOL] assertEquals(tokenManager.jj_scanpos, tokenManager.jj_lastpos); [EOL] assertTrue(result); // The kind matches [EOL] }
public void testJjScanTokenWithScanposNotEqualsLastpos() { [EOL] Token firstToken = new Token(); [EOL] Token secondToken = new Token(); [EOL] firstToken.next = secondToken; [EOL] ParserTokenManager tokenManager = new ParserTokenManager(null); [EOL] tokenManager.jj_scanpos = firstToken; [EOL] tokenManager.jj_lastpos = secondToken; [EOL] boolean result = tokenManager.jj_scan_token(42); [EOL] assertEquals(secondToken, tokenManager.jj_scanpos); [EOL] assertFalse(result); // Assuming kind 42 is not the kind of secondToken [EOL] }
public void testJjScanTokenWithRescanTrue() { [EOL] Token firstToken = new Token(); [EOL] firstToken.kind = 42; [EOL] Token secondToken = new Token(); [EOL] secondToken.kind = 42; [EOL] firstToken.next = secondToken; [EOL] ParserTokenManager tokenManager = new ParserTokenManager(null); [EOL] tokenManager.jj_scanpos = firstToken; [EOL] tokenManager.jj_lastpos = secondToken; [EOL] tokenManager.jj_rescan = true; [EOL] boolean result = tokenManager.jj_scan_token(42); [EOL] assertEquals(secondToken, tokenManager.jj_scanpos); [EOL] assertTrue(result); // The kind matches [EOL] }
public void testJjSave_NewJJCalls() { [EOL] int index = 0; [EOL] int xla = 1; [EOL] jj_gen = 0; [EOL] jj_la = 0; [EOL] token = new Token(); [EOL] jj_2_rtns = new JJCalls[1]; [EOL] jj_2_rtns[index] = new JJCalls(); [EOL] jj_2_rtns[index].gen = -1; // Ensure the gen is less than jj_gen to enter the loop [EOL] jj_save(index, xla); [EOL] assertEquals("The gen should be updated to jj_gen + xla - jj_la", jj_gen + xla - jj_la, jj_2_rtns[index].gen); [EOL] assertEquals("The first should be updated to token", token, jj_2_rtns[index].first); [EOL] assertEquals("The arg should be updated to xla", xla, jj_2_rtns[index].arg); [EOL] assertNotNull("The next should be a new JJCalls object", jj_2_rtns[index].next); [EOL] }
public void testJjSave_ExistingNextJJCalls() { [EOL] int index = 0; [EOL] int xla = 1; [EOL] jj_gen = 0; [EOL] jj_la = 0; [EOL] token = new Token(); [EOL] jj_2_rtns = new JJCalls[1]; [EOL] jj_2_rtns[index] = new JJCalls(); [EOL] jj_2_rtns[index].gen = 1; // Ensure the gen is greater than jj_gen to not enter the loop [EOL] JJCalls nextJJCalls = new JJCalls(); [EOL] jj_2_rtns[index].next = nextJJCalls; [EOL] jj_save(index, xla); [EOL] assertEquals("The gen should be updated to jj_gen + xla - jj_la", jj_gen + xla - jj_la, jj_2_rtns[index].gen); [EOL] assertEquals("The first should be updated to token", token, jj_2_rtns[index].first); [EOL] assertEquals("The arg should be updated to xla", xla, jj_2_rtns[index].arg); [EOL] assertSame("The next should be the same JJCalls object", nextJJCalls, jj_2_rtns[index].next); [EOL] }
public void testCoreOperationWithNullArgs() { [EOL] try { [EOL] new CoreOperation(null); [EOL] fail("Should throw IllegalArgumentException for null args"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCoreOperationWithEmptyArgs() { [EOL] Expression[] args = new Expression[0]; [EOL] CoreOperation operation = new CoreOperation(args); [EOL] assertNotNull("CoreOperation should not be null with empty args", operation); [EOL] }
public void testCoreOperationWithNonNullArgs() { [EOL] Expression[] args = new Expression[]{new ExpressionMock()}; [EOL] CoreOperation operation = new CoreOperation(args); [EOL] assertNotNull("CoreOperation should not be null with non-null args", operation); [EOL] }
public void testToStringWithSingleArg() { [EOL] String[] args = {"arg1"}; [EOL] YourClass instance = new YourClass(args); [EOL] String expected = instance.getSymbol() + instance.parenthesize(args[0], false); [EOL] String result = instance.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testToStringWithMultipleArgs() { [EOL] String[] args = {"arg1", "arg2", "arg3"}; [EOL] YourClass instance = new YourClass(args); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] for (int i = 0; i < args.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(' '); [EOL] buffer.append(instance.getSymbol()); [EOL] buffer.append(' '); [EOL] } [EOL] buffer.append(instance.parenthesize(args[i], i == 0)); [EOL] } [EOL] String expected = buffer.toString(); [EOL] String result = instance.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testParenthesizeWithNonCoreOperation() { [EOL] Expression expression = mock(Expression.class); [EOL] when(expression.toString()).thenReturn("NonCoreOperation"); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("NonCoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationLowerPrecedence() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(2); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationEqualPrecedenceSymmetric() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(1); [EOL] when(isSymmetric()).thenReturn(true); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationEqualPrecedenceNonSymmetricLeft() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(1); [EOL] when(isSymmetric()).thenReturn(false); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationEqualPrecedenceNonSymmetricRight() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(1); [EOL] when(isSymmetric()).thenReturn(false); [EOL] String result = parenthesize(expression, false); [EOL] assertEquals("(CoreOperation)", result); [EOL] }
public void testParenthesizeWithCoreOperationHigherPrecedence() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(2); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(1); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("(CoreOperation)", result); [EOL] }
public void testSetPropertyWithValidMap() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] String propertyName = "key"; [EOL] Object value = "value"; [EOL] setProperty(map, propertyName, value); [EOL] assertEquals("value", map.get("key")); [EOL] }
public void testSetPropertyWithNullMap() { [EOL] try { [EOL] setProperty(null, "key", "value"); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testQNameWithNoColon() { [EOL] QName qName = new QName("localName"); [EOL] assertNull(qName.getPrefix()); [EOL] assertEquals("localName", qName.getName()); [EOL] }
public void testQNameWithColon() { [EOL] QName qName = new QName("ns:localName"); [EOL] assertEquals("ns", qName.getPrefix()); [EOL] assertEquals("localName", qName.getName()); [EOL] }
public void testInterpretSimpleExpressionPathWithNullContext() { [EOL] NodePointer result = JXPathContext.interpretSimpleExpressionPath(null, null, null, null); [EOL] assertNull("Expected result to be null when context is null", result); [EOL] } [EOL] public void testInterpretSimpleExpressionPathWithNonNullContextAndRoot() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer root = mock(NodePointer.class); [EOL] Expression[] predicates = new Expression[0]; [EOL] Step[] steps = new Step[0]; [EOL] NodePointer result = JXPathContext.interpretSimpleExpressionPath(context, root, predicates, steps); [EOL] assertNotNull("Expected result to be not null when context and root are not null", result); [EOL] }
public void testInterpretSimpleExpressionPathWithPredicates() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer root = mock(NodePointer.class); [EOL] Expression[] predicates = new Expression[] { mock(Expression.class) }; [EOL] Step[] steps = new Step[0]; [EOL] NodePointer result = JXPathContext.interpretSimpleExpressionPath(context, root, predicates, steps); [EOL] assertNotNull("Expected result to be not null when predicates are provided", result); [EOL] }
public void testInterpretSimpleExpressionPathWithSteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer root = mock(NodePointer.class); [EOL] Expression[] predicates = new Expression[0]; [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] NodePointer result = JXPathContext.interpretSimpleExpressionPath(context, root, predicates, steps); [EOL] assertNotNull("Expected result to be not null when steps are provided", result); [EOL] }
public void testCreateChildPointerForStepWithChildAxis() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] verify(propertyPointer).setPropertyName(name.toString()); [EOL] assertFalse(result.isAttribute()); [EOL] }
public void testCreateChildPointerForStepWithAttributeAxis() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] verify(propertyPointer).setPropertyName(name.toString()); [EOL] assertTrue(result.isAttribute()); [EOL] }
public void testCreateChildPointerForStepWithLangAttribute() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("xml", "lang"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] assertTrue(result instanceof LangAttributePointer); [EOL] }
public void testCreateChildPointerForStepWithNonChildOrAttributeAxis() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_DESCENDANT); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] assertSame(parentPointer, result); [EOL] }
private static NodePointer doPredicateIndex(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL] Expression predicate = predicates[currentPredicate]; [EOL] int index = indexFromPredicate(context, predicate); [EOL] NodePointer pointer = parent; [EOL] if (isCollectionElement(pointer, index)) { [EOL] pointer = (NodePointer) pointer.clone(); [EOL] pointer.setIndex(index); [EOL] return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL] } [EOL] return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, currentPredicate); [EOL] }
public void testCreateNullPointerForPredicatesWithEmptyPredicates() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[0]; [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateNullPointerForPredicatesWithNameAttributeTestPredicate() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(NameAttributeTest.class); [EOL] when(predicates[0].computeValue(context)).thenReturn("testKey"); [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] assertEquals("testKey", ((NullPropertyPointer) result).getNameAttributeValue()); [EOL] }
public void testCreateNullPointerForPredicatesWithNonNameAttributeTestPredicateAndParentIsNotANullPropertyPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(Expression.class); [EOL] when(predicates[0].computeValue(context)).thenReturn(1); [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertTrue(result instanceof NullElementPointer); [EOL] assertEquals(1, ((NullElementPointer) result).getIndex()); [EOL] }
public void testCreateNullPointerForPredicatesWithNonNameAttributeTestPredicateAndParentIsANullPropertyPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NullPropertyPointer parent = mock(NullPropertyPointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(Expression.class); [EOL] when(predicates[0].computeValue(context)).thenReturn(1); [EOL] createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] verify(parent).setIndex(1); [EOL] }
public void testIsAtomicTrue() { [EOL] assertTrue(instance.isAtomic()); [EOL] }
public void testIsAtomicFalse() { [EOL] assertFalse(instance.isAtomic()); [EOL] }
public void testIsDynamicTrue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setDynamicPropertyHandlerClass(SomeDynamicPropertyHandlerClass.class); [EOL] boolean result = context.isDynamic(); [EOL] assertTrue(result); [EOL] }
public void testIsDynamicFalse() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setDynamicPropertyHandlerClass(null); [EOL] boolean result = context.isDynamic(); [EOL] assertFalse(result); [EOL] }
public void testGetPropertyDescriptorsWithInterface() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(MyInterface.class); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] List<String> propertyNames = Arrays.stream(result) [EOL] .map(PropertyDescriptor::getName) [EOL] .collect(Collectors.toList()); [EOL] assertTrue(propertyNames.contains("propertyName1")); [EOL] assertTrue(propertyNames.contains("propertyName2")); [EOL] }
public void testGetPropertyDescriptorsWithClass() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(MyRegularClass.class); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] List<String> propertyNames = Arrays.stream(result) [EOL] .map(PropertyDescriptor::getName) [EOL] .collect(Collectors.toList()); [EOL] assertTrue(propertyNames.contains("propertyName1")); [EOL] assertTrue(propertyNames.contains("propertyName2")); [EOL] }
public void testGetPropertyDescriptorsCachesResult() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(MyRegularClass.class); [EOL] PropertyDescriptor[] result1 = instance.getPropertyDescriptors(); [EOL] PropertyDescriptor[] result2 = instance.getPropertyDescriptors(); [EOL] assertSame(result1, result2); // Check if the cached result is returned the second time [EOL] }
public void testGetPropertyDescriptorsHandlesIntrospectionException() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(ProblematicClass.class); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNull(result); // Assuming the method returns null on exception [EOL] }
public PropertyDescriptor getPropertyDescriptor(String propertyName) { [EOL] if (propertyNames == null) { [EOL] PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL] String[] names = new String[pds.length]; [EOL] for (int i = 0; i < pds.length; i++) { [EOL] names[i] = pds[i].getName(); [EOL] } [EOL] propertyNames = names; [EOL] } [EOL] for (int i = 0; i < propertyNames.length; i++) { [EOL] if (propertyNames[i] == propertyName) { [EOL] return propertyDescriptors[i]; [EOL] } [EOL] } [EOL] for (int i = 0; i < propertyNames.length; i++) { [EOL] if (propertyNames[i].equals(propertyName)) { [EOL] return propertyDescriptors[i]; [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testGetDynamicPropertyHandlerClass() { [EOL] YourClass instance = new YourClass(); [EOL] Class expected = SomeDynamicPropertyHandlerClass.class; [EOL] instance.dynamicPropertyHandlerClass = expected; [EOL] Class result = instance.getDynamicPropertyHandlerClass(); [EOL] assertEquals(expected, result); [EOL] }
public void testCreatePathForAttribute() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parentPointer = mock(NodePointer.class); [EOL] NodePointer attributePointer = mock(NodePointer.class); [EOL] when(parentPointer.createPath(context)).thenReturn(parentPointer); [EOL] when(parentPointer.createAttribute(context, "attributeName")).thenReturn(attributePointer); [EOL] when(parentPointer.isAttribute()).thenReturn(true); [EOL] NodePointer testPointer = new NodePointer(parentPointer, "attributeName", true); [EOL] NodePointer result = testPointer.createPath(context); [EOL] assertSame("Expected attribute pointer to be returned", attributePointer, result); [EOL] }
public void testCreatePathForNonAttributeWithPropertyOwnerPointer() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parentPointer = mock(NodePointer.class); [EOL] PropertyOwnerPointer propertyOwnerPointer = mock(PropertyOwnerPointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentPointer.createPath(context)).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer instanceof PropertyOwnerPointer).thenReturn(true); [EOL] when(propertyOwnerPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.createChild(context, "childName", 1)).thenReturn(childPointer); [EOL] when(parentPointer.isAttribute()).thenReturn(false); [EOL] NodePointer testPointer = new NodePointer(parentPointer, "childName", false); [EOL] testPointer.setIndex(1); [EOL] NodePointer result = testPointer.createPath(context); [EOL] assertSame("Expected child pointer to be returned", childPointer, result); [EOL] }
public void testCreatePathForNonAttributeWithoutPropertyOwnerPointer() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parentPointer = mock(NodePointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parentPointer.createPath(context)).thenReturn(parentPointer); [EOL] when(parentPointer.createChild(context, "childName", 1)).thenReturn(childPointer); [EOL] when(parentPointer.isAttribute()).thenReturn(false); [EOL] NodePointer testPointer = new NodePointer(parentPointer, "childName", false); [EOL] testPointer.setIndex(1); [EOL] NodePointer result = testPointer.createPath(context); [EOL] assertSame("Expected child pointer to be returned", childPointer, result); [EOL] }
public void testCreatePathForAttribute() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer newParent = mock(NodePointer.class); [EOL] NodePointer attributePointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(newParent); [EOL] when(newParent.createAttribute(context, "attributeName")).thenReturn(attributePointer); [EOL] TestNodePointer testNodePointer = new TestNodePointer(parent, true, "attributeName"); [EOL] NodePointer result = testNodePointer.createPath(context, "attributeValue"); [EOL] verify(newParent).createAttribute(context, "attributeName"); [EOL] verify(attributePointer).setValue("attributeValue"); [EOL] assertEquals(attributePointer, result); [EOL] }
public void testCreatePathForNonAttributePropertyOwner() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] PropertyOwnerPointer propertyOwnerPointer = mock(PropertyOwnerPointer.class); [EOL] NodePointer propertyPointer = mock(NodePointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.createChild(context, "propertyName", 1, "propertyValue")).thenReturn(childPointer); [EOL] TestNodePointer testNodePointer = new TestNodePointer(parent, false, "propertyName", 1); [EOL] NodePointer result = testNodePointer.createPath(context, "propertyValue"); [EOL] verify(propertyOwnerPointer).getPropertyPointer(); [EOL] verify(propertyPointer).createChild(context, "propertyName", 1, "propertyValue"); [EOL] assertEquals(childPointer, result); [EOL] }
public void testCreatePathForNonAttributeNonPropertyOwner() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer newParent = mock(NodePointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(newParent); [EOL] when(newParent.createChild(context, "elementName", 0, "elementValue")).thenReturn(childPointer); [EOL] TestNodePointer testNodePointer = new TestNodePointer(parent, false, "elementName"); [EOL] NodePointer result = testNodePointer.createPath(context, "elementValue"); [EOL] verify(newParent).createChild(context, "elementName", 0, "elementValue"); [EOL] assertEquals(childPointer, result); [EOL] }
public void testDoubleValueWithNumber() { [EOL] double expected = 123.456; [EOL] Number number = 123.456; [EOL] double result = doubleValue(number); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithBooleanTrue() { [EOL] double expected = 0.0; [EOL] Boolean bool = true; [EOL] double result = doubleValue(bool); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithBooleanFalse() { [EOL] double expected = 1.0; [EOL] Boolean bool = false; [EOL] double result = doubleValue(bool); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithEmptyString() { [EOL] double expected = 0.0; [EOL] String str = ""; [EOL] double result = doubleValue(str); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithValidString() { [EOL] double expected = 123.456; [EOL] String str = "123.456"; [EOL] double result = doubleValue(str); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithInvalidString() { [EOL] double expected = Double.NaN; [EOL] String str = "notANumber"; [EOL] double result = doubleValue(str); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNodePointer() { [EOL] double expected = 123.456; [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(nodePointer.getValue()).thenReturn(123.456); [EOL] double result = doubleValue(nodePointer); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNonNullEvalContext() { [EOL] double expected = 123.456; [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.getValue()).thenReturn(123.456); [EOL] double result = doubleValue(ctx); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNullEvalContext() { [EOL] double expected = Double.NaN; [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] double result = doubleValue(ctx); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithOtherObject() { [EOL] double expected = Double.NaN; // Assuming stringValue(Object) returns a non-parsable String [EOL] Object object = new Object(); [EOL] double result = doubleValue(object); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testBeanPointerConstructorWithValidArguments() { [EOL] QName name = new QName("testName"); [EOL] Object bean = new Object(); [EOL] JXPathBeanInfo beanInfo = mock(JXPathBeanInfo.class); [EOL] Locale locale = Locale.ENGLISH; [EOL] BeanPointer beanPointer = new BeanPointer(name, bean, beanInfo, locale); [EOL] assertNotNull(beanPointer); [EOL] assertEquals(name, beanPointer.getName()); [EOL] assertEquals(bean, beanPointer.getBean()); [EOL] assertEquals(beanInfo, beanPointer.getBeanInfo()); [EOL] assertEquals(locale, beanPointer.getLocale()); [EOL] }
public void testBeanPointerWithNonNullValues() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testName"); [EOL] Object bean = new Object(); [EOL] JXPathBeanInfo beanInfo = mock(JXPathBeanInfo.class); [EOL] BeanPointer beanPointer = new BeanPointer(parent, name, bean, beanInfo); [EOL] assertNotNull(beanPointer); [EOL] assertEquals(parent, beanPointer.getParent()); [EOL] assertEquals(name, beanPointer.getName()); [EOL] assertEquals(bean, beanPointer.getBean()); [EOL] assertEquals(beanInfo, beanPointer.getBeanInfo()); [EOL] }
public void testBeanPointerWithNullValues() { [EOL] BeanPointer beanPointer = new BeanPointer(null, null, null, null); [EOL] assertNotNull(beanPointer); [EOL] assertNull(beanPointer.getParent()); [EOL] assertNull(beanPointer.getName()); [EOL] assertNull(beanPointer.getBean()); [EOL] assertNull(beanPointer.getBeanInfo()); [EOL] }
public int getLength() { [EOL] return 1; [EOL] }
public void testIsLeafWithNullNode() { [EOL] YourNodeClass node = new YourNodeClass(null); // Replace YourNodeClass with the actual class that has the isLeaf method [EOL] boolean result = node.isLeaf(); [EOL] assertTrue("Node should be considered a leaf when it has a null value", result); [EOL] }
public void testIsLeafWithAtomicValue() { [EOL] YourNodeClass node = new YourNodeClass("AtomicValue"); // Replace "AtomicValue" with an actual atomic value [EOL] JXPathIntrospector mockIntrospector = mock(JXPathIntrospector.class); [EOL] BeanInfo mockBeanInfo = mock(BeanInfo.class); [EOL] when(mockIntrospector.getBeanInfo(any(Class.class))).thenReturn(mockBeanInfo); [EOL] when(mockBeanInfo.isAtomic()).thenReturn(true); [EOL] boolean result = node.isLeaf(); [EOL] assertTrue("Node with an atomic value should be considered a leaf", result); [EOL] }
public void testIsLeafWithNonAtomicValue() { [EOL] YourNodeClass node = new YourNodeClass(new Object()); // Replace new Object() with a non-atomic value [EOL] JXPathIntrospector mockIntrospector = mock(JXPathIntrospector.class); [EOL] BeanInfo mockBeanInfo = mock(BeanInfo.class); [EOL] when(mockIntrospector.getBeanInfo(any(Class.class))).thenReturn(mockBeanInfo); [EOL] when(mockBeanInfo.isAtomic()).thenReturn(false); [EOL] boolean result = node.isLeaf(); [EOL] assertFalse("Node with a non-atomic value should not be considered a leaf", result); [EOL] }
public void testAsPathWithParentNotNull() { [EOL] YourParentClass parent = mock(YourParentClass.class); [EOL] when(parent.asPath()).thenReturn("parentPath"); [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setParent(parent); [EOL] String result = instance.asPath(); [EOL] assertEquals("parentPath", result); [EOL] }
public void testAsPathWithBeanNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBean(null); [EOL] String result = instance.asPath(); [EOL] assertEquals("null()", result); [EOL] }
public void testAsPathWithBeanNumberWithoutDecimal() { [EOL] YourClassUnderTest instance = new ClassUnderTest(); [EOL] instance.setBean(123); [EOL] String result = instance.asPath(); [EOL] assertEquals("123", result); [EOL] }
public void testAsPathWithBeanNumberWithDecimal() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBean(123.0); [EOL] String result = instance.asPath(); [EOL] assertEquals("123", result); [EOL] }
public void testAsPathWithBeanBooleanTrue() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBean(true); [EOL] String result = instance.asPath(); [EOL] assertEquals("true()", result); [EOL] }
public void testAsPathWithBeanBooleanFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBean(false); [EOL] String result = instance.asPath(); [EOL] assertEquals("false()", result); [EOL] }
public void testAsPathWithBeanString() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBean("testString"); [EOL] String result = instance.asPath(); [EOL] assertEquals("'testString'", result); [EOL] }
public void testAsPathWithBeanNotHandledType() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBean(new Object()); [EOL] String result = instance.asPath(); [EOL] assertEquals("/", result); [EOL] }
public void testCreatePathWithNullBaseValueAndSuccessfulFactory() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] AbstractFactory factory = mock(AbstractFactory.class); [EOL] when(getBaseValue()).thenReturn(null); [EOL] when(getAbstractFactory(context)).thenReturn(factory); [EOL] when(factory.createObject(context, this, getBean(), getPropertyName(), 0)).thenReturn(true); [EOL] NodePointer result = createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] verify(factory, times(1)).createObject(context, this, getBean(), getPropertyName(), 0); [EOL] }
public void testCreatePathWithNullBaseValueAndUnsuccessfulFactory() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] AbstractFactory factory = mock(AbstractFactory.class); [EOL] when(getBaseValue()).thenReturn(null); [EOL] when(getAbstractFactory(context)).thenReturn(factory); [EOL] when(factory.createObject(context, this, getBean(), getPropertyName(), 0)).thenReturn(false); [EOL] try { [EOL] createPath(context); [EOL] fail("Expected JXPathAbstractFactoryException to be thrown"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] assertEquals("Factory could not create an object for path: " + asPath(), e.getMessage()); [EOL] } [EOL] }
public void testCreatePathWithValidBaseValueAndInvalidIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object baseValue = new Object(); [EOL] when(getBaseValue()).thenReturn(baseValue); [EOL] setIndex(-1); // Assuming there is a method to set the index [EOL] try { [EOL] createPath(context); [EOL] fail("Expected JXPathInvalidAccessException to be thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] assertEquals("Index is less than 1: " + asPath(), e.getMessage()); [EOL] } [EOL] }
public void testCreatePathWithValidBaseValueAndIndexOutOfBounds() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object baseValue = new ArrayList<>(); [EOL] when(getBaseValue()).thenReturn(baseValue); [EOL] when(getLength()).thenReturn(0); [EOL] setIndex(1); // Assuming there is a method to set the index [EOL] PropertyHandler handler = mock(PropertyHandler.class); [EOL] when(getPropertyHandler()).thenReturn(handler); [EOL] NodePointer result = createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] verify(handler, times(1)).setProperty(getBean(), getPropertyName(), any()); [EOL] }
public void testCreatePathWithValidBaseValueAndValidIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object baseValue = new ArrayList<>(); [EOL] ((ArrayList) baseValue).add(new Object()); [EOL] when(getBaseValue()).thenReturn(baseValue); [EOL] when(getLength()).thenReturn(1); [EOL] setIndex(0); // Assuming there is a method to set the index [EOL] NodePointer result = createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] }
public void testCreatePathWithWholeCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new ConcreteNodePointer(WHOLE_COLLECTION); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(nodePointer, result); [EOL] verify(handler).setProperty(nodePointer.getBean(), nodePointer.getPropertyName(), value); [EOL] }
public void testCreatePathWithSpecificIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] int specificIndex = 1; // Assuming 1 is a valid index other than WHOLE_COLLECTION [EOL] NodePointer nodePointer = new ConcreteNodePointer(specificIndex); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(nodePointer, result); [EOL] verify(nodePointer).createPath(context); [EOL] verify(ValueUtils).setValue(nodePointer.getBaseValue(), specificIndex, value); [EOL] }
public void testRemoveWithWholeCollection() { [EOL] context.setIndex(WHOLE_COLLECTION); [EOL] context.remove(); [EOL] assertTrue("Expected removeKey to be called", context.isRemoveKeyCalled()); [EOL] }
public void testRemoveWithCollection() { [EOL] context.setIndex(1); // Assuming 1 is a valid index for a collection [EOL] context.setIsCollection(true); [EOL] context.setBaseValue(createCollectionWithMultipleItems()); [EOL] context.remove(); [EOL] assertNotNull("Expected collection to be modified", context.getModifiedCollection()); [EOL] assertTrue("Expected setProperty to be called", context.isSetPropertyCalled()); [EOL] }
public void testRemoveWithIndexZero() { [EOL] context.setIndex(0); [EOL] context.setIsCollection(false); [EOL] context.remove(); [EOL] assertTrue("Expected removeKey to be called", context.isRemoveKeyCalled()); [EOL] }
public void testRemoveKey_WithMap() { [EOL] JXPathContext context = JXPathContext.newContext(new HashMap()); [EOL] context.setValue("testKey", "testValue"); [EOL] context.removePath("testKey"); [EOL] Map contextBean = (Map) context.getContextBean(); [EOL] assertFalse(contextBean.containsKey("testKey")); [EOL] }
public void testRemoveKey_WithNonMap() { [EOL] TestBean testBean = new TestBean(); [EOL] testBean.setProperty("testProperty", "testValue"); [EOL] JXPathContext context = JXPathContext.newContext(testBean); [EOL] context.removePath("testProperty"); [EOL] assertNull(testBean.getProperty("testProperty")); [EOL] }
public void testGetBeanInfoWithCachedInfo() { [EOL] Class beanClass = SomeBean.class; [EOL] JXPathBeanInfo expectedBeanInfo = new JXPathBasicBeanInfo(beanClass); [EOL] byClass.put(beanClass, expectedBeanInfo); [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertEquals("Should retrieve the cached bean info", expectedBeanInfo, actualBeanInfo); [EOL] }
public void testGetBeanInfoWithDynamicBeanInfo() { [EOL] Class beanClass = SomeOtherBean.class; [EOL] JXPathBeanInfo expectedBeanInfo = findDynamicBeanInfo(beanClass); [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertEquals("Should retrieve the dynamic bean info", expectedBeanInfo, actualBeanInfo); [EOL] }
public void testGetBeanInfoWithInformant() { [EOL] Class beanClass = YetAnotherBean.class; [EOL] JXPathBeanInfo expectedBeanInfo = findInformant(beanClass); [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertEquals("Should retrieve the informant bean info", expectedBeanInfo, actualBeanInfo); [EOL] }
public void testGetBeanInfoWithNewBeanInfo() { [EOL] Class beanClass = NewBean.class; [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertTrue("Should create a new JXPathBasicBeanInfo", actualBeanInfo instanceof JXPathBasicBeanInfo); [EOL] assertEquals("Created bean info should be for the correct class", beanClass, actualBeanInfo.getBeanClass()); [EOL] }
public Object next() { [EOL] if (pointerIterator != null) { [EOL] return pointerIterator.next(); [EOL] } [EOL] if (getDocumentOrder() != 0) { [EOL] if (!constructIterator()) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] return pointerIterator.next(); [EOL] } else { [EOL] if (!done && !hasPerformedIteratorStep) { [EOL] performIteratorStep(); [EOL] } [EOL] if (done) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] hasPerformedIteratorStep = false; [EOL] return getCurrentNodePointer(); [EOL] } [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=0; [EOL] boolean startedSetIteration=false; [EOL] boolean done=false; [EOL] boolean hasPerformedIteratorStep=false; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=new Comparator() { [EOL] public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] } [EOL] }
private boolean constructIterator() { [EOL] HashSet set = new HashSet(); [EOL] ArrayList list = new ArrayList(); [EOL] while (nextSet()) { [EOL] while (nextNode()) { [EOL] NodePointer pointer = getCurrentNodePointer(); [EOL] if (!set.contains(pointer)) { [EOL] set.add(pointer); [EOL] list.add(pointer); [EOL] } [EOL] } [EOL] } [EOL] if (list.isEmpty()) { [EOL] return false; [EOL] } [EOL] if (getDocumentOrder() == 1) { [EOL] Collections.sort(list); [EOL] } else { [EOL] Collections.sort(list, REVERSE_COMPARATOR); [EOL] } [EOL] pointerIterator = list.iterator(); [EOL] return true; [EOL] }
public void testGetPropertyCount_AtomicBean() { [EOL] beanInfo.setAtomic(true); [EOL] int count = bean.getPropertyCount(); [EOL] assertEquals(0, count); [EOL] }
public void testGetPropertyCount_NonAtomicBean() { [EOL] beanInfo.setAtomic(false); [EOL] PropertyDescriptor[] descriptors = new PropertyDescriptor[] { [EOL] new PropertyDescriptor("property1", MyBean.class), [EOL] new PropertyDescriptor("property2", MyBean.class) [EOL] }; [EOL] when(bean.getPropertyDescriptors()).thenReturn(descriptors); [EOL] int count = bean.getPropertyCount(); [EOL] assertEquals(2, count); [EOL] }
public void testGetPropertyNamesWhenNamesIsNull() { [EOL] PropertyDescriptor[] mockPropertyDescriptors = new PropertyDescriptor[] { [EOL] new PropertyDescriptor("property1", null), [EOL] new PropertyDescriptor("property2", null) [EOL] }; [EOL] when(objectUnderTest.getPropertyDescriptors()).thenReturn(mockPropertyDescriptors); [EOL] String[] result = objectUnderTest.getPropertyNames(); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("property1", result[0]); [EOL] assertEquals("property2", result[1]); [EOL] }
public void testGetPropertyNamesWhenNamesIsNotNull() { [EOL] String[] preInitializedNames = new String[] {"property1", "property2"}; [EOL] objectUnderTest.setNames(preInitializedNames); // or use reflection if the field is private [EOL] String[] result = objectUnderTest.getPropertyNames(); [EOL] assertSame(preInitializedNames, result); [EOL] }
public void testSetPropertyIndex_NewIndex() { [EOL] int newIndex = 1; // Assuming the original propertyIndex is not 1 [EOL] setPropertyIndex(newIndex); [EOL] assertEquals(newIndex, propertyIndex); [EOL] assertNull(propertyName); [EOL] assertNull(propertyDescriptor); [EOL] assertEquals(UNINITIALIZED, baseValue); [EOL] assertEquals(UNINITIALIZED, value); [EOL] }
public void testSetPropertyIndex_SameIndex() { [EOL] int originalIndex = propertyIndex; [EOL] setPropertyIndex(originalIndex); [EOL] assertEquals(originalIndex, propertyIndex); [EOL] assertNotNull(propertyName); [EOL] assertNotNull(propertyDescriptor); [EOL] assertNotEquals(UNINITIALIZED, baseValue); [EOL] assertNotEquals(UNINITIALIZED, value); [EOL] }
public void testSetIndex_NewIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int newIndex = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] instance.setIndex(newIndex); [EOL] assertEquals(newIndex, instance.getIndex()); [EOL] assertEquals(UNINITIALIZED, instance.getValue()); [EOL] }
public void testSetIndex_SameIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int sameIndex = 0; // Assuming the initial index is 0 [EOL] instance.setIndex(sameIndex); [EOL] assertEquals(sameIndex, instance.getIndex()); [EOL] assertNotEquals(UNINITIALIZED, instance.getValue()); [EOL] }
public void testSetIndex_WholeCollectionToZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION); [EOL] instance.setIndex(0); [EOL] assertEquals(0, instance.getIndex()); [EOL] assertNotEquals(UNINITIALIZED, instance.getValue()); [EOL] }
public void testSetIndex_WholeCollectionToNonZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION); [EOL] int newIndex = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] instance.setIndex(newIndex); [EOL] assertEquals(newIndex, instance.getIndex()); [EOL] assertEquals(UNINITIALIZED, instance.getValue()); [EOL] }
public void testSetIndex_NonZeroToWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] int initialIndex = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] instance.setIndex(initialIndex); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION); [EOL] assertEquals(YourClass.WHOLE_COLLECTION, instance.getIndex()); [EOL] assertEquals(UNINITIALIZED, instance.getValue()); [EOL] }
public void testGetImmediateNode_UninitializedWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = WHOLE_COLLECTION; [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNode_UninitializedNotWholeCollectionWithNullPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = NOT_WHOLE_COLLECTION; // This should be a valid index that is not WHOLE_COLLECTION [EOL] instance.setPropertyDescriptor(null); // Assuming there is a method to set the property descriptor [EOL] Object result = instance.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNode_UninitializedNotWholeCollectionWithNonNullPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = NOT_WHOLE_COLLECTION; // This should be a valid index that is not WHOLE_COLLECTION [EOL] PropertyDescriptor pd = new PropertyDescriptor(); // Assuming a constructor for PropertyDescriptor [EOL] instance.setPropertyDescriptor(pd); // Assuming there is a method to set the property descriptor [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNode_AlreadyInitialized() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] Object expectedValue = new Object(); [EOL] instance.value = expectedValue; [EOL] Object result = instance.getImmediateNode(); [EOL] assertSame(expectedValue, result); [EOL] }
public void testIsCollectionWithNullPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return null; [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithIndexedPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new IndexedPropertyDescriptor(); [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithNegativeHint() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor() { [EOL] @Override [EOL] public Class<?> getPropertyType() { [EOL] return SomeClassWithNegativeHint.class; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] ValueUtils.mockGetCollectionHint(SomeClassWithNegativeHint.class, -1); [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithPositiveHint() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor() { [EOL] @Override [EOL] public Class<?> getPropertyType() { [EOL] return SomeClassWithPositiveHint.class; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] ValueUtils.mockGetCollectionHint(SomeClassWithPositiveHint.class, 1); [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithBaseValueNotNullAndIsCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor() { [EOL] @Override [EOL] public Class<?> getPropertyType() { [EOL] return SomeClass.class; [EOL] } [EOL] }; [EOL] } [EOL] @Override [EOL] protected Object getBaseValue() { [EOL] return new SomeCollectionClass(); [EOL] } [EOL] }; [EOL] ValueUtils.mockGetCollectionHint(SomeClass.class, 0); [EOL] ValueUtils.mockIsCollection(new SomeCollectionClass(), true); [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithBaseValueNotNullAndIsNotCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor() { [EOL] @Override [EOL] public Class<?> getPropertyType() { [EOL] return SomeClass.class; [EOL] } [EOL] }; [EOL] } [EOL] @Override [EOL] protected Object getBaseValue() { [EOL] return new SomeNonCollectionClass(); [EOL] } [EOL] }; [EOL] ValueUtils.mockGetCollectionHint(SomeClass.class, 0); [EOL] ValueUtils.mockIsCollection(new SomeNonCollectionClass(), false); [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testGetLengthWithNullPropertyDescriptor() { [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] return null; [EOL] } [EOL] }; [EOL] int length = objUnderTest.getLength(); [EOL] assertEquals(1, length); [EOL] }
public void testGetLengthWithIndexedPropertyDescriptor() { [EOL] IndexedPropertyDescriptor indexedPd = mock(IndexedPropertyDescriptor.class); [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] return indexedPd; [EOL] } [EOL] }; [EOL] when(ValueUtils.getIndexedPropertyLength(any(), eq(indexedPd))).thenReturn(5); [EOL] int length = objUnderTest.getLength(); [EOL] assertEquals(5, length); [EOL] }
public void testGetLengthWithNonIndexedPropertyDescriptorAndNegativeHint() { [EOL] PropertyDescriptor pd = mock(PropertyDescriptor.class); [EOL] when(pd.getPropertyType()).thenReturn(SomeClass.class); [EOL] when(ValueUtils.getCollectionHint(SomeClass.class)).thenReturn(-1); [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] return pd; [EOL] } [EOL] }; [EOL] int length = objUnderTest.getLength(); [EOL] assertEquals(1, length); [EOL] }
public void testGetLengthWithNonIndexedPropertyDescriptorAndPositiveHint() { [EOL] PropertyDescriptor pd = mock(PropertyDescriptor.class); [EOL] when(pd.getPropertyType()).thenReturn(SomeCollectionClass.class); [EOL] when(ValueUtils.getCollectionHint(SomeCollectionClass.class)).thenReturn(10); [EOL] Object baseValue = new Object(); [EOL] when(ValueUtils.getLength(baseValue)).thenReturn(10); [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] return pd; [EOL] } [EOL] @Override [EOL] public Object getBaseValue() { [EOL] return baseValue; [EOL] } [EOL] }; [EOL] int length = objUnderTest.getLength(); [EOL] assertEquals(10, length); [EOL] }
public void testSetValueWithNullPropertyDescriptor() { [EOL] try { [EOL] setup(); [EOL] setPropertyDescriptor(null); [EOL] instance.setValue("someValue"); [EOL] fail("Expected JXPathInvalidAccessException was not thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] assertEquals("Cannot set property: " + instance.asPath() + " - no such property", e.getMessage()); [EOL] } [EOL] }
public void testSetValueOnWholeCollection() { [EOL] setup(); [EOL] setIndex(WHOLE_COLLECTION); [EOL] setPropertyDescriptor(validPropertyDescriptor); [EOL] Object value = "someValue"; [EOL] instance.setValue(value); [EOL] verifyValueSet(instance.getBean(), validPropertyDescriptor, value); [EOL] }
public void testSetValueOnSpecificIndex() { [EOL] setup(); [EOL] setIndex(1); [EOL] setPropertyDescriptor(validPropertyDescriptor); [EOL] Object value = "someValue"; [EOL] instance.setValue(value); [EOL] verifyValueSetAtIndex(instance.getBean(), validPropertyDescriptor, 1, value); [EOL] }
public void testGetPropertyNameWhenPropertyNameIsNullAndPropertyDescriptorIsNull() { [EOL] YourClassUnderTest testInstance = new YourClassUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] return null; [EOL] } [EOL] }; [EOL] String result = testInstance.getPropertyName(); [EOL] assertEquals("*", result); [EOL] }
public void testGetPropertyNameWhenPropertyNameIsNullAndPropertyDescriptorIsNotNull() { [EOL] final String expectedPropertyName = "testProperty"; [EOL] YourClassUnderTest testInstance = new YourClassUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] PropertyDescriptor pd = new PropertyDescriptor(); [EOL] pd.setName(expectedPropertyName); [EOL] return pd; [EOL] } [EOL] }; [EOL] String result = testInstance.getPropertyName(); [EOL] assertEquals(expectedPropertyName, result); [EOL] }
public void testGetPropertyNameWhenPropertyNameIsNotNull() { [EOL] final String expectedPropertyName = "initializedProperty"; [EOL] YourClassUnderTest testInstance = new YourClassUnderTest(); [EOL] testInstance.propertyName = expectedPropertyName; // Assuming propertyName can be accessed directly or via a setter [EOL] String result = testInstance.getPropertyName(); [EOL] assertEquals(expectedPropertyName, result); [EOL] }
public void testGetPropertyDescriptorWhenNull() { [EOL] setPropertyDescriptor(null); // Ensure propertyDescriptor is null before the test [EOL] setPropertyName("someProperty"); [EOL] setBeanInfo(mockBeanInfo); [EOL] when(mockBeanInfo.getPropertyDescriptor("someProperty")).thenReturn(mockPropertyDescriptor); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals(mockPropertyDescriptor, result); [EOL] }
public void testGetPropertyDescriptorWhenIndexIsUnspecified() { [EOL] setPropertyDescriptor(null); [EOL] setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL] setPropertyName("someProperty"); [EOL] setBeanInfo(mockBeanInfo); [EOL] when(mockBeanInfo.getPropertyDescriptor("someProperty")).thenReturn(mockPropertyDescriptor); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals(mockPropertyDescriptor, result); [EOL] }
public void testGetPropertyDescriptorWhenIndexIsValid() { [EOL] setPropertyDescriptor(null); [EOL] setPropertyIndex(1); // Assuming index 1 is valid [EOL] PropertyDescriptor[] mockPropertyDescriptors = new PropertyDescriptor[] {mockPropertyDescriptor1, mockPropertyDescriptor2}; [EOL] setPropertyDescriptors(mockPropertyDescriptors); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals(mockPropertyDescriptors[1], result); [EOL] }
public void testGetPropertyDescriptorWhenIndexIsInvalid() { [EOL] setPropertyDescriptor(null); [EOL] setPropertyIndex(-1); // Assuming -1 is invalid [EOL] PropertyDescriptor[] mockPropertyDescriptors = new PropertyDescriptor[] {}; [EOL] setPropertyDescriptors(mockPropertyDescriptors); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNull(result); [EOL] }
public void testGetPropertyDescriptorWhenAlreadySet() { [EOL] setPropertyDescriptor(mockPropertyDescriptor); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals(mockPropertyDescriptor, result); [EOL] }
public void testGetPropertyDescriptorsWhenNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.beanInfo = mock(BeanInfo.class); [EOL] PropertyDescriptor[] expectedDescriptors = new PropertyDescriptor[0]; [EOL] when(instance.beanInfo.getPropertyDescriptors()).thenReturn(expectedDescriptors); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNotNull(result); [EOL] assertSame("The returned propertyDescriptors should be the same as expectedDescriptors", expectedDescriptors, result); [EOL] }
public void testGetPropertyDescriptorsWhenNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] PropertyDescriptor[] expectedDescriptors = new PropertyDescriptor[0]; [EOL] instance.propertyDescriptors = expectedDescriptors; // Set the propertyDescriptors directly [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNotNull(result); [EOL] assertSame("The returned propertyDescriptors should be the same as the one already set", expectedDescriptors, result); [EOL] }
public void testPackageFunctionsConstructorWithValidArguments() { [EOL] String classPrefix = "com.example"; [EOL] String namespace = "http://www.example.com"; [EOL] PackageFunctions packageFunctions = new PackageFunctions(classPrefix, namespace); [EOL] assertNotNull(packageFunctions); [EOL] assertEquals(classPrefix, packageFunctions.getClassPrefix()); [EOL] assertEquals(namespace, packageFunctions.getNamespace()); [EOL] }
public void testPackageFunctionsConstructorWithNullArguments() { [EOL] PackageFunctions packageFunctions = new PackageFunctions(null, null); [EOL] assertNotNull(packageFunctions); [EOL] assertNull(packageFunctions.getClassPrefix()); [EOL] assertNull(packageFunctions.getNamespace()); [EOL] }
public void testCoreOperationGreaterThanWithNonNullArguments() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationGreaterThan operation = new CoreOperationGreaterThan(arg1, arg2); [EOL] assertNotNull(operation); [EOL] }
public void testCoreOperationGreaterThanWithNullArguments() { [EOL] try { [EOL] new CoreOperationGreaterThan(null, null); [EOL] fail("Should throw IllegalArgumentException for null arguments"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 3; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
protected boolean isSymmetric() { [EOL] return false; [EOL] }
public void testGetSymbol() { [EOL] MyClass instance = new MyClass(); [EOL] String expected = ">"; [EOL] String actual = instance.getSymbol(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCreateNodePointerWithNonNullValues() { [EOL] QName name = new QName("testName"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNotNull(result); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(bean, result.getBean()); [EOL] assertEquals(locale, result.getLocale()); [EOL] }
public void testCreateNodePointerWithNullName() { [EOL] QName name = null; [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNotNull(result); [EOL] assertNull(result.getName()); [EOL] assertEquals(bean, result.getBean()); [EOL] assertEquals(locale, result.getLocale()); [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL] if (bean == null) { [EOL] return new NullPointer(parent, name); [EOL] } [EOL] JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL] return new BeanPointer(parent, name, bean, bi); [EOL] }
public void testCoreOperationCompareWithNonNullExpressions() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationCompare operation = new CoreOperationCompare(arg1, arg2); [EOL] assertNotNull(operation); [EOL] assertEquals(arg1, operation.getArguments()[0]); [EOL] assertEquals(arg2, operation.getArguments()[1]); [EOL] }
protected boolean equal(EvalContext context, Expression left, Expression right) { [EOL] Object l = left.compute(context); [EOL] Object r = right.compute(context); [EOL] if (l instanceof InitialContext || l instanceof SelfContext) { [EOL] l = ((EvalContext) l).getSingleNodePointer(); [EOL] } [EOL] if (r instanceof InitialContext || r instanceof SelfContext) { [EOL] r = ((EvalContext) r).getSingleNodePointer(); [EOL] } [EOL] if (l instanceof Collection) { [EOL] l = ((Collection) l).iterator(); [EOL] } [EOL] if (r instanceof Collection) { [EOL] r = ((Collection) r).iterator(); [EOL] } [EOL] if ((l instanceof Iterator) && !(r instanceof Iterator)) { [EOL] return contains((Iterator) l, r); [EOL] } else if (!(l instanceof Iterator) && (r instanceof Iterator)) { [EOL] return contains((Iterator) r, l); [EOL] } else if (l instanceof Iterator && r instanceof Iterator) { [EOL] return findMatch((Iterator) l, (Iterator) r); [EOL] } [EOL] return equal(l, r); [EOL] }
public void testContainsWithEmptyIterator() { [EOL] Iterator it = Collections.emptyIterator(); [EOL] Object value = new Object(); [EOL] boolean result = contains(it, value); [EOL] assertFalse(result); [EOL] }
public void testContainsWithIteratorContainingValue() { [EOL] List<Object> list = Arrays.asList("a", "b", "c"); [EOL] Iterator it = list.iterator(); [EOL] Object value = "b"; [EOL] boolean result = contains(it, value); [EOL] assertTrue(result); [EOL] }
public void testContainsWithIteratorNotContainingValue() { [EOL] List<Object> list = Arrays.asList("a", "b", "c"); [EOL] Iterator it = list.iterator(); [EOL] Object value = "d"; [EOL] boolean result = contains(it, value); [EOL] assertFalse(result); [EOL] }
public void testEqualWithBothPointersAndEqual() { [EOL] Pointer left = mock(Pointer.class); [EOL] Pointer right = mock(Pointer.class); [EOL] when(left.equals(right)).thenReturn(true); [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithLeftPointerAndRightNonPointer() { [EOL] Pointer left = mock(Pointer.class); [EOL] Object right = new Object(); [EOL] when(left.getValue()).thenReturn(right); [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithRightPointerAndLeftNonPointer() { [EOL] Object left = new Object(); [EOL] Pointer right = mock(Pointer.class); [EOL] when(right.getValue()).thenReturn(left); [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithBothNonPointersAndEqual() { [EOL] Object left = new Object(); [EOL] Object right = left; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithBooleanLeft() { [EOL] Boolean left = true; [EOL] Object right = new Object(); [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithBooleanRight() { [EOL] Object left = new Object(); [EOL] Boolean right = true; [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithNumberLeft() { [EOL] Number left = 5; [EOL] Object right = new Object(); [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithNumberRight() { [EOL] Object left = new Object(); [EOL] Number right = 5; [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithStringLeft() { [EOL] String left = "test"; [EOL] Object right = new Object(); [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithStringRight() { [EOL] Object left = new Object(); [EOL] String right = "test"; [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithBothNull() { [EOL] Object left = null; [EOL] Object right = null; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithLeftNullAndRightNonNull() { [EOL] Object left = null; [EOL] Object right = new Object(); [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithLeftNonNullAndRightNull() { [EOL] Object left = new Object(); [EOL] Object right = null; [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testEqualWithNonEqualNonPointers() { [EOL] Object left = new Object(); [EOL] Object right = new Object(); [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testPredicateContextWithNullExpression() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] Expression expression = null; [EOL] PredicateContext predicateContext = new PredicateContext(parentContext, expression); [EOL] assertNull(predicateContext.getExpression()); [EOL] }
public void testPredicateContextWithNameAttributeTestExpression() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NameAttributeTest nameAttributeTest = mock(NameAttributeTest.class); [EOL] when(nameAttributeTest.getNameTestExpression()).thenReturn(mock(Expression.class)); [EOL] PredicateContext predicateContext = new PredicateContext(parentContext, nameAttributeTest); [EOL] assertNotNull(predicateContext.getNameTestExpression()); [EOL] }
public void testPredicateContextWithNonNameAttributeTestExpression() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] PredicateContext predicateContext = new PredicateContext(parentContext, expression); [EOL] assertNull(predicateContext.getNameTestExpression()); [EOL] }
public void testNextNodeWhenDone() { [EOL] YourClass instance = new YourClass(); [EOL] instance.done = true; [EOL] boolean result = instance.nextNode(); [EOL] assertFalse("Expected nextNode to return false when done is true", result); [EOL] }
public void testNextNodeWithParentContextReturningFalse() { [EOL] YourClass instance = new YourClass(); [EOL] ParentContext parentContext = mock(ParentContext.class); [EOL] when(parentContext.nextNode()).thenReturn(false); [EOL] instance.parentContext = parentContext; [EOL] boolean result = instance.nextNode(); [EOL] assertFalse("Expected nextNode to return false when parentContext.nextNode() returns false", result); [EOL] }
public void testNextNodeWithSetupDynamicPropertyPointerReturningTrue() { [EOL] YourClass instance = new YourClass(); [EOL] ParentContext parentContext = mock(ParentContext.class); [EOL] when(parentContext.nextNode()).thenReturn(true); [EOL] instance.parentContext = parentContext; [EOL] instance.setupDynamicPropertyPointer = true; // Assuming this is a boolean field for the example [EOL] NameTestExpression nameTestExpression = mock(NameTestExpression.class); [EOL] DynamicPropertyPointer dynamicPropertyPointer = mock(DynamicPropertyPointer.class); [EOL] instance.nameTestExpression = nameTestExpression; [EOL] instance.dynamicPropertyPointer = dynamicPropertyPointer; [EOL] when(nameTestExpression.computeValue(parentContext)).thenReturn("propertyName"); [EOL] when(dynamicPropertyPointer.getPropertyNames()).thenReturn(new String[]{"propertyName"}); [EOL] when(dynamicPropertyPointer.setPropertyName("propertyName")).thenReturn(true); [EOL] boolean result = instance.nextNode(); [EOL] assertTrue("Expected nextNode to return true when setupDynamicPropertyPointer() returns true", result); [EOL] }
public void testNextNodeWithIteratorAndNoNextElement() { [EOL] YourClass instance = new YourClass(); [EOL] ParentContext parentContext = mock(ParentContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] Iterator iterator = mock(Iterator.class); [EOL] when(parentContext.nextNode()).thenReturn(true); [EOL] when(expression.computeValue(parentContext)).thenReturn(iterator); [EOL] when(iterator.hasNext()).thenReturn(false); [EOL] instance.parentContext = parentContext; [EOL] instance.expression = expression; [EOL] boolean result = instance.nextNode(); [EOL] assertFalse("Expected nextNode to return false when the Iterator has no next element", result); [EOL] }
public void testNextNodeWithNumberPredicate() { [EOL] YourClass instance = new YourClass(); [EOL] ParentContext parentContext = mock(ParentContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] when(parentContext.nextNode()).thenReturn(true); [EOL] when(expression.computeValue(parentContext)).thenReturn(1); // Assuming the number is 1 for simplicity [EOL] instance.parentContext = parentContext; [EOL] instance.expression = expression; [EOL] boolean result = instance.nextNode(); [EOL] assertTrue("Expected nextNode to return true when the predicate is a Number", result); [EOL] }
public void testNextNodeWithBooleanPredicateReturningTrue() { [EOL] YourClass instance = new YourClass(); [EOL] ParentContext parentContext = mock(ParentContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] when(parentContext.nextNode()).thenReturn(true); [EOL] when(expression.computeValue(parentContext)).thenReturn(Boolean.TRUE); [EOL] instance.parentContext = parentContext; [EOL] instance.expression = expression; [EOL] boolean result = instance.nextNode(); [EOL] assertTrue("Expected nextNode to return true when the predicate is a Boolean true", result); [EOL] }
public void testSetupDynamicPropertyPointer_NameTestExpressionIsNull() { [EOL] this.nameTestExpression = null; [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_ParentIsNull() { [EOL] this.nameTestExpression = someNonNullValue; [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(null); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_ParentIsNotPropertyOwnerPointer() { [EOL] this.nameTestExpression = someNonNullValue; [EOL] NodePointer nonPropertyOwnerPointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(nonPropertyOwnerPointer); [EOL] when(nonPropertyOwnerPointer.getValuePointer()).thenReturn(nonPropertyOwnerPointer); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_SuccessfulSetup() { [EOL] this.nameTestExpression = someNonNullValue; [EOL] PropertyOwnerPointer propertyOwnerPointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getValuePointer()).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertTrue(result); [EOL] assertEquals(propertyPointer, dynamicPropertyPointer); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionFails() { [EOL] context.setPosition(0); [EOL] Mockito.when(context.setPosition(1)).thenReturn(false); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds_DynamicPropertyPointerNotNull() { [EOL] context.setPosition(0); [EOL] Mockito.when(context.setPosition(1)).thenReturn(true); [EOL] DynamicPropertyPointer mockDynamicPropertyPointer = Mockito.mock(DynamicPropertyPointer.class); [EOL] context.dynamicPropertyPointer = mockDynamicPropertyPointer; [EOL] NodePointer mockValuePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockDynamicPropertyPointer.getValuePointer()).thenReturn(mockValuePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockValuePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds_DynamicPropertyPointerNull() { [EOL] context.setPosition(0); [EOL] Mockito.when(context.setPosition(1)).thenReturn(true); [EOL] context.dynamicPropertyPointer = null; [EOL] NodePointer mockParentNodePointer = Mockito.mock(NodePointer.class); [EOL] Context mockParentContext = Mockito.mock(Context.class); [EOL] context.parentContext = mockParentContext; [EOL] Mockito.when(mockParentContext.getCurrentNodePointer()).thenReturn(mockParentNodePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockParentNodePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionNotZero_DynamicPropertyPointerNotNull() { [EOL] context.setPosition(1); [EOL] DynamicPropertyPointer mockDynamicPropertyPointer = Mockito.mock(DynamicPropertyPointer.class); [EOL] context.dynamicPropertyPointer = mockDynamicPropertyPointer; [EOL] NodePointer mockValuePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockDynamicPropertyPointer.getValuePointer()).thenReturn(mockValuePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockValuePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionNotZero_DynamicPropertyPointerNull() { [EOL] context.setPosition(1); [EOL] context.dynamicPropertyPointer = null; [EOL] NodePointer mockParentNodePointer = Mockito.mock(NodePointer.class); [EOL] Context mockParentContext = Mockito.mock(Context.class); [EOL] context.parentContext = mockParentContext; [EOL] Mockito.when(mockParentContext.getCurrentNodePointer()).thenReturn(mockParentNodePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockParentNodePointer, result); [EOL] }
public void testReset() { [EOL] ParentContext mockParentContext = mock(ParentContext.class); [EOL] TestableClass instance = new TestableClass(mockParentContext); [EOL] instance.done = true; // Set done to true to check if it's reset to false [EOL] instance.reset(); [EOL] verify(mockParentContext).reset(); // Verify that parentContext.reset() is called [EOL] assertFalse(instance.done); // Check if done is reset to false [EOL] }
public void testNextSetTrue() { [EOL] ParentContext mockParentContext = Mockito.mock(ParentContext.class); [EOL] Mockito.when(mockParentContext.nextSet()).thenReturn(true); [EOL] this.parentContext = mockParentContext; [EOL] boolean result = nextSet(); [EOL] assertTrue(result); [EOL] }
public void testNextSetFalse() { [EOL] ParentContext mockParentContext = Mockito.mock(ParentContext.class); [EOL] Mockito.when(mockParentContext.nextSet()).thenReturn(false); [EOL] this.parentContext = mockParentContext; [EOL] boolean result = nextSet(); [EOL] assertFalse(result); [EOL] }
public Object convert(Object object, Class toType) { [EOL] if (object == null) { [EOL] if (toType.isPrimitive()) { [EOL] return convertNullToPrimitive(toType); [EOL] } [EOL] return null; [EOL] } [EOL] if (toType == Object.class) { [EOL] if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return object; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL] return object; [EOL] } [EOL] if (fromType.isArray()) { [EOL] int length = Array.getLength(object); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] for (int i = 0; i < length; i++) { [EOL] collection.add(Array.get(object, i)); [EOL] } [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] int length = ((Collection) object).size(); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = it.next(); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] collection.addAll((Collection) object); [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } else if (toType == String.class) { [EOL] return object.toString(); [EOL] } else if (object instanceof Boolean) { [EOL] if (toType == boolean.class) { [EOL] return object; [EOL] } [EOL] boolean value = ((Boolean) object).booleanValue(); [EOL] return allocateNumber(toType, value ? 1 : 0); [EOL] } else if (object instanceof Number) { [EOL] double value = ((Number) object).doubleValue(); [EOL] if (toType == boolean.class || toType == Boolean.class) { [EOL] return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL] } [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return allocateNumber(toType, value); [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return object; [EOL] } [EOL] } else if (object instanceof String) { [EOL] Object value = convertStringToPrimitive(object, toType); [EOL] if (value != null) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter converter = ConvertUtils.lookup(toType); [EOL] if (converter != null) { [EOL] return converter.convert(toType, object); [EOL] } [EOL] throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
protected void FillBuff() throws java.io.IOException { [EOL] if (maxNextCharInd == available) { [EOL] if (available == bufsize) { [EOL] if (tokenBegin > 2048) { [EOL] bufpos = maxNextCharInd = 0; [EOL] available = tokenBegin; [EOL] } else if (tokenBegin < 0) [EOL] bufpos = maxNextCharInd = 0; [EOL] else [EOL] ExpandBuff(false); [EOL] } else if (available > tokenBegin) [EOL] available = bufsize; [EOL] else if ((tokenBegin - available) < 2048) [EOL] ExpandBuff(true); [EOL] else [EOL] available = tokenBegin; [EOL] } [EOL] int i; [EOL] try { [EOL] if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) { [EOL] inputStream.close(); [EOL] throw new java.io.IOException(); [EOL] } else [EOL] maxNextCharInd += i; [EOL] return; [EOL] } catch (java.io.IOException e) { [EOL] --bufpos; [EOL] backup(0); [EOL] if (tokenBegin == -1) [EOL] tokenBegin = bufpos; [EOL] throw e; [EOL] } [EOL] }
public void testBeginTokenWithValidChar() throws java.io.IOException { [EOL] initReaderWithContent("validContent"); [EOL] char result = BeginToken(); [EOL] assertEquals('v', result); [EOL] assertEquals(0, tokenBegin); [EOL] }
public void testBeginTokenAtEndOfFile() throws java.io.IOException { [EOL] initReaderWithContent(""); // Empty content to simulate end of file [EOL] try { [EOL] BeginToken(); [EOL] fail("Expected an IOException due to end of file"); [EOL] } catch (IOException e) { [EOL] } [EOL] assertEquals(-1, tokenBegin); [EOL] }
public void testUpdateLineColumnWithCR() { [EOL] UpdateLineColumn('\r'); [EOL] } [EOL] public void testUpdateLineColumnWithLF() { [EOL] UpdateLineColumn('\n'); [EOL] } [EOL] public void testUpdateLineColumnWithTab() { [EOL] UpdateLineColumn('\t'); [EOL] } [EOL] public void testUpdateLineColumnWithRegularChar() { [EOL] UpdateLineColumn('a'); [EOL] }
public void testUpdateLineColumnWithCRFollowingLF() { [EOL] prevCharIsLF = true; [EOL] UpdateLineColumn('\r'); [EOL] } [EOL] public void testUpdateLineColumnWithLFFollowingCR() { [EOL] prevCharIsCR = true; [EOL] UpdateLineColumn('\n'); [EOL] }
public void testUpdateLineColumnWithNonNewlineFollowingCR() { [EOL] prevCharIsCR = true; [EOL] UpdateLineColumn('a'); [EOL] }
public void testReadCharWithNonEmptyBuffer() throws java.io.IOException { [EOL] buffer[0] = 'a'; [EOL] bufsize = 1; [EOL] bufpos = 0; [EOL] inBuf = 1; [EOL] char result = readChar(); [EOL] assertEquals('a', result); [EOL] assertEquals(0, inBuf); [EOL] assertEquals(0, bufpos); [EOL] }
public void testReadCharWithEmptyBufferAndNonEmptyMaxNextCharInd() throws java.io.IOException { [EOL] buffer[0] = 'b'; [EOL] bufsize = 1; [EOL] bufpos = -1; // To ensure that the if condition (++bufpos >= maxNextCharInd) is true [EOL] maxNextCharInd = 1; [EOL] inBuf = 0; [EOL] char result = readChar(); [EOL] assertEquals('b', result); [EOL] }
public void testReadCharWithEmptyBufferAndEmptyMaxNextCharInd() throws java.io.IOException { [EOL] buffer[0] = 'c'; [EOL] bufsize = 1; [EOL] bufpos = 0; // To ensure that the if condition (++bufpos >= maxNextCharInd) is false [EOL] maxNextCharInd = 0; [EOL] inBuf = 0; [EOL] char result = readChar(); [EOL] assertEquals('c', result); [EOL] }
public void testGetEndColumn_ValidBufPos() { [EOL] int[] testBufColumn = {1, 2, 3, 4, 5}; [EOL] int testBufPos = 2; // Index for which we want to get the value [EOL] int expected = testBufColumn[testBufPos]; [EOL] int actual = getEndColumn(); [EOL] }
public void testGetEndColumn_BufPosAtEnd() { [EOL] int[] testBufColumn = {1, 2, 3, 4, 5}; [EOL] int testBufPos = testBufColumn.length - 1; // Last index [EOL] int expected = testBufColumn[testBufPos]; [EOL] int actual = getEndColumn(); [EOL] }
public void testGetEndLine_PositiveBufPos() { [EOL] int expectedLine = 5; // Replace with an actual line number expected [EOL] int bufpos = 3; // Replace with an actual buffer position [EOL] int[] bufline = new int[] {1, 2, 3, 4, expectedLine}; // Replace with actual buffer line array [EOL] YourClass instance = new YourClass(bufline, bufpos); // Replace 'YourClass' with the actual class name [EOL] int result = instance.getEndLine(); [EOL] assertEquals(expectedLine, result); [EOL] }
public void testGetEndLine_NegativeBufPos() { [EOL] int expectedLine = -1; // Assuming the method should return -1 for negative 'bufpos' [EOL] int bufpos = -1; // A negative buffer position [EOL] int[] bufline = new int[] {1, 2, 3, 4, 5}; // Replace with actual buffer line array [EOL] YourClass instance = new YourClass(bufline, bufpos); // Replace 'YourClass' with the actual class name [EOL] int result = instance.getEndLine(); [EOL] assertEquals(expectedLine, result); [EOL] }
public void testGetEndLine_BufPosOutOfBounds() { [EOL] int expectedLine = 0; // Assuming the method should handle out of bounds by returning 0 or some default value [EOL] int bufpos = 10; // An out of bounds buffer position [EOL] int[] bufline = new int[] {1, 2, 3, 4, 5}; // Replace with actual buffer line array [EOL] YourClass instance = new YourClass(bufline, bufpos); // Replace 'YourClass' with the actual class name [EOL] int result = instance.getEndLine(); [EOL] assertEquals(expectedLine, result); [EOL] }
public void testGetBeginColumn_ValidTokenBegin() { [EOL] JxPath parser = new JxPath(new StringReader("")); [EOL] parser.tokenBegin = 0; [EOL] parser.bufcolumn = new int[]{5, 10, 15}; // Assuming bufcolumn is accessible and modifiable [EOL] int beginColumn = parser.getBeginColumn(); [EOL] assertEquals(5, beginColumn); [EOL] } [EOL] public void testGetBeginColumn_NegativeTokenBegin() { [EOL] JxPath parser = new JxPath(new StringReader("")); [EOL] parser.tokenBegin = -1; [EOL] parser.bufcolumn = new int[]{5, 10, 15}; // Assuming bufcolumn is accessible and modifiable [EOL] try { [EOL] parser.getBeginColumn(); [EOL] fail("Expected an ArrayIndexOutOfBoundsException to be thrown"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testGetBeginColumn_TokenBeginExceedsBufferLength() { [EOL] JxPath parser = new JxPath(new StringReader("")); [EOL] parser.tokenBegin = 3; [EOL] parser.bufcolumn = new int[]{5, 10, 15}; // Assuming bufcolumn is accessible and modifiable [EOL] try { [EOL] parser.getBeginColumn(); [EOL] fail("Expected an ArrayIndexOutOfBoundsException to be thrown"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetBeginLine() { [EOL] ParserTokenManager tokenManager = new ParserTokenManager(null); [EOL] tokenManager.bufline = new int[]{1, 2, 3, 4, 5}; [EOL] tokenManager.tokenBegin = 0; [EOL] assertEquals(1, tokenManager.getBeginLine()); [EOL] tokenManager.tokenBegin = 3; [EOL] assertEquals(4, tokenManager.getBeginLine()); [EOL] }
public void testBackupWithPositiveAmountLessThanBufpos() { [EOL] int amount = 10; [EOL] int initialBufpos = 20; [EOL] int initialInBuf = 5; [EOL] int bufsize = 50; [EOL] YourClass instance = new YourClass(initialBufpos, initialInBuf, bufsize); [EOL] instance.backup(amount); [EOL] assertEquals(initialInBuf + amount, instance.getInBuf()); [EOL] assertEquals(initialBufpos - amount, instance.getBufpos()); [EOL] }
public void testBackupWithPositiveAmountGreaterThanBufpos() { [EOL] int amount = 60; [EOL] int initialBufpos = 50; [EOL] int initialInBuf = 5; [EOL] int bufsize = 100; [EOL] YourClass instance = new YourClass(initialBufpos, initialInBuf, bufsize); [EOL] instance.backup(amount); [EOL] assertEquals(initialInBuf + amount, instance.getInBuf()); [EOL] assertEquals(initialBufpos - amount + bufsize, instance.getBufpos()); [EOL] }
public void testReInitWithNewBufferSize() { [EOL] MyParser parser = new MyParser(); [EOL] java.io.StringReader reader = new java.io.StringReader("Test input"); [EOL] int startLine = 1; [EOL] int startColumn = 1; [EOL] int bufferSize = 256; [EOL] parser.ReInit(reader, startLine, startColumn, bufferSize); [EOL] assertEquals("Buffer size should match the provided buffer size", bufferSize, parser.buffer.length); [EOL] assertEquals("Start line should be set correctly", startLine, parser.line); [EOL] assertEquals("Start column should be set to startColumn - 1", startColumn - 1, parser.column); [EOL] assertEquals("Buffer position should be initialized to -1", -1, parser.bufpos); [EOL] }
public void testReInitWithExistingBufferSize() { [EOL] MyParser parser = new MyParser(); [EOL] java.io.StringReader reader = new java.io.StringReader("Test input"); [EOL] int startLine = 1; [EOL] int startColumn = 1; [EOL] int bufferSize = 256; [EOL] parser.ReInit(reader, startLine, startColumn, bufferSize); [EOL] parser.ReInit(reader, startLine, startColumn, bufferSize); [EOL] assertEquals("Buffer should not be reallocated if the size is the same", bufferSize, parser.buffer.length); [EOL] assertEquals("Start line should be set correctly", startLine, parser.line); [EOL] assertEquals("Start column should be set to startColumn - 1", startColumn - 1, parser.column); [EOL] assertEquals("Buffer position should be initialized to -1", -1, parser.bufpos); [EOL] }
public void testReInitWithValidParameters() { [EOL] java.io.StringReader reader = new java.io.StringReader("some input data"); [EOL] int startline = 1; [EOL] int startcolumn = 1; [EOL] YourClassName instance = new YourClassName(); [EOL] instance.ReInit(reader, startline, startcolumn); [EOL] }
public void testReInitWithDifferentStartLine() { [EOL] java.io.StringReader reader = new java.io.StringReader("some input data"); [EOL] int startline = 10; [EOL] int startcolumn = 1; [EOL] YourClassName instance = new YourClassName(); [EOL] instance.ReInit(reader, startline, startcolumn); [EOL] }
public void testReInitWithDifferentStartColumn() { [EOL] java.io.StringReader reader = new java.io.StringReader("some input data"); [EOL] int startline = 1; [EOL] int startcolumn = 10; [EOL] YourClassName instance = new YourClassName(); [EOL] instance.ReInit(reader, startline, startcolumn); [EOL] }
public void testGetImageWithBufposGreaterThanOrEqualToTokenBegin() { [EOL] char[] buffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int tokenBegin = 1; [EOL] int bufpos = 2; [EOL] YourClass obj = new YourClass(buffer, tokenBegin, bufpos); [EOL] String result = obj.GetImage(); [EOL] assertEquals("bc", result); [EOL] }
public void testGetImageWithBufposLessThanTokenBegin() { [EOL] char[] buffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int tokenBegin = 3; [EOL] int bufpos = 1; [EOL] int bufsize = 5; [EOL] YourClass obj = new YourClass(buffer, tokenBegin, bufpos, bufsize); [EOL] String result = obj.GetImage(); [EOL] assertEquals("deab", result); [EOL] }
public void testComputeValueWhenEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[]{mock(Object.class), mock(Object.class)}; [EOL] JxPath jxPath = new JxPath(args); [EOL] when(jxPath.equal(context, args[0], args[1])).thenReturn(true); [EOL] Object result = jxPath.computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueWhenNotEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[]{mock(Object.class), mock(Object.class)}; [EOL] JxPath jxPath = new JxPath(args); [EOL] when(jxPath.equal(context, args[0], args[1])).thenReturn(false); [EOL] Object result = jxPath.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testNamespacePointerWithNonNullParentAndPrefix() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String prefix = "testPrefix"; [EOL] String namespaceURI = "testNamespaceURI"; [EOL] NamespacePointer namespacePointer = new NamespacePointer(parent, prefix, namespaceURI); [EOL] assertNotNull(namespacePointer); [EOL] assertEquals(parent, namespacePointer.getParent()); [EOL] assertEquals(prefix, namespacePointer.getPrefix()); [EOL] assertEquals(namespaceURI, namespacePointer.getNamespaceURI()); [EOL] }
public void testNamespacePointerWithNullParent() { [EOL] String prefix = "testPrefix"; [EOL] String namespaceURI = "testNamespaceURI"; [EOL] NamespacePointer namespacePointer = new NamespacePointer(null, prefix, namespaceURI); [EOL] assertNotNull(namespacePointer); [EOL] assertNull(namespacePointer.getParent()); [EOL] assertEquals(prefix, namespacePointer.getPrefix()); [EOL] assertEquals(namespaceURI, namespacePointer.getNamespaceURI()); [EOL] }
public void testNamespacePointerWithNullPrefix() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String namespaceURI = "testNamespaceURI"; [EOL] NamespacePointer namespacePointer = new NamespacePointer(parent, null, namespaceURI); [EOL] assertNotNull(namespacePointer); [EOL] assertEquals(parent, namespacePointer.getParent()); [EOL] assertNull(namespacePointer.getPrefix()); [EOL] assertEquals(namespaceURI, namespacePointer.getNamespaceURI()); [EOL] }
public void testNamespacePointerWithNullNamespaceURI() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String prefix = "testPrefix"; [EOL] NamespacePointer namespacePointer = new NamespacePointer(parent, prefix, null); [EOL] assertNotNull(namespacePointer); [EOL] assertEquals(parent, namespacePointer.getParent()); [EOL] assertEquals(prefix, namespacePointer.getPrefix()); [EOL] assertNull(namespacePointer.getNamespaceURI()); [EOL] }
public void testGetNameWithNonNullPrefix() { [EOL] String prefix = "testPrefix"; [EOL] QName testQName = new QName(prefix); [EOL] QName result = testQName.getName(); [EOL] assertNotNull(result); [EOL] assertEquals(prefix, result.getPrefix()); [EOL] }
public void testGetNameWithNullPrefix() { [EOL] String prefix = null; [EOL] QName testQName = new QName(prefix); [EOL] QName result = testQName.getName(); [EOL] assertNotNull(result); [EOL] assertNull(result.getPrefix()); [EOL] }
public void testGetNamespaceURI_WithNullNamespaceURI() { [EOL] NamespaceContext parent = mock(NamespaceContext.class); [EOL] when(parent.getNamespaceURI(anyString())).thenReturn("http://example.com/"); [EOL] MyNamespaceContext context = new MyNamespaceContext(parent, "prefix"); [EOL] String result = context.getNamespaceURI(); [EOL] assertEquals("http://example.com/", result); [EOL] }
public void testGetNamespaceURI_WithNonNullNamespaceURI() { [EOL] NamespaceContext parent = mock(NamespaceContext.class); [EOL] MyNamespaceContext context = new MyNamespaceContext(parent, "prefix"); [EOL] context.namespaceURI = "http://example.org/"; [EOL] String result = context.getNamespaceURI(); [EOL] assertEquals("http://example.org/", result); [EOL] }
public void testCoreOperationNotEqualConstructor() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationNotEqual notEqual = new CoreOperationNotEqual(arg1, arg2); [EOL] assertNotNull(notEqual); [EOL] }
protected int getPrecedence() { [EOL] return 2; [EOL] }
public void testGetSymbol() { [EOL] ClassName instance = new ClassName(); [EOL] String result = instance.getSymbol(); [EOL] assertEquals("Expected symbol to be '!=', but was: " + result, "!=", result); [EOL] }
public void testNewTokenWithDefaultKind() { [EOL] Token token = ClassName.newToken(0); [EOL] assertNotNull(token); [EOL] }
public void testComputeContextDependentWhenAbsoluteIsFalse() { [EOL] MyXPathClass testInstance = new MyXPathClass(); [EOL] testInstance.absolute = false; [EOL] boolean result = testInstance.computeContextDependent(); [EOL] assertTrue("Expected context to be dependent when absolute is false", result); [EOL] }
public void testComputeContextDependentWhenAbsoluteIsTrue() { [EOL] MyXPathClass testInstance = new MyXPathClass(); [EOL] testInstance.absolute = true; [EOL] MyXPathClass superInstance = mock(MyXPathClass.class); [EOL] when(superInstance.computeContextDependent()).thenReturn(true); [EOL] boolean result = testInstance.computeContextDependent(); [EOL] assertTrue("Expected context to be dependent when absolute is true", result); [EOL] }
public void testNumberWithValidDouble() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Object result = context.number("123.456"); [EOL] assertTrue(result instanceof Constant); [EOL] assertEquals(123.456, ((Constant) result).computeValue(null)); [EOL] } [EOL] public void testNumberWithInvalidDouble() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] try { [EOL] context.number("invalid"); [EOL] fail("Should have thrown an exception due to invalid double format"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public Object sum(Object[] arguments) { [EOL] return new CoreOperationAdd(toExpressionArray(arguments)); [EOL] }
public void testEqualWithNameAttributeTest() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] when(isNameAttributeTest(left)).thenReturn(true); [EOL] Object result = equal(left, right); [EOL] assertTrue(result instanceof NameAttributeTest); [EOL] assertEquals(left, ((NameAttributeTest) result).getLeftExpression()); [EOL] assertEquals(right, ((NameAttributeTest) result).getRightExpression()); [EOL] }
public void testEqualWithCoreOperationEqual() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] when(isNameAttributeTest(left)).thenReturn(false); [EOL] Object result = equal(left, right); [EOL] assertTrue(result instanceof CoreOperationEqual); [EOL] assertEquals(left, ((CoreOperationEqual) result).getLeftExpression()); [EOL] assertEquals(right, ((CoreOperationEqual) result).getRightExpression()); [EOL] }
public void testNotEqualWithNonNullExpressions() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] Object result = notEqual(left, right); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreOperationNotEqual); [EOL] }
public void testNotEqualWithLeftNullExpression() { [EOL] Expression right = mock(Expression.class); [EOL] Object result = notEqual(null, right); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreOperationNotEqual); [EOL] }
public void testNotEqualWithRightNullExpression() { [EOL] Expression left = mock(Expression.class); [EOL] Object result = notEqual(left, null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreOperationNotEqual); [EOL] }
public void testNotEqualWithBothNullExpressions() { [EOL] Object result = notEqual(null, null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreOperationNotEqual); [EOL] }
public void testToExpressionArrayWithNonNullArray() { [EOL] Object[] inputArray = new Object[]{new ExpressionImpl(), new ExpressionImpl()}; [EOL] Expression[] result = toExpressionArray(inputArray); [EOL] assertNotNull(result); [EOL] assertEquals(inputArray.length, result.length); [EOL] for (int i = 0; i < inputArray.length; i++) { [EOL] assertSame(inputArray[i], result[i]); [EOL] } [EOL] }
public void testToExpressionArrayWithNullArray() { [EOL] Object[] inputArray = null; [EOL] Expression[] result = toExpressionArray(inputArray); [EOL] assertNull(result); [EOL] }
public void testIsNameAttributeTest_NotInstanceOfLocationPath() { [EOL] Expression arg = mock(Expression.class); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_StepsNotEqualOne() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[2]; // Assuming Step is a valid class [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_AxisNotAttribute() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_CHILD); // Assuming AXIS_CHILD is a valid constant and different from AXIS_ATTRIBUTE [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NotInstanceOfNodeNameTest() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step step = mock(Step.class); [EOL] Step[] steps = new Step[]{step}; [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeTest); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NodeNameNotEqualsQNAME_NAME() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step step = mock(Step.class); [EOL] Step[] steps = new Step[]{step}; [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName qname = mock(QName.class); [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(qname); [EOL] when(qname.equals(QNAME_NAME)).thenReturn(false); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_ValidCase() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step step = mock(Step.class); [EOL] Step[] steps = new Step[]{step}; [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(QNAME_NAME); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertTrue(result); [EOL] }
public Expression[] getPredicates() { [EOL] return predicates; [EOL] }
public void testIsSimpleExpressionPath_WhenBasicKnownIsFalse() { [EOL] setBasicKnown(false); [EOL] setPredicates(new Predicates()); // Assuming Predicates is a class and we can create an instance [EOL] boolean result = isSimpleExpressionPath(); [EOL] assertTrue(result == basic); // Assuming 'basic' is a field that holds the expected result [EOL] }
public void testIsSimpleExpressionPath_WhenBasicKnownIsTrue() { [EOL] setBasicKnown(true); [EOL] boolean result = isSimpleExpressionPath(); [EOL] assertTrue(result == basic); // Assuming 'basic' is a field that holds the expected result [EOL] }
public Object computeValue(EvalContext context) { [EOL] return expressionPath(context, true); [EOL] }
protected Object expressionPath(EvalContext evalContext, boolean firstMatch) { [EOL] Object value = expression.compute(evalContext); [EOL] EvalContext context; [EOL] if (value instanceof InitialContext) { [EOL] context = (InitialContext) value; [EOL] } else if (value instanceof EvalContext) { [EOL] context = new UnionContext(evalContext, new EvalContext[] { (EvalContext) value }); [EOL] } else { [EOL] context = evalContext.getRootContext().getConstantContext(value); [EOL] } [EOL] if (firstMatch && isSimpleExpressionPath() && !(context instanceof NodeSetContext)) { [EOL] EvalContext ctx = context; [EOL] NodePointer ptr = (NodePointer) ctx.getSingleNodePointer(); [EOL] if (ptr != null && (ptr.getIndex() == NodePointer.WHOLE_COLLECTION || predicates == null || predicates.length == 0)) { [EOL] return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps()); [EOL] } [EOL] } [EOL] if (predicates != null) { [EOL] for (int j = 0; j < predicates.length; j++) { [EOL] if (j != 0) { [EOL] context = new UnionContext(context, new EvalContext[] { context }); [EOL] } [EOL] context = new PredicateContext(context, predicates[j]); [EOL] } [EOL] } [EOL] if (firstMatch) { [EOL] return getSingleNodePointerForSteps(context); [EOL] } else { [EOL] return evalSteps(context); [EOL] } [EOL] }
public void testGetImmediateNodeWithWildcardName() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "*"); [EOL] Object result = context.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithWholeCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "validPropertyName"); [EOL] context.getVariables().declareVariable("index", WHOLE_COLLECTION); [EOL] Object result = context.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertTrue(isWholeCollection(result)); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndValidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "indexedPropertyName"); [EOL] context.getVariables().declareVariable("index", 1); // Assuming index 1 is valid [EOL] Object result = context.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAtIndex1, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndInvalidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "indexedPropertyName"); [EOL] context.getVariables().declareVariable("index", invalidIndex); // Assuming this index is invalid [EOL] Object result = context.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndIllegalArgumentException() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "indexedPropertyName"); [EOL] context.getVariables().declareVariable("index", indexCausingException); // Assuming this index causes IllegalArgumentException [EOL] Object result = context.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAfterException, result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndNonZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "nonIndexedPropertyName"); [EOL] context.getVariables().declareVariable("index", nonZeroIndex); // Assuming this index is not zero [EOL] Object result = context.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] context.getVariables().declareVariable("name", "nonIndexedPropertyName"); [EOL] context.getVariables().declareVariable("index", 0); [EOL] Object result = context.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedNonIndexedValue, result); [EOL] }
public void testSetValueWithWholeCollection() { [EOL] int index = WHOLE_COLLECTION; [EOL] Object value = new Object(); [EOL] setValue(index, value); [EOL] verify(dynaBean).set(getPropertyName(), any()); [EOL] }
public void testSetValueWithIndexedProperty() { [EOL] int index = 1; // Any index that is not WHOLE_COLLECTION [EOL] Object value = new Object(); [EOL] setValue(index, value); [EOL] verify(dynaBean).set(getPropertyName(), eq(index), any()); [EOL] }
public void testSetValueWithNonIndexedProperty() { [EOL] int index = 1; // Any index that is not WHOLE_COLLECTION [EOL] Object value = new Object(); [EOL] setValue(index, value); [EOL] verify(dynaBean).get(getPropertyName()); [EOL] verifyStatic(ValueUtils.class); [EOL] ValueUtils.setValue(any(), eq(index), eq(value)); [EOL] }
public void testToStringWithAxisChild() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_CHILD); [EOL] instance.setNodeTest("testNode"); [EOL] String result = instance.toString(); [EOL] assertEquals("testNode", result); [EOL] }
public void testToStringWithAxisAttribute() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_ATTRIBUTE); [EOL] instance.setNodeTest("testNode"); [EOL] String result = instance.toString(); [EOL] assertEquals("@testNode", result); [EOL] }
public void testToStringWithAxisSelfNodeTypeNode() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_SELF); [EOL] NodeTypeTest nodeTest = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] instance.setNodeTest(nodeTest); [EOL] String result = instance.toString(); [EOL] assertEquals(".", result); [EOL] }
public void testToStringWithAxisParentNodeTypeNode() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_PARENT); [EOL] NodeTypeTest nodeTest = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] instance.setNodeTest(nodeTest); [EOL] String result = instance.toString(); [EOL] assertEquals("..", result); [EOL] }
public void testToStringWithAxisDescendantOrSelfNodeTypeNodeNoPredicates() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_DESCENDANT_OR_SELF); [EOL] NodeTypeTest nodeTest = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] instance.setNodeTest(nodeTest); [EOL] instance.setPredicates(null); [EOL] String result = instance.toString(); [EOL] assertEquals("", result); [EOL] }
public void testToStringWithOtherAxis() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_OTHER); [EOL] instance.setNodeTest("testNode"); [EOL] instance.setAxisToStringReturnValue("otherAxis"); [EOL] String result = instance.toString(); [EOL] assertEquals("otherAxis::testNode", result); [EOL] }
public void testToStringWithPredicates() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_OTHER); [EOL] instance.setNodeTest("testNode"); [EOL] instance.setAxisToStringReturnValue("otherAxis"); [EOL] Expression[] predicates = new Expression[]{new Expression("predicate1"), new Expression("predicate2")}; [EOL] instance.setPredicates(predicates); [EOL] String result = instance.toString(); [EOL] assertEquals("otherAxis::testNode[predicate1][predicate2]", result); [EOL] }
public void testAxisToStringSelf() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_SELF); [EOL] assertEquals("self", result); [EOL] } [EOL] public void testAxisToStringChild() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_CHILD); [EOL] assertEquals("child", result); [EOL] } [EOL] public void testAxisToStringParent() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_PARENT); [EOL] assertEquals("parent", result); [EOL] } [EOL] public void testAxisToStringAncestor() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_ANCESTOR); [EOL] assertEquals("ancestor", result); [EOL] } [EOL] public void testAxisToStringAttribute() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_ATTRIBUTE); [EOL] assertEquals("attribute", result); [EOL] } [EOL] public void testAxisToStringNamespace() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_NAMESPACE); [EOL] assertEquals("namespace", result); [EOL] } [EOL] public void testAxisToStringPreceding() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_PRECEDING); [EOL] assertEquals("preceding", result); [EOL] } [EOL] public void testAxisToStringFollowing() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_FOLLOWING); [EOL] assertEquals("following", result); [EOL] } [EOL] public void testAxisToStringDescendant() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_DESCENDANT); [EOL] assertEquals("descendant", result); [EOL] } [EOL] public void testAxisToStringAncestorOrSelf() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_ANCESTOR_OR_SELF); [EOL] assertEquals("ancestor-or-self", result); [EOL] } [EOL] public void testAxisToStringFollowingSibling() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_FOLLOWING_SIBLING); [EOL] assertEquals("following-sibling", result); [EOL] } [EOL] public void testAxisToStringPrecedingSibling() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_PRECEDING_SIBLING); [EOL] assertEquals("preceding-sibling", result); [EOL] } [EOL] public void testAxisToStringDescendantOrSelf() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_DESCENDANT_OR_SELF); [EOL] assertEquals("descendant-or-self", result); [EOL] } [EOL] public void testAxisToStringUnknown() { [EOL] String result = YourClass.axisToString(-1); [EOL] assertEquals("UNKNOWN", result); [EOL] }
public void testNamespaceResolverWithNullParent() { [EOL] NamespaceResolver resolver = new NamespaceResolver(null); [EOL] assertNull("Parent should be null", resolver.getParent()); [EOL] }
public void testNamespaceResolverWithNonNullParent() { [EOL] NamespaceResolver parentResolver = new NamespaceResolver(null); [EOL] NamespaceResolver resolver = new NamespaceResolver(parentResolver); [EOL] assertNotNull("Parent should not be null", resolver.getParent()); [EOL] assertEquals("Parent should be the one that was set", parentResolver, resolver.getParent()); [EOL] }
public void testSetNamespaceContextPointerWithNonNullPointer() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NodePointer pointer = new NodePointer() { [EOL] }; [EOL] context.setNamespaceContextPointer(pointer); [EOL] assertEquals(pointer, context.getNamespaceContextPointer()); [EOL] }
public void testSeal_WithNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.seal(); [EOL] assertTrue("Context should be sealed", context.isSealed()); [EOL] }
public void testSeal_WithParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] JXPathContext childContext = parentContext.newContext(new Object()); [EOL] childContext.seal(); [EOL] assertTrue("Child context should be sealed", childContext.isSealed()); [EOL] assertTrue("Parent context should be sealed", parentContext.isSealed()); [EOL] }
public void testJXPathContextWithNullParentAndNullContextBean() { [EOL] JXPathContext context = new JXPathContext(null, null); [EOL] assertNull(context.parentContext); [EOL] assertNull(context.contextBean); [EOL] } [EOL] public void testJXPathContextWithNonNullParentAndNullContextBean() { [EOL] JXPathContext parentContext = new JXPathContext(null, null); [EOL] JXPathContext context = new JXPathContext(parentContext, null); [EOL] assertNotNull(context.parentContext); [EOL] assertNull(context.contextBean); [EOL] } [EOL] public void testJXPathContextWithNullParentAndNonNullContextBean() { [EOL] Object contextBean = new Object(); [EOL] JXPathContext context = new JXPathContext(null, contextBean); [EOL] assertNull(context.parentContext); [EOL] assertNotNull(context.contextBean); [EOL] } [EOL] public void testJXPathContextWithNonNullParentAndNonNullContextBean() { [EOL] JXPathContext parentContext = new JXPathContext(null, null); [EOL] Object contextBean = new Object(); [EOL] JXPathContext context = new JXPathContext(parentContext, contextBean); [EOL] assertNotNull(context.parentContext); [EOL] assertNotNull(context.contextBean); [EOL] }
public void testGetParentContextNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JXPathContext parent = JXPathContext.newContext(context, new Object()); [EOL] assertNotNull("Parent context should not be null", parent.getParentContext()); [EOL] }
public void testGetParentContextNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] assertNull("Parent context should be null", context.getParentContext()); [EOL] }
public void testSetFunctions_Null() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFunctions(null); [EOL] assertNull("Functions should be null", context.getFunctions()); [EOL] }
public void testSetFunctions_NonNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Functions functions = new CustomFunctions(); [EOL] context.setFunctions(functions); [EOL] assertEquals("Functions should be the same as set", functions, context.getFunctions()); [EOL] }
public void testGetFunctionsWhenFunctionsIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Functions expectedFunctions = new Functions(); [EOL] context.setFunctions(expectedFunctions); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertEquals("Expected the non-null functions object to be returned", expectedFunctions, actualFunctions); [EOL] }
public void testGetFunctionsWhenFunctionsIsNullAndParentContextIsNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFunctions(null); [EOL] context.setParentContext(null); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertEquals("Expected GENERIC_FUNCTIONS to be returned when functions is null and parent context is null", JXPathContext.GENERIC_FUNCTIONS, actualFunctions); [EOL] }
public void testGetFunctionsWhenFunctionsIsNullAndParentContextIsNotNull() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] JXPathContext context = JXPathContext.newContext(parentContext, new Object()); [EOL] context.setFunctions(null); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertNull("Expected null to be returned when functions is null but parent context is not null", actualFunctions); [EOL] }
public void testGetFactory_WithNullFactoryAndNonNullParentContext() { [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] AbstractFactory mockFactory = mock(AbstractFactory.class); [EOL] when(parentContext.getFactory()).thenReturn(mockFactory); [EOL] MyClass instance = new MyClass(); [EOL] instance.setParentContext(parentContext); [EOL] AbstractFactory result = instance.getFactory(); [EOL] assertEquals("Expected the factory from the parent context", mockFactory, result); [EOL] }
public void testGetFactory_WithNonNullFactory() { [EOL] AbstractFactory nonNullFactory = mock(AbstractFactory.class); [EOL] MyClass instance = new MyClass(); [EOL] instance.setFactory(nonNullFactory); [EOL] AbstractFactory result = instance.getFactory(); [EOL] assertEquals("Expected the non-null factory", nonNullFactory, result); [EOL] }
public void testGetFactory_WithNullFactoryAndNullParentContext() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setParentContext(null); [EOL] AbstractFactory result = instance.getFactory(); [EOL] assertNull("Expected null factory", result); [EOL] }
public void testGetLocale_WithNullLocaleAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Locale result = context.getLocale(); [EOL] assertEquals("Expected default locale", Locale.getDefault(), result); [EOL] }
public void testGetLocale_WithNullLocaleAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] parentContext.setLocale(Locale.FRENCH); [EOL] Locale result = childContext.getLocale(); [EOL] assertEquals("Expected parent context locale", Locale.FRENCH, result); [EOL] }
public void testGetLocale_WithNonNullLocale() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(Locale.GERMAN); [EOL] Locale result = context.getLocale(); [EOL] assertEquals("Expected set locale", Locale.GERMAN, result); [EOL] }
public void testCompileWithNullContext() { [EOL] CompiledExpression result = ClassName.compile("some/xpath"); [EOL] assertNotNull("CompiledExpression should not be null", result); [EOL] }
public void testCompileWithNonNullContext() { [EOL] ClassName.compilationContext = JXPathContext.newContext(null); [EOL] CompiledExpression result = ClassName.compile("some/xpath"); [EOL] assertNotNull("CompiledExpression should not be null", result); [EOL] }
public void testSetKeyManager() { [EOL] YourClass instance = new YourClass(); [EOL] KeyManager keyManager = new MockKeyManager(); [EOL] instance.setKeyManager(keyManager); [EOL] assertEquals(keyManager, instance.getKeyManager()); [EOL] }
public void testGetKeyManagerWithNonNullKeyManager() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] KeyManager expectedKeyManager = new DefaultKeyManager(); [EOL] context.setKeyManager(expectedKeyManager); [EOL] KeyManager actualKeyManager = context.getKeyManager(); [EOL] assertEquals("KeyManager should be the one that was set", expectedKeyManager, actualKeyManager); [EOL] }
public void testGetKeyManagerWithNullKeyManagerAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] KeyManager expectedKeyManager = new DefaultKeyManager(); [EOL] parentContext.setKeyManager(expectedKeyManager); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext, new Object()); [EOL] KeyManager actualKeyManager = childContext.getKeyManager(); [EOL] assertEquals("KeyManager should be retrieved from the parent context", expectedKeyManager, actualKeyManager); [EOL] }
public void testGetKeyManagerWithNullKeyManagerAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] KeyManager actualKeyManager = context.getKeyManager(); [EOL] assertNull("KeyManager should be null when not set and no parent context exists", actualKeyManager); [EOL] }
public void testGetPointerByKeyWithNonNullKeyManager() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] KeyManager mockManager = Mockito.mock(KeyManager.class); [EOL] Mockito.when(mockManager.getPointerByKey(context, "testKey", "testValue")) [EOL] .thenReturn(new Pointer() { [EOL] }); [EOL] context.setKeyManager(mockManager); [EOL] Pointer result = context.getPointerByKey("testKey", "testValue"); [EOL] assertNotNull("Expected a non-null Pointer", result); [EOL] }
public void testGetPointerByKeyWithNullKeyManager() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setKeyManager(null); [EOL] try { [EOL] context.getPointerByKey("testKey", "testValue"); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot find an element by key - no KeyManager has been specified", e.getMessage()); [EOL] } [EOL] }
public void testChildIteratorWithNullTest() { [EOL] NodeIterator result = childIterator(null, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestAndDefaultNamespace() { [EOL] NodeTest test = new NodeNameTest(new QName("", "testNode")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestAndNonDefaultNamespace() { [EOL] NodeTest test = new NodeNameTest(new QName("nonDefault", "testNode")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestWildcard() { [EOL] NodeTest test = new NodeNameTest(new QName("", "*")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeTypeTestNode() { [EOL] NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithOtherNodeTypeTest() { [EOL] NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_COMMENT); // Assuming NODE_TYPE_COMMENT is a valid node type and different from NODE_TYPE_NODE [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNull(result); [EOL] }
public void testCreateNodeIteratorWithReverseTrue() { [EOL] String property = "someProperty"; [EOL] boolean reverse = true; [EOL] NodePointer startWith = new NodePointerMock(); [EOL] NodeIterator result = createNodeIterator(property, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyIterator); [EOL] assertEquals(property, ((PropertyIterator) result).getProperty()); [EOL] assertEquals(reverse, ((PropertyIterator) result).isReverse()); [EOL] assertEquals(startWith, ((PropertyIterator) result).getStartWith()); [EOL] }
public void testCreateNodeIteratorWithReverseFalse() { [EOL] String property = "someProperty"; [EOL] boolean reverse = false; [EOL] NodePointer startWith = new NodePointerMock(); [EOL] NodeIterator result = createNodeIterator(property, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyIterator); [EOL] assertEquals(property, ((PropertyIterator) result).getProperty()); [EOL] assertEquals(reverse, ((PropertyIterator) result).isReverse()); [EOL] assertEquals(startWith, ((PropertyIterator) result).getStartWith()); [EOL] }
protected PropertyOwnerPointer(NodePointer parent, Locale locale) { [EOL] super(parent, locale); [EOL] }
public void testSetIndex_NewIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int newIndex = 1; [EOL] instance.setIndex(newIndex); [EOL] assertEquals(newIndex, instance.getIndex()); [EOL] assertEquals(YourClass.UNINITIALIZED, instance.getValue()); [EOL] }
public void testSetIndex_SameIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int index = 0; [EOL] instance.setIndex(index); // Assuming the default index is 0 [EOL] instance.setIndex(index); [EOL] assertEquals(index, instance.getIndex()); [EOL] assertNotEquals(YourClass.UNINITIALIZED, instance.getValue()); [EOL] }
public void testGetImmediateNode_UninitializedWholeCollection() { [EOL] this.value = UNINITIALIZED; [EOL] this.index = WHOLE_COLLECTION; [EOL] Object result = getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(ValueUtils.getValue(getBaseValue()), result); [EOL] }
public void testGetImmediateNode_UninitializedNotWholeCollection() { [EOL] this.value = UNINITIALIZED; [EOL] this.index = 1; // Any value other than WHOLE_COLLECTION [EOL] Object result = getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(ValueUtils.getValue(getBaseValue(), index), result); [EOL] }
public void testGetImmediateNode_AlreadyInitialized() { [EOL] this.value = new Object(); // Any initialized value [EOL] this.index = WHOLE_COLLECTION; // Index value is irrelevant in this case [EOL] Object result = getImmediateNode(); [EOL] assertSame(this.value, result); [EOL] }
public void testJDOMNamespaceIteratorWithDocumentNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Document document = mock(Document.class); [EOL] Element rootElement = mock(Element.class); [EOL] when(parent.getNode()).thenReturn(document); [EOL] when(document.getRootElement()).thenReturn(rootElement); [EOL] JDOMNamespaceIterator iterator = new JDOMNamespaceIterator(parent); [EOL] assertNotNull(iterator.namespaces); [EOL] assertNotNull(iterator.prefixes); [EOL] verify(parent).getNode(); [EOL] verify(document).getRootElement(); [EOL] }
public void testJDOMNamespaceIteratorWithElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Element element = mock(Element.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] JDOMNamespaceIterator iterator = new JDOMNamespaceIterator(parent); [EOL] assertNotNull(iterator.namespaces); [EOL] assertNotNull(iterator.prefixes); [EOL] verify(parent).getNode(); [EOL] }
public void testJDOMNamespaceIteratorWithNonElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Object nonElementNode = new Object(); [EOL] when(parent.getNode()).thenReturn(nonElementNode); [EOL] JDOMNamespaceIterator iterator = new JDOMNamespaceIterator(parent); [EOL] assertNull(iterator.namespaces); [EOL] assertNull(iterator.prefixes); [EOL] verify(parent).getNode(); [EOL] }
public void testCollectNamespacesWithNonNullNamespace() { [EOL] Element element = mock(Element.class); [EOL] Namespace ns = mock(Namespace.class); [EOL] when(element.getNamespace()).thenReturn(ns); [EOL] when(ns.getPrefix()).thenReturn("prefix"); [EOL] when(element.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(element.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.contains(ns)); [EOL] assertTrue(prefixes.contains(ns.getPrefix())); [EOL] }
public void testCollectNamespacesWithNullNamespace() { [EOL] Element element = mock(Element.class); [EOL] when(element.getNamespace()).thenReturn(null); [EOL] when(element.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(element.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.isEmpty()); [EOL] assertTrue(prefixes.isEmpty()); [EOL] }
public void testCollectNamespacesWithAdditionalNamespaces() { [EOL] Element element = mock(Element.class); [EOL] Namespace ns1 = mock(Namespace.class); [EOL] Namespace ns2 = mock(Namespace.class); [EOL] when(element.getNamespace()).thenReturn(null); [EOL] when(ns1.getPrefix()).thenReturn("prefix1"); [EOL] when(ns2.getPrefix()).thenReturn("prefix2"); [EOL] List<Namespace> additionalNamespaces = Arrays.asList(ns1, ns2); [EOL] when(element.getAdditionalNamespaces()).thenReturn(additionalNamespaces); [EOL] when(element.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.containsAll(additionalNamespaces)); [EOL] assertTrue(prefixes.contains("prefix1")); [EOL] assertTrue(prefixes.contains("prefix2")); [EOL] }
public void testCollectNamespacesWithParentElement() { [EOL] Element element = mock(Element.class); [EOL] Element parentElement = mock(Element.class); [EOL] Namespace ns = mock(Namespace.class); [EOL] when(element.getNamespace()).thenReturn(ns); [EOL] when(ns.getPrefix()).thenReturn("prefix"); [EOL] when(element.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(element.getParent()).thenReturn(parentElement); [EOL] when(parentElement.getNamespace()).thenReturn(ns); [EOL] when(parentElement.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(parentElement.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.contains(ns)); [EOL] assertTrue(prefixes.contains(ns.getPrefix())); [EOL] }
public void testGetNodePointer_PositionIsZeroAndSetPositionFails() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionIsZeroAndSetPositionSucceeds() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PositionIsGreaterThanZero() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 2; // Assuming there are at least two namespaces in the list [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testSetPositionWithNullNamespaces() { [EOL] this.namespaces = null; [EOL] boolean result = setPosition(1); [EOL] assertFalse(result); [EOL] }
public void testSetPositionWithEmptyNamespaces() { [EOL] this.namespaces = new ArrayList<>(); [EOL] boolean result = setPosition(1); [EOL] assertFalse(result); [EOL] }
public void testSetPositionBelowRange() { [EOL] this.namespaces = Arrays.asList("namespace1", "namespace2"); [EOL] boolean result = setPosition(0); [EOL] assertFalse(result); [EOL] }
public void testSetPositionWithinRange() { [EOL] this.namespaces = Arrays.asList("namespace1", "namespace2"); [EOL] boolean result = setPosition(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionAtUpperBound() { [EOL] this.namespaces = Arrays.asList("namespace1", "namespace2"); [EOL] boolean result = setPosition(2); [EOL] assertTrue(result); [EOL] }
public void testSetPositionAboveRange() { [EOL] this.namespaces = Arrays.asList("namespace1", "namespace2"); [EOL] boolean result = setPosition(3); [EOL] assertFalse(result); [EOL] }
public void testBeanAttributeIteratorWithNullPrefixAndNullName() { [EOL] QName name = new QName(null, null); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertFalse(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithNullPrefixAndWildcardName() { [EOL] QName name = new QName(null, "*"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertFalse(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithXmlPrefixAndLangName() { [EOL] QName name = new QName("xml", "lang"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertTrue(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithXmlPrefixAndWildcardName() { [EOL] QName name = new QName("xml", "*"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertTrue(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithNonXmlPrefixAndLangName() { [EOL] QName name = new QName("nonxml", "lang"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertFalse(iterator.includeXmlLang); [EOL] }
public void testGetNodePointer_IncludeXmlLangTrue_PositionOne() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.includeXmlLang = true; [EOL] instance.position = 1; [EOL] instance.parent = new ParentClass(); // Assuming ParentClass exists and is appropriate [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertTrue(result instanceof LangAttributePointer); [EOL] }
public void testGetNodePointer_IncludeXmlLangFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.includeXmlLang = false; [EOL] instance.position = 1; // or any other value that is not relevant when includeXmlLang is false [EOL] instance.parent = new ParentClass(); // Assuming ParentClass exists and is appropriate [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertTrue(result instanceof SuperNodePointerClass); [EOL] }
public void testGetNodePointer_IncludeXmlLangTrue_PositionNotOne() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.includeXmlLang = true; [EOL] instance.position = 2; // or any other value that is not 1 [EOL] instance.parent = new ParentClass(); // Assuming ParentClass exists and is appropriate [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertTrue(result instanceof SuperNodePointerClass); [EOL] }
public void testGetPosition() { [EOL] MyClass instance = new MyClass(); [EOL] int expected = 10; // Assuming 'position' should be 10 for this test case [EOL] instance.position = expected; // Directly setting the position for the purpose of the test [EOL] int result = instance.getPosition(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetPositionWithIncludeXmlLangTrueAndPositionOne() { [EOL] myObjectUnderTest.includeXmlLang = true; [EOL] boolean result = myObjectUnderTest.setPosition(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionWithIncludeXmlLangTrueAndPositionNotOne() { [EOL] myObjectUnderTest.includeXmlLang = true; [EOL] boolean result = myObjectUnderTest.setPosition(2); [EOL] assertTrue(result); [EOL] }
public void testSetPositionWithIncludeXmlLangFalse() { [EOL] myObjectUnderTest.includeXmlLang = false; [EOL] boolean result = myObjectUnderTest.setPosition(1); [EOL] assertTrue(result); [EOL] }
public void testIsChildOrderingRequired() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isChildOrderingRequired(); [EOL] assertTrue(result); [EOL] }
public void testNextNode_InitialCall_NodePresentAndNotLeaf() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.isLeaf()).thenReturn(false); [EOL] Mockito.when(mockNodePointer.testNode(Mockito.any())).thenReturn(true); [EOL] NodeIterator mockIterator = Mockito.mock(NodeIterator.class); [EOL] Mockito.when(mockNodePointer.childIterator(Mockito.any(), Mockito.eq(false), Mockito.isNull())).thenReturn(mockIterator); [EOL] Context mockContext = Mockito.mock(Context.class); [EOL] Mockito.when(mockContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] YourClassUnderTest testObject = new YourClassUnderTest(mockContext); [EOL] testObject.includeSelf = true; [EOL] boolean result = testObject.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, testObject.position); [EOL] }
public void testNextNode_InitialCall_NodePresentAndLeaf() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.isLeaf()).thenReturn(true); [EOL] Mockito.when(mockNodePointer.testNode(Mockito.any())).thenReturn(true); [EOL] Context mockContext = Mockito.mock(Context.class); [EOL] Mockito.when(mockContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] YourClassUnderTest testObject = new YourClassUnderTest(mockContext); [EOL] testObject.includeSelf = true; [EOL] boolean result = testObject.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, testObject.position); [EOL] }
public void testNextNode_InitialCall_NoNodePresent() { [EOL] Context mockContext = Mockito.mock(Context.class); [EOL] Mockito.when(mockContext.getCurrentNodePointer()).thenReturn(null); [EOL] YourClassUnderTest testObject = new YourClassUnderTest(mockContext); [EOL] boolean result = testObject.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_SubsequentCall_StackNotEmpty() { [EOL] NodeIterator mockIterator = Mockito.mock(NodeIterator.class); [EOL] Mockito.when(mockIterator.setPosition(Mockito.anyInt())).thenReturn(true); [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockIterator.getNodePointer()).thenReturn(mockNodePointer); [EOL] Mockito.when(mockNodePointer.isLeaf()).thenReturn(true); [EOL] Mockito.when(mockNodePointer.testNode(Mockito.any())).thenReturn(true); [EOL] Stack<NodeIterator> mockStack = new Stack<>(); [EOL] mockStack.push(mockIterator); [EOL] YourClassUnderTest testObject = new YourClassUnderTest(null); [EOL] testObject.stack = mockStack; [EOL] testObject.setStarted = true; [EOL] boolean result = testObject.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, testObject.position); [EOL] }
public void testNextNode_SubsequentCall_StackEmpty() { [EOL] Stack<NodeIterator> mockStack = new Stack<>(); [EOL] YourClassUnderTest testObject = new YourClassUnderTest(null); [EOL] testObject.stack = mockStack; [EOL] testObject.setStarted = true; [EOL] boolean result = testObject.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testIsRecursiveWithEmptyStack() { [EOL] stack.clear(); [EOL] currentNodePointer = new NodePointerImpl(new Object()); [EOL] boolean result = isRecursive(); [EOL] assertFalse(result); [EOL] }
public void testIsRecursiveWithNonMatchingNodes() { [EOL] stack.clear(); [EOL] Object node1 = new Object(); [EOL] Object node2 = new Object(); [EOL] currentNodePointer = new NodePointerImpl(node1); [EOL] NodeIterator it = new NodeIteratorImpl(new NodePointerImpl(node2)); [EOL] stack.add(it); [EOL] boolean result = isRecursive(); [EOL] assertFalse(result); [EOL] }
public void testIsRecursiveWithMatchingNodes() { [EOL] stack.clear(); [EOL] Object node = new Object(); [EOL] currentNodePointer = new NodePointerImpl(node); [EOL] NodeIterator it = new NodeIteratorImpl(new NodePointerImpl(node)); [EOL] stack.add(it); [EOL] boolean result = isRecursive(); [EOL] assertTrue(result); [EOL] }
public void testPathConstructorWithNullSteps() { [EOL] Step[] steps = null; [EOL] Path path = new Path(steps); [EOL] assertNull("Path steps should be null", path.getSteps()); [EOL] }
public void testPathConstructorWithEmptySteps() { [EOL] Step[] steps = new Step[0]; [EOL] Path path = new Path(steps); [EOL] assertEquals("Path steps should be empty", 0, path.getSteps().length); [EOL] }
public void testPathConstructorWithNonEmptySteps() { [EOL] Step[] steps = new Step[]{new Step(), new Step()}; [EOL] Path path = new Path(steps); [EOL] assertEquals("Path steps should have 2 elements", 2, path.getSteps().length); [EOL] }
public void testGetSteps() { [EOL] MyClass instance = new MyClass(); [EOL] Step[] expectedSteps = new Step[] {/* initialize with expected steps */}; [EOL] instance.steps = expectedSteps; // Assuming 'steps' can be accessed directly or through a setter method [EOL] Step[] result = instance.getSteps(); [EOL] assertArrayEquals(expectedSteps, result); [EOL] }
public void testIsSimplePath_WithBasicKnownTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.basicKnown = true; [EOL] instance.basic = true; // or false [EOL] boolean result = instance.isSimplePath(); [EOL] assertEquals(instance.basic, result); [EOL] }
public void testIsSimplePath_WithBasicKnownFalseAndAllStepsSimple() { [EOL] YourClass instance = new YourClass(); [EOL] instance.basicKnown = false; [EOL] Step[] simpleSteps = new Step[] { /* initialize with simple steps */ }; [EOL] instance.setSteps(simpleSteps); // Assuming there's a method to set steps [EOL] boolean result = instance.isSimplePath(); [EOL] assertTrue(result); [EOL] }
public void testIsSimplePath_WithBasicKnownFalseAndComplexStep() { [EOL] YourClass instance = new YourClass(); [EOL] instance.basicKnown = false; [EOL] Step[] mixedSteps = new Step[] { /* initialize with at least one complex step */ }; [EOL] instance.setSteps(mixedSteps); [EOL] boolean result = instance.isSimplePath(); [EOL] assertFalse(result); [EOL] }
protected boolean isSimpleStep(Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_SELF) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeTypeTest)) { [EOL] return false; [EOL] } [EOL] int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL] if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeNameTest)) { [EOL] return false; [EOL] } [EOL] if (((NodeNameTest) nodeTest).isWildcard()) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } [EOL] return false; [EOL] }
public void testAreBasicPredicatesWithNull() { [EOL] boolean result = areBasicPredicates(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testAreBasicPredicatesWithEmptyArray() { [EOL] Expression[] predicates = new Expression[0]; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertTrue(result); [EOL] } [EOL] public void testAreBasicPredicatesWithNonContextDependentNameAttributeTest() { [EOL] Expression[] predicates = new Expression[1]; [EOL] NameAttributeTest nat = mock(NameAttributeTest.class); [EOL] when(nat.isContextDependent()).thenReturn(false); [EOL] when(nat.getNameTestExpression()).thenReturn(mock(NameTestExpression.class)); [EOL] predicates[0] = nat; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertTrue(result); [EOL] } [EOL] public void testAreBasicPredicatesWithContextDependentNameAttributeTest() { [EOL] Expression[] predicates = new Expression[1]; [EOL] NameAttributeTest nat = mock(NameAttributeTest.class); [EOL] when(nat.isContextDependent()).thenReturn(true); [EOL] when(nat.getNameTestExpression()).thenReturn(mock(NameTestExpression.class)); [EOL] predicates[0] = nat; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertFalse(result); [EOL] } [EOL] public void testAreBasicPredicatesWithContextDependentNonNameAttributeTest() { [EOL] Expression[] predicates = new Expression[1]; [EOL] Expression exp = mock(Expression.class); [EOL] when(exp.isContextDependent()).thenReturn(true); [EOL] predicates[0] = exp; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertFalse(result); [EOL] } [EOL] public void testAreBasicPredicatesWithMultipleNonContextDependentExpressions() { [EOL] Expression[] predicates = new Expression[2]; [EOL] predicates[0] = mock(Expression.class); [EOL] predicates[1] = mock(Expression.class); [EOL] when(predicates[0].isContextDependent()).thenReturn(false); [EOL] when(predicates[1].isContextDependent()).thenReturn(false); [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertFalse(result); [EOL] }

public void testSearchForPathWithNonNullPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testSearchForPathWithNullPointerAndSimpleSteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] setSimpleSteps(true); [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithNullPointerAndComplexStep() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] setSimpleSteps(false); [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialPointerAndNoNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] setSimpleSteps(true); [EOL] when(context.hasNext()).thenReturn(true, false); [EOL] Pointer partialPointer = mock(Pointer.class); [EOL] when(context.next()).thenReturn(partialPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPointer); [EOL] }
public void testSearchForPathWithPartialPointerAndNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] setSimpleSteps(true); [EOL] when(context.hasNext()).thenReturn(true, true); [EOL] Pointer partialPointer = mock(Pointer.class); [EOL] when(context.next()).thenReturn(partialPointer, mock(Pointer.class)); [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
protected EvalContext evalSteps(EvalContext context) { [EOL] return buildContextChain(context, steps.length, false); [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL] if (nodeTest instanceof NodeNameTest) { [EOL] QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL] String prefix = qname.getPrefix(); [EOL] String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL] if (namespaceURI != null) { [EOL] nodeTest = new NodeNameTest(qname, namespaceURI); [EOL] } [EOL] } [EOL] switch(axis) { [EOL] case Compiler.AXIS_ANCESTOR: [EOL] return new AncestorContext(context, false, nodeTest); [EOL] case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL] return new AncestorContext(context, true, nodeTest); [EOL] case Compiler.AXIS_ATTRIBUTE: [EOL] return new AttributeContext(context, nodeTest); [EOL] case Compiler.AXIS_CHILD: [EOL] return new ChildContext(context, nodeTest, false, false); [EOL] case Compiler.AXIS_DESCENDANT: [EOL] return new DescendantContext(context, false, nodeTest); [EOL] case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL] return new DescendantContext(context, true, nodeTest); [EOL] case Compiler.AXIS_FOLLOWING: [EOL] return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL] case Compiler.AXIS_FOLLOWING_SIBLING: [EOL] return new ChildContext(context, nodeTest, true, false); [EOL] case Compiler.AXIS_NAMESPACE: [EOL] return new NamespaceContext(context, nodeTest); [EOL] case Compiler.AXIS_PARENT: [EOL] return new ParentContext(context, nodeTest); [EOL] case Compiler.AXIS_PRECEDING: [EOL] return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL] case Compiler.AXIS_PRECEDING_SIBLING: [EOL] return new ChildContext(context, nodeTest, true, true); [EOL] case Compiler.AXIS_SELF: [EOL] return new SelfContext(context, nodeTest); [EOL] } [EOL] return null; [EOL] }
public void testIsContainer() { [EOL] Container container = new Container(); [EOL] boolean result = container.isContainer(); [EOL] assertTrue(result); [EOL] }
public void testSetValueWithActualTrueAndIndexNotWholeCollection() { [EOL] VariableContextUnderTest context = new VariableContextUnderTest(true, WHOLE_COLLECTION - 1); [EOL] Object expectedValue = new Object(); [EOL] context.setValue(expectedValue); [EOL] assertNotNull("Expected valuePointer to be null after setting value", context.valuePointer); [EOL] assertEquals("Expected the value to be set at the specified index", expectedValue, context.getBaseValueAtIndex()); [EOL] } [EOL] public void testSetValueWithActualTrueAndIndexWholeCollection() { [EOL] VariableContextUnderTest context = new VariableContextUnderTest(true, WHOLE_COLLECTION); [EOL] Object expectedValue = new Object(); [EOL] context.setValue(expectedValue); [EOL] assertNotNull("Expected valuePointer to be null after setting value", context.valuePointer); [EOL] assertEquals("Expected the value to be declared in variables", expectedValue, context.variables.getVariableValue(context.name.toString())); [EOL] } [EOL] public void testSetValueWithActualFalse() { [EOL] VariableContextUnderTest context = new VariableContextUnderTest(false, WHOLE_COLLECTION); [EOL] Object value = new Object(); [EOL] try { [EOL] context.setValue(value); [EOL] fail("Expected JXPathException to be thrown for undefined variable"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Expected exception message to match for undefined variable", "Cannot set undefined variable: " + context.name, e.getMessage()); [EOL] } [EOL] }
public void testCreatePathWithActualTrue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = new NodePointerSubclass(true); [EOL] NodePointer result = nodePointer.createPath(context); [EOL] assertEquals("Expected the same NodePointer instance when 'actual' is true", nodePointer, result); [EOL] }
public void testCreatePathWithActualFalseAndFactoryDeclaresVariable() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = new NodePointerSubclass(false); [EOL] AbstractFactory factory = Mockito.mock(AbstractFactory.class); [EOL] Mockito.when(factory.declareVariable(Mockito.any(JXPathContext.class), Mockito.anyString())).thenReturn(true); [EOL] nodePointer.setAbstractFactory(factory); [EOL] NodePointer result = nodePointer.createPath(context); [EOL] assertEquals("Expected the same NodePointer instance when factory declares variable", nodePointer, result); [EOL] }
public void testCreatePathWithActualFalseAndFactoryDoesNotDeclareVariable() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = new NodePointerSubclass(false); [EOL] AbstractFactory factory = Mockito.mock(AbstractFactory.class); [EOL] Mockito.when(factory.declareVariable(Mockito.any(JXPathContext.class), Mockito.anyString())).thenReturn(false); [EOL] nodePointer.setAbstractFactory(factory); [EOL] try { [EOL] nodePointer.createPath(context); [EOL] fail("Expected JXPathAbstractFactoryException to be thrown"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] assertEquals("Expected exception message to match", "Factory cannot define variable '" + nodePointer.getName() + "' for path: " + nodePointer.asPath(), e.getMessage()); [EOL] } [EOL] }
public void testFindVariablesWhenVariableIsDeclared() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.getVariables().declareVariable("testVariable", "testValue"); [EOL] findVariables(context); // Assuming 'name' is set to "testVariable" before this call [EOL] assertTrue("Expected to find the declared variable", actual); [EOL] } [EOL] public void testFindVariablesWhenVariableIsNotDeclared() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] findVariables(context); // Assuming 'name' is set to a name that was not declared [EOL] assertFalse("Did not expect to find the undeclared variable", actual); [EOL] } [EOL] public void testFindVariablesInParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] parentContext.getVariables().declareVariable("testVariable", "testValue"); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext, new Object()); [EOL] findVariables(childContext); // Assuming 'name' is set to "testVariable" before this call [EOL] assertTrue("Expected to find the declared variable in the parent context", actual); [EOL] }
public void testEquals_SameObject() { [EOL] VariablePointer vp = new VariablePointer(); [EOL] boolean result = vp.equals(vp); [EOL] assert result == true; [EOL] }
public void testEquals_NullAndDifferentClass() { [EOL] VariablePointer vp = new VariablePointer(); [EOL] boolean result = vp.equals(null); [EOL] assert result == false; [EOL] result = vp.equals(new Object()); [EOL] assert result == false; [EOL] }
public void testEquals_DifferentVariablePointer() { [EOL] VariablePointer vp1 = new VariablePointer(); [EOL] vp1.setVariables(...); // Assuming a method to set variables [EOL] vp1.setName("name1"); [EOL] vp1.setIndex(1); [EOL] VariablePointer vp2 = new VariablePointer(); [EOL] vp2.setVariables(...); // Set to a different instance than vp1 [EOL] vp2.setName("name2"); [EOL] vp2.setIndex(2); [EOL] boolean result = vp1.equals(vp2); [EOL] assert result == false; [EOL] }
public void testEquals_SameFields() { [EOL] VariablePointer vp1 = new VariablePointer(); [EOL] vp1.setVariables(...); // Assuming a method to set variables [EOL] vp1.setName("name"); [EOL] vp1.setIndex(1); [EOL] VariablePointer vp2 = new VariablePointer(); [EOL] vp2.setVariables(vp1.getVariables()); // Assuming a getter method [EOL] vp2.setName(new String("name")); // Ensure it's a different instance with the same value [EOL] vp2.setIndex(1); [EOL] boolean result = vp1.equals(vp2); [EOL] assert result == true; [EOL] }
public void testNewNodePointerWithNullBean() { [EOL] QName name = new QName("test"); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = ClassName.newNodePointer(name, null, locale); [EOL] assertTrue(result instanceof NullPointer); [EOL] }
public void testNewNodePointerWithNonNullBean() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointerFactory factory = new NodePointerFactory() { [EOL] public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL] return new ConcreteNodePointer(name, bean, locale); [EOL] } [EOL] }; [EOL] JXPathContextReferenceImpl.addNodePointerFactory(factory); [EOL] NodePointer result = ClassName.newNodePointer(name, bean, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ConcreteNodePointer); [EOL] }
public void testNewNodePointerWithNoMatchingFactory() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] try { [EOL] NodePointer result = ClassName.newNodePointer(name, bean, locale); [EOL] fail("Should have thrown JXPathException"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Could not allocate a NodePointer for object of " + bean.getClass(), e.getMessage()); [EOL] } [EOL] }
public void testNodePointerWithNullParentAndLocale() { [EOL] NodePointer nodePointer = new NodePointer(null, null); [EOL] assertNull(nodePointer.parent); [EOL] assertNull(nodePointer.locale); [EOL] }
public void testNodePointerWithNonNullParentAndLocale() { [EOL] NodePointer parent = new NodePointer(null, null); [EOL] Locale locale = new Locale("en"); [EOL] NodePointer nodePointer = new NodePointer(parent, locale); [EOL] assertNotNull(nodePointer.parent); [EOL] assertEquals(locale, nodePointer.locale); [EOL] }
public void testGetParent_NullParent() { [EOL] NodePointer testNodePointer = createTestNodePointerWithNullParent(); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertNull(result); [EOL] } [EOL] public void testGetParent_NonContainerParent() { [EOL] NodePointer testNodePointer = createTestNodePointerWithNonContainerParent(); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isContainer()); [EOL] } [EOL] public void testGetParent_ContainerParent() { [EOL] NodePointer testNodePointer = createTestNodePointerWithContainerParent(); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isContainer()); [EOL] }
public void testGetParent_ContainerParentWithContainerGrandparent() { [EOL] NodePointer testNodePointer = createTestNodePointerWithContainerParentAndContainerGrandparent(); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isContainer()); [EOL] }
public void testIsAttributeTrue() { [EOL] YourClass instance = new YourClass(true); // Assuming there's a constructor that sets the attribute field [EOL] assertTrue(instance.isAttribute()); [EOL] }
public void testIsAttributeFalse() { [EOL] YourClass instance = new YourClass(false); // Assuming there's a constructor that sets the attribute field [EOL] assertFalse(instance.isAttribute()); [EOL] }
public void testIsRoot_WhenParentIsNull_ShouldReturnTrue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.parent = null; [EOL] assertTrue(context.isRoot()); [EOL] }
public void testIsRoot_WhenParentIsNotNull_ShouldReturnFalse() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.parent = new JXPathContext(); [EOL] assertFalse(context.isRoot()); [EOL] }
public void testIsNodeWhenContainerIsTrue() { [EOL] when(mockedObject.isContainer()).thenReturn(true); [EOL] boolean result = mockedObject.isNode(); [EOL] assertFalse("isNode should return false when isContainer returns true", result); [EOL] } [EOL] public void testIsNodeWhenContainerIsFalse() { [EOL] when(mockedObject.isContainer()).thenReturn(false); [EOL] boolean result = mockedObject.isNode(); [EOL] assertTrue("isNode should return true when isContainer returns false", result); [EOL] }
public boolean isContainer() { [EOL] return false; [EOL] }
public void testGetValueWhenValuePointerIsNotThis() { [EOL] NodePointer mockValuePointer = Mockito.mock(NodePointer.class); [EOL] NodePointer mockThis = Mockito.mock(NodePointer.class, Mockito.CALLS_REAL_METHODS); [EOL] Mockito.when(mockThis.getValuePointer()).thenReturn(mockValuePointer); [EOL] Mockito.when(mockValuePointer.getValue()).thenReturn("MockValue"); [EOL] Mockito.when(mockValuePointer != mockThis).thenReturn(true); [EOL] Object result = mockThis.getValue(); [EOL] assertEquals("MockValue", result); [EOL] }
public void testGetValueWhenValuePointerIsThis() { [EOL] NodePointer mockThis = Mockito.mock(NodePointer.class, Mockito.CALLS_REAL_METHODS); [EOL] Mockito.when(mockThis.getValuePointer()).thenReturn(mockThis); [EOL] Mockito.when(mockThis.getNode()).thenReturn("MockNode"); [EOL] Object result = mockThis.getValue(); [EOL] assertEquals("MockNode", result); [EOL] }
public void testIsActualWithWholeCollection() { [EOL] instance.index = WHOLE_COLLECTION; [EOL] boolean result = instance.isActual(); [EOL] assert result : "Expected isActual to return true when index equals WHOLE_COLLECTION"; [EOL] }
public void testIsActualWithNegativeIndex() { [EOL] instance.index = -1; // Assuming index is accessible, otherwise use a setter or constructor [EOL] boolean result = instance.isActual(); [EOL] assert !result : "Expected isActual to return false when index is negative"; [EOL] }
public void testIsActualWithIndexInRange() { [EOL] instance.index = 0; // Assuming getLength() returns a value greater than 0 [EOL] boolean result = instance.isActual(); [EOL] assert result : "Expected isActual to return true when index is within range (0 <= index < getLength())"; [EOL] }
public void testIsActualWithIndexOutOfRange() { [EOL] instance.index = 10; // Assuming getLength() returns a value less than 10 [EOL] boolean result = instance.isActual(); [EOL] assert !result : "Expected isActual to return false when index is out of range (index >= getLength())"; [EOL] }
public void testGetRootNode_WithNullRootAndNonNullParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] Object expectedRootNode = parentContext.getRootNode(); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setParentContext(parentContext); [EOL] Object actualRootNode = context.getRootNode(); [EOL] assertEquals("getRootNode should return the parent's root node when its own root node is null", expectedRootNode, actualRootNode); [EOL] }
public void testGetRootNode_WithNullRootAndNullParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Object actualRootNode = context.getRootNode(); [EOL] assertNotNull("getRootNode should return the immediate node when root node and parent are null", actualRootNode); [EOL] }
public void testGetRootNode_WithNonNullRoot() { [EOL] Object expectedRootNode = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(expectedRootNode); [EOL] Object actualRootNode = context.getRootNode(); [EOL] assertSame("getRootNode should return the set root node when it is not null", expectedRootNode, actualRootNode); [EOL] }
public void testNodeWithNullTest() { [EOL] boolean result = testNode(null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndContainer() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndNullNodeName() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(this.getName()).thenReturn(null); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndDifferentPrefixes() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testPrefix", "testName"); [EOL] QName nodeName = new QName("nodePrefix", "nodeName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.getNamespaceURI("testPrefix")).thenReturn("testNamespace"); [EOL] when(this.getNamespaceURI("nodePrefix")).thenReturn("nodeNamespace"); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndSamePrefixesDifferentNamespaces() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("prefix", "testName"); [EOL] QName nodeName = new QName("prefix", "nodeName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.getNamespaceURI("prefix")).thenReturn("testNamespace", "nodeNamespace"); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestWildcard() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.isWildcard()).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestSameQName() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("prefix", "name"); [EOL] QName nodeName = new QName("prefix", "name"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.getNamespaceURI("prefix")).thenReturn("namespace"); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestAndNodeTypeNode() { [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] when(this.isNode()).thenReturn(true); [EOL] boolean result = testNode(nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestAndNotNodeTypeNode() { [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); // Assuming NODE_TYPE_COMMENT is a valid node type and different from NODE_TYPE_NODE [EOL] boolean result = testNode(nodeTypeTest); [EOL] assertFalse(result); [EOL] }
public void testCreatePathWithNullValue() { [EOL] NodePointer testNodePointer = new TestNodePointer(); [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer result = testNodePointer.createPath(context, null); [EOL] assertNull("Expected value to be null", testNodePointer.getValue()); [EOL] assertSame("Expected result to be the same as testNodePointer", testNodePointer, result); [EOL] } [EOL] public void testCreatePathWithNonNullValue() { [EOL] NodePointer testNodePointer = new TestNodePointer(); [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object nonNullValue = new Object(); [EOL] NodePointer result = testNodePointer.createPath(context, nonNullValue); [EOL] assertSame("Expected value to be the same as nonNullValue", nonNullValue, testNodePointer.getValue()); [EOL] assertSame("Expected result to be the same as testNodePointer", testNodePointer, result); [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL] return this; [EOL] }
public void testIsDefaultNamespaceWithNullPrefix() { [EOL] boolean result = instance.isDefaultNamespace(null); [EOL] assertTrue(result); [EOL] }
public void testIsDefaultNamespaceWithNonExistentPrefix() { [EOL] boolean result = instance.isDefaultNamespace("nonExistentPrefix"); [EOL] assertFalse(result); [EOL] }
public void testIsDefaultNamespaceWithExistingPrefix() { [EOL] instance.setDefaultNamespaceURI("http://example.com/default"); [EOL] instance.setNamespaceURI("existingPrefix", "http://example.com/default"); [EOL] boolean result = instance.isDefaultNamespace("existingPrefix"); [EOL] assertTrue(result); [EOL] }
public void testGetPointerByKeyWithValidKeyAndValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String key = "validKey"; [EOL] String value = "validValue"; [EOL] Pointer result = getPointerByKey(context, key, value); [EOL] assertNotNull(result); [EOL] }
public void testGetPointerByKeyWithNullContext() { [EOL] JXPathContext context = null; [EOL] String key = "validKey"; [EOL] String value = "validValue"; [EOL] try { [EOL] getPointerByKey(context, key, value); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetPointerByKeyWithNullKey() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String key = null; [EOL] String value = "validValue"; [EOL] try { [EOL] getPointerByKey(context, key, value); [EOL] fail("Should have thrown IllegalArgumentException or similar"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPointerByKeyWithNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String key = "validKey"; [EOL] String value = null; [EOL] Pointer result = getPointerByKey(context, key, value); [EOL] assertNull(result); [EOL] }
public void testAsPathWithParentContainer() { [EOL] when(parent.isContainer()).thenReturn(true); [EOL] when(parent.asPath()).thenReturn("/parentPath"); [EOL] String result = node.asPath(); [EOL] assertEquals("/parentPath", result); [EOL] }
public void testAsPathWithParentNonContainer() { [EOL] when(parent.isContainer()).thenReturn(false); [EOL] when(parent.asPath()).thenReturn("/parentPath"); [EOL] String result = node.asPath(); [EOL] assertEquals("/parentPath/", result); [EOL] }
public void testAsPathWithAttribute() { [EOL] when(parent.isContainer()).thenReturn(false); [EOL] when(parent.asPath()).thenReturn(""); [EOL] node.setAttribute(true); [EOL] node.setName("attributeName"); [EOL] String result = node.asPath(); [EOL] assertEquals("/@attributeName", result); [EOL] }
public void testAsPathWithCollectionIndex() { [EOL] when(parent.isContainer()).thenReturn(false); [EOL] when(parent.asPath()).thenReturn(""); [EOL] node.setCollection(true); [EOL] node.setIndex(1); // Assuming index is 0-based [EOL] node.setName("collectionElement"); [EOL] String result = node.asPath(); [EOL] assertEquals("/collectionElement[2]", result); [EOL] }
public void testAsPathWithWholeCollection() { [EOL] when(parent.isContainer()).thenReturn(false); [EOL] when(parent.asPath()).thenReturn(""); [EOL] node.setCollection(true); [EOL] node.setIndex(WHOLE_COLLECTION); // Assuming WHOLE_COLLECTION is a constant indicating the whole collection [EOL] node.setName("collectionElement"); [EOL] String result = node.asPath(); [EOL] assertEquals("/collectionElement", result); [EOL] }
public void testSetValueWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] Object value = null; [EOL] instance.setValue(value); [EOL] assertNull("The attribute value should be null", instance.getValue()); [EOL] }
public void testSetValueWithString() { [EOL] YourClass instance = new YourClass(); [EOL] String value = "testString"; [EOL] instance.setValue(value); [EOL] assertEquals("The attribute value should be 'testString'", "testString", instance.getValue()); [EOL] }
public void testSetValueWithNonStringObject() { [EOL] YourClass instance = new YourClass(); [EOL] Object value = Integer.valueOf(123); [EOL] instance.setValue(value); [EOL] assertEquals("The attribute value should be '123' as a String", "123", instance.getValue()); [EOL] }
public void testRemove_AttributeHasParent() { [EOL] DomNode mockParent = mock(DomNode.class); [EOL] DomAttr mockAttr = mock(DomAttr.class); [EOL] when(mockAttr.getParent()).thenReturn(mockParent); [EOL] AttributeRemover remover = new AttributeRemover(mockAttr); [EOL] remover.remove(); [EOL] verify(mockParent).removeAttribute(mockAttr); [EOL] }
public void testRemove_AttributeHasNoParent() { [EOL] DomAttr mockAttr = mock(DomAttr.class); [EOL] when(mockAttr.getParent()).thenReturn(null); [EOL] AttributeRemover remover = new AttributeRemover(mockAttr); [EOL] remover.remove(); [EOL] verify(mockAttr, never()).removeAttribute(any(DomAttr.class)); [EOL] }
public void testIsCollectionWithNull() { [EOL] boolean result = isCollection(null); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithArray() { [EOL] boolean result = isCollection(new int[]{1, 2, 3}); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithCollection() { [EOL] boolean result = isCollection(new ArrayList<>()); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithNonCollection() { [EOL] boolean result = isCollection(new Object()); [EOL] assertFalse(result); [EOL] }
public void testGetCollectionHintWithArrayClass() { [EOL] int result = ClassName.getCollectionHint(int[].class); [EOL] assertEquals(1, result); [EOL] }
public void testGetCollectionHintWithCollectionClass() { [EOL] int result = ClassName.getCollectionHint(ArrayList.class); [EOL] assertEquals(1, result); [EOL] }
public void testGetCollectionHintWithPrimitiveClass() { [EOL] int result = ClassName.getCollectionHint(int.class); [EOL] assertEquals(-1, result); [EOL] }
public void testGetCollectionHintWithInterfaceClass() { [EOL] int result = ClassName.getCollectionHint(List.class); [EOL] assertEquals(0, result); [EOL] }
public void testGetCollectionHintWithFinalClass() { [EOL] int result = ClassName.getCollectionHint(String.class); [EOL] assertEquals(-1, result); [EOL] }
public void testGetCollectionHintWithRegularClass() { [EOL] int result = ClassName.getCollectionHint(Object.class); [EOL] assertEquals(0, result); [EOL] }
public void testGetIndexedPropertyLengthWithReadMethod() { [EOL] Object object = new ObjectWithIndexedProperty(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(ObjectWithIndexedProperty.class.getMethod("getIndexedValue", int.class)); [EOL] int length = JXPath.getIndexedPropertyLength(object, pd); [EOL] assertEquals("Expected length did not match", ObjectWithIndexedProperty.EXPECTED_LENGTH, length); [EOL] }
public void testGetIndexedPropertyLengthWithIndexedReadMethod() { [EOL] Object object = new ObjectWithIndexedProperty(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] when(pd.getIndexedReadMethod()).thenReturn(ObjectWithIndexedProperty.class.getMethod("getIndexedValue", int.class)); [EOL] int length = JXPath.getIndexedPropertyLength(object, pd); [EOL] assertEquals("Expected length did not match", ObjectWithIndexedProperty.EXPECTED_LENGTH, length); [EOL] }
public void testGetIndexedPropertyLengthWithNoReadMethodThrowsException() { [EOL] Object object = new ObjectWithIndexedProperty(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] when(pd.getIndexedReadMethod()).thenReturn(null); [EOL] try { [EOL] JXPath.getIndexedPropertyLength(object, pd); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("No indexed read method for property " + pd.getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetIndexedPropertyLengthWithExceptionInLoop() { [EOL] Object object = new ObjectWithIndexedProperty(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] Method readMethod = ObjectWithIndexedProperty.class.getMethod("getIndexedValueWithException", int.class); [EOL] when(pd.getIndexedReadMethod()).thenReturn(readMethod); [EOL] int length = JXPath.getIndexedPropertyLength(object, pd); [EOL] assertEquals("Expected length did not match", ObjectWithIndexedProperty.EXPECTED_EXCEPTION_INDEX, length); [EOL] }
public void testGetIndexedPropertyLengthWithLoopExceedingMaxCountThrowsException() { [EOL] Object object = new ObjectWithIndexedProperty(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] Method readMethod = ObjectWithIndexedProperty.class.getMethod("getIndexedValueExceedingMaxCount", int.class); [EOL] when(pd.getIndexedReadMethod()).thenReturn(readMethod); [EOL] try { [EOL] JXPath.getIndexedPropertyLength(object, pd); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot determine the length of the indexed property " + pd.getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetLengthWithNull() { [EOL] int result = getLength(null); [EOL] assertEquals(0, result); [EOL] }
public void testGetLengthWithArray() { [EOL] int[] array = new int[] {1, 2, 3}; [EOL] int result = getLength(array); [EOL] assertEquals(3, result); [EOL] }
public void testGetLengthWithCollection() { [EOL] Collection<Integer> collection = new ArrayList<>(); [EOL] collection.add(1); [EOL] collection.add(2); [EOL] collection.add(3); [EOL] int result = getLength(collection); [EOL] assertEquals(3, result); [EOL] }
public void testGetLengthWithNonCollectionObject() { [EOL] Object obj = new Object(); [EOL] int result = getLength(obj); [EOL] assertEquals(1, result); [EOL] }
public void testExpandCollectionWithNull() { [EOL] Object result = expandCollection(null, 10); [EOL] assertNull(result); [EOL] } [EOL] public void testExpandCollectionWithArray() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] int newSize = 5; [EOL] Object result = expandCollection(array, newSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.getClass().isArray()); [EOL] assertEquals(newSize, Array.getLength(result)); [EOL] } [EOL] public void testExpandCollectionWithCollection() { [EOL] Collection<Integer> collection = new ArrayList<>(Arrays.asList(1, 2, 3)); [EOL] int newSize = 5; [EOL] Object result = expandCollection(collection, newSize); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Collection); [EOL] assertEquals(newSize, ((Collection) result).size()); [EOL] } [EOL] public void testExpandCollectionWithInvalidType() { [EOL] try { [EOL] Object result = expandCollection("InvalidType", 10); [EOL] fail("Should have thrown JXPathException"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetValueWithNullCollection() { [EOL] Object result = getValue(null, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithEmptyArray() { [EOL] Object[] array = new Object[0]; [EOL] Object result = getValue(array, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidArrayIndex() { [EOL] Object[] array = new Object[] { "a", "b", "c" }; [EOL] Object result = getValue(array, 1); [EOL] assertEquals("b", result); [EOL] } [EOL] public void testGetValueWithInvalidArrayIndex() { [EOL] Object[] array = new Object[] { "a", "b", "c" }; [EOL] Object result = getValue(array, 3); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithNegativeArrayIndex() { [EOL] Object[] array = new Object[] { "a", "b", "c" }; [EOL] Object result = getValue(array, -1); [EOL] assertNull(result); [EOL] }
public void testGetValueWithEmptyList() { [EOL] List<Object> list = new ArrayList<>(); [EOL] Object result = getValue(list, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidListIndex() { [EOL] List<Object> list = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(list, 1); [EOL] assertEquals("b", result); [EOL] } [EOL] public void testGetValueWithInvalidListIndex() { [EOL] List<Object> list = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(list, 3); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithNegativeListIndex() { [EOL] List<Object> list = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(list, -1); [EOL] assertNull(result); [EOL] }
public void testGetValueWithEmptyCollection() { [EOL] Collection<Object> collection = new HashSet<>(); [EOL] Object result = getValue(collection, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidCollectionIndex() { [EOL] Collection<Object> collection = new HashSet<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(collection, 1); [EOL] assertNotNull(result); // Cannot assert specific value due to unpredictable iteration order of HashSet [EOL] } [EOL] public void testGetValueWithInvalidCollectionIndex() { [EOL] Collection<Object> collection = new HashSet<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(collection, 3); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithNegativeCollectionIndex() { [EOL] Collection<Object> collection = new HashSet<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(collection, -1); [EOL] assertNull(result); [EOL] }
public void testSetValueWithArray() { [EOL] Object array = new int[]{1, 2, 3}; [EOL] int index = 1; [EOL] Object value = 4; [EOL] JXPath.setValue(array, index, value); [EOL] assertEquals(4, Array.get(array, index)); [EOL] } [EOL] public void testSetValueWithList() { [EOL] List<Object> list = new ArrayList<>(); [EOL] list.add("a"); [EOL] list.add("b"); [EOL] list.add("c"); [EOL] int index = 1; [EOL] Object value = "z"; [EOL] JXPath.setValue(list, index, value); [EOL] assertEquals("z", list.get(index)); [EOL] } [EOL] public void testSetValueWithUnsupportedCollection() { [EOL] Collection<Object> collection = new HashSet<>(); [EOL] collection.add("a"); [EOL] int index = 0; [EOL] Object value = "z"; [EOL] try { [EOL] JXPath.setValue(collection, index, value); [EOL] fail("UnsupportedOperationException expected"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] } [EOL] public void testSetValueWithNull() { [EOL] Object collection = null; [EOL] int index = 1; [EOL] Object value = "z"; [EOL] JXPath.setValue(collection, index, value); [EOL] assertNull(collection); [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index) { [EOL] if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL] try { [EOL] IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL] Method method = ipd.getIndexedReadMethod(); [EOL] if (method != null) { [EOL] return method.invoke(bean, new Object[] { new Integer(index) }); [EOL] } [EOL] } catch (InvocationTargetException ex) { [EOL] Throwable t = ((InvocationTargetException) ex).getTargetException(); [EOL] if (t instanceof ArrayIndexOutOfBoundsException) { [EOL] return null; [EOL] } [EOL] throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), t); [EOL] } catch (Throwable ex) { [EOL] throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), ex); [EOL] } [EOL] } [EOL] return getValue(getValue(bean, propertyDescriptor), index); [EOL] }
public void testSetValueWithIndexedPropertyDescriptorAndValidMethod() { [EOL] Object bean = new MyBean(); [EOL] IndexedPropertyDescriptor propertyDescriptor = mock(IndexedPropertyDescriptor.class); [EOL] Method writeMethod = MyBean.class.getMethod("setIndexedProperty", int.class, String.class); [EOL] when(propertyDescriptor.getIndexedWriteMethod()).thenReturn(writeMethod); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] assertEquals("testValue", ((MyBean) bean).getIndexedProperty(index)); [EOL] }
public void testSetValueWithIndexedPropertyDescriptorAndNullMethod() { [EOL] Object bean = new MyBean(); [EOL] IndexedPropertyDescriptor propertyDescriptor = mock(IndexedPropertyDescriptor.class); [EOL] when(propertyDescriptor.getIndexedWriteMethod()).thenReturn(null); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] try { [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testSetValueWithNonIndexedPropertyDescriptor() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] int index = 0; [EOL] Object value = "testValue"; [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] assertEquals("testValue", ((MyBean) bean).getSimpleProperty()); [EOL] }
public void testSetValueWithNonIndexedPropertyDescriptorAndNonZeroIndex() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] try { [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testSetValueWithCollection() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] Collection collection = new ArrayList(); [EOL] collection.add("initialValue"); [EOL] when(JXPath.getValue(bean, propertyDescriptor)).thenReturn(collection); [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] assertEquals("testValue", new ArrayList(collection).get(index)); [EOL] }
public void testGetDynamicPropertyHandlerWithExistingHandler() { [EOL] Class clazz = ExistingHandlerClass.class; [EOL] DynamicPropertyHandler expectedHandler = new ExistingHandler(); [EOL] dynamicPropertyHandlerMap.put(clazz, expectedHandler); [EOL] DynamicPropertyHandler resultHandler = ClassName.getDynamicPropertyHandler(clazz); [EOL] assertSame("Handler should be the one previously stored", expectedHandler, resultHandler); [EOL] }
public void testGetDynamicPropertyHandlerWithNewHandler() { [EOL] Class clazz = NewHandlerClass.class; [EOL] DynamicPropertyHandler resultHandler = ClassName.getDynamicPropertyHandler(clazz); [EOL] assertNotNull("Handler should not be null", resultHandler); [EOL] assertTrue("Handler should be instance of the class", clazz.isInstance(resultHandler)); [EOL] }
public void testGetDynamicPropertyHandlerWithException() { [EOL] Class clazz = ExceptionThrowingHandlerClass.class; [EOL] try { [EOL] ClassName.getDynamicPropertyHandler(clazz); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Exception message should match", "Cannot allocate dynamic property handler of class " + clazz.getName(), e.getMessage()); [EOL] } [EOL] }
public void testCreateNodePointerWithDocument() { [EOL] QName name = new QName("test"); [EOL] Document document = createMockDocument(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, document, locale); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] }
public void testCreateNodePointerWithElement() { [EOL] QName name = new QName("test"); [EOL] Element element = createMockElement(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, element, locale); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] }
public void testCreateNodePointerWithNonNode() { [EOL] QName name = new QName("test"); [EOL] Object nonNodeBean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, nonNodeBean, locale); [EOL] assertNull(result); [EOL] }
public void testGetNameReturnsNull() { [EOL] MyClass instance = new MyClass(); [EOL] QName result = instance.getName(); [EOL] assertNull(result); [EOL] }
public Object getBaseValue() { [EOL] return container; [EOL] }
public void testGetLength_BaseValueIsNull() { [EOL] setBaseValueToNull(); // This is a placeholder for the actual implementation [EOL] int length = getLength(); [EOL] assertEquals(1, length); [EOL] }
public void testGetLength_BaseValueIsNotNull() { [EOL] setBaseValueToNonNull(); // This is a placeholder for the actual implementation [EOL] int length = getLength(); [EOL] int expectedLength = determineExpectedLengthOfBaseValue(); // This is a placeholder for the actual implementation [EOL] assertEquals(expectedLength, length); [EOL] }
public Object getImmediateNode() { [EOL] Object value = getBaseValue(); [EOL] if (index != WHOLE_COLLECTION) { [EOL] if (index >= 0 && index < getLength()) { [EOL] return ValueUtils.getValue(value, index); [EOL] } else { [EOL] return null; [EOL] } [EOL] } else { [EOL] return ValueUtils.getValue(value); [EOL] } [EOL] }
public void testGetImmediateValuePointerWhenValuePointerIsNull() { [EOL] NodePointer testNodePointer = createTestNodePointerWithNullValuePointer(); [EOL] NodePointer result = testNodePointer.getImmediateValuePointer(); [EOL] assertNotNull("Expected non-null valuePointer", result); [EOL] }
public void testGetImmediateValuePointerWhenValuePointerIsNotNull() { [EOL] NodePointer testNodePointer = createTestNodePointerWithNonNullValuePointer(); [EOL] NodePointer result = testNodePointer.getImmediateValuePointer(); [EOL] assertSame("Expected the same valuePointer that was already set", testNodePointer.existingValuePointer, result); [EOL] }
public void testChildIteratorWithNullTestAndFalseReverseAndNullStartWith() { [EOL] NodeTest test = null; [EOL] boolean reverse = false; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNonNullTestAndFalseReverseAndNullStartWith() { [EOL] NodeTest test = new NodeTest(); // Replace with actual constructor or factory method [EOL] boolean reverse = false; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNonNullTestAndTrueReverseAndNullStartWith() { [EOL] NodeTest test = new NodeTest(); // Replace with actual constructor or factory method [EOL] boolean reverse = true; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNonNullTestAndFalseReverseAndNonNullStartWith() { [EOL] NodeTest test = new NodeTest(); // Replace with actual constructor or factory method [EOL] boolean reverse = false; [EOL] NodePointer startWith = new NodePointer(); // Replace with actual constructor or factory method [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] }
public void testNamespaceIterator() { [EOL] NodeIterator result = obj.namespaceIterator(); [EOL] assertNotNull("The result should not be null", result); [EOL] }
public void testAsPath_WithNonNullParent() { [EOL] Node parent = mock(Node.class); [EOL] when(parent.asPath()).thenReturn("/parent/path"); [EOL] Node node = new Node(parent); [EOL] String result = node.asPath(); [EOL] assertEquals("/parent/path", result); [EOL] }
public void testAsPath_WithNullParent() { [EOL] Node node = new Node(null); [EOL] String result = node.asPath(); [EOL] assertEquals("/", result); [EOL] }
```java [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL] switch(pos) { [EOL] case 0: [EOL] if ((active1 & 0xc0000L) != 0L) [EOL] return 10; [EOL] if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 1: [EOL] if ((active0 & 0x8000008000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 1; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 2: [EOL] if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 2; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 3: [EOL] if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL] if (jjmatchedPos != 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 4: [EOL] if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 5: [EOL] if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL] if (jjmatchedPos != 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 6: [EOL] if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 6; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 7: [EOL] if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x802000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 8: [EOL] if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] if (jjmatchedPos != 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 9: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 10: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 10; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 11: [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 11; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 12: [EOL] if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 12; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 13: [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 13; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 14: [EOL] if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x1000f00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 14; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 15: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xf00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 16: [EOL] if ((active0 & 0xe00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 17: [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 18: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 18; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 19: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 19; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [
```java [EOL] private final int jjStopAtPos(int pos, int kind) { [EOL] jjmatchedKind = kind; [EOL] jjmatchedPos = pos; [EOL] return pos + 1; [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\
private final int jjMoveStringLiteralDfa0_0() { [EOL] switch(curChar) { [EOL] case 33: [EOL] return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL] case 36: [EOL] return jjStopAtPos(0, 17); [EOL] case 40: [EOL] return jjStopAtPos(0, 80); [EOL] case 41: [EOL] return jjStopAtPos(0, 81); [EOL] case 42: [EOL] return jjStopAtPos(0, 88); [EOL] case 43: [EOL] return jjStopAtPos(0, 9); [EOL] case 44: [EOL] return jjStopAtPos(0, 87); [EOL] case 45: [EOL] return jjStopAtPos(0, 10); [EOL] case 46: [EOL] jjmatchedKind = 82; [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL] case 47: [EOL] jjmatchedKind = 6; [EOL] return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL] case 58: [EOL] return jjStopAtPos(0, 79); [EOL] case 60: [EOL] jjmatchedKind = 13; [EOL] return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL] case 61: [EOL] return jjStopAtPos(0, 11); [EOL] case 62: [EOL] jjmatchedKind = 15; [EOL] return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL] case 64: [EOL] return jjStopAtPos(0, 86); [EOL] case 91: [EOL] return jjStopAtPos(0, 84); [EOL] case 93: [EOL] return jjStopAtPos(0, 85); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL] case 107: [EOL] return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL] case 124: [EOL] return jjStopAtPos(0, 8); [EOL] default: [EOL] return jjMoveNfa_0(0, 0); [EOL] } [EOL] }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(0, active0, active1); [EOL] return 1; [EOL] } [EOL] switch(curChar) { [EOL] case 46: [EOL] if ((active1 & 0x80000L) != 0L) [EOL] return jjStopAtPos(1, 83); [EOL] break; [EOL] case 47: [EOL] if ((active0 & 0x80L) != 0L) [EOL] return jjStopAtPos(1, 7); [EOL] break; [EOL] case 61: [EOL] if ((active0 & 0x1000L) != 0L) [EOL] return jjStopAtPos(1, 12); [EOL] else if ((active0 & 0x4000L) != 0L) [EOL] return jjStopAtPos(1, 14); [EOL] else if ((active0 & 0x10000L) != 0L) [EOL] return jjStopAtPos(1, 16); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL] case 100: [EOL] if ((active0 & 0x8000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 51, 12); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL] case 104: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL] case 114: [EOL] if ((active0 & 0x8000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 27, 12); [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(0, active0, active1); [EOL] }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(0, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(1, active0, active1); [EOL] return 2; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL] case 100: [EOL] if ((active0 & 0x10000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 28, 12); [EOL] else if ((active0 & 0x20000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 29, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL] case 109: [EOL] if ((active1 & 0x200L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 73, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL] case 116: [EOL] if ((active1 & 0x8L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 67, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL] case 118: [EOL] if ((active0 & 0x40000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 30, 12); [EOL] break; [EOL] case 120: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL] case 121: [EOL] if ((active0 & 0x10000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 52, 12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(1, active0, active1); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(1, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(2, active0, active1); [EOL] return 3; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x80000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 31, 12); [EOL] else if ((active0 & 0x80000000000000L) != 0L) { [EOL] jjmatchedKind = 55; [EOL] jjmatchedPos = 3; [EOL] } else if ((active1 & 0x10L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 68, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x80L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 71, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL] case 108: [EOL] if ((active1 & 0x40L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 70, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL] case 116: [EOL] if ((active0 & 0x100000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 32, 12); [EOL] else if ((active0 & 0x1000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 48, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(2, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\
```java [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(2, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(3, active0, active1); [EOL] return 4; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL] case 100: [EOL] if ((active1 & 0x1000L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 76, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x20L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 69, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x400L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 74, 12); [EOL] break; [EOL] case 115: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL] case 116: [EOL] if ((active0 & 0x4000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 50, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(3, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(3, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(4, active0, active1); [EOL] return 5; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x800000000L) != 0L) [EOL] return jjStopAtPos(5, 35); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active0 & 0x100000000000000L) != 0L) { [EOL] jjmatchedKind = 56; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x100L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 72, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 57, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(4, active0, active1); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(4, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(5, active0, active1); [EOL] return 6; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL] case 58: [EOL] if ((active0 & 0x1000000000L) != 0L) [EOL] return jjStopAtPos(6, 36); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x800L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 75, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL] case 110: [EOL] if ((active1 & 0x4L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 66, 12); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 33, 12); [EOL] break; [EOL] case 117: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\
```java [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(5, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(6, active0, active1); [EOL] return 7; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x2000000000L) != 0L) [EOL] return jjStopAtPos(7, 37); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 110: [EOL] if ((active0 & 0x2000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 49, 12); [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL] case 115: [EOL] if ((active0 & 0x800000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 59, 12); [EOL] break; [EOL] case 116: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 122: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(6, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\
```java [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(6, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(7, active0, active1); [EOL] return 8; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x2L) != 0L) [EOL] return jjStartNfaWithStates_0(8, 65, 12); [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL] case 103: [EOL] if ((active0 & 0x4000000000000000L) != 0L) { [EOL] jjmatchedKind = 62; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\
```java [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(7, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(8, active0, active1); [EOL] return 9; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL] case 58: [EOL] if ((active0 & 0x4000000000L) != 0L) [EOL] return jjStopAtPos(9, 38); [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(9, 53, 12); [EOL] break; [EOL] case 103: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\
```java [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(8, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(9, active0, active1); [EOL] return 10; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x8000000000L) != 0L) [EOL] return jjStopAtPos(10, 39); [EOL] else if ((active0 & 0x10000000000L) != 0L) [EOL] return jjStopAtPos(10, 40); [EOL] else if ((active0 & 0x20000000000L) != 0L) [EOL] return jjStopAtPos(10, 41); [EOL] else if ((active0 & 0x40000000000L) != 0L) [EOL] return jjStopAtPos(10, 42); [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(10, 58, 12); [EOL] break; [EOL] case 114: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(9, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163
```java [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(9, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(10, active0, active1); [EOL] return 11; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x80000000000L) != 0L) [EOL] return jjStopAtPos(11, 43); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(10, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\
```java [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(10, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(11, active0, active1); [EOL] return 12; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x8000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 63, 12); [EOL] break; [EOL] case 105: [EOL] if ((active0 & 0x40000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 54, 12); [EOL] break; [EOL] case 110: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x2000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 77, 12); [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(11, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\
```java [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(11, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(12, active0, active1); [EOL] return 13; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(12, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154
```java [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(12, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(13, active0, active1); [EOL] return 14; [EOL] } [EOL] switch(curChar) { [EOL] case 101: [EOL] if ((active1 & 0x1L) != 0L) [EOL] return jjStartNfaWithStates_0(14, 64, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active0 & 0x2000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(14, 61, 12); [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(13, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\
```java [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(13, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(14, active0, 0L); [EOL] return 15; [EOL] } [EOL] switch(curChar) { [EOL] case 101: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(15, 60, 12); [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(14, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\
private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(14, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(15, active0, 0L); [EOL] return 16; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(15, active0, 0L); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(15, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(16, active0, 0L); [EOL] return 17; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x100000000000L) != 0L) [EOL] return jjStopAtPos(17, 44); [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(16, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156
```java [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(16, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(17, active0, 0L); [EOL] return 18; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x200000000000L) != 0L) [EOL] return jjStopAtPos(18, 45); [EOL] else if ((active0 & 0x400000000000L) != 0L) [EOL] return jjStopAtPos(18, 46); [EOL] return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(17, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163
```java [EOL] private final void jjCheckNAdd(int state) { [EOL] if (jjrounds[state] != jjround) { [EOL] jjstateSet[jjnewStateCnt++] = state; [EOL] jjrounds[state] = jjround; [EOL] } [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154
```java [EOL] private final void jjCheckNAddTwoStates(int state1, int state2) { [EOL] jjCheckNAdd(state1); [EOL] jjCheckNAdd(state2); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc800803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162
private final int jjMoveNfa_0(int startState, int curPos) { [EOL] int[] nextStates; [EOL] int startsAt = 0; [EOL] jjnewStateCnt = 13; [EOL] int i = 1; [EOL] jjstateSet[0] = startState; [EOL] int j, kind = 0x7fffffff; [EOL] for (; ; ) { [EOL] if (++jjround == 0x7fffffff) [EOL] ReInitRounds(); [EOL] if (curChar < 64) { [EOL] long l = 1L << curChar; [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if ((0x3ff000000000000L & l) != 0L) { [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] } else if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] else if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] else if (curChar == 34) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 1: [EOL] if ((0xfffffffbffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 2: [EOL] if (curChar == 34 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 3: [EOL] if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 4: [EOL] if ((0xffffff7fffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 5: [EOL] if (curChar == 39 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 6: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] break; [EOL] case 7: [EOL] if (curChar != 46) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 8: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 9: [EOL] if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 10: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 12: [EOL] if ((0x3ff600000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjstateSet[jjnewStateCnt++] = 12; [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else if (curChar < 128) { [EOL] long l = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] case 12: [EOL] if ((0x7fffffe87fffffeL & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] jjAddStates(2, 3); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else { [EOL] int hiByte = (int) (curChar >> 8); [EOL] int i1 = hiByte >> 6; [EOL] long l1 = 1L << (hiByte & 077); [EOL] int i2 = (curChar & 0xff) >> 6; [EOL] long l2 = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(2, 3); [EOL] break; [EOL] case 12: [EOL] if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } [EOL] if (kind != 0x7fffffff) { [EOL] jjmatchedKind = kind; [EOL] jjmatchedPos = curPos; [EOL] kind = 0x7fffffff; [EOL] } [EOL] ++curPos; [EOL] if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL] return curPos; [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] return curPos; [EOL] } [EOL] } [EOL] }
public void testReInitWithSimpleCharStream() { [EOL] SimpleCharStream stream = new SimpleCharStream(new StringReader("input")); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(stream); [EOL] tokenManager.ReInit(stream); [EOL] assertEquals("Expected jjmatchedPos to be reset to 0", 0, tokenManager.jjmatchedPos); [EOL] assertEquals("Expected jjnewStateCnt to be reset to 0", 0, tokenManager.jjnewStateCnt); [EOL] assertEquals("Expected curLexState to be reset to defaultLexState", tokenManager.defaultLexState, tokenManager.curLexState); [EOL] assertSame("Expected input_stream to be the same as stream", stream, tokenManager.input_stream); [EOL] }
public void testXPathParserTokenManagerWithStream() { [EOL] SimpleCharStream stream = new SimpleCharStream(new StringReader("input")); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(stream); [EOL] assertNotNull("Expected tokenManager to be created with stream", tokenManager); [EOL] assertEquals("Expected curLexState to be defaultLexState", tokenManager.defaultLexState, tokenManager.curLexState); [EOL] assertSame("Expected input_stream to be the same as stream", stream, tokenManager.input_stream); [EOL] }
public void testXPathParserTokenManagerWithStreamAndState() { [EOL] SimpleCharStream stream = new SimpleCharStream(new StringReader("input")); [EOL] int lexState = 1; // Assuming 1 is a valid lexState [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(stream, lexState); [EOL] assertNotNull("Expected tokenManager to be created with stream and lexState", tokenManager); [EOL] assertEquals("Expected curLexState to be set to lexState", lexState, tokenManager.curLexState); [EOL] assertSame("Expected input_stream to be the same as stream", stream, tokenManager.input_stream); [EOL] }
public void testSetDebugStream() { [EOL] SimpleCharStream stream = new SimpleCharStream(new StringReader("input")); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(stream); [EOL] PrintStream debugStream = new PrintStream(new ByteArrayOutputStream()); [EOL] tokenManager.setDebugStream(debugStream); [EOL] assertSame("Expected debugStream to be set", debugStream, tokenManager.debugStream); [EOL] }
```java [EOL] private final void ReInitRounds() { [EOL] int i; [EOL] jjround = 0x80000001; [EOL] for (i = 13; i-- > 0; ) jjrounds[i] = 0x80000000; [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154
```java [EOL] protected Token jjFillToken() { [EOL] Token t = Token.newToken(jjmatchedKind); [EOL] t.kind = jjmatchedKind; [EOL] String im = jjstrLiteralImages[jjmatchedKind]; [EOL] t.image = (im == null) ? input_stream.GetImage() : im; [EOL] t.beginLine = input_stream.getBeginLine(); [EOL] t.beginColumn = input_stream.getBeginColumn(); [EOL] t.endLine = input_stream.getEndLine(); [EOL] t.endColumn = input_stream.getEndColumn(); [EOL] return t; [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\
public Token testGetNextTokenWithIOExceptionOnBeginToken() { [EOL] SimpleCharStream input_stream = mock(SimpleCharStream.class); [EOL] when(input_stream.BeginToken()).thenThrow(new IOException()); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(input_stream); [EOL] Token result = tokenManager.getNextToken(); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.kind); [EOL] }
public Token testGetNextTokenWithIOExceptionOnBackup() { [EOL] SimpleCharStream input_stream = mock(SimpleCharStream.class); [EOL] when(input_stream.BeginToken()).thenReturn(' '); [EOL] doThrow(new IOException()).when(input_stream).backup(0); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(input_stream); [EOL] Token result = tokenManager.getNextToken(); [EOL] assertNotNull(result); [EOL] assertEquals(SOME_EXPECTED_KIND, result.kind); [EOL] }
public Token testGetNextTokenWithValidToken() { [EOL] SimpleCharStream input_stream = mock(SimpleCharStream.class); [EOL] when(input_stream.BeginToken()).thenReturn('a'); [EOL] when(input_stream.backup(anyInt())).thenAnswer(invocation -> null); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(input_stream); [EOL] tokenManager.jjmatchedKind = SOME_MATCHED_KIND; // Set to a valid kind that is not 0x7fffffff [EOL] tokenManager.jjmatchedPos = 0; [EOL] when(tokenManager.jjMoveStringLiteralDfa0_0()).thenReturn(1); [EOL] Token result = tokenManager.getNextToken(); [EOL] assertNotNull(result); [EOL] assertEquals(SOME_MATCHED_KIND, result.kind); [EOL] }
public Token testGetNextTokenWithEOFSeen() { [EOL] SimpleCharStream input_stream = mock(SimpleCharStream.class); [EOL] when(input_stream.BeginToken()).thenReturn('a'); [EOL] when(input_stream.backup(anyInt())).thenAnswer(invocation -> null); [EOL] when(input_stream.readChar()).thenThrow(new IOException()); [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(input_stream); [EOL] tokenManager.jjmatchedKind = 0x7fffffff; [EOL] tokenManager.jjmatchedPos = 0; [EOL] when(tokenManager.jjMoveStringLiteralDfa0_0()).thenReturn(1); [EOL] assertThrows(TokenMgrError.class, tokenManager::getNextToken); [EOL] }
public void testNodeWithNullTest() { [EOL] Node node = mock(Node.class); [EOL] boolean result = testNode(node, null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testNamespace", "testLocalName"); [EOL] when(testNameTest.getNodeName()).thenReturn(testName); [EOL] when(testNameTest.getNamespaceURI()).thenReturn("testNamespace"); [EOL] when(testNameTest.isWildcard()).thenReturn(false); [EOL] when(DOMNodePointer.getLocalName(node)).thenReturn("testLocalName"); [EOL] when(DOMNodePointer.getNamespaceURI(node)).thenReturn("testNamespace"); [EOL] boolean result = testNode(node, testNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndNonElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] boolean result = testNode(node, testNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeTypeTestElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestDocumentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestProcessingInstructionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithProcessingInstructionTest() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("testTarget"); [EOL] boolean result = testNode(node, piTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithMismatchedProcessingInstructionTest() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("differentTarget"); [EOL] boolean result = testNode(node, piTest); [EOL] assertFalse(result); [EOL] }
public void testNamespaceIterator() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodeIterator iterator = context.namespaceIterator(); [EOL] assertNotNull("Iterator should not be null", iterator); [EOL] assertTrue("Iterator should be instance of DOMNamespaceIterator", iterator instanceof DOMNamespaceIterator); [EOL] }
public void testSetValueWithTextNodeAndNonNullNonEmptyString() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] String value = "Test String"; [EOL] setValue(value); [EOL] verify(node).setNodeValue(value); [EOL] }
public void testSetValueWithTextNodeAndNullString() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] String value = null; [EOL] setValue(value); [EOL] verify(node.getParentNode()).removeChild(node); [EOL] }
public void testSetValueWithTextNodeAndEmptyString() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] String value = ""; [EOL] setValue(value); [EOL] verify(node.getParentNode()).removeChild(node); [EOL] }
public void testSetValueWithNonTextNodeAndNodeValue() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] Node value = mock(Node.class); [EOL] when(value.cloneNode(true)).thenReturn(value); [EOL] when(node.getOwnerDocument()).thenReturn(mock(Document.class)); [EOL] when(node.getChildNodes()).thenReturn(mock(NodeList.class)); [EOL] setValue(value); [EOL] verify(node).appendChild(value); [EOL] }
public void testSetValueWithNonTextNodeAndElementValue() { [EOL] Node node = mock(Node.class); [EOL] Node value = mock(Element.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(value.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(value); [EOL] when(value.cloneNode(true)).thenReturn(value); [EOL] when(node.getOwnerDocument()).thenReturn(mock(Document.class)); [EOL] when(node.getChildNodes()).thenReturn(mock(NodeList.class)); [EOL] setValue(value); [EOL] verify(node).appendChild(value); [EOL] }
public void testSetValueWithNonTextNodeAndStringValue() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] String value = "Test String"; [EOL] Document doc = mock(Document.class); [EOL] Text textNode = mock(Text.class); [EOL] when(node.getOwnerDocument()).thenReturn(doc); [EOL] when(doc.createTextNode(value)).thenReturn(textNode); [EOL] when(node.getChildNodes()).thenReturn(mock(NodeList.class)); [EOL] setValue(value); [EOL] verify(node).appendChild(textNode); [EOL] }
public void testSetValueWithNonTextNodeAndEmptyStringValue() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] String value = ""; [EOL] when(node.getChildNodes()).thenReturn(mock(NodeList.class)); [EOL] setValue(value); [EOL] verify(node, never()).appendChild(any(Node.class)); [EOL] }
public void testCreateChildWithWholeCollectionIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = mock(NodePointer.class); [EOL] AbstractFactory abstractFactory = mock(AbstractFactory.class); [EOL] when(testNodePointer.getAbstractFactory(context)).thenReturn(abstractFactory); [EOL] when(abstractFactory.createObject(context, testNodePointer, testNodePointer.node, name.toString(), 0)).thenReturn(true); [EOL] NodeIterator nodeIterator = mock(NodeIterator.class); [EOL] when(testNodePointer.childIterator(any(NodeTest.class), eq(false), isNull())).thenReturn(nodeIterator); [EOL] when(nodeIterator.setPosition(1)).thenReturn(true); [EOL] NodePointer resultNodePointer = mock(NodePointer.class); [EOL] when(nodeIterator.getNodePointer()).thenReturn(resultNodePointer); [EOL] NodePointer result = testNodePointer.createChild(context, name, NodePointer.WHOLE_COLLECTION); [EOL] assertNotNull(result); [EOL] assertSame(resultNodePointer, result); [EOL] }
public void testCreateChildWithNonWholeCollectionIndexAndSuccess() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = mock(NodePointer.class); [EOL] AbstractFactory abstractFactory = mock(AbstractFactory.class); [EOL] when(testNodePointer.getAbstractFactory(context)).thenReturn(abstractFactory); [EOL] when(abstractFactory.createObject(context, testNodePointer, testNodePointer.node, name.toString(), 1)).thenReturn(true); [EOL] NodeIterator nodeIterator = mock(NodeIterator.class); [EOL] when(testNodePointer.childIterator(any(NodeTest.class), eq(false), isNull())).thenReturn(nodeIterator); [EOL] when(nodeIterator.setPosition(2)).thenReturn(true); [EOL] NodePointer resultNodePointer = mock(NodePointer.class); [EOL] when(nodeIterator.getNodePointer()).thenReturn(resultNodePointer); [EOL] NodePointer result = testNodePointer.createChild(context, name, 1); [EOL] assertNotNull(result); [EOL] assertSame(resultNodePointer, result); [EOL] }
public void testCreateChildWithNonWholeCollectionIndexAndFailure() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] NodePointer testNodePointer = mock(NodePointer.class); [EOL] AbstractFactory abstractFactory = mock(AbstractFactory.class); [EOL] when(testNodePointer.getAbstractFactory(context)).thenReturn(abstractFactory); [EOL] when(abstractFactory.createObject(context, testNodePointer, testNodePointer.node, name.toString(), 1)).thenReturn(false); [EOL] try { [EOL] testNodePointer.createChild(context, name, 1); [EOL] fail("JXPathAbstractFactoryException expected"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] assertEquals("Factory could not create a child node for path: " + testNodePointer.asPath() + "/" + name + "[2]", e.getMessage()); [EOL] } [EOL] }
public void testCreateAttributeWithNonElementNode() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testName"); [EOL] NodePointer testNodePointer = new NodePointer() { [EOL] }; [EOL] NodePointer nodePointer = new NodePointer(testNodePointer) { [EOL] public boolean isElement() { [EOL] return false; [EOL] } [EOL] public NodePointer createAttribute(JXPathContext context, QName name) { [EOL] return testNodePointer; [EOL] } [EOL] }; [EOL] NodePointer result = nodePointer.createAttribute(context, name); [EOL] assertSame("Should return the super.createAttribute result", testNodePointer, result); [EOL] }
public void testCreateAttributeWithElementNodeAndKnownPrefix() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] NodePointer nodePointer = new NodePointer(null) { [EOL] public boolean isElement() { [EOL] return true; [EOL] } [EOL] public String getNamespaceURI(String prefix) { [EOL] return "testNamespace"; [EOL] } [EOL] public NodeIterator attributeIterator(QName name) { [EOL] NodeIterator iterator = mock(NodeIterator.class); [EOL] when(iterator.getNodePointer()).thenReturn(this); [EOL] return iterator; [EOL] } [EOL] public Node getNode() { [EOL] return element; [EOL] } [EOL] }; [EOL] doNothing().when(element).setAttributeNS(anyString(), anyString(), anyString()); [EOL] nodePointer.createAttribute(context, name); [EOL] verify(element).setAttributeNS(eq("testNamespace"), eq(name.toString()), eq("")); [EOL] }
public void testCreateAttributeWithElementNodeAndUnknownPrefix() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("unknownPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] NodePointer nodePointer = new NodePointer(null) { [EOL] public boolean isElement() { [EOL] return true; [EOL] } [EOL] public String getNamespaceURI(String prefix) { [EOL] return null; [EOL] } [EOL] public Node getNode() { [EOL] return element; [EOL] } [EOL] }; [EOL] try { [EOL] nodePointer.createAttribute(context, name); [EOL] fail("JXPathException expected for unknown namespace prefix"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Unknown namespace prefix: unknownPrefix", e.getMessage()); [EOL] } [EOL] }
public void testCreateAttributeWithElementNodeAndNoPrefix() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testName"); [EOL] Element element = mock(Element.class); [EOL] NodePointer nodePointer = new NodePointer(null) { [EOL] public boolean isElement() { [EOL] return true; [EOL] } [EOL] public NodeIterator attributeIterator(QName name) { [EOL] NodeIterator iterator = mock(NodeIterator.class); [EOL] when(iterator.getNodePointer()).thenReturn(this); [EOL] return iterator; [EOL] } [EOL] public Node getNode() { [EOL] return element; [EOL] } [EOL] }; [EOL] when(element.hasAttribute(name.getName())).thenReturn(false); [EOL] nodePointer.createAttribute(context, name); [EOL] verify(element).setAttribute(eq(name.getName()), eq("")); [EOL] }
public void testCreateAttributeWithElementNodeAndExistingAttribute() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testName"); [EOL] Element element = mock(Element.class); [EOL] NodePointer nodePointer = new NodePointer(null) { [EOL] public boolean isElement() { [EOL] return true; [EOL] } [EOL] public NodeIterator attributeIterator(QName name) { [EOL] NodeIterator iterator = mock(NodeIterator.class); [EOL] when(iterator.getNodePointer()).thenReturn(this); [EOL] return iterator; [EOL] } [EOL] public Node getNode() { [EOL] return element; [EOL] } [EOL] }; [EOL] when(element.hasAttribute(name.getName())).thenReturn(true); [EOL] nodePointer.createAttribute(context, name); [EOL] verify(element, never()).setAttribute(eq(name.getName()), eq("")); [EOL] }
public void testRemove_WithNonNullParent() { [EOL] Document document = createSampleDocument(); [EOL] Node nodeToRemove = document.getElementsByTagName("sampleTag").item(0); [EOL] DOMNodePointer nodePointer = new DOMNodePointer(nodeToRemove); [EOL] nodePointer.remove(); [EOL] assertNull("Node should be removed", nodeToRemove.getParentNode()); [EOL] } [EOL] public void testRemove_WithNullParent() { [EOL] Document document = createSampleDocumentWithRootOnly(); [EOL] Node rootNode = document.getDocumentElement(); [EOL] DOMNodePointer nodePointer = new DOMNodePointer(rootNode); [EOL] try { [EOL] nodePointer.remove(); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot remove root DOM node", e.getMessage()); [EOL] } [EOL] }

public void testAsPathWithNonNullId() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setId("testId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id('testId')", result); [EOL] }
public void testAsPathWithNullIdAndNonNullParent() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.startsWith("id('parentId')/")); [EOL] }
public void testAsPathWithElementNodeAndDefaultNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] DOMNodePointer parentInstance = mock(DOMNodePointer.class); [EOL] when(parentInstance.asPath()).thenReturn("/"); [EOL] instance.setParent(parentInstance); [EOL] NamespaceResolver namespaceResolver = mock(NamespaceResolver.class); [EOL] when(namespaceResolver.getDefaultNamespaceURI()).thenReturn("defaultNamespace"); [EOL] when(instance.getNamespaceURI()).thenReturn("defaultNamespace"); [EOL] instance.setNamespaceResolver(namespaceResolver); [EOL] when(DOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] String result = instance.asPath(); [EOL] assertEquals("/localName[1]", result); [EOL] }
public void testAsPathWithElementNodeAndNonDefaultNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] DOMNodePointer parentInstance = mock(DOMNodePointer.class); [EOL] when(parentInstance.asPath()).thenReturn("/"); [EOL] instance.setParent(parentInstance); [EOL] NamespaceResolver namespaceResolver = mock(NamespaceResolver.class); [EOL] when(namespaceResolver.getDefaultNamespaceURI()).thenReturn("defaultNamespace"); [EOL] when(instance.getNamespaceURI()).thenReturn("nonDefaultNamespace"); [EOL] when(namespaceResolver.getPrefix("nonDefaultNamespace")).thenReturn("prefix"); [EOL] instance.setNamespaceResolver(namespaceResolver); [EOL] when(DOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] String result = instance.asPath(); [EOL] assertEquals("/prefix:localName[1]", result); [EOL] }
public void testAsPathWithTextNode() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertEquals("/text()[1]", result); [EOL] }
public void testAsPathWithProcessingInstructionNode() { [EOL] YourClass instance = new YourClass(); [EOL] ProcessingInstruction piNode = mock(ProcessingInstruction.class); [EOL] when(piNode.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(piNode.getTarget()).thenReturn("target"); [EOL] instance.setNode(piNode); [EOL] String result = instance.asPath(); [EOL] assertEquals("/processing-instruction('target')[1]", result); [EOL] }
public void testAsPathWithDocumentNode() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertEquals("", result); [EOL] }
public void testGetRelativePositionOfTextNode_NoSiblings() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(null); [EOL] JxPath jxPath = new JxPath(node); [EOL] int position = jxPath.getRelativePositionOfTextNode(); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfTextNode_WithNonTextSiblings() { [EOL] Node node = mock(Node.class); [EOL] Node prevSibling = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(prevSibling); [EOL] when(prevSibling.getPreviousSibling()).thenReturn(null); [EOL] when(prevSibling.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] JxPath jxPath = new JxPath(node); [EOL] int position = jxPath.getRelativePositionOfTextNode(); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfTextNode_WithTextSiblings() { [EOL] Node node = mock(Node.class); [EOL] Node prevSibling1 = mock(Node.class); [EOL] Node prevSibling2 = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(prevSibling1); [EOL] when(prevSibling1.getPreviousSibling()).thenReturn(prevSibling2); [EOL] when(prevSibling2.getPreviousSibling()).thenReturn(null); [EOL] when(prevSibling1.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(prevSibling2.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE); [EOL] JxPath jxPath = new JxPath(node); [EOL] int position = jxPath.getRelativePositionOfTextNode(); [EOL] assertEquals(3, position); [EOL] }
public void testHashCode() { [EOL] Object node = new Object(); [EOL] JXPathContextReferenceImpl.NodePointerTestWrapper wrapper = new JXPathContextReferenceImpl.NodePointerTestWrapper(node); [EOL] int expectedHashCode = System.identityHashCode(node); [EOL] int actualHashCode = wrapper.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testGetLocalNameWithNonNullLocalName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getLocalName()).thenReturn("localName"); [EOL] String result = getLocalName(node); [EOL] assertEquals("localName", result); [EOL] }
public void testGetLocalNameWithNullLocalNameAndNoColonInNodeName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getLocalName()).thenReturn(null); [EOL] when(node.getNodeName()).thenReturn("nodeName"); [EOL] String result = getLocalName(node); [EOL] assertEquals("nodeName", result); [EOL] }
public void testGetLocalNameWithNullLocalNameAndColonInNodeName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getLocalName()).thenReturn(null); [EOL] when(node.getNodeName()).thenReturn("prefix:localPart"); [EOL] String result = getLocalName(node); [EOL] assertEquals("localPart", result); [EOL] }
public void testStringValueWithCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] when(node.getData()).thenReturn(" comment "); [EOL] String result = stringValue(node); [EOL] assertEquals("comment", result); [EOL] }
public void testStringValueWithTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(node.getNodeValue()).thenReturn(" text "); [EOL] String result = stringValue(node); [EOL] assertEquals("text", result); [EOL] }
public void testStringValueWithCDataSectionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE); [EOL] when(node.getNodeValue()).thenReturn(" cdata "); [EOL] String result = stringValue(node); [EOL] assertEquals("cdata", result); [EOL] }
public void testStringValueWithProcessingInstructionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction)node).getData()).thenReturn(" instruction "); [EOL] String result = stringValue(node); [EOL] assertEquals("instruction", result); [EOL] }
public void testStringValueWithOtherNodeHavingTextChild() { [EOL] Node node = mock(Node.class); [EOL] Node childNode = mock(Node.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(childNode); [EOL] when(childNode.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(childNode.getNodeValue()).thenReturn(" child text "); [EOL] String result = stringValue(node); [EOL] assertEquals("child text", result); [EOL] }
public void testStringValueWithOtherNodeHavingNonTextChild() { [EOL] Node node = mock(Node.class); [EOL] Node childNode = mock(Node.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(childNode); [EOL] when(childNode.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(childNode.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(0); // No children to ensure recursion does not proceed [EOL] String result = stringValue(node); [EOL] assertEquals("", result); [EOL] }
public void testGetAbstractFactoryWithNonNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] AbstractFactory expectedFactory = new AbstractFactory() { [EOL] }; [EOL] context.setFactory(expectedFactory); [EOL] AbstractFactory resultFactory = getAbstractFactory(context); [EOL] assertEquals("Expected factory should be returned", expectedFactory, resultFactory); [EOL] } [EOL] public void testGetAbstractFactoryWithNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] try { [EOL] getAbstractFactory(context); [EOL] fail("JXPathException should be thrown when factory is null"); [EOL] } catch (JXPathException e) { [EOL] assertTrue("Exception message should contain 'Factory is not set on the JXPathContext'", [EOL] e.getMessage().contains("Factory is not set on the JXPathContext")); [EOL] } [EOL] }
public void testClassFunctionsConstructor() { [EOL] Class<?> expectedFunctionClass = String.class; // Use String class as an example [EOL] String expectedNamespace = "exampleNamespace"; [EOL] ClassFunctions classFunctions = new ClassFunctions(expectedFunctionClass, expectedNamespace); [EOL] assertEquals(expectedFunctionClass, classFunctions.functionClass); [EOL] assertEquals(expectedNamespace, classFunctions.namespace); [EOL] }
public void testGetFunctionWithDifferentNamespace() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction("http://different.com", name, parameters); [EOL] assertNull(result); [EOL] } [EOL] public void testGetFunctionWithNullParameters() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Function result = getFunction(namespace, name, null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetFunctionWithNameNewAndConstructorExists() { [EOL] String namespace = "http://example.com"; [EOL] String name = "new"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ConstructorFunction); [EOL] } [EOL] public void testGetFunctionWithNameNewAndConstructorNotExists() { [EOL] String namespace = "http://example.com"; [EOL] String name = "new"; [EOL] Object[] parameters = new Object[]{"nonExistentConstructor"}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] } [EOL] public void testGetFunctionWithStaticMethodExists() { [EOL] String namespace = "http://example.com"; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] } [EOL] public void testGetFunctionWithStaticMethodNotExists() { [EOL] String namespace = "http://example.com"; [EOL] String name = "nonExistentMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] } [EOL] public void testGetFunctionWithInstanceMethodExists() { [EOL] String namespace = "http://example.com"; [EOL] String name = "instanceMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] } [EOL] public void testGetFunctionWithInstanceMethodNotExists() { [EOL] String namespace = "http://example.com"; [EOL] String name = "nonExistentMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testJDOMNamespacePointerWithNonNullParentAndPrefix() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String prefix = "testPrefix"; [EOL] String namespaceURI = "http://test.com"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(parent, prefix, namespaceURI); [EOL] assertNotNull(pointer); [EOL] assertEquals(prefix, pointer.getPrefix()); [EOL] assertEquals(namespaceURI, pointer.getNamespaceURI()); [EOL] assertEquals(parent, pointer.getParent()); [EOL] }
public void testJDOMNamespacePointerWithNullParent() { [EOL] String prefix = "testPrefix"; [EOL] String namespaceURI = "http://test.com"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(null, prefix, namespaceURI); [EOL] assertNotNull(pointer); [EOL] assertEquals(prefix, pointer.getPrefix()); [EOL] assertEquals(namespaceURI, pointer.getNamespaceURI()); [EOL] assertNull(pointer.getParent()); [EOL] }
public void testJDOMNamespacePointerWithEmptyPrefix() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String prefix = ""; [EOL] String namespaceURI = "http://test.com"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(parent, prefix, namespaceURI); [EOL] assertNotNull(pointer); [EOL] assertEquals(prefix, pointer.getPrefix()); [EOL] assertEquals(namespaceURI, pointer.getNamespaceURI()); [EOL] assertEquals(parent, pointer.getParent()); [EOL] }
public void testJDOMNamespacePointerWithNullPrefix() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String namespaceURI = "http://test.com"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(parent, null, namespaceURI); [EOL] assertNotNull(pointer); [EOL] assertNull(pointer.getPrefix()); [EOL] assertEquals(namespaceURI, pointer.getNamespaceURI()); [EOL] assertEquals(parent, pointer.getParent()); [EOL] }
public void testJDOMNamespacePointerWithNullNamespaceURI() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] String prefix = "testPrefix"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(parent, prefix, null); [EOL] assertNotNull(pointer); [EOL] assertEquals(prefix, pointer.getPrefix()); [EOL] assertNull(pointer.getNamespaceURI()); [EOL] assertEquals(parent, pointer.getParent()); [EOL] }
public void testDOMNodeIteratorWithNonNullStartWith() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Node node = mock(Node.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] Node startNode = mock(Node.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(startWith.getNode()).thenReturn(startNode); [EOL] DOMNodeIterator iterator = new DOMNodeIterator(parent, nodeTest, false, startWith); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(node, iterator.node); [EOL] assertEquals(startNode, iterator.child); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testDOMNodeIteratorWithNullStartWith() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Node node = mock(Node.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] DOMNodeIterator iterator = new DOMNodeIterator(parent, nodeTest, true, null); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(node, iterator.node); [EOL] assertNull(iterator.child); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertTrue(iterator.reverse); [EOL] }
private boolean next() { [EOL] position++; [EOL] if (!reverse) { [EOL] if (position == 1) { [EOL] if (child == null) { [EOL] child = node.getFirstChild(); [EOL] } else { [EOL] child = child.getNextSibling(); [EOL] } [EOL] } else { [EOL] child = child.getNextSibling(); [EOL] } [EOL] while (child != null && !testChild()) { [EOL] child = child.getNextSibling(); [EOL] } [EOL] } else { [EOL] if (position == 1) { [EOL] if (child == null) { [EOL] child = node.getLastChild(); [EOL] } else { [EOL] child = child.getPreviousSibling(); [EOL] } [EOL] } else { [EOL] child = child.getPreviousSibling(); [EOL] } [EOL] while (child != null && !testChild()) { [EOL] child = child.getPreviousSibling(); [EOL] } [EOL] } [EOL] return child != null; [EOL] }
public void testLookupConstructorWithExactMatch() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { "stringParam", 123 }; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNotNull(constructor); [EOL] assertEquals(2, constructor.getParameterTypes().length); [EOL] assertEquals(String.class, constructor.getParameterTypes()[0]); [EOL] assertEquals(Integer.class, constructor.getParameterTypes()[1]); [EOL] }
public void testLookupConstructorWithNullParameters() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = null; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNotNull(constructor); [EOL] assertEquals(0, constructor.getParameterTypes().length); [EOL] }
public void testLookupConstructorWithSomeNullParameters() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { null, 123 }; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNotNull(constructor); [EOL] assertEquals(1, constructor.getParameterTypes().length); [EOL] assertEquals(Integer.class, constructor.getParameterTypes()[0]); [EOL] }
public void testLookupConstructorWithAmbiguousMatch() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { "stringParam", "anotherStringParam" }; [EOL] try { [EOL] jxPath.lookupConstructor(targetClass, parameters); [EOL] fail("Expected JXPathException due to ambiguous constructor match"); [EOL] } catch (JXPathException ex) { [EOL] } [EOL] }
public void testLookupConstructorWithNoMatch() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { new Object(), new Object() }; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNull(constructor); [EOL] }
public void testMatchParameterTypesWithExpressionContextFirst() { [EOL] Class[] types = new Class[] {ExpressionContext.class, String.class}; [EOL] Object[] parameters = new Object[] {"test"}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchParameterTypesWithoutExpressionContextFirst() { [EOL] Class[] types = new Class[] {String.class, Integer.class}; [EOL] Object[] parameters = new Object[] {"test", 123}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchParameterTypesWithMismatchingLength() { [EOL] Class[] types = new Class[] {String.class}; [EOL] Object[] parameters = new Object[] {"test", 123}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchParameterTypesWithNullParameters() { [EOL] Class[] types = new Class[] {String.class}; [EOL] Object[] parameters = null; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchParameterTypesWithNoMatch() { [EOL] Class[] types = new Class[] {String.class}; [EOL] Object[] parameters = new Object[] {123}; // Assuming matchType would return NO_MATCH for this case [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testGetName_WithPrefixAndLocalName() { [EOL] Attr attr = mock(Attr.class); [EOL] when(attr.getPrefix()).thenReturn("prefix"); [EOL] when(attr.getLocalName()).thenReturn("localName"); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(attr, null); [EOL] QName result = domNodePointer.getName(); [EOL] assertEquals("prefix", result.getPrefix()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetName_WithNullPrefix() { [EOL] Attr attr = mock(Attr.class); [EOL] when(attr.getPrefix()).thenReturn(null); [EOL] when(attr.getLocalName()).thenReturn("localName"); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(attr, null); [EOL] QName result = domNodePointer.getName(); [EOL] assertNull(result.getPrefix()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testRemove_AttributeExists() { [EOL] Element ownerElementMock = mock(Element.class); [EOL] Attr attrMock = mock(Attr.class); [EOL] when(attrMock.getOwnerElement()).thenReturn(ownerElementMock); [EOL] MyClass myClassInstance = new MyClass(attrMock); [EOL] myClassInstance.remove(); [EOL] verify(ownerElementMock).removeAttributeNode(attrMock); [EOL] }
public void testRemove_AttributeDoesNotExist() { [EOL] Element ownerElementMock = mock(Element.class); [EOL] Attr attrMock = mock(Attr.class); [EOL] when(attrMock.getOwnerElement()).thenReturn(null); [EOL] MyClass myClassInstance = new MyClass(attrMock); [EOL] myClassInstance.remove(); [EOL] verify(ownerElementMock, never()).removeAttributeNode(attrMock); [EOL] }
public void testAsPathWithParent() { [EOL] Node parent = new Node("parent"); [EOL] Node child = new Node("child"); [EOL] child.setParent(parent); [EOL] String result = child.asPath(); [EOL] assertEquals("/parent/@child", result); [EOL] }
public void testAsPathWithoutParent() { [EOL] Node node = new Node("node"); [EOL] String result = node.asPath(); [EOL] assertEquals("@node", result); [EOL] }
public void testAsPathWithParentAndTrailingSlash() { [EOL] Node parent = new Node("parent/"); [EOL] Node child = new Node("child"); [EOL] child.setParent(parent); [EOL] String result = child.asPath(); [EOL] assertEquals("/parent/@child", result); [EOL] }
public void testPrepareWithNullParent() { [EOL] parentContext.setCurrentNodePointer(null); [EOL] prepare(); [EOL] assertNull(iterator); [EOL] }
public void testPrepareWithNonNullParentAndStartFromParentLocationTrue() { [EOL] NodePointer mockParent = createMockParent(); [EOL] parentContext.setCurrentNodePointer(mockParent); [EOL] when(mockParent.getParent()).thenReturn(mockParent); // Assuming a mock framework is used [EOL] startFromParentLocation = true; [EOL] prepare(); [EOL] assertNotNull(iterator); [EOL] verify(mockParent).childIterator(nodeTest, reverse, mockParent); [EOL] }
public void testPrepareWithNonNullParentAndStartFromParentLocationFalse() { [EOL] NodePointer mockParent = createMockParent(); [EOL] parentContext.setCurrentNodePointer(mockParent); [EOL] startFromParentLocation = false; [EOL] prepare(); [EOL] assertNotNull(iterator); [EOL] verify(mockParent).childIterator(nodeTest, reverse, null); [EOL] }
public void testCreateNodePointerWithNode() { [EOL] QName name = new QName("test"); [EOL] Node node = mock(Node.class); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, node, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodePointer); [EOL] }
public void testCreateNodePointerWithNonNode() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNull(result); [EOL] }
private boolean testAttr(Attr attr, QName testName) { [EOL] String nodePrefix = DOMNodePointer.getPrefix(attr); [EOL] String nodeLocalName = DOMNodePointer.getLocalName(attr); [EOL] if (nodePrefix != null && nodePrefix.equals("xmlns")) { [EOL] return false; [EOL] } [EOL] if (nodePrefix == null && nodeLocalName.equals("xmlns")) { [EOL] return false; [EOL] } [EOL] String testLocalName = testName.getName(); [EOL] if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { [EOL] String testPrefix = testName.getPrefix(); [EOL] if (equalStrings(testPrefix, nodePrefix)) { [EOL] return true; [EOL] } [EOL] String testNS = null; [EOL] if (testPrefix != null) { [EOL] testNS = parent.getNamespaceURI(testPrefix); [EOL] } [EOL] String nodeNS = null; [EOL] if (nodePrefix != null) { [EOL] nodeNS = parent.getNamespaceURI(nodePrefix); [EOL] } [EOL] return equalStrings(testNS, nodeNS); [EOL] } [EOL] return false; [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespace() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] Attr mockAttr = mock(Attr.class); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespace"); [EOL] when(mockElement.getAttributeNodeNS("namespace", "localName")).thenReturn(mockAttr); [EOL] when(mockQName.getName()).thenReturn("localName"); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNonNullPrefixButNullNamespace() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] Attr mockAttr = mock(Attr.class); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn(null); [EOL] when(mockElement.getAttributeNode("localName")).thenReturn(mockAttr); [EOL] when(mockQName.getName()).thenReturn("localName"); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNullPrefix() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn(null); [EOL] when(mockQName.getName()).thenReturn("localName"); [EOL] when(mockElement.getAttributeNode("localName")).thenReturn(null); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNull(result); [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespaceButNullAttr() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespace"); [EOL] when(mockElement.getAttributeNodeNS("namespace", "localName")).thenReturn(null); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(1); [EOL] when(mockNamedNodeMap.item(0)).thenReturn(mockAttr); [EOL] when(mockQName.getName()).thenReturn("localName"); [EOL] when(testAttr(mockAttr, mockQName)).thenReturn(true); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespaceButNoMatchingAttr() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespace"); [EOL] when(mockElement.getAttributeNodeNS("namespace", "localName")).thenReturn(null); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(1); [EOL] when(mockNamedNodeMap.item(0)).thenReturn(mockAttr); [EOL] when(mockQName.getName()).thenReturn("localName"); [EOL] when(testAttr(mockAttr, mockQName)).thenReturn(false); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNull(result); [EOL] }
public void testSetPropertyIndex_NewIndex() { [EOL] int newIndex = 1; [EOL] YourClass instance = new YourClass(); [EOL] instance.setPropertyIndex(newIndex); [EOL] assertEquals(newIndex, instance.propertyIndex); [EOL] assertEquals(YourClass.WHOLE_COLLECTION, instance.getIndex()); [EOL] }
public void testSetPropertyIndex_SameIndex() { [EOL] int index = 0; [EOL] YourClass instance = new YourClass(); [EOL] instance.setPropertyIndex(index); [EOL] instance.setPropertyIndex(index); [EOL] assertEquals(index, instance.propertyIndex); [EOL] }
public void testIsCollection_BaseValueNull() { [EOL] when(getBaseValue()).thenReturn(null); // Mocking getBaseValue to return null [EOL] boolean result = isCollection(); [EOL] assertFalse(result); [EOL] }
public void testIsCollection_BaseValueIsCollection() { [EOL] Object collectionValue = new ArrayList<>(); // Assuming ValueUtils.isCollection() would return true for a collection [EOL] when(getBaseValue()).thenReturn(collectionValue); // Mocking getBaseValue to return a collection [EOL] boolean result = isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollection_BaseValueIsNotCollection() { [EOL] Object nonCollectionValue = new Object(); // Assuming ValueUtils.isCollection() would return false for a non-collection [EOL] when(getBaseValue()).thenReturn(nonCollectionValue); // Mocking getBaseValue to return a non-collection [EOL] boolean result = isCollection(); [EOL] assertFalse(result); [EOL] }
public int testGetLength_BaseValueNull() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] int expected = 0; [EOL] int actual = context.getLength(); [EOL] assertEquals(expected, actual); [EOL] }
public int testGetLength_BaseValueNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] int expected = ValueUtils.getLength(context.getBaseValue()); [EOL] int actual = context.getLength(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCreatePathWithNullNode() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] TestNodePointer testNodePointer = new TestNodePointer(null); [EOL] AbstractFactory factory = Mockito.mock(AbstractFactory.class); [EOL] Mockito.when(factory.createObject(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any(), Mockito.anyInt())).thenReturn(true); [EOL] testNodePointer.setAbstractFactory(factory); [EOL] NodePointer result = testNodePointer.createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] assertSame("Expected createPath to return 'this'", testNodePointer, result); [EOL] }
public void testCreatePathWithNonNullNode() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object node = new Object(); [EOL] TestNodePointer testNodePointer = new TestNodePointer(node); [EOL] NodePointer result = testNodePointer.createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] assertSame("Expected createPath to return 'this'", testNodePointer, result); [EOL] }
public void testCreatePathWithFactoryFailure() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] TestNodePointer testNodePointer = new TestNodePointer(null); [EOL] AbstractFactory factory = Mockito.mock(AbstractFactory.class); [EOL] Mockito.when(factory.createObject(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any(), Mockito.anyInt())).thenReturn(false); [EOL] testNodePointer.setAbstractFactory(factory); [EOL] try { [EOL] testNodePointer.createPath(context); [EOL] fail("Expected JXPathAbstractFactoryException to be thrown"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] String expectedMessage = "Factory " + factory + " could not create an object for path: " + testNodePointer.asPath(); [EOL] assertEquals("Exception message mismatch", expectedMessage, e.getMessage()); [EOL] } [EOL] }
public void testCreatePathWithIndexNotWholeCollectionAndIndexGreater() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new ConcreteNodePointer(); [EOL] nodePointer.index = nodePointer.getLength() + 1; // index greater than length [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, nodePointer.getValue()); [EOL] } [EOL] public void testCreatePathWithIndexNotWholeCollectionAndIndexEqual() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new ConcreteNodePointer(); [EOL] nodePointer.index = nodePointer.getLength(); // index equal to length [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, nodePointer.getValue()); [EOL] } [EOL] public void testCreatePathWithIndexWholeCollection() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new ConcreteNodePointer(); [EOL] nodePointer.index = NodePointer.WHOLE_COLLECTION; [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, nodePointer.getValue()); [EOL] }
public void testCreateChildWithNameAndValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = new QName("testName"); [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new PropertyPointer(); // Assuming PropertyPointer is a valid subclass of NodePointer [EOL] NodePointer result = nodePointer.createChild(context, name, index, value); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyPointer); [EOL] assertEquals("testName", ((PropertyPointer) result).getPropertyName()); [EOL] assertEquals(index, ((PropertyPointer) result).getIndex()); [EOL] }
public void testCreateChildWithNullName() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = null; [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new PropertyPointer(); // Assuming PropertyPointer is a valid subclass of NodePointer [EOL] NodePointer result = nodePointer.createChild(context, name, index, value); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyPointer); [EOL] assertNull(((PropertyPointer) result).getPropertyName()); [EOL] assertEquals(index, ((PropertyPointer) result).getIndex()); [EOL] }
public void testCreateChildWithNonNullName() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = new QName("testNamespace", "testName"); [EOL] int index = 1; [EOL] NodePointer testNodePointer = new TestNodePointer(); [EOL] NodePointer result = testNodePointer.createChild(context, name, index); [EOL] assertNotNull("Result should not be null", result); [EOL] assertTrue("Result should be instance of PropertyPointer", result instanceof PropertyPointer); [EOL] assertEquals("Property name should be set to 'testNamespace:testName'", "testNamespace:testName", ((PropertyPointer) result).getPropertyName()); [EOL] assertEquals("Index should be set to 1", 1, ((PropertyPointer) result).getIndex()); [EOL] }
public void testCreateChildWithNullName() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = null; [EOL] int index = 1; [EOL] NodePointer testNodePointer = new TestNodePointer(); [EOL] NodePointer result = testNodePointer.createChild(context, name, index); [EOL] assertNotNull("Result should not be null", result); [EOL] assertTrue("Result should be instance of PropertyPointer", result instanceof PropertyPointer); [EOL] assertNull("Property name should be null", ((PropertyPointer) result).getPropertyName()); [EOL] assertEquals("Index should be set to 1", 1, ((PropertyPointer) result).getIndex()); [EOL] }
public void testGetAbstractFactoryWithNonNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] AbstractFactory expectedFactory = new AbstractFactory() { [EOL] }; [EOL] context.setFactory(expectedFactory); [EOL] AbstractFactory resultFactory = getAbstractFactory(context); [EOL] assertEquals("Expected factory should be returned", expectedFactory, resultFactory); [EOL] } [EOL] public void testGetAbstractFactoryWithNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] try { [EOL] getAbstractFactory(context); [EOL] fail("JXPathException should be thrown when factory is null"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Factory is not set on the JXPathContext - cannot create path: /", e.getMessage()); [EOL] } [EOL] }
public void testCoreOperationAddWithNoArgs() { [EOL] Expression[] args = new Expression[0]; [EOL] CoreOperationAdd operationAdd = new CoreOperationAdd(args); [EOL] assertNotNull(operationAdd); [EOL] }
public void testCoreOperationAddWithOneArg() { [EOL] Expression[] args = new Expression[1]; [EOL] args[0] = mock(Expression.class); [EOL] CoreOperationAdd operationAdd = new CoreOperationAdd(args); [EOL] assertNotNull(operationAdd); [EOL] }
public void testCoreOperationAddWithMultipleArgs() { [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] CoreOperationAdd operationAdd = new CoreOperationAdd(args); [EOL] assertNotNull(operationAdd); [EOL] }
public void testComputeValueWithEmptyArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[0]; [EOL] MyClass myClass = new MyClass(args); // Assuming MyClass is the class where computeValue is defined [EOL] Object result = myClass.computeValue(context); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(0.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testComputeValueWithSingleArg() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[]{mock(MyArgClass.class)}; // Assuming MyArgClass has a method computeValue [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(10.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testComputeValueWithMultipleArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[]{mock(MyArgClass.class), mock(MyArgClass.class)}; [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(20.0); [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(30.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 4; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
public String getSymbol() { [EOL] return "+"; [EOL] }
public void testCreateNodePointerWithContainer() { [EOL] QName name = new QName("test"); [EOL] Container container = new Container(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, container, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ContainerPointer); [EOL] }
public void testCreateNodePointerWithNonContainer() { [EOL] QName name = new QName("test"); [EOL] Object nonContainerBean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, nonContainerBean, locale); [EOL] assertNull(result); [EOL] }
public void testLangAttributePointerWithNonNullParent() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] LangAttributePointer pointer = new LangAttributePointer(parent); [EOL] assertNotNull(pointer.getParent()); [EOL] }
public void testGetBaseValueWithNonNullParentAndLocale() { [EOL] Parent parentMock = mock(Parent.class); [EOL] Locale locale = new Locale("en", "US"); [EOL] when(parentMock.getLocale()).thenReturn(locale); [EOL] MyClass myClassInstance = new MyClass(parentMock); [EOL] Object result = myClassInstance.getBaseValue(); [EOL] assertEquals("en-US", result); [EOL] }
public void testGetBaseValueWithNullParent() { [EOL] Parent parentMock = mock(Parent.class); [EOL] when(parentMock.getLocale()).thenReturn(null); [EOL] MyClass myClassInstance = new MyClass(parentMock); [EOL] Object result = myClassInstance.getBaseValue(); [EOL] assertNull(result); [EOL] }
public Object getImmediateNode() { [EOL] return getBaseValue(); [EOL] }
public void testCreateNodePointerWithDynaBean() { [EOL] QName name = new QName("test"); [EOL] Object bean = new MockDynaBean(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertTrue(result instanceof DynaBeanPointer); [EOL] }
public void testCreateNodePointerWithNonDynaBean() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); // Assuming Object is not an instance of DynaBean [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNull(result); [EOL] }
public void testCreateNodePointerWithCollection() { [EOL] QName name = new QName("test"); [EOL] Object bean = new ArrayList(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertTrue(result instanceof CollectionPointer); [EOL] }
public void testCreateNodePointerWithNonCollection() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNull(result); [EOL] }
public void testJXPathContextReferenceImplWithNonNullContextPointer() { [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] Object contextBean = new Object(); [EOL] Pointer contextPointer = mock(Pointer.class); [EOL] when(contextPointer.getRootNode()).thenReturn(new Object()); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer); [EOL] assertNotNull(contextReference); [EOL] assertSame(contextPointer, contextReference.contextPointer); [EOL] assertNotNull(contextReference.rootPointer); [EOL] }
public void testJXPathContextReferenceImplWithNullContextPointer() { [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] Object contextBean = new Object(); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, null); [EOL] assertNotNull(contextReference); [EOL] assertNotNull(contextReference.contextPointer); [EOL] assertSame(contextReference.contextPointer, contextReference.rootPointer); [EOL] }
public void testJXPathContextReferenceImplWithParentContextBeingJXPathContextReferenceImpl() { [EOL] JXPathContextReferenceImpl parentContext = mock(JXPathContextReferenceImpl.class); [EOL] NamespaceResolver namespaceResolver = new NamespaceResolver(); [EOL] when(parentContext.getNamespaceResolver()).thenReturn(namespaceResolver); [EOL] Object contextBean = new Object(); [EOL] Pointer contextPointer = mock(Pointer.class); [EOL] when(contextPointer.getRootNode()).thenReturn(new Object()); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer); [EOL] assertNotNull(contextReference); [EOL] assertNotNull(contextReference.namespaceResolver); [EOL] assertSame(namespaceResolver, contextReference.namespaceResolver.getParent()); [EOL] }
public void testCreateNodeFactoryArray_WhenArrayIsNull() { [EOL] JXPathContext.nodeFactoryArray = null; [EOL] JXPathContext.nodeFactories.clear(); [EOL] NodePointerFactory factory1 = mock(NodePointerFactory.class); [EOL] when(factory1.getOrder()).thenReturn(1); [EOL] NodePointerFactory factory2 = mock(NodePointerFactory.class); [EOL] when(factory2.getOrder()).thenReturn(2); [EOL] JXPathContext.nodeFactories.add(factory1); [EOL] JXPathContext.nodeFactories.add(factory2); [EOL] JXPathContext.createNodeFactoryArray(); [EOL] assertNotNull("nodeFactoryArray should not be null", JXPathContext.nodeFactoryArray); [EOL] assertEquals("nodeFactoryArray should have the same size as nodeFactories", [EOL] JXPathContext.nodeFactories.size(), JXPathContext.nodeFactoryArray.length); [EOL] assertEquals("The first element should be factory1", factory1, JXPathContext.nodeFactoryArray[0]); [EOL] assertEquals("The second element should be factory2", factory2, JXPathContext.nodeFactoryArray[1]); [EOL] }
public void testCreateNodeFactoryArray_WhenArrayIsNotNull() { [EOL] NodePointerFactory[] preInitializedArray = new NodePointerFactory[]{}; [EOL] JXPathContext.nodeFactoryArray = preInitializedArray; [EOL] JXPathContext.createNodeFactoryArray(); [EOL] assertSame("nodeFactoryArray should not be re-initialized", [EOL] preInitializedArray, JXPathContext.nodeFactoryArray); [EOL] }
public void testGetCompiler() { [EOL] assertNotNull("Compiler should not be null", instance.getCompiler()); [EOL] }
public void testCompilePathWithValidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String validXPath = "/valid/xpath"; [EOL] CompiledExpression expression = context.compilePath(validXPath); [EOL] assertNotNull("CompiledExpression should not be null", expression); [EOL] assertTrue("CompiledExpression should be instance of JXPathCompiledExpression", [EOL] expression instanceof JXPathCompiledExpression); [EOL] assertEquals("CompiledExpression xpath should match input xpath", validXPath, [EOL] ((JXPathCompiledExpression) expression).getXPath()); [EOL] }

private Expression compileExpression(String xpath) { [EOL] Expression expr; [EOL] synchronized (compiled) { [EOL] if (USE_SOFT_CACHE) { [EOL] expr = null; [EOL] SoftReference ref = (SoftReference) compiled.get(xpath); [EOL] if (ref != null) { [EOL] expr = (Expression) ref.get(); [EOL] } [EOL] } else { [EOL] expr = (Expression) compiled.get(xpath); [EOL] } [EOL] } [EOL] if (expr != null) { [EOL] return expr; [EOL] } [EOL] expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL] synchronized (compiled) { [EOL] if (USE_SOFT_CACHE) { [EOL] if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL] Iterator it = compiled.entrySet().iterator(); [EOL] while (it.hasNext()) { [EOL] Entry me = (Entry) it.next(); [EOL] if (((SoftReference) me.getValue()).get() == null) { [EOL] it.remove(); [EOL] } [EOL] } [EOL] cleanupCount = 0; [EOL] } [EOL] compiled.put(xpath, new SoftReference(expr)); [EOL] } else { [EOL] compiled.put(xpath, expr); [EOL] } [EOL] } [EOL] return expr; [EOL] }
public void testSetValueWithValidXPathAndNonNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] String validXPath = "/valid/xpath"; [EOL] context.setValue(validXPath, value); [EOL] Object retrievedValue = context.getValue(validXPath); [EOL] assertEquals("The value should be set correctly", value, retrievedValue); [EOL] }
public void testSetValueWithValidXPathAndNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String validXPath = "/valid/xpath"; [EOL] context.setValue(validXPath, null); [EOL] Object retrievedValue = context.getValue(validXPath); [EOL] assertNull("The value should be set to null", retrievedValue); [EOL] }
public void testSetValueWithInvalidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] String invalidXPath = "/invalid/xpath"; [EOL] try { [EOL] context.setValue(invalidXPath, value); [EOL] fail("An exception should be thrown for an invalid XPath"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testSetValueWithValidArguments() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] } catch (JXPathException e) { [EOL] fail("Should not have thrown an exception with valid arguments"); [EOL] } [EOL] }
public void testSetValueWithInvalidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/invalid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] fail("Should have thrown a JXPathException due to invalid XPath"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testSetValueWithNullXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = null; [EOL] Expression expr = context.compile("/valid/xpath"); [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] fail("Should have thrown a JXPathException due to null XPath"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testSetValueWithNullExpression() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = null; [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] fail("Should have thrown a JXPathException due to null Expression"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testSetValueWithNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Object value = null; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] } catch (JXPathException e) { [EOL] fail("Should not have thrown an exception with null value"); [EOL] } [EOL] }
public void testCreatePathAndSetValueWithValidInput() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Object value = "New Value"; [EOL] Pointer result = context.createPathAndSetValue(xpath, value); [EOL] assertNotNull(result); [EOL] assertEquals("New Value", result.getValue()); [EOL] }
public void testCreatePathAndSetValueWithInvalidInput() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/invalid/xpath"; [EOL] Object value = "New Value"; [EOL] try { [EOL] context.createPathAndSetValue(xpath, value); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testCreatePathAndSetValueSuccess() { [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] Pointer result = jxPath.createPathAndSetValue(xpath, expr, value); [EOL] assertNotNull(result); [EOL] }
public void testCreatePathAndSetValueWithException() { [EOL] String xpath = "/invalid/xpath"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] try { [EOL] jxPath.createPathAndSetValue(xpath, expr, value); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException ex) { [EOL] assertEquals("Exception trying to create xpath " + xpath, ex.getMessage()); [EOL] assertNotNull(ex.getCause()); [EOL] } [EOL] }
public void testSetValueWithPointerResultAndCreateTrue() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = true; [EOL] Pointer mockPointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(mockPointer); [EOL] when(mockPointer.createPath(any(JXPathContext.class), eq(value))).thenReturn(mockPointer); [EOL] Pointer result = setValue(xpath, expr, value, create); [EOL] assertNotNull(result); [EOL] verify(mockPointer).createPath(any(JXPathContext.class), eq(value)); [EOL] }
public void testSetValueWithPointerResultAndCreateFalse() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = false; [EOL] Pointer mockPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(mockPointer); [EOL] Pointer result = setValue(xpath, expr, value, create); [EOL] assertNotNull(result); [EOL] verify(mockPointer).setValue(value); [EOL] }
public void testSetValueWithEvalContextResult() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = false; [EOL] EvalContext mockEvalContext = mock(EvalContext.class); [EOL] Pointer mockPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(mockEvalContext); [EOL] when(mockEvalContext.getSingleNodePointer()).thenReturn(mockPointer); [EOL] Pointer result = setValue(xpath, expr, value, create); [EOL] assertNotNull(result); [EOL] verify(mockEvalContext).getSingleNodePointer(); [EOL] verify(mockPointer).setValue(value); [EOL] }
public void testSetValueWithNonPointerNonEvalContextResultAndCreateTrue() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = true; [EOL] Object nonPointerResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nonPointerResult); [EOL] try { [EOL] setValue(xpath, expr, value, create); [EOL] fail("Expected JXPathException was not thrown."); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot set value for xpath: " + xpath, e.getMessage()); [EOL] } [EOL] }
public void testSetValueWithNonPointerNonEvalContextResultAndCreateFalse() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = false; [EOL] Object nonPointerResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nonPointerResult); [EOL] try { [EOL] setValue(xpath, expr, value, create); [EOL] fail("Expected JXPathException was not thrown."); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot set value for xpath: " + xpath, e.getMessage()); [EOL] } [EOL] }
public void testGetRelativeContextWithNonNullNode() { [EOL] Pointer mockPointer = mock(Pointer.class); [EOL] Object node = new Object(); [EOL] when(mockPointer.getNode()).thenReturn(node); [EOL] JXPathContext context = jxPathContext.getRelativeContext(mockPointer); [EOL] assertNotNull("Context should not be null", context); [EOL] assertTrue("Context should be instance of JXPathContextReferenceImpl", context instanceof JXPathContextReferenceImpl); [EOL] }
public void testGetRelativeContextWithNullNode() { [EOL] Pointer mockPointer = mock(Pointer.class); [EOL] when(mockPointer.getNode()).thenReturn(null); [EOL] try { [EOL] jxPathContext.getRelativeContext(mockPointer); [EOL] fail("JXPathException expected for null node"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot create a relative context for a non-existent node: " + mockPointer, e.getMessage()); [EOL] } [EOL] }
public void testGetVariablePointerWithDeclaredVariable() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("testVar", "testValue"); [EOL] NodePointer result = context.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertEquals("testValue", result.getValue()); [EOL] }
public void testGetVariablePointerWithUndeclaredVariable() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NodePointer result = context.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertNull(result.getValue()); [EOL] }
public void testGetVariablePointerWithNestedContexts() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] parentContext.getVariables().declareVariable("testVar", "parentValue"); [EOL] childContext.getVariables().declareVariable("testVar", "childValue"); [EOL] NodePointer result = childContext.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertEquals("childValue", result.getValue()); [EOL] }
public void testGetVariablePointerWithNestedContextsUndeclared() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] parentContext.getVariables().declareVariable("testVar", "parentValue"); [EOL] NodePointer result = childContext.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertEquals("parentValue", result.getValue()); [EOL] }
public void testGetFunctionWithValidFunction() { [EOL] QName functionName = new QName("http://example.com", "testFunction"); [EOL] Object[] parameters = new Object[]{}; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Functions mockFunctions = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(mockFunctions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(expectedFunction); [EOL] context.setFunctions(mockFunctions); [EOL] Function result = context.getFunction(functionName, parameters); [EOL] assertNotNull(result); [EOL] assertSame(expectedFunction, result); [EOL] }
public void testGetFunctionWithFunctionNotFound() { [EOL] QName functionName = new QName("http://example.com", "nonExistentFunction"); [EOL] Object[] parameters = new Object[]{}; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Functions mockFunctions = mock(Functions.class); [EOL] when(mockFunctions.getFunction("http://example.com", "nonExistentFunction", parameters)).thenReturn(null); [EOL] context.setFunctions(mockFunctions); [EOL] try { [EOL] context.getFunction(functionName, parameters); [EOL] fail("JXPathFunctionNotFoundException expected"); [EOL] } catch (JXPathFunctionNotFoundException e) { [EOL] assertEquals("Undefined function: " + functionName.toString(), e.getMessage()); [EOL] } [EOL] }
public void testGetFunctionWithParentContext() { [EOL] QName functionName = new QName("http://example.com", "testFunction"); [EOL] Object[] parameters = new Object[]{}; [EOL] JXPathContext childContext = JXPathContext.newContext(null); [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] childContext.setParentContext(parentContext); [EOL] Functions mockChildFunctions = mock(Functions.class); [EOL] Functions mockParentFunctions = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(mockChildFunctions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(null); [EOL] when(mockParentFunctions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(expectedFunction); [EOL] childContext.setFunctions(mockChildFunctions); [EOL] parentContext.setFunctions(mockParentFunctions); [EOL] Function result = childContext.getFunction(functionName, parameters); [EOL] assertNotNull(result); [EOL] assertSame(expectedFunction, result); [EOL] }
public void testGetDefaultNamespaceURI_WithNonNullDefaultNamespaceURI() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setDefaultNamespaceURI("http://example.com"); [EOL] String result = context.getDefaultNamespaceURI(); [EOL] assertEquals("http://example.com", result); [EOL] } [EOL] public void testGetDefaultNamespaceURI_WithNullDefaultNamespaceURIAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] parentContext.setDefaultNamespaceURI("http://parent.com"); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] String result = childContext.getDefaultNamespaceURI(); [EOL] assertEquals("http://parent.com", result); [EOL] } [EOL] public void testGetDefaultNamespaceURI_WithNullDefaultNamespaceURIAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String result = context.getDefaultNamespaceURI(); [EOL] assertNull(result); [EOL] }
public void testParseExpressionValid() { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] String validExpression = "/valid/xpath/expression"; [EOL] Object expectedExpr = new Object(); [EOL] JxPathParser parser = new JxPathParser(new StringReader("")); [EOL] parser.setCompiler(mockCompiler); [EOL] when(parser.parseExpression()).thenReturn(expectedExpr); [EOL] Object result = JxPath.parseExpression(validExpression, mockCompiler); [EOL] assertNotNull(result); [EOL] assertEquals(expectedExpr, result); [EOL] }
public void testParseExpressionWithTokenMgrError() { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] String invalidExpression = "/invalid/xpath/expression"; [EOL] JxPathParser parser = new JxPathParser(new StringReader("")); [EOL] parser.setCompiler(mockCompiler); [EOL] when(parser.parseExpression()).thenThrow(new TokenMgrError("Error", TokenMgrError.LEXICAL_ERROR)); [EOL] try { [EOL] JxPath.parseExpression(invalidExpression, mockCompiler); [EOL] fail("JXPathInvalidSyntaxException expected"); [EOL] } catch (JXPathInvalidSyntaxException e) { [EOL] } [EOL] }
public void testParseExpressionWithParseException() { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] String invalidExpression = "/invalid/xpath/expression"; [EOL] JxPathParser parser = new JxPathParser(new StringReader("")); [EOL] parser.setCompiler(mockCompiler); [EOL] when(parser.parseExpression()).thenThrow(new ParseException("Error")); [EOL] try { [EOL] JxPath.parseExpression(invalidExpression, mockCompiler); [EOL] fail("JXPathInvalidSyntaxException expected"); [EOL] } catch (JXPathInvalidSyntaxException e) { [EOL] } [EOL] }
public void testGetValueWithNullDocumentAndNonNullXmlUrl() throws Exception { [EOL] }
public void testGetValueWithNullDocumentAndNullXmlUrl() { [EOL] }
public void testGetValueWithNonNullDocument() { [EOL] }
public void testGetValueWithNullDocumentAndXmlUrlThrowsException() throws Exception { [EOL] }
public void testOperationWithNullArgs() { [EOL] Operation operation = new Operation(null); [EOL] assertNull("Args should be null", operation.getArgs()); [EOL] }
public void testOperationWithEmptyArgs() { [EOL] Expression[] args = new Expression[0]; [EOL] Operation operation = new Operation(args); [EOL] assertEquals("Args should be empty", 0, operation.getArgs().length); [EOL] }
public void testOperationWithNonNullArgs() { [EOL] Expression[] args = new Expression[]{new Expression()}; [EOL] Operation operation = new Operation(args); [EOL] assertNotNull("Args should not be null", operation.getArgs()); [EOL] assertEquals("Args length should be 1", 1, operation.getArgs().length); [EOL] }
public void testComputeContextDependentWithNullArgs() { [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependentWithEmptyArgs() { [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependentWithAllArgsNotContextDependent() { [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependentWithOneArgContextDependent() { [EOL] boolean result = computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testNextWithReverseFalseAndPositionOneAndChildNotNull() { [EOL] position = 0; [EOL] reverse = false; [EOL] child = mockChild(); [EOL] children.add(child); [EOL] children.add(mockChild()); // Add another child to ensure the list has more than one element [EOL] boolean result = next(); [EOL] assertTrue(result); [EOL] assertEquals(children.indexOf(child) + 1, index); [EOL] }
public void testNextWithReverseFalseAndPositionGreaterThanOne() { [EOL] position = 2; [EOL] reverse = false; [EOL] children.add(mockChild()); [EOL] children.add(mockChild()); // Add another child to ensure the list has more than one element [EOL] boolean result = next(); [EOL] assertTrue(result); [EOL] assertEquals(1, index); [EOL] }
public void testNextWithReverseFalseAndNoChildren() { [EOL] position = 1; [EOL] reverse = false; [EOL] children.clear(); // Clear the list to simulate no children [EOL] boolean result = next(); [EOL] assertFalse(result); [EOL] }
public void testNextWithReverseTrueAndPositionOneAndChildNotNull() { [EOL] position = 0; [EOL] reverse = true; [EOL] child = mockChild(); [EOL] children.add(mockChild()); [EOL] children.add(child); // Add the child to ensure it's in the list [EOL] boolean result = next(); [EOL] assertTrue(result); [EOL] assertEquals(children.indexOf(child) - 1, index); [EOL] }
public void testNextWithReverseTrueAndPositionGreaterThanOne() { [EOL] position = 2; [EOL] reverse = true; [EOL] children.add(mockChild()); [EOL] children.add(mockChild()); // Add another child to ensure the list has more than one element [EOL] boolean result = next(); [EOL] assertTrue(result); [EOL] assertEquals(children.size() - 3, index); [EOL] }
public void testNextWithReverseTrueAndNoChildren() { [EOL] position = 1; [EOL] reverse = true; [EOL] children.clear(); // Clear the list to simulate no children [EOL] boolean result = next(); [EOL] assertFalse(result); [EOL] }
