public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
protected Object functionKey(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String key = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String value = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     JXPathContext jxpathContext = context.getJXPathContext(); [EOL]     NodePointer pointer = (NodePointer) jxpathContext.getContextPointer(); [EOL]     return pointer.getPointerByKey(jxpathContext, key, value); [EOL] }
protected Object functionKey(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String key = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String value = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     JXPathContext jxpathContext = context.getJXPathContext(); [EOL]     NodePointer pointer = (NodePointer) jxpathContext.getContextPointer(); [EOL]     return pointer.getPointerByKey(jxpathContext, key, value); [EOL] }
public DOMNamespaceIterator(NodePointer parent) { [EOL]     this.parent = parent; [EOL]     attributes = new ArrayList(); [EOL]     collectNamespaces(attributes, (Node) parent.getNode()); [EOL] }
public DOMNamespaceIterator(NodePointer parent) { [EOL]     this.parent = parent; [EOL]     attributes = new ArrayList(); [EOL]     collectNamespaces(attributes, (Node) parent.getNode()); [EOL] }
private void collectNamespaces(List attributes, Node node) { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent != null) { [EOL]         collectNamespaces(attributes, parent); [EOL]     } [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         NamedNodeMap map = node.getAttributes(); [EOL]         int count = map.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Attr attr = (Attr) map.item(i); [EOL]             String prefix = DOMNodePointer.getPrefix(attr); [EOL]             String name = DOMNodePointer.getLocalName(attr); [EOL]             if ((prefix != null && prefix.equals("xmlns")) || (prefix == null && name.equals("xmlns"))) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void collectNamespaces(List attributes, Node node) { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent != null) { [EOL]         collectNamespaces(attributes, parent); [EOL]     } [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         NamedNodeMap map = node.getAttributes(); [EOL]         int count = map.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Attr attr = (Attr) map.item(i); [EOL]             String prefix = DOMNodePointer.getPrefix(attr); [EOL]             String name = DOMNodePointer.getLocalName(attr); [EOL]             if ((prefix != null && prefix.equals("xmlns")) || (prefix == null && name.equals("xmlns"))) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void collectNamespaces(List attributes, Node node) { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent != null) { [EOL]         collectNamespaces(attributes, parent); [EOL]     } [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         NamedNodeMap map = node.getAttributes(); [EOL]         int count = map.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Attr attr = (Attr) map.item(i); [EOL]             String prefix = DOMNodePointer.getPrefix(attr); [EOL]             String name = DOMNodePointer.getLocalName(attr); [EOL]             if ((prefix != null && prefix.equals("xmlns")) || (prefix == null && name.equals("xmlns"))) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     String prefix = ""; [EOL]     Attr attr = (Attr) attributes.get(index); [EOL]     String name = attr.getPrefix(); [EOL]     if (name != null && name.equals("xmlns")) { [EOL]         prefix = DOMNodePointer.getLocalName(attr); [EOL]     } [EOL]     return new NamespacePointer(parent, prefix, attr.getValue()); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     String prefix = ""; [EOL]     Attr attr = (Attr) attributes.get(index); [EOL]     String name = attr.getPrefix(); [EOL]     if (name != null && name.equals("xmlns")) { [EOL]         prefix = DOMNodePointer.getLocalName(attr); [EOL]     } [EOL]     return new NamespacePointer(parent, prefix, attr.getValue()); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     String prefix = ""; [EOL]     Attr attr = (Attr) attributes.get(index); [EOL]     String name = attr.getPrefix(); [EOL]     if (name != null && name.equals("xmlns")) { [EOL]         prefix = DOMNodePointer.getLocalName(attr); [EOL]     } [EOL]     return new NamespacePointer(parent, prefix, attr.getValue()); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     String prefix = ""; [EOL]     Attr attr = (Attr) attributes.get(index); [EOL]     String name = attr.getPrefix(); [EOL]     if (name != null && name.equals("xmlns")) { [EOL]         prefix = DOMNodePointer.getLocalName(attr); [EOL]     } [EOL]     return new NamespacePointer(parent, prefix, attr.getValue()); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     String prefix = ""; [EOL]     Attr attr = (Attr) attributes.get(index); [EOL]     String name = attr.getPrefix(); [EOL]     if (name != null && name.equals("xmlns")) { [EOL]         prefix = DOMNodePointer.getLocalName(attr); [EOL]     } [EOL]     return new NamespacePointer(parent, prefix, attr.getValue()); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(name, bean, handler, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(name, bean, handler, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(parent, name, bean, handler); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(parent, name, bean, handler); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(parent, name, bean, handler); [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator namespaceIterator() { [EOL]     return new JDOMNamespaceIterator(this); [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node instanceof Text) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             ((Text) node).setText(string); [EOL]         } else { [EOL]             nodeParent(node).removeContent((Text) node); [EOL]         } [EOL]     } else { [EOL]         Element element = (Element) node; [EOL]         element.getContent().clear(); [EOL]         if (value instanceof Element) { [EOL]             Element valueElement = (Element) value; [EOL]             addContent(valueElement.getContent()); [EOL]         } else if (value instanceof Document) { [EOL]             Document valueDocument = (Document) value; [EOL]             addContent(valueDocument.getContent()); [EOL]         } else if (value instanceof Text || value instanceof CDATA) { [EOL]             String string = ((Text) value).getText(); [EOL]             element.addContent(new Text(string)); [EOL]         } else if (value instanceof ProcessingInstruction) { [EOL]             ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone(); [EOL]             element.addContent(pi); [EOL]         } else if (value instanceof Comment) { [EOL]             Comment comment = (Comment) ((Comment) value).clone(); [EOL]             element.addContent(comment); [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 element.addContent(new Text(string)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static String getPrefix(Object node) { [EOL]     if (node instanceof Element) { [EOL]         String prefix = ((Element) node).getNamespacePrefix(); [EOL]         return (prefix == null || prefix.equals("")) ? null : prefix; [EOL]     } else if (node instanceof Attribute) { [EOL]         String prefix = ((Attribute) node).getNamespacePrefix(); [EOL]         return (prefix == null || prefix.equals("")) ? null : prefix; [EOL]     } [EOL]     return null; [EOL] }
public static String getPrefix(Object node) { [EOL]     if (node instanceof Element) { [EOL]         String prefix = ((Element) node).getNamespacePrefix(); [EOL]         return (prefix == null || prefix.equals("")) ? null : prefix; [EOL]     } else if (node instanceof Attribute) { [EOL]         String prefix = ((Attribute) node).getNamespacePrefix(); [EOL]         return (prefix == null || prefix.equals("")) ? null : prefix; [EOL]     } [EOL]     return null; [EOL] }
public static String getPrefix(Object node) { [EOL]     if (node instanceof Element) { [EOL]         String prefix = ((Element) node).getNamespacePrefix(); [EOL]         return (prefix == null || prefix.equals("")) ? null : prefix; [EOL]     } else if (node instanceof Attribute) { [EOL]         String prefix = ((Attribute) node).getNamespacePrefix(); [EOL]         return (prefix == null || prefix.equals("")) ? null : prefix; [EOL]     } [EOL]     return null; [EOL] }
public static String getLocalName(Object node) { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getName(); [EOL]     } else if (node instanceof Attribute) { [EOL]         return ((Attribute) node).getName(); [EOL]     } [EOL]     return null; [EOL] }
public static String getLocalName(Object node) { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getName(); [EOL]     } else if (node instanceof Attribute) { [EOL]         return ((Attribute) node).getName(); [EOL]     } [EOL]     return null; [EOL] }
public static String getLocalName(Object node) { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getName(); [EOL]     } else if (node instanceof Attribute) { [EOL]         return ((Attribute) node).getName(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } [EOL]     boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index); [EOL]     if (success) { [EOL]         NodeTest nodeTest; [EOL]         String prefix = name.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getNamespaceURI(prefix) : context.getDefaultNamespaceURI(); [EOL]         nodeTest = new NodeNameTest(name, namespaceURI); [EOL]         NodeIterator it = childIterator(nodeTest, false, null); [EOL]         if (it != null && it.setPosition(index + 1)) { [EOL]             return it.getNodePointer(); [EOL]         } [EOL]     } [EOL]     throw new JXPathAbstractFactoryException("Factory could not create " + "a child node for path: " + asPath() + "/" + name + "[" + (index + 1) + "]"); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } [EOL]     boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index); [EOL]     if (success) { [EOL]         NodeTest nodeTest; [EOL]         String prefix = name.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getNamespaceURI(prefix) : context.getDefaultNamespaceURI(); [EOL]         nodeTest = new NodeNameTest(name, namespaceURI); [EOL]         NodeIterator it = childIterator(nodeTest, false, null); [EOL]         if (it != null && it.setPosition(index + 1)) { [EOL]             return it.getNodePointer(); [EOL]         } [EOL]     } [EOL]     throw new JXPathAbstractFactoryException("Factory could not create " + "a child node for path: " + asPath() + "/" + name + "[" + (index + 1) + "]"); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } [EOL]     boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index); [EOL]     if (success) { [EOL]         NodeTest nodeTest; [EOL]         String prefix = name.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getNamespaceURI(prefix) : context.getDefaultNamespaceURI(); [EOL]         nodeTest = new NodeNameTest(name, namespaceURI); [EOL]         NodeIterator it = childIterator(nodeTest, false, null); [EOL]         if (it != null && it.setPosition(index + 1)) { [EOL]             return it.getNodePointer(); [EOL]         } [EOL]     } [EOL]     throw new JXPathAbstractFactoryException("Factory could not create " + "a child node for path: " + asPath() + "/" + name + "[" + (index + 1) + "]"); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     NodePointer ptr = createChild(context, name, index); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     NodePointer ptr = createChild(context, name, index); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         Attribute attr = element.getAttribute(name.getName(), ns); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), "", ns); [EOL]         } [EOL]     } else { [EOL]         Attribute attr = element.getAttribute(name.getName()); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         Attribute attr = element.getAttribute(name.getName(), ns); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), "", ns); [EOL]         } [EOL]     } else { [EOL]         Attribute attr = element.getAttribute(name.getName()); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         Attribute attr = element.getAttribute(name.getName(), ns); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), "", ns); [EOL]         } [EOL]     } else { [EOL]         Attribute attr = element.getAttribute(name.getName()); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         Attribute attr = element.getAttribute(name.getName(), ns); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), "", ns); [EOL]         } [EOL]     } else { [EOL]         Attribute attr = element.getAttribute(name.getName()); [EOL]         if (attr == null) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public void remove() { [EOL]     Element parent = nodeParent(node); [EOL]     if (parent == null) { [EOL]         throw new JXPathException("Cannot remove root JDOM node"); [EOL]     } [EOL]     parent.getContent().remove(node); [EOL] }
public void remove() { [EOL]     Element parent = nodeParent(node); [EOL]     if (parent == null) { [EOL]         throw new JXPathException("Cannot remove root JDOM node"); [EOL]     } [EOL]     parent.getContent().remove(node); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     Element parent; [EOL]     if (node instanceof Text) { [EOL]         parent = (Element) ((Text) node).getParent(); [EOL]     } else { [EOL]         parent = (Element) ((CDATA) node).getParent(); [EOL]     } [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Text || child instanceof CDATA) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     Element parent; [EOL]     if (node instanceof Text) { [EOL]         parent = (Element) ((Text) node).getParent(); [EOL]     } else { [EOL]         parent = (Element) ((CDATA) node).getParent(); [EOL]     } [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Text || child instanceof CDATA) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     Element parent; [EOL]     if (node instanceof Text) { [EOL]         parent = (Element) ((Text) node).getParent(); [EOL]     } else { [EOL]         parent = (Element) ((CDATA) node).getParent(); [EOL]     } [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Text || child instanceof CDATA) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     Element parent; [EOL]     if (node instanceof Text) { [EOL]         parent = (Element) ((Text) node).getParent(); [EOL]     } else { [EOL]         parent = (Element) ((CDATA) node).getParent(); [EOL]     } [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Text || child instanceof CDATA) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
public void setCompiler(Compiler compiler) { [EOL]     this.compiler = compiler; [EOL] }
public void setCompiler(Compiler compiler) { [EOL]     this.compiler = compiler; [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object parseExpression() throws ParseException { [EOL]     Object ex; [EOL]     ex = Expression(); [EOL]     jj_consume_token(0); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object parseExpression() throws ParseException { [EOL]     Object ex; [EOL]     ex = Expression(); [EOL]     jj_consume_token(0); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public void NodeTest(ArrayList steps) throws ParseException { [EOL]     int axis; [EOL]     int type = -1; [EOL]     String instruction = null; [EOL]     Object name = null; [EOL]     Object s; [EOL]     Object p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 86: [EOL]         case 88: [EOL]             axis = AxisSpecifier(); [EOL]             if (jj_2_3(2147483647)) { [EOL]                 type = NodeType(); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(81); [EOL]             } else if (jj_2_4(2147483647)) { [EOL]                 jj_consume_token(PI); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(Literal); [EOL]                 instruction = unescape(token.image.substring(1, token.image.length() - 1)); [EOL]                 jj_consume_token(81); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                     case 88: [EOL]                         name = WildcardName(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[10] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case 82: [EOL]             jj_consume_token(82); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case 83: [EOL]             jj_consume_token(83); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[11] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     label_3: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[12] = jj_gen; [EOL]                 break label_3; [EOL]         } [EOL]         p = Predicate(); [EOL]         ps.add(p); [EOL]     } [EOL]     if (name != null) { [EOL]         s = compiler.nodeNameTest(name); [EOL]     } else if (instruction != null) { [EOL]         s = compiler.processingInstructionTest(instruction); [EOL]     } else { [EOL]         s = compiler.nodeTypeTest(type); [EOL]     } [EOL]     steps.add(compiler.step(axis, s, ps.toArray())); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object Expression() throws ParseException { [EOL]     Object ex; [EOL]     ex = OrExpr(); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnionExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = PathExpr(); [EOL]     label_5: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case UNION: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[20] = jj_gen; [EOL]                 break label_5; [EOL]         } [EOL]         jj_consume_token(UNION); [EOL]         r = PathExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.union(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnionExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = PathExpr(); [EOL]     label_5: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case UNION: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[20] = jj_gen; [EOL]                 break label_5; [EOL]         } [EOL]         jj_consume_token(UNION); [EOL]         r = PathExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.union(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object OrExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = AndExpr(); [EOL]     label_8: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[24] = jj_gen; [EOL]                 break label_8; [EOL]         } [EOL]         jj_consume_token(OR); [EOL]         r = AndExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.or(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AndExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = EqualityExpr(); [EOL]     label_9: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case AND: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[25] = jj_gen; [EOL]                 break label_9; [EOL]         } [EOL]         jj_consume_token(AND); [EOL]         r = EqualityExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.and(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AndExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = EqualityExpr(); [EOL]     label_9: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case AND: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[25] = jj_gen; [EOL]                 break label_9; [EOL]         } [EOL]         jj_consume_token(AND); [EOL]         r = EqualityExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.and(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AndExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = EqualityExpr(); [EOL]     label_9: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case AND: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[25] = jj_gen; [EOL]                 break label_9; [EOL]         } [EOL]         jj_consume_token(AND); [EOL]         r = EqualityExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.and(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object EqualityExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = RelationalExpr(); [EOL]     label_10: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]             case NEQ: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[26] = jj_gen; [EOL]                 break label_10; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]                 jj_consume_token(EQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.equal(ex, r); [EOL]                 break; [EOL]             case NEQ: [EOL]                 jj_consume_token(NEQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.notEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[27] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object EqualityExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = RelationalExpr(); [EOL]     label_10: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]             case NEQ: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[26] = jj_gen; [EOL]                 break label_10; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]                 jj_consume_token(EQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.equal(ex, r); [EOL]                 break; [EOL]             case NEQ: [EOL]                 jj_consume_token(NEQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.notEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[27] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object EqualityExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = RelationalExpr(); [EOL]     label_10: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]             case NEQ: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[26] = jj_gen; [EOL]                 break label_10; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]                 jj_consume_token(EQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.equal(ex, r); [EOL]                 break; [EOL]             case NEQ: [EOL]                 jj_consume_token(NEQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.notEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[27] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AdditiveExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = SubtractiveExpr(); [EOL]     label_12: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case PLUS: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[30] = jj_gen; [EOL]                 break label_12; [EOL]         } [EOL]         jj_consume_token(PLUS); [EOL]         r = SubtractiveExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.sum(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AdditiveExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = SubtractiveExpr(); [EOL]     label_12: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case PLUS: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[30] = jj_gen; [EOL]                 break label_12; [EOL]         } [EOL]         jj_consume_token(PLUS); [EOL]         r = SubtractiveExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.sum(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object SubtractiveExpr() throws ParseException { [EOL]     Object ex, r = null; [EOL]     ex = MultiplicativeExpr(); [EOL]     label_13: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MINUS: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[31] = jj_gen; [EOL]                 break label_13; [EOL]         } [EOL]         jj_consume_token(MINUS); [EOL]         r = MultiplicativeExpr(); [EOL]         ex = compiler.minus(ex, r); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object SubtractiveExpr() throws ParseException { [EOL]     Object ex, r = null; [EOL]     ex = MultiplicativeExpr(); [EOL]     label_13: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MINUS: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[31] = jj_gen; [EOL]                 break label_13; [EOL]         } [EOL]         jj_consume_token(MINUS); [EOL]         r = MultiplicativeExpr(); [EOL]         ex = compiler.minus(ex, r); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object MultiplicativeExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = UnaryExpr(); [EOL]     label_14: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MOD: [EOL]             case DIV: [EOL]             case 88: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[32] = jj_gen; [EOL]                 break label_14; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case 88: [EOL]                 jj_consume_token(88); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.multiply(ex, r); [EOL]                 break; [EOL]             case DIV: [EOL]                 jj_consume_token(DIV); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.divide(ex, r); [EOL]                 break; [EOL]             case MOD: [EOL]                 jj_consume_token(MOD); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.mod(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[33] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final private boolean jj_2_6(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_6(); [EOL]     jj_save(5, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_6(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_6(); [EOL]     jj_save(5, xla); [EOL]     return retval; [EOL] }
final private boolean jj_3R_18() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_62()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_63()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_64()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_65()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_66()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_67()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_68()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_69()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_70()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_71()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_72()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_73()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_74()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_75()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_76()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_77()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_78()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_79()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_80()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_81()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_82()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_83()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_84()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_85()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_86()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_87()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_88()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_89()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_90()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_91()) [EOL]                                                                                                                             return true; [EOL]                                                                                                                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_153() { [EOL]     if (jj_scan_token(86)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_153() { [EOL]     if (jj_scan_token(86)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_153() { [EOL]     if (jj_scan_token(86)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_32() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_32() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_32() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_31() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_31() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_31() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_28() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_28() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_28() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_147() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_147() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_147() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_102() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_55() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_55() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_55() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3_6() { [EOL]     if (jj_3R_19()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_6() { [EOL]     if (jj_3R_19()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_6() { [EOL]     if (jj_3R_19()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_90() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_90() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_90() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_95() { [EOL]     if (jj_scan_token(Number)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_94() { [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_94() { [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_94() { [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_92() { [EOL]     if (jj_3R_103()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_92() { [EOL]     if (jj_3R_103()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_92() { [EOL]     if (jj_3R_103()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_69() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_69() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_69() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
public void ReInit(java.io.Reader stream) { [EOL]     jj_input_stream.ReInit(stream, 1, 1); [EOL]     token_source.ReInit(jj_input_stream); [EOL]     token = new Token(); [EOL]     token.next = jj_nt = token_source.getNextToken(); [EOL]     jj_gen = 0; [EOL]     for (int i = 0; i < 39; i++) jj_la1[i] = -1; [EOL]     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls(); [EOL] }
public void ReInit(java.io.Reader stream) { [EOL]     jj_input_stream.ReInit(stream, 1, 1); [EOL]     token_source.ReInit(jj_input_stream); [EOL]     token = new Token(); [EOL]     token.next = jj_nt = token_source.getNextToken(); [EOL]     jj_gen = 0; [EOL]     for (int i = 0; i < 39; i++) jj_la1[i] = -1; [EOL]     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls(); [EOL] }
final private Token jj_consume_token(int kind) throws ParseException { [EOL]     Token oldToken = token; [EOL]     if ((token = jj_nt).next != null) [EOL]         jj_nt = jj_nt.next; [EOL]     else [EOL]         jj_nt = jj_nt.next = token_source.getNextToken(); [EOL]     if (token.kind == kind) { [EOL]         jj_gen++; [EOL]         if (++jj_gc > 100) { [EOL]             jj_gc = 0; [EOL]             for (int i = 0; i < jj_2_rtns.length; i++) { [EOL]                 JJCalls c = jj_2_rtns[i]; [EOL]                 while (c != null) { [EOL]                     if (c.gen < jj_gen) [EOL]                         c.first = null; [EOL]                     c = c.next; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return token; [EOL]     } [EOL]     jj_nt = token; [EOL]     token = oldToken; [EOL]     jj_kind = kind; [EOL]     throw generateParseException(); [EOL] }
final private Token jj_consume_token(int kind) throws ParseException { [EOL]     Token oldToken = token; [EOL]     if ((token = jj_nt).next != null) [EOL]         jj_nt = jj_nt.next; [EOL]     else [EOL]         jj_nt = jj_nt.next = token_source.getNextToken(); [EOL]     if (token.kind == kind) { [EOL]         jj_gen++; [EOL]         if (++jj_gc > 100) { [EOL]             jj_gc = 0; [EOL]             for (int i = 0; i < jj_2_rtns.length; i++) { [EOL]                 JJCalls c = jj_2_rtns[i]; [EOL]                 while (c != null) { [EOL]                     if (c.gen < jj_gen) [EOL]                         c.first = null; [EOL]                     c = c.next; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return token; [EOL]     } [EOL]     jj_nt = token; [EOL]     token = oldToken; [EOL]     jj_kind = kind; [EOL]     throw generateParseException(); [EOL] }
final private Token jj_consume_token(int kind) throws ParseException { [EOL]     Token oldToken = token; [EOL]     if ((token = jj_nt).next != null) [EOL]         jj_nt = jj_nt.next; [EOL]     else [EOL]         jj_nt = jj_nt.next = token_source.getNextToken(); [EOL]     if (token.kind == kind) { [EOL]         jj_gen++; [EOL]         if (++jj_gc > 100) { [EOL]             jj_gc = 0; [EOL]             for (int i = 0; i < jj_2_rtns.length; i++) { [EOL]                 JJCalls c = jj_2_rtns[i]; [EOL]                 while (c != null) { [EOL]                     if (c.gen < jj_gen) [EOL]                         c.first = null; [EOL]                     c = c.next; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return token; [EOL]     } [EOL]     jj_nt = token; [EOL]     token = oldToken; [EOL]     jj_kind = kind; [EOL]     throw generateParseException(); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private void jj_save(int index, int xla) { [EOL]     JJCalls p = jj_2_rtns[index]; [EOL]     while (p.gen > jj_gen) { [EOL]         if (p.next == null) { [EOL]             p = p.next = new JJCalls(); [EOL]             break; [EOL]         } [EOL]         p = p.next; [EOL]     } [EOL]     p.gen = jj_gen + xla - jj_la; [EOL]     p.first = token; [EOL]     p.arg = xla; [EOL] }
final private void jj_save(int index, int xla) { [EOL]     JJCalls p = jj_2_rtns[index]; [EOL]     while (p.gen > jj_gen) { [EOL]         if (p.next == null) { [EOL]             p = p.next = new JJCalls(); [EOL]             break; [EOL]         } [EOL]         p = p.next; [EOL]     } [EOL]     p.gen = jj_gen + xla - jj_la; [EOL]     p.first = token; [EOL]     p.arg = xla; [EOL] }
public CoreOperation(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperation(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperation(Expression[] args) { [EOL]     super(args); [EOL] }
public String toString() { [EOL]     if (args.length == 1) { [EOL]         return getSymbol() + parenthesize(args[0], false); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(' '); [EOL]                 buffer.append(getSymbol()); [EOL]                 buffer.append(' '); [EOL]             } [EOL]             buffer.append(parenthesize(args[i], i == 0)); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String toString() { [EOL]     if (args.length == 1) { [EOL]         return getSymbol() + parenthesize(args[0], false); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(' '); [EOL]                 buffer.append(getSymbol()); [EOL]                 buffer.append(' '); [EOL]             } [EOL]             buffer.append(parenthesize(args[i], i == 0)); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
public void setProperty(Object object, String propertyName, Object value) { [EOL]     ((Map) object).put(propertyName, value); [EOL] }
public void setProperty(Object object, String propertyName, Object value) { [EOL]     ((Map) object).put(propertyName, value); [EOL] }
public QName(String qualifiedName) { [EOL]     int index = qualifiedName.indexOf(':'); [EOL]     if (index == -1) { [EOL]         prefix = null; [EOL]         name = qualifiedName; [EOL]     } else { [EOL]         prefix = qualifiedName.substring(0, index); [EOL]         name = qualifiedName.substring(index + 1); [EOL]     } [EOL] }
public QName(String qualifiedName) { [EOL]     int index = qualifiedName.indexOf(':'); [EOL]     if (index == -1) { [EOL]         prefix = null; [EOL]         name = qualifiedName; [EOL]     } else { [EOL]         prefix = qualifiedName.substring(0, index); [EOL]         name = qualifiedName.substring(index + 1); [EOL]     } [EOL] }
public static NodePointer interpretSimpleExpressionPath(EvalContext context, NodePointer root, Expression[] predicates, Step[] steps) { [EOL]     NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0); [EOL]     return pointer; [EOL] }
public static NodePointer interpretSimpleExpressionPath(EvalContext context, NodePointer root, Expression[] predicates, Step[] steps) { [EOL]     NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0); [EOL]     return pointer; [EOL] }
public static NodePointer interpretSimpleExpressionPath(EvalContext context, NodePointer root, Expression[] predicates, Step[] steps) { [EOL]     NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0); [EOL]     return pointer; [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer doPredicateIndex(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     int index = indexFromPredicate(context, predicate); [EOL]     NodePointer pointer = parent; [EOL]     if (isCollectionElement(pointer, index)) { [EOL]         pointer = (NodePointer) pointer.clone(); [EOL]         pointer.setIndex(index); [EOL]         return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, currentPredicate); [EOL] }
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] }
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] }
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] }
public boolean isAtomic() { [EOL]     return atomic; [EOL] }
public boolean isAtomic() { [EOL]     return atomic; [EOL] }
public boolean isDynamic() { [EOL]     return dynamicPropertyHandlerClass != null; [EOL] }
public boolean isDynamic() { [EOL]     return dynamicPropertyHandlerClass != null; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor getPropertyDescriptor(String propertyName) { [EOL]     if (propertyNames == null) { [EOL]         PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL]         String[] names = new String[pds.length]; [EOL]         for (int i = 0; i < pds.length; i++) { [EOL]             names[i] = pds[i].getName(); [EOL]         } [EOL]         propertyNames = names; [EOL]     } [EOL]     for (int i = 0; i < propertyNames.length; i++) { [EOL]         if (propertyNames[i] == propertyName) { [EOL]             return propertyDescriptors[i]; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < propertyNames.length; i++) { [EOL]         if (propertyNames[i].equals(propertyName)) { [EOL]             return propertyDescriptors[i]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Class getDynamicPropertyHandlerClass() { [EOL]     return dynamicPropertyHandlerClass; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         return newParent.createAttribute(context, getName()); [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), getIndex()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         return newParent.createAttribute(context, getName()); [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), getIndex()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         return newParent.createAttribute(context, getName()); [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), getIndex()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         NodePointer pointer = newParent.createAttribute(context, getName()); [EOL]         pointer.setValue(value); [EOL]         return pointer; [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), index, value); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         NodePointer pointer = newParent.createAttribute(context, getName()); [EOL]         pointer.setValue(value); [EOL]         return pointer; [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), index, value); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         NodePointer pointer = newParent.createAttribute(context, getName()); [EOL]         pointer.setValue(value); [EOL]         return pointer; [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), index, value); [EOL]     } [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL]     this.bean = bean; [EOL]     this.beanInfo = beanInfo; [EOL] }
public BeanPointer(NodePointer parent, QName name, Object bean, JXPathBeanInfo beanInfo) { [EOL]     super(parent); [EOL]     this.name = name; [EOL]     this.bean = bean; [EOL]     this.beanInfo = beanInfo; [EOL] }
public BeanPointer(NodePointer parent, QName name, Object bean, JXPathBeanInfo beanInfo) { [EOL]     super(parent); [EOL]     this.name = name; [EOL]     this.bean = bean; [EOL]     this.beanInfo = beanInfo; [EOL] }
public int getLength() { [EOL]     return 1; [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         createPath(context); [EOL]         ValueUtils.setValue(getBaseValue(), index, value); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         createPath(context); [EOL]         ValueUtils.setValue(getBaseValue(), index, value); [EOL]     } [EOL]     return this; [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         removeKey(); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         handler.setProperty(getBean(), getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         removeKey(); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         removeKey(); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         handler.setProperty(getBean(), getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         removeKey(); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         removeKey(); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         handler.setProperty(getBean(), getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         removeKey(); [EOL]     } [EOL] }
private void removeKey() { [EOL]     Object bean = getBean(); [EOL]     if (bean instanceof Map) { [EOL]         ((Map) bean).remove(getPropertyName()); [EOL]     } else { [EOL]         handler.setProperty(bean, getPropertyName(), null); [EOL]     } [EOL] }
private void removeKey() { [EOL]     Object bean = getBean(); [EOL]     if (bean instanceof Map) { [EOL]         ((Map) bean).remove(getPropertyName()); [EOL]     } else { [EOL]         handler.setProperty(bean, getPropertyName(), null); [EOL]     } [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public Object next() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.next(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         if (!constructIterator()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         return pointerIterator.next(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         if (done) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         hasPerformedIteratorStep = false; [EOL]         return getCurrentNodePointer(); [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
private boolean constructIterator() { [EOL]     HashSet set = new HashSet(); [EOL]     ArrayList list = new ArrayList(); [EOL]     while (nextSet()) { [EOL]         while (nextNode()) { [EOL]             NodePointer pointer = getCurrentNodePointer(); [EOL]             if (!set.contains(pointer)) { [EOL]                 set.add(pointer); [EOL]                 list.add(pointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     if (getDocumentOrder() == 1) { [EOL]         Collections.sort(list); [EOL]     } else { [EOL]         Collections.sort(list, REVERSE_COMPARATOR); [EOL]     } [EOL]     pointerIterator = list.iterator(); [EOL]     return true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getPropertyCount() { [EOL]     if (beanInfo.isAtomic()) { [EOL]         return 0; [EOL]     } [EOL]     return getPropertyDescriptors().length; [EOL] }
public int getPropertyCount() { [EOL]     if (beanInfo.isAtomic()) { [EOL]         return 0; [EOL]     } [EOL]     return getPropertyDescriptors().length; [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL]         names = new String[pds.length]; [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             names[i] = pds[i].getName(); [EOL]         } [EOL]     } [EOL]     return names; [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL]         names = new String[pds.length]; [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             names[i] = pds[i].getName(); [EOL]         } [EOL]     } [EOL]     return names; [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         propertyName = null; [EOL]         propertyDescriptor = null; [EOL]         baseValue = UNINITIALIZED; [EOL]         value = UNINITIALIZED; [EOL]     } [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         propertyName = null; [EOL]         propertyDescriptor = null; [EOL]         baseValue = UNINITIALIZED; [EOL]         value = UNINITIALIZED; [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public int getLength() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return 1; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return ValueUtils.getIndexedPropertyLength(getBean(), (IndexedPropertyDescriptor) pd); [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return 1; [EOL]     } [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public int getLength() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return 1; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return ValueUtils.getIndexedPropertyLength(getBean(), (IndexedPropertyDescriptor) pd); [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return 1; [EOL]     } [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public int getLength() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return 1; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return ValueUtils.getIndexedPropertyLength(getBean(), (IndexedPropertyDescriptor) pd); [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return 1; [EOL]     } [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public int getLength() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return 1; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return ValueUtils.getIndexedPropertyLength(getBean(), (IndexedPropertyDescriptor) pd); [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return 1; [EOL]     } [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public void setValue(Object value) { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property: " + asPath() + " - no such property"); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         ValueUtils.setValue(getBean(), pd, value); [EOL]     } else { [EOL]         ValueUtils.setValue(getBean(), pd, index, value); [EOL]     } [EOL]     this.value = value; [EOL] }
public void setValue(Object value) { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property: " + asPath() + " - no such property"); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         ValueUtils.setValue(getBean(), pd, value); [EOL]     } else { [EOL]         ValueUtils.setValue(getBean(), pd, index, value); [EOL]     } [EOL]     this.value = value; [EOL] }
public void setValue(Object value) { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property: " + asPath() + " - no such property"); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         ValueUtils.setValue(getBean(), pd, value); [EOL]     } else { [EOL]         ValueUtils.setValue(getBean(), pd, index, value); [EOL]     } [EOL]     this.value = value; [EOL] }
public String getPropertyName() { [EOL]     if (propertyName == null) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd != null) { [EOL]             propertyName = pd.getName(); [EOL]         } [EOL]     } [EOL]     return propertyName != null ? propertyName : "*"; [EOL] }
public String getPropertyName() { [EOL]     if (propertyName == null) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd != null) { [EOL]             propertyName = pd.getName(); [EOL]         } [EOL]     } [EOL]     return propertyName != null ? propertyName : "*"; [EOL] }
public String getPropertyName() { [EOL]     if (propertyName == null) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd != null) { [EOL]             propertyName = pd.getName(); [EOL]         } [EOL]     } [EOL]     return propertyName != null ? propertyName : "*"; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
protected PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         propertyDescriptors = beanInfo.getPropertyDescriptors(); [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
protected PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         propertyDescriptors = beanInfo.getPropertyDescriptors(); [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PackageFunctions(String classPrefix, String namespace) { [EOL]     this.classPrefix = classPrefix; [EOL]     this.namespace = namespace; [EOL] }
public PackageFunctions(String classPrefix, String namespace) { [EOL]     this.classPrefix = classPrefix; [EOL]     this.namespace = namespace; [EOL] }
public CoreOperationGreaterThan(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public CoreOperationGreaterThan(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
protected int getPrecedence() { [EOL]     return 3; [EOL] }
protected boolean isSymmetric() { [EOL]     return false; [EOL] }
public String getSymbol() { [EOL]     return ">"; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     return new BeanPointer(name, bean, bi, locale); [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     return new BeanPointer(name, bean, bi, locale); [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     return new BeanPointer(parent, name, bean, bi); [EOL] }
public CoreOperationCompare(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
protected boolean equal(EvalContext context, Expression left, Expression right) { [EOL]     Object l = left.compute(context); [EOL]     Object r = right.compute(context); [EOL]     if (l instanceof InitialContext || l instanceof SelfContext) { [EOL]         l = ((EvalContext) l).getSingleNodePointer(); [EOL]     } [EOL]     if (r instanceof InitialContext || r instanceof SelfContext) { [EOL]         r = ((EvalContext) r).getSingleNodePointer(); [EOL]     } [EOL]     if (l instanceof Collection) { [EOL]         l = ((Collection) l).iterator(); [EOL]     } [EOL]     if (r instanceof Collection) { [EOL]         r = ((Collection) r).iterator(); [EOL]     } [EOL]     if ((l instanceof Iterator) && !(r instanceof Iterator)) { [EOL]         return contains((Iterator) l, r); [EOL]     } else if (!(l instanceof Iterator) && (r instanceof Iterator)) { [EOL]         return contains((Iterator) r, l); [EOL]     } else if (l instanceof Iterator && r instanceof Iterator) { [EOL]         return findMatch((Iterator) l, (Iterator) r); [EOL]     } [EOL]     return equal(l, r); [EOL] }
protected boolean contains(Iterator it, Object value) { [EOL]     while (it.hasNext()) { [EOL]         Object element = it.next(); [EOL]         if (equal(element, value)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean contains(Iterator it, Object value) { [EOL]     while (it.hasNext()) { [EOL]         Object element = it.next(); [EOL]         if (equal(element, value)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean contains(Iterator it, Object value) { [EOL]     while (it.hasNext()) { [EOL]         Object element = it.next(); [EOL]         if (equal(element, value)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
public PredicateContext(EvalContext parentContext, Expression expression) { [EOL]     super(parentContext); [EOL]     this.expression = expression; [EOL]     if (expression instanceof NameAttributeTest) { [EOL]         nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression(); [EOL]     } [EOL] }
public PredicateContext(EvalContext parentContext, Expression expression) { [EOL]     super(parentContext); [EOL]     this.expression = expression; [EOL]     if (expression instanceof NameAttributeTest) { [EOL]         nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression(); [EOL]     } [EOL] }
public PredicateContext(EvalContext parentContext, Expression expression) { [EOL]     super(parentContext); [EOL]     this.expression = expression; [EOL]     if (expression instanceof NameAttributeTest) { [EOL]         nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression(); [EOL]     } [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     parentContext.reset(); [EOL]     done = false; [EOL] }
public boolean nextSet() { [EOL]     reset(); [EOL]     return parentContext.nextSet(); [EOL] }
public boolean nextSet() { [EOL]     reset(); [EOL]     return parentContext.nextSet(); [EOL] }
public Object convert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         if (toType.isPrimitive()) { [EOL]             return convertNullToPrimitive(toType); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         if (object instanceof NodeSet) { [EOL]             return convert(((NodeSet) object).getValues(), toType); [EOL]         } else if (object instanceof Pointer) { [EOL]             return convert(((Pointer) object).getValue(), toType); [EOL]         } [EOL]         return object; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL]         return object; [EOL]     } [EOL]     if (fromType.isArray()) { [EOL]         int length = Array.getLength(object); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 collection.add(Array.get(object, i)); [EOL]             } [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         int length = ((Collection) object).size(); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = it.next(); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             collection.addAll((Collection) object); [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return convert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return convert(((Pointer) object).getValue(), toType); [EOL]     } else if (toType == String.class) { [EOL]         return object.toString(); [EOL]     } else if (object instanceof Boolean) { [EOL]         if (toType == boolean.class) { [EOL]             return object; [EOL]         } [EOL]         boolean value = ((Boolean) object).booleanValue(); [EOL]         return allocateNumber(toType, value ? 1 : 0); [EOL]     } else if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         if (toType == boolean.class || toType == Boolean.class) { [EOL]             return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return allocateNumber(toType, value); [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return object; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         Object value = convertStringToPrimitive(object, toType); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     Converter converter = ConvertUtils.lookup(toType); [EOL]     if (converter != null) { [EOL]         return converter.convert(toType, object); [EOL]     } [EOL]     throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
protected void FillBuff() throws java.io.IOException { [EOL]     if (maxNextCharInd == available) { [EOL]         if (available == bufsize) { [EOL]             if (tokenBegin > 2048) { [EOL]                 bufpos = maxNextCharInd = 0; [EOL]                 available = tokenBegin; [EOL]             } else if (tokenBegin < 0) [EOL]                 bufpos = maxNextCharInd = 0; [EOL]             else [EOL]                 ExpandBuff(false); [EOL]         } else if (available > tokenBegin) [EOL]             available = bufsize; [EOL]         else if ((tokenBegin - available) < 2048) [EOL]             ExpandBuff(true); [EOL]         else [EOL]             available = tokenBegin; [EOL]     } [EOL]     int i; [EOL]     try { [EOL]         if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) { [EOL]             inputStream.close(); [EOL]             throw new java.io.IOException(); [EOL]         } else [EOL]             maxNextCharInd += i; [EOL]         return; [EOL]     } catch (java.io.IOException e) { [EOL]         --bufpos; [EOL]         backup(0); [EOL]         if (tokenBegin == -1) [EOL]             tokenBegin = bufpos; [EOL]         throw e; [EOL]     } [EOL] }
public char BeginToken() throws java.io.IOException { [EOL]     tokenBegin = -1; [EOL]     char c = readChar(); [EOL]     tokenBegin = bufpos; [EOL]     return c; [EOL] }
public char BeginToken() throws java.io.IOException { [EOL]     tokenBegin = -1; [EOL]     char c = readChar(); [EOL]     tokenBegin = bufpos; [EOL]     return c; [EOL] }
protected void UpdateLineColumn(char c) { [EOL]     column++; [EOL]     if (prevCharIsLF) { [EOL]         prevCharIsLF = false; [EOL]         line += (column = 1); [EOL]     } else if (prevCharIsCR) { [EOL]         prevCharIsCR = false; [EOL]         if (c == '\n') { [EOL]             prevCharIsLF = true; [EOL]         } else [EOL]             line += (column = 1); [EOL]     } [EOL]     switch(c) { [EOL]         case '\r': [EOL]             prevCharIsCR = true; [EOL]             break; [EOL]         case '\n': [EOL]             prevCharIsLF = true; [EOL]             break; [EOL]         case '\t': [EOL]             column--; [EOL]             column += (8 - (column & 07)); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     bufline[bufpos] = line; [EOL]     bufcolumn[bufpos] = column; [EOL] }
protected void UpdateLineColumn(char c) { [EOL]     column++; [EOL]     if (prevCharIsLF) { [EOL]         prevCharIsLF = false; [EOL]         line += (column = 1); [EOL]     } else if (prevCharIsCR) { [EOL]         prevCharIsCR = false; [EOL]         if (c == '\n') { [EOL]             prevCharIsLF = true; [EOL]         } else [EOL]             line += (column = 1); [EOL]     } [EOL]     switch(c) { [EOL]         case '\r': [EOL]             prevCharIsCR = true; [EOL]             break; [EOL]         case '\n': [EOL]             prevCharIsLF = true; [EOL]             break; [EOL]         case '\t': [EOL]             column--; [EOL]             column += (8 - (column & 07)); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     bufline[bufpos] = line; [EOL]     bufcolumn[bufpos] = column; [EOL] }
protected void UpdateLineColumn(char c) { [EOL]     column++; [EOL]     if (prevCharIsLF) { [EOL]         prevCharIsLF = false; [EOL]         line += (column = 1); [EOL]     } else if (prevCharIsCR) { [EOL]         prevCharIsCR = false; [EOL]         if (c == '\n') { [EOL]             prevCharIsLF = true; [EOL]         } else [EOL]             line += (column = 1); [EOL]     } [EOL]     switch(c) { [EOL]         case '\r': [EOL]             prevCharIsCR = true; [EOL]             break; [EOL]         case '\n': [EOL]             prevCharIsLF = true; [EOL]             break; [EOL]         case '\t': [EOL]             column--; [EOL]             column += (8 - (column & 07)); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     bufline[bufpos] = line; [EOL]     bufcolumn[bufpos] = column; [EOL] }
public char readChar() throws java.io.IOException { [EOL]     if (inBuf > 0) { [EOL]         --inBuf; [EOL]         if (++bufpos == bufsize) [EOL]             bufpos = 0; [EOL]         return buffer[bufpos]; [EOL]     } [EOL]     if (++bufpos >= maxNextCharInd) [EOL]         FillBuff(); [EOL]     char c = buffer[bufpos]; [EOL]     UpdateLineColumn(c); [EOL]     return (c); [EOL] }
public char readChar() throws java.io.IOException { [EOL]     if (inBuf > 0) { [EOL]         --inBuf; [EOL]         if (++bufpos == bufsize) [EOL]             bufpos = 0; [EOL]         return buffer[bufpos]; [EOL]     } [EOL]     if (++bufpos >= maxNextCharInd) [EOL]         FillBuff(); [EOL]     char c = buffer[bufpos]; [EOL]     UpdateLineColumn(c); [EOL]     return (c); [EOL] }
public char readChar() throws java.io.IOException { [EOL]     if (inBuf > 0) { [EOL]         --inBuf; [EOL]         if (++bufpos == bufsize) [EOL]             bufpos = 0; [EOL]         return buffer[bufpos]; [EOL]     } [EOL]     if (++bufpos >= maxNextCharInd) [EOL]         FillBuff(); [EOL]     char c = buffer[bufpos]; [EOL]     UpdateLineColumn(c); [EOL]     return (c); [EOL] }
public int getEndColumn() { [EOL]     return bufcolumn[bufpos]; [EOL] }
public int getEndColumn() { [EOL]     return bufcolumn[bufpos]; [EOL] }
public int getEndLine() { [EOL]     return bufline[bufpos]; [EOL] }
public int getEndLine() { [EOL]     return bufline[bufpos]; [EOL] }
public int getEndLine() { [EOL]     return bufline[bufpos]; [EOL] }
public int getBeginColumn() { [EOL]     return bufcolumn[tokenBegin]; [EOL] }
public int getBeginLine() { [EOL]     return bufline[tokenBegin]; [EOL] }
public void backup(int amount) { [EOL]     inBuf += amount; [EOL]     if ((bufpos -= amount) < 0) [EOL]         bufpos += bufsize; [EOL] }
public void backup(int amount) { [EOL]     inBuf += amount; [EOL]     if ((bufpos -= amount) < 0) [EOL]         bufpos += bufsize; [EOL] }
public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) { [EOL]     inputStream = dstream; [EOL]     line = startline; [EOL]     column = startcolumn - 1; [EOL]     if (buffer == null || buffersize != buffer.length) { [EOL]         available = bufsize = buffersize; [EOL]         buffer = new char[buffersize]; [EOL]         bufline = new int[buffersize]; [EOL]         bufcolumn = new int[buffersize]; [EOL]     } [EOL]     prevCharIsLF = prevCharIsCR = false; [EOL]     tokenBegin = inBuf = maxNextCharInd = 0; [EOL]     bufpos = -1; [EOL] }
public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) { [EOL]     inputStream = dstream; [EOL]     line = startline; [EOL]     column = startcolumn - 1; [EOL]     if (buffer == null || buffersize != buffer.length) { [EOL]         available = bufsize = buffersize; [EOL]         buffer = new char[buffersize]; [EOL]         bufline = new int[buffersize]; [EOL]         bufcolumn = new int[buffersize]; [EOL]     } [EOL]     prevCharIsLF = prevCharIsCR = false; [EOL]     tokenBegin = inBuf = maxNextCharInd = 0; [EOL]     bufpos = -1; [EOL] }
public void ReInit(java.io.Reader dstream, int startline, int startcolumn) { [EOL]     ReInit(dstream, startline, startcolumn, 4096); [EOL] }
public void ReInit(java.io.Reader dstream, int startline, int startcolumn) { [EOL]     ReInit(dstream, startline, startcolumn, 4096); [EOL] }
public void ReInit(java.io.Reader dstream, int startline, int startcolumn) { [EOL]     ReInit(dstream, startline, startcolumn, 4096); [EOL] }
public String GetImage() { [EOL]     if (bufpos >= tokenBegin) [EOL]         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1); [EOL]     else [EOL]         return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1); [EOL] }
public String GetImage() { [EOL]     if (bufpos >= tokenBegin) [EOL]         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1); [EOL]     else [EOL]         return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public NamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public NamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public NamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public NamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public QName getName() { [EOL]     return new QName(prefix); [EOL] }
public QName getName() { [EOL]     return new QName(prefix); [EOL] }
public String getNamespaceURI() { [EOL]     if (namespaceURI == null) { [EOL]         namespaceURI = parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return namespaceURI; [EOL] }
public String getNamespaceURI() { [EOL]     if (namespaceURI == null) { [EOL]         namespaceURI = parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return namespaceURI; [EOL] }
public CoreOperationNotEqual(Expression arg1, Expression arg2) { [EOL]     super(arg1, arg2); [EOL] }
protected int getPrecedence() { [EOL]     return 2; [EOL] }
public String getSymbol() { [EOL]     return "!="; [EOL] }
public static final Token newToken(int ofKind) { [EOL]     switch(ofKind) { [EOL]         default: [EOL]             return new Token(); [EOL]     } [EOL] }
public boolean computeContextDependent() { [EOL]     if (!absolute) { [EOL]         return true; [EOL]     } [EOL]     return super.computeContextDependent(); [EOL] }
public boolean computeContextDependent() { [EOL]     if (!absolute) { [EOL]         return true; [EOL]     } [EOL]     return super.computeContextDependent(); [EOL] }
public Object number(String value) { [EOL]     return new Constant(new Double(value)); [EOL] }
public Object sum(Object[] arguments) { [EOL]     return new CoreOperationAdd(toExpressionArray(arguments)); [EOL] }
public Object equal(Object left, Object right) { [EOL]     if (isNameAttributeTest((Expression) left)) { [EOL]         return new NameAttributeTest((Expression) left, (Expression) right); [EOL]     } else { [EOL]         return new CoreOperationEqual((Expression) left, (Expression) right); [EOL]     } [EOL] }
public Object equal(Object left, Object right) { [EOL]     if (isNameAttributeTest((Expression) left)) { [EOL]         return new NameAttributeTest((Expression) left, (Expression) right); [EOL]     } else { [EOL]         return new CoreOperationEqual((Expression) left, (Expression) right); [EOL]     } [EOL] }
public Object notEqual(Object left, Object right) { [EOL]     return new CoreOperationNotEqual((Expression) left, (Expression) right); [EOL] }
public Object notEqual(Object left, Object right) { [EOL]     return new CoreOperationNotEqual((Expression) left, (Expression) right); [EOL] }
public Object notEqual(Object left, Object right) { [EOL]     return new CoreOperationNotEqual((Expression) left, (Expression) right); [EOL] }
public Object notEqual(Object left, Object right) { [EOL]     return new CoreOperationNotEqual((Expression) left, (Expression) right); [EOL] }
private Expression[] toExpressionArray(Object[] array) { [EOL]     Expression[] expArray = null; [EOL]     if (array != null) { [EOL]         expArray = new Expression[array.length]; [EOL]         for (int i = 0; i < expArray.length; i++) { [EOL]             expArray[i] = (Expression) array[i]; [EOL]         } [EOL]     } [EOL]     return expArray; [EOL] }
private Expression[] toExpressionArray(Object[] array) { [EOL]     Expression[] expArray = null; [EOL]     if (array != null) { [EOL]         expArray = new Expression[array.length]; [EOL]         for (int i = 0; i < expArray.length; i++) { [EOL]             expArray[i] = (Expression) array[i]; [EOL]         } [EOL]     } [EOL]     return expArray; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public Expression[] getPredicates() { [EOL]     return predicates; [EOL] }
public boolean isSimpleExpressionPath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = isSimplePath() && areBasicPredicates(getPredicates()); [EOL]     } [EOL]     return basic; [EOL] }
public boolean isSimpleExpressionPath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = isSimplePath() && areBasicPredicates(getPredicates()); [EOL]     } [EOL]     return basic; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return expressionPath(context, true); [EOL] }
protected Object expressionPath(EvalContext evalContext, boolean firstMatch) { [EOL]     Object value = expression.compute(evalContext); [EOL]     EvalContext context; [EOL]     if (value instanceof InitialContext) { [EOL]         context = (InitialContext) value; [EOL]     } else if (value instanceof EvalContext) { [EOL]         context = new UnionContext(evalContext, new EvalContext[] { (EvalContext) value }); [EOL]     } else { [EOL]         context = evalContext.getRootContext().getConstantContext(value); [EOL]     } [EOL]     if (firstMatch && isSimpleExpressionPath() && !(context instanceof NodeSetContext)) { [EOL]         EvalContext ctx = context; [EOL]         NodePointer ptr = (NodePointer) ctx.getSingleNodePointer(); [EOL]         if (ptr != null && (ptr.getIndex() == NodePointer.WHOLE_COLLECTION || predicates == null || predicates.length == 0)) { [EOL]             return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps()); [EOL]         } [EOL]     } [EOL]     if (predicates != null) { [EOL]         for (int j = 0; j < predicates.length; j++) { [EOL]             if (j != 0) { [EOL]                 context = new UnionContext(context, new EvalContext[] { context }); [EOL]             } [EOL]             context = new PredicateContext(context, predicates[j]); [EOL]         } [EOL]     } [EOL]     if (firstMatch) { [EOL]         return getSingleNodePointerForSteps(context); [EOL]     } else { [EOL]         return evalSteps(context); [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
private void setValue(int index, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), convert(value, false)); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, convert(value, true)); [EOL]     } else { [EOL]         Object baseValue = dynaBean.get(getPropertyName()); [EOL]         ValueUtils.setValue(baseValue, index, value); [EOL]     } [EOL] }
private void setValue(int index, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), convert(value, false)); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, convert(value, true)); [EOL]     } else { [EOL]         Object baseValue = dynaBean.get(getPropertyName()); [EOL]         ValueUtils.setValue(baseValue, index, value); [EOL]     } [EOL] }
private void setValue(int index, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), convert(value, false)); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, convert(value, true)); [EOL]     } else { [EOL]         Object baseValue = dynaBean.get(getPropertyName()); [EOL]         ValueUtils.setValue(baseValue, index, value); [EOL]     } [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String axisToString(int axis) { [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_SELF: [EOL]             return "self"; [EOL]         case Compiler.AXIS_CHILD: [EOL]             return "child"; [EOL]         case Compiler.AXIS_PARENT: [EOL]             return "parent"; [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return "ancestor"; [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return "attribute"; [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return "namespace"; [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return "preceding"; [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return "following"; [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return "descendant"; [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return "ancestor-or-self"; [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return "following-sibling"; [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return "preceding-sibling"; [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return "descendant-or-self"; [EOL]     } [EOL]     return "UNKNOWN"; [EOL] }
public NamespaceResolver(NamespaceResolver parent) { [EOL]     this.parent = parent; [EOL] }
public NamespaceResolver(NamespaceResolver parent) { [EOL]     this.parent = parent; [EOL] }
public void setNamespaceContextPointer(NodePointer pointer) { [EOL]     this.pointer = pointer; [EOL] }
public void seal() { [EOL]     sealed = true; [EOL]     if (parent != null) { [EOL]         parent.seal(); [EOL]     } [EOL] }
public void seal() { [EOL]     sealed = true; [EOL]     if (parent != null) { [EOL]         parent.seal(); [EOL]     } [EOL] }
protected JXPathContext(JXPathContext parentContext, Object contextBean) { [EOL]     this.parentContext = parentContext; [EOL]     this.contextBean = contextBean; [EOL] }
public JXPathContext getParentContext() { [EOL]     return parentContext; [EOL] }
public JXPathContext getParentContext() { [EOL]     return parentContext; [EOL] }
public void setFunctions(Functions functions) { [EOL]     this.functions = functions; [EOL] }
public void setFunctions(Functions functions) { [EOL]     this.functions = functions; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public AbstractFactory getFactory() { [EOL]     if (factory == null && parentContext != null) { [EOL]         return parentContext.getFactory(); [EOL]     } [EOL]     return factory; [EOL] }
public AbstractFactory getFactory() { [EOL]     if (factory == null && parentContext != null) { [EOL]         return parentContext.getFactory(); [EOL]     } [EOL]     return factory; [EOL] }
public AbstractFactory getFactory() { [EOL]     if (factory == null && parentContext != null) { [EOL]         return parentContext.getFactory(); [EOL]     } [EOL]     return factory; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getLocale(); [EOL]         } else { [EOL]             locale = Locale.getDefault(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getLocale(); [EOL]         } else { [EOL]             locale = Locale.getDefault(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getLocale(); [EOL]         } else { [EOL]             locale = Locale.getDefault(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public static CompiledExpression compile(String xpath) { [EOL]     if (compilationContext == null) { [EOL]         compilationContext = JXPathContext.newContext(null); [EOL]     } [EOL]     return compilationContext.compilePath(xpath); [EOL] }
public static CompiledExpression compile(String xpath) { [EOL]     if (compilationContext == null) { [EOL]         compilationContext = JXPathContext.newContext(null); [EOL]     } [EOL]     return compilationContext.compilePath(xpath); [EOL] }
public void setKeyManager(KeyManager keyManager) { [EOL]     this.keyManager = keyManager; [EOL] }
public KeyManager getKeyManager() { [EOL]     if (keyManager == null && parentContext != null) { [EOL]         return parentContext.getKeyManager(); [EOL]     } [EOL]     return keyManager; [EOL] }
public KeyManager getKeyManager() { [EOL]     if (keyManager == null && parentContext != null) { [EOL]         return parentContext.getKeyManager(); [EOL]     } [EOL]     return keyManager; [EOL] }
public KeyManager getKeyManager() { [EOL]     if (keyManager == null && parentContext != null) { [EOL]         return parentContext.getKeyManager(); [EOL]     } [EOL]     return keyManager; [EOL] }
public Pointer getPointerByKey(String key, String value) { [EOL]     KeyManager manager = getKeyManager(); [EOL]     if (manager != null) { [EOL]         return manager.getPointerByKey(this, key, value); [EOL]     } else { [EOL]         throw new JXPathException("Cannot find an element by key - " + "no KeyManager has been specified"); [EOL]     } [EOL] }
public Pointer getPointerByKey(String key, String value) { [EOL]     KeyManager manager = getKeyManager(); [EOL]     if (manager != null) { [EOL]         return manager.getPointerByKey(this, key, value); [EOL]     } else { [EOL]         throw new JXPathException("Cannot find an element by key - " + "no KeyManager has been specified"); [EOL]     } [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator createNodeIterator(String property, boolean reverse, NodePointer startWith) { [EOL]     return new PropertyIterator(this, property, reverse, startWith); [EOL] }
public NodeIterator createNodeIterator(String property, boolean reverse, NodePointer startWith) { [EOL]     return new PropertyIterator(this, property, reverse, startWith); [EOL] }
protected PropertyOwnerPointer(NodePointer parent, Locale locale) { [EOL]     super(parent, locale); [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         super.setIndex(index); [EOL]         value = UNINITIALIZED; [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         super.setIndex(index); [EOL]         value = UNINITIALIZED; [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             value = ValueUtils.getValue(getBaseValue(), index); [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             value = ValueUtils.getValue(getBaseValue(), index); [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             value = ValueUtils.getValue(getBaseValue(), index); [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public JDOMNamespaceIterator(NodePointer parent) { [EOL]     this.parent = parent; [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getRootElement(); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         namespaces = new ArrayList(); [EOL]         prefixes = new HashSet(); [EOL]         collectNamespaces((Element) node); [EOL]     } [EOL] }
public JDOMNamespaceIterator(NodePointer parent) { [EOL]     this.parent = parent; [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getRootElement(); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         namespaces = new ArrayList(); [EOL]         prefixes = new HashSet(); [EOL]         collectNamespaces((Element) node); [EOL]     } [EOL] }
public JDOMNamespaceIterator(NodePointer parent) { [EOL]     this.parent = parent; [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getRootElement(); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         namespaces = new ArrayList(); [EOL]         prefixes = new HashSet(); [EOL]         collectNamespaces((Element) node); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     Namespace ns = (Namespace) namespaces.get(index); [EOL]     return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI()); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     Namespace ns = (Namespace) namespaces.get(index); [EOL]     return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI()); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     Namespace ns = (Namespace) namespaces.get(index); [EOL]     return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI()); [EOL] }
public boolean setPosition(int position) { [EOL]     if (namespaces == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= namespaces.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (namespaces == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= namespaces.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (namespaces == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= namespaces.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (namespaces == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= namespaces.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (namespaces == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= namespaces.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (namespaces == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= namespaces.size(); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (includeXmlLang && position == 1) { [EOL]         return new LangAttributePointer(parent); [EOL]     } else { [EOL]         return super.getNodePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (includeXmlLang && position == 1) { [EOL]         return new LangAttributePointer(parent); [EOL]     } else { [EOL]         return super.getNodePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (includeXmlLang && position == 1) { [EOL]         return new LangAttributePointer(parent); [EOL]     } else { [EOL]         return super.getNodePointer(); [EOL]     } [EOL] }
public int getPosition() { [EOL]     return position; [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (includeXmlLang) { [EOL]         if (position == 1) { [EOL]             return true; [EOL]         } else { [EOL]             return super.setPosition(position - 1); [EOL]         } [EOL]     } else { [EOL]         this.position = position; [EOL]         return super.setPosition(position); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (includeXmlLang) { [EOL]         if (position == 1) { [EOL]             return true; [EOL]         } else { [EOL]             return super.setPosition(position - 1); [EOL]         } [EOL]     } else { [EOL]         this.position = position; [EOL]         return super.setPosition(position); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (includeXmlLang) { [EOL]         if (position == 1) { [EOL]             return true; [EOL]         } else { [EOL]             return super.setPosition(position - 1); [EOL]         } [EOL]     } else { [EOL]         this.position = position; [EOL]         return super.setPosition(position); [EOL]     } [EOL] }
public boolean isChildOrderingRequired() { [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         stack = new Stack(); [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (currentNodePointer != null) { [EOL]             if (!currentNodePointer.isLeaf()) { [EOL]                 stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]             } [EOL]             if (includeSelf) { [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     while (!stack.isEmpty()) { [EOL]         NodeIterator it = (NodeIterator) stack.peek(); [EOL]         if (it.setPosition(it.getPosition() + 1)) { [EOL]             currentNodePointer = it.getNodePointer(); [EOL]             if (!isRecursive()) { [EOL]                 if (!currentNodePointer.isLeaf()) { [EOL]                     stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]                 } [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             stack.pop(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         stack = new Stack(); [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (currentNodePointer != null) { [EOL]             if (!currentNodePointer.isLeaf()) { [EOL]                 stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]             } [EOL]             if (includeSelf) { [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     while (!stack.isEmpty()) { [EOL]         NodeIterator it = (NodeIterator) stack.peek(); [EOL]         if (it.setPosition(it.getPosition() + 1)) { [EOL]             currentNodePointer = it.getNodePointer(); [EOL]             if (!isRecursive()) { [EOL]                 if (!currentNodePointer.isLeaf()) { [EOL]                     stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]                 } [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             stack.pop(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         stack = new Stack(); [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (currentNodePointer != null) { [EOL]             if (!currentNodePointer.isLeaf()) { [EOL]                 stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]             } [EOL]             if (includeSelf) { [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     while (!stack.isEmpty()) { [EOL]         NodeIterator it = (NodeIterator) stack.peek(); [EOL]         if (it.setPosition(it.getPosition() + 1)) { [EOL]             currentNodePointer = it.getNodePointer(); [EOL]             if (!isRecursive()) { [EOL]                 if (!currentNodePointer.isLeaf()) { [EOL]                     stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]                 } [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             stack.pop(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         stack = new Stack(); [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (currentNodePointer != null) { [EOL]             if (!currentNodePointer.isLeaf()) { [EOL]                 stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]             } [EOL]             if (includeSelf) { [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     while (!stack.isEmpty()) { [EOL]         NodeIterator it = (NodeIterator) stack.peek(); [EOL]         if (it.setPosition(it.getPosition() + 1)) { [EOL]             currentNodePointer = it.getNodePointer(); [EOL]             if (!isRecursive()) { [EOL]                 if (!currentNodePointer.isLeaf()) { [EOL]                     stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]                 } [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             stack.pop(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         stack = new Stack(); [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (currentNodePointer != null) { [EOL]             if (!currentNodePointer.isLeaf()) { [EOL]                 stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]             } [EOL]             if (includeSelf) { [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     while (!stack.isEmpty()) { [EOL]         NodeIterator it = (NodeIterator) stack.peek(); [EOL]         if (it.setPosition(it.getPosition() + 1)) { [EOL]             currentNodePointer = it.getNodePointer(); [EOL]             if (!isRecursive()) { [EOL]                 if (!currentNodePointer.isLeaf()) { [EOL]                     stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]                 } [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             stack.pop(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean isRecursive() { [EOL]     Object node = currentNodePointer.getNode(); [EOL]     for (int i = stack.size() - 1; --i >= 0; ) { [EOL]         NodeIterator it = (NodeIterator) stack.get(i); [EOL]         Pointer pointer = it.getNodePointer(); [EOL]         if (pointer != null && pointer.getNode() == node) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean isRecursive() { [EOL]     Object node = currentNodePointer.getNode(); [EOL]     for (int i = stack.size() - 1; --i >= 0; ) { [EOL]         NodeIterator it = (NodeIterator) stack.get(i); [EOL]         Pointer pointer = it.getNodePointer(); [EOL]         if (pointer != null && pointer.getNode() == node) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean isRecursive() { [EOL]     Object node = currentNodePointer.getNode(); [EOL]     for (int i = stack.size() - 1; --i >= 0; ) { [EOL]         NodeIterator it = (NodeIterator) stack.get(i); [EOL]         Pointer pointer = it.getNodePointer(); [EOL]         if (pointer != null && pointer.getNode() == node) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Path(Step[] steps) { [EOL]     this.steps = steps; [EOL] }
public Path(Step[] steps) { [EOL]     this.steps = steps; [EOL] }
public Path(Step[] steps) { [EOL]     this.steps = steps; [EOL] }
public Step[] getSteps() { [EOL]     return steps; [EOL] }
public boolean isSimplePath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = true; [EOL]         Step[] steps = getSteps(); [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (!isSimpleStep(steps[i])) { [EOL]                 basic = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return basic; [EOL] }
public boolean isSimplePath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = true; [EOL]         Step[] steps = getSteps(); [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (!isSimpleStep(steps[i])) { [EOL]                 basic = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return basic; [EOL] }
public boolean isSimplePath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = true; [EOL]         Step[] steps = getSteps(); [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (!isSimpleStep(steps[i])) { [EOL]                 basic = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return basic; [EOL] }
protected boolean isSimpleStep(Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeTypeTest)) { [EOL]             return false; [EOL]         } [EOL]         int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL]         if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         if (((NodeNameTest) nodeTest).isWildcard()) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } [EOL]     return false; [EOL] }
protected boolean areBasicPredicates(Expression[] predicates) { [EOL]     if (predicates != null && predicates.length != 0) { [EOL]         boolean firstIndex = true; [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i] instanceof NameAttributeTest) { [EOL]                 if (((NameAttributeTest) predicates[i]).getNameTestExpression().isContextDependent()) { [EOL]                     return false; [EOL]                 } [EOL]             } else if (predicates[i].isContextDependent()) { [EOL]                 return false; [EOL]             } else { [EOL]                 if (!firstIndex) { [EOL]                     return false; [EOL]                 } [EOL]                 firstIndex = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
protected boolean areBasicPredicates(Expression[] predicates) { [EOL]     if (predicates != null && predicates.length != 0) { [EOL]         boolean firstIndex = true; [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i] instanceof NameAttributeTest) { [EOL]                 if (((NameAttributeTest) predicates[i]).getNameTestExpression().isContextDependent()) { [EOL]                     return false; [EOL]                 } [EOL]             } else if (predicates[i].isContextDependent()) { [EOL]                 return false; [EOL]             } else { [EOL]                 if (!firstIndex) { [EOL]                     return false; [EOL]                 } [EOL]                 firstIndex = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected EvalContext evalSteps(EvalContext context) { [EOL]     return buildContextChain(context, steps.length, false); [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
public boolean isContainer() { [EOL]     return true; [EOL] }
public void setValue(Object value) { [EOL]     if (!actual) { [EOL]         throw new JXPathException("Cannot set undefined variable: " + name); [EOL]     } [EOL]     valuePointer = null; [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         Object collection = getBaseValue(); [EOL]         ValueUtils.setValue(collection, index, value); [EOL]     } else { [EOL]         variables.declareVariable(name.toString(), value); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (!actual) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         if (!factory.declareVariable(context, name.toString())) { [EOL]             throw new JXPathAbstractFactoryException("Factory cannot define variable '" + name + "' for path: " + asPath()); [EOL]         } [EOL]         findVariables(context); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (!actual) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         if (!factory.declareVariable(context, name.toString())) { [EOL]             throw new JXPathAbstractFactoryException("Factory cannot define variable '" + name + "' for path: " + asPath()); [EOL]         } [EOL]         findVariables(context); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (!actual) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         if (!factory.declareVariable(context, name.toString())) { [EOL]             throw new JXPathAbstractFactoryException("Factory cannot define variable '" + name + "' for path: " + asPath()); [EOL]         } [EOL]         findVariables(context); [EOL]     } [EOL]     return this; [EOL] }
protected void findVariables(JXPathContext context) { [EOL]     valuePointer = null; [EOL]     JXPathContext varCtx = context; [EOL]     while (varCtx != null) { [EOL]         variables = varCtx.getVariables(); [EOL]         if (variables.isDeclaredVariable(name.toString())) { [EOL]             actual = true; [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         variables = null; [EOL]     } [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof VariablePointer)) { [EOL]         return false; [EOL]     } [EOL]     VariablePointer other = (VariablePointer) object; [EOL]     return variables == other.variables && name.equals(other.name) && index == other.index; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof VariablePointer)) { [EOL]         return false; [EOL]     } [EOL]     VariablePointer other = (VariablePointer) object; [EOL]     return variables == other.variables && name.equals(other.name) && index == other.index; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof VariablePointer)) { [EOL]         return false; [EOL]     } [EOL]     VariablePointer other = (VariablePointer) object; [EOL]     return variables == other.variables && name.equals(other.name) && index == other.index; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof VariablePointer)) { [EOL]         return false; [EOL]     } [EOL]     VariablePointer other = (VariablePointer) object; [EOL]     return variables == other.variables && name.equals(other.name) && index == other.index; [EOL] }
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
protected NodePointer(NodePointer parent, Locale locale) { [EOL]     this.parent = parent; [EOL]     this.locale = locale; [EOL] }
protected NodePointer(NodePointer parent, Locale locale) { [EOL]     this.parent = parent; [EOL]     this.locale = locale; [EOL] }
public NodePointer getParent() { [EOL]     NodePointer pointer = parent; [EOL]     while (pointer != null && pointer.isContainer()) { [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return pointer; [EOL] }
public NodePointer getParent() { [EOL]     NodePointer pointer = parent; [EOL]     while (pointer != null && pointer.isContainer()) { [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return pointer; [EOL] }
public boolean isAttribute() { [EOL]     return attribute; [EOL] }
public boolean isAttribute() { [EOL]     return attribute; [EOL] }
public boolean isRoot() { [EOL]     return parent == null; [EOL] }
public boolean isRoot() { [EOL]     return parent == null; [EOL] }
public boolean isNode() { [EOL]     return !isContainer(); [EOL] }
public boolean isContainer() { [EOL]     return false; [EOL] }
public Object getValue() { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != this) { [EOL]         return valuePointer.getValue(); [EOL]     } [EOL]     return getNode(); [EOL] }
public Object getValue() { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != this) { [EOL]         return valuePointer.getValue(); [EOL]     } [EOL]     return getNode(); [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public Object getRootNode() { [EOL]     if (rootNode == null) { [EOL]         if (parent != null) { [EOL]             rootNode = parent.getRootNode(); [EOL]         } else { [EOL]             rootNode = getImmediateNode(); [EOL]         } [EOL]     } [EOL]     return rootNode; [EOL] }
public Object getRootNode() { [EOL]     if (rootNode == null) { [EOL]         if (parent != null) { [EOL]             rootNode = parent.getRootNode(); [EOL]         } else { [EOL]             rootNode = getImmediateNode(); [EOL]         } [EOL]     } [EOL]     return rootNode; [EOL] }
public Object getRootNode() { [EOL]     if (rootNode == null) { [EOL]         if (parent != null) { [EOL]             rootNode = parent.getRootNode(); [EOL]         } else { [EOL]             rootNode = getImmediateNode(); [EOL]         } [EOL]     } [EOL]     return rootNode; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     setValue(value); [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     return this; [EOL] }
protected boolean isDefaultNamespace(String prefix) { [EOL]     if (prefix == null) { [EOL]         return true; [EOL]     } [EOL]     String namespace = getNamespaceURI(prefix); [EOL]     if (namespace == null) { [EOL]         return false; [EOL]     } [EOL]     return namespace.equals(getDefaultNamespaceURI()); [EOL] }
protected boolean isDefaultNamespace(String prefix) { [EOL]     if (prefix == null) { [EOL]         return true; [EOL]     } [EOL]     String namespace = getNamespaceURI(prefix); [EOL]     if (namespace == null) { [EOL]         return false; [EOL]     } [EOL]     return namespace.equals(getDefaultNamespaceURI()); [EOL] }
protected boolean isDefaultNamespace(String prefix) { [EOL]     if (prefix == null) { [EOL]         return true; [EOL]     } [EOL]     String namespace = getNamespaceURI(prefix); [EOL]     if (namespace == null) { [EOL]         return false; [EOL]     } [EOL]     return namespace.equals(getDefaultNamespaceURI()); [EOL] }
public Pointer getPointerByKey(JXPathContext context, String key, String value) { [EOL]     return context.getPointerByKey(key, value); [EOL] }
public Pointer getPointerByKey(JXPathContext context, String key, String value) { [EOL]     return context.getPointerByKey(key, value); [EOL] }
public Pointer getPointerByKey(JXPathContext context, String key, String value) { [EOL]     return context.getPointerByKey(key, value); [EOL] }
public Pointer getPointerByKey(JXPathContext context, String key, String value) { [EOL]     return context.getPointerByKey(key, value); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public void setValue(Object value) { [EOL]     attr.setValue((String) TypeUtils.convert(value, String.class)); [EOL] }
public void setValue(Object value) { [EOL]     attr.setValue((String) TypeUtils.convert(value, String.class)); [EOL] }
public void setValue(Object value) { [EOL]     attr.setValue((String) TypeUtils.convert(value, String.class)); [EOL] }
public void remove() { [EOL]     attr.getParent().removeAttribute(attr); [EOL] }
public void remove() { [EOL]     attr.getParent().removeAttribute(attr); [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static Object expandCollection(Object collection, int size) { [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         Object bigger = Array.newInstance(collection.getClass().getComponentType(), size); [EOL]         System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection)); [EOL]         return bigger; [EOL]     } else if (collection instanceof Collection) { [EOL]         while (((Collection) collection).size() < size) { [EOL]             ((Collection) collection).add(null); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot turn " + collection.getClass().getName() + " into a collection of size " + size); [EOL]     } [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static void setValue(Object collection, int index, Object value) { [EOL]     collection = getValue(collection); [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             Array.set(collection, index, convert(value, collection.getClass().getComponentType())); [EOL]         } else if (collection instanceof List) { [EOL]             ((List) collection).set(index, value); [EOL]         } else if (collection instanceof Collection) { [EOL]             throw new UnsupportedOperationException("Cannot set value of an element of a " + collection.getClass().getName()); [EOL]         } [EOL]     } [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedReadMethod(); [EOL]             if (method != null) { [EOL]                 return method.invoke(bean, new Object[] { new Integer(index) }); [EOL]             } [EOL]         } catch (InvocationTargetException ex) { [EOL]             Throwable t = ((InvocationTargetException) ex).getTargetException(); [EOL]             if (t instanceof ArrayIndexOutOfBoundsException) { [EOL]                 return null; [EOL]             } [EOL]             throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), t); [EOL]         } catch (Throwable ex) { [EOL]             throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), ex); [EOL]         } [EOL]     } [EOL]     return getValue(getValue(bean, propertyDescriptor), index); [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public QName getName() { [EOL]     return null; [EOL] }
public Object getBaseValue() { [EOL]     return container; [EOL] }
public int getLength() { [EOL]     Object value = getBaseValue(); [EOL]     if (value == null) { [EOL]         return 1; [EOL]     } [EOL]     return ValueUtils.getLength(value); [EOL] }
public int getLength() { [EOL]     Object value = getBaseValue(); [EOL]     if (value == null) { [EOL]         return 1; [EOL]     } [EOL]     return ValueUtils.getLength(value); [EOL] }
public Object getImmediateNode() { [EOL]     Object value = getBaseValue(); [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index >= 0 && index < getLength()) { [EOL]             return ValueUtils.getValue(value, index); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         return ValueUtils.getValue(value); [EOL]     } [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         Object value = getImmediateNode(); [EOL]         valuePointer = NodePointer.newChildNodePointer(this, getName(), value); [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         Object value = getImmediateNode(); [EOL]         valuePointer = NodePointer.newChildNodePointer(this, getName(), value); [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator namespaceIterator() { [EOL]     return getValuePointer().namespaceIterator(); [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL]     switch(pos) { [EOL]         case 0: [EOL]             if ((active1 & 0xc0000L) != 0L) [EOL]                 return 10; [EOL]             if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 1: [EOL]             if ((active0 & 0x8000008000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 1; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 2: [EOL]             if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 2; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 3: [EOL]             if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL]                 if (jjmatchedPos != 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 4: [EOL]             if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 4; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 5: [EOL]             if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL]                 if (jjmatchedPos != 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 6: [EOL]             if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 6; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 7: [EOL]             if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 7; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x802000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 8: [EOL]             if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 if (jjmatchedPos != 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 9: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 9; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 10: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 10; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 11: [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 11; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 12: [EOL]             if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 12; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 13: [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 13; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 14: [EOL]             if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x1000f00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 14; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 15: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xf00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 15; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 16: [EOL]             if ((active0 & 0xe00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 16; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 17: [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 17; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 18: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 18; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 19: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 19; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 20: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 20; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         default: [EOL]             return -1; [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjStopAtPos(int pos, int kind) { [EOL]     jjmatchedKind = kind; [EOL]     jjmatchedPos = pos; [EOL]     return pos + 1; [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(0, active0, active1); [EOL]         return 1; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 46: [EOL]             if ((active1 & 0x80000L) != 0L) [EOL]                 return jjStopAtPos(1, 83); [EOL]             break; [EOL]         case 47: [EOL]             if ((active0 & 0x80L) != 0L) [EOL]                 return jjStopAtPos(1, 7); [EOL]             break; [EOL]         case 61: [EOL]             if ((active0 & 0x1000L) != 0L) [EOL]                 return jjStopAtPos(1, 12); [EOL]             else if ((active0 & 0x4000L) != 0L) [EOL]                 return jjStopAtPos(1, 14); [EOL]             else if ((active0 & 0x10000L) != 0L) [EOL]                 return jjStopAtPos(1, 16); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL]         case 100: [EOL]             if ((active0 & 0x8000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 51, 12); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL]         case 104: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL]         case 114: [EOL]             if ((active0 & 0x8000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 27, 12); [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(0, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(0, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(1, active0, active1); [EOL]         return 2; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL]         case 100: [EOL]             if ((active0 & 0x10000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 28, 12); [EOL]             else if ((active0 & 0x20000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 29, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL]         case 109: [EOL]             if ((active1 & 0x200L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 73, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active1 & 0x8L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 67, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL]         case 118: [EOL]             if ((active0 & 0x40000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 30, 12); [EOL]             break; [EOL]         case 120: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL]         case 121: [EOL]             if ((active0 & 0x10000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 52, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(1, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(2, active0, active1); [EOL]         return 3; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x80000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 31, 12); [EOL]             else if ((active0 & 0x80000000000000L) != 0L) { [EOL]                 jjmatchedKind = 55; [EOL]                 jjmatchedPos = 3; [EOL]             } else if ((active1 & 0x10L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 68, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x80L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 71, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL]         case 108: [EOL]             if ((active1 & 0x40L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 70, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL]         case 116: [EOL]             if ((active0 & 0x100000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 32, 12); [EOL]             else if ((active0 & 0x1000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 48, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(2, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(2, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(3, active0, active1); [EOL]         return 4; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL]         case 100: [EOL]             if ((active1 & 0x1000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 76, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x20L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 69, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x400L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 74, 12); [EOL]             break; [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL]         case 116: [EOL]             if ((active0 & 0x4000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 50, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(3, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(3, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(4, active0, active1); [EOL]         return 5; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x800000000L) != 0L) [EOL]                 return jjStopAtPos(5, 35); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active0 & 0x100000000000000L) != 0L) { [EOL]                 jjmatchedKind = 56; [EOL]                 jjmatchedPos = 5; [EOL]             } [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x100L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 72, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 57, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(4, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(4, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(5, active0, active1); [EOL]         return 6; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL]         case 58: [EOL]             if ((active0 & 0x1000000000L) != 0L) [EOL]                 return jjStopAtPos(6, 36); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x800L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 75, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL]         case 110: [EOL]             if ((active1 & 0x4L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 66, 12); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 33, 12); [EOL]             break; [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(5, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(6, active0, active1); [EOL]         return 7; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x2000000000L) != 0L) [EOL]                 return jjStopAtPos(7, 37); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 110: [EOL]             if ((active0 & 0x2000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 49, 12); [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL]         case 115: [EOL]             if ((active0 & 0x800000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 59, 12); [EOL]             break; [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 122: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(6, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(7, active0, active1); [EOL]         return 8; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x2L) != 0L) [EOL]                 return jjStartNfaWithStates_0(8, 65, 12); [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL]         case 103: [EOL]             if ((active0 & 0x4000000000000000L) != 0L) { [EOL]                 jjmatchedKind = 62; [EOL]                 jjmatchedPos = 8; [EOL]             } [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(7, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(8, active0, active1); [EOL]         return 9; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL]         case 58: [EOL]             if ((active0 & 0x4000000000L) != 0L) [EOL]                 return jjStopAtPos(9, 38); [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(9, 53, 12); [EOL]             break; [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(8, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(9, active0, active1); [EOL]         return 10; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x8000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 39); [EOL]             else if ((active0 & 0x10000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 40); [EOL]             else if ((active0 & 0x20000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 41); [EOL]             else if ((active0 & 0x40000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 42); [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(10, 58, 12); [EOL]             break; [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(9, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(9, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(10, active0, active1); [EOL]         return 11; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x80000000000L) != 0L) [EOL]                 return jjStopAtPos(11, 43); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(10, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(10, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(11, active0, active1); [EOL]         return 12; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x8000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 63, 12); [EOL]             break; [EOL]         case 105: [EOL]             if ((active0 & 0x40000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 54, 12); [EOL]             break; [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x2000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 77, 12); [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(11, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(11, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(12, active0, active1); [EOL]         return 13; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(12, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(12, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(13, active0, active1); [EOL]         return 14; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active1 & 0x1L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 64, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active0 & 0x2000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 61, 12); [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(13, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(13, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(14, active0, 0L); [EOL]         return 15; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(15, 60, 12); [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(14, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(14, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(15, active0, 0L); [EOL]         return 16; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(15, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(15, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(16, active0, 0L); [EOL]         return 17; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x100000000000L) != 0L) [EOL]                 return jjStopAtPos(17, 44); [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(16, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(16, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(17, active0, 0L); [EOL]         return 18; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x200000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 45); [EOL]             else if ((active0 & 0x400000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 46); [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(17, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final void jjCheckNAdd(int state) { [EOL]     if (jjrounds[state] != jjround) { [EOL]         jjstateSet[jjnewStateCnt++] = state; [EOL]         jjrounds[state] = jjround; [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final void jjCheckNAddTwoStates(int state1, int state2) { [EOL]     jjCheckNAdd(state1); [EOL]     jjCheckNAdd(state2); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveNfa_0(int startState, int curPos) { [EOL]     int[] nextStates; [EOL]     int startsAt = 0; [EOL]     jjnewStateCnt = 13; [EOL]     int i = 1; [EOL]     jjstateSet[0] = startState; [EOL]     int j, kind = 0x7fffffff; [EOL]     for (; ; ) { [EOL]         if (++jjround == 0x7fffffff) [EOL]             ReInitRounds(); [EOL]         if (curChar < 64) { [EOL]             long l = 1L << curChar; [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if ((0x3ff000000000000L & l) != 0L) { [EOL]                             if (kind > 20) [EOL]                                 kind = 20; [EOL]                             jjCheckNAddTwoStates(6, 7); [EOL]                         } else if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         else if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         else if (curChar == 34) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 1: [EOL]                         if ((0xfffffffbffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 2: [EOL]                         if (curChar == 34 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 3: [EOL]                         if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 4: [EOL]                         if ((0xffffff7fffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 5: [EOL]                         if (curChar == 39 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 6: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAddTwoStates(6, 7); [EOL]                         break; [EOL]                     case 7: [EOL]                         if (curChar != 46) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 8: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 9: [EOL]                         if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 10: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 12: [EOL]                         if ((0x3ff600000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjstateSet[jjnewStateCnt++] = 12; [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else if (curChar < 128) { [EOL]             long l = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                     case 12: [EOL]                         if ((0x7fffffe87fffffeL & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         jjAddStates(2, 3); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else { [EOL]             int hiByte = (int) (curChar >> 8); [EOL]             int i1 = hiByte >> 6; [EOL]             long l1 = 1L << (hiByte & 077); [EOL]             int i2 = (curChar & 0xff) >> 6; [EOL]             long l2 = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(2, 3); [EOL]                         break; [EOL]                     case 12: [EOL]                         if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } [EOL]         if (kind != 0x7fffffff) { [EOL]             jjmatchedKind = kind; [EOL]             jjmatchedPos = curPos; [EOL]             kind = 0x7fffffff; [EOL]         } [EOL]         ++curPos; [EOL]         if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL]             return curPos; [EOL]         try { [EOL]             curChar = input_stream.readChar(); [EOL]         } catch (java.io.IOException e) { [EOL]             return curPos; [EOL]         } [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public void ReInit(SimpleCharStream stream) { [EOL]     jjmatchedPos = jjnewStateCnt = 0; [EOL]     curLexState = defaultLexState; [EOL]     input_stream = stream; [EOL]     ReInitRounds(); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public void ReInit(SimpleCharStream stream) { [EOL]     jjmatchedPos = jjnewStateCnt = 0; [EOL]     curLexState = defaultLexState; [EOL]     input_stream = stream; [EOL]     ReInitRounds(); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public void ReInit(SimpleCharStream stream) { [EOL]     jjmatchedPos = jjnewStateCnt = 0; [EOL]     curLexState = defaultLexState; [EOL]     input_stream = stream; [EOL]     ReInitRounds(); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public void ReInit(SimpleCharStream stream) { [EOL]     jjmatchedPos = jjnewStateCnt = 0; [EOL]     curLexState = defaultLexState; [EOL]     input_stream = stream; [EOL]     ReInitRounds(); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final void ReInitRounds() { [EOL]     int i; [EOL]     jjround = 0x80000001; [EOL]     for (i = 13; i-- > 0; ) jjrounds[i] = 0x80000000; [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
protected Token jjFillToken() { [EOL]     Token t = Token.newToken(jjmatchedKind); [EOL]     t.kind = jjmatchedKind; [EOL]     String im = jjstrLiteralImages[jjmatchedKind]; [EOL]     t.image = (im == null) ? input_stream.GetImage() : im; [EOL]     t.beginLine = input_stream.getBeginLine(); [EOL]     t.beginColumn = input_stream.getBeginColumn(); [EOL]     t.endLine = input_stream.getEndLine(); [EOL]     t.endColumn = input_stream.getEndColumn(); [EOL]     return t; [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public Token getNextToken() { [EOL]     int kind; [EOL]     Token specialToken = null; [EOL]     Token matchedToken; [EOL]     int curPos = 0; [EOL]     EOFLoop: for (; ; ) { [EOL]         try { [EOL]             curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e) { [EOL]             jjmatchedKind = 0; [EOL]             matchedToken = jjFillToken(); [EOL]             return matchedToken; [EOL]         } [EOL]         try { [EOL]             input_stream.backup(0); [EOL]             while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L) curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e1) { [EOL]             continue EOFLoop; [EOL]         } [EOL]         jjmatchedKind = 0x7fffffff; [EOL]         jjmatchedPos = 0; [EOL]         curPos = jjMoveStringLiteralDfa0_0(); [EOL]         if (jjmatchedKind != 0x7fffffff) { [EOL]             if (jjmatchedPos + 1 < curPos) [EOL]                 input_stream.backup(curPos - jjmatchedPos - 1); [EOL]             if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { [EOL]                 matchedToken = jjFillToken(); [EOL]                 return matchedToken; [EOL]             } else { [EOL]                 continue EOFLoop; [EOL]             } [EOL]         } [EOL]         int error_line = input_stream.getEndLine(); [EOL]         int error_column = input_stream.getEndColumn(); [EOL]         String error_after = null; [EOL]         boolean EOFSeen = false; [EOL]         try { [EOL]             input_stream.readChar(); [EOL]             input_stream.backup(1); [EOL]         } catch (java.io.IOException e1) { [EOL]             EOFSeen = true; [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]             if (curChar == '\n' || curChar == '\r') { [EOL]                 error_line++; [EOL]                 error_column = 0; [EOL]             } else [EOL]                 error_column++; [EOL]         } [EOL]         if (!EOFSeen) { [EOL]             input_stream.backup(1); [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]         } [EOL]         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public Token getNextToken() { [EOL]     int kind; [EOL]     Token specialToken = null; [EOL]     Token matchedToken; [EOL]     int curPos = 0; [EOL]     EOFLoop: for (; ; ) { [EOL]         try { [EOL]             curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e) { [EOL]             jjmatchedKind = 0; [EOL]             matchedToken = jjFillToken(); [EOL]             return matchedToken; [EOL]         } [EOL]         try { [EOL]             input_stream.backup(0); [EOL]             while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L) curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e1) { [EOL]             continue EOFLoop; [EOL]         } [EOL]         jjmatchedKind = 0x7fffffff; [EOL]         jjmatchedPos = 0; [EOL]         curPos = jjMoveStringLiteralDfa0_0(); [EOL]         if (jjmatchedKind != 0x7fffffff) { [EOL]             if (jjmatchedPos + 1 < curPos) [EOL]                 input_stream.backup(curPos - jjmatchedPos - 1); [EOL]             if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { [EOL]                 matchedToken = jjFillToken(); [EOL]                 return matchedToken; [EOL]             } else { [EOL]                 continue EOFLoop; [EOL]             } [EOL]         } [EOL]         int error_line = input_stream.getEndLine(); [EOL]         int error_column = input_stream.getEndColumn(); [EOL]         String error_after = null; [EOL]         boolean EOFSeen = false; [EOL]         try { [EOL]             input_stream.readChar(); [EOL]             input_stream.backup(1); [EOL]         } catch (java.io.IOException e1) { [EOL]             EOFSeen = true; [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]             if (curChar == '\n' || curChar == '\r') { [EOL]                 error_line++; [EOL]                 error_column = 0; [EOL]             } else [EOL]                 error_column++; [EOL]         } [EOL]         if (!EOFSeen) { [EOL]             input_stream.backup(1); [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]         } [EOL]         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public Token getNextToken() { [EOL]     int kind; [EOL]     Token specialToken = null; [EOL]     Token matchedToken; [EOL]     int curPos = 0; [EOL]     EOFLoop: for (; ; ) { [EOL]         try { [EOL]             curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e) { [EOL]             jjmatchedKind = 0; [EOL]             matchedToken = jjFillToken(); [EOL]             return matchedToken; [EOL]         } [EOL]         try { [EOL]             input_stream.backup(0); [EOL]             while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L) curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e1) { [EOL]             continue EOFLoop; [EOL]         } [EOL]         jjmatchedKind = 0x7fffffff; [EOL]         jjmatchedPos = 0; [EOL]         curPos = jjMoveStringLiteralDfa0_0(); [EOL]         if (jjmatchedKind != 0x7fffffff) { [EOL]             if (jjmatchedPos + 1 < curPos) [EOL]                 input_stream.backup(curPos - jjmatchedPos - 1); [EOL]             if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { [EOL]                 matchedToken = jjFillToken(); [EOL]                 return matchedToken; [EOL]             } else { [EOL]                 continue EOFLoop; [EOL]             } [EOL]         } [EOL]         int error_line = input_stream.getEndLine(); [EOL]         int error_column = input_stream.getEndColumn(); [EOL]         String error_after = null; [EOL]         boolean EOFSeen = false; [EOL]         try { [EOL]             input_stream.readChar(); [EOL]             input_stream.backup(1); [EOL]         } catch (java.io.IOException e1) { [EOL]             EOFSeen = true; [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]             if (curChar == '\n' || curChar == '\r') { [EOL]                 error_line++; [EOL]                 error_column = 0; [EOL]             } else [EOL]                 error_column++; [EOL]         } [EOL]         if (!EOFSeen) { [EOL]             input_stream.backup(1); [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]         } [EOL]         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public Token getNextToken() { [EOL]     int kind; [EOL]     Token specialToken = null; [EOL]     Token matchedToken; [EOL]     int curPos = 0; [EOL]     EOFLoop: for (; ; ) { [EOL]         try { [EOL]             curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e) { [EOL]             jjmatchedKind = 0; [EOL]             matchedToken = jjFillToken(); [EOL]             return matchedToken; [EOL]         } [EOL]         try { [EOL]             input_stream.backup(0); [EOL]             while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L) curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e1) { [EOL]             continue EOFLoop; [EOL]         } [EOL]         jjmatchedKind = 0x7fffffff; [EOL]         jjmatchedPos = 0; [EOL]         curPos = jjMoveStringLiteralDfa0_0(); [EOL]         if (jjmatchedKind != 0x7fffffff) { [EOL]             if (jjmatchedPos + 1 < curPos) [EOL]                 input_stream.backup(curPos - jjmatchedPos - 1); [EOL]             if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { [EOL]                 matchedToken = jjFillToken(); [EOL]                 return matchedToken; [EOL]             } else { [EOL]                 continue EOFLoop; [EOL]             } [EOL]         } [EOL]         int error_line = input_stream.getEndLine(); [EOL]         int error_column = input_stream.getEndColumn(); [EOL]         String error_after = null; [EOL]         boolean EOFSeen = false; [EOL]         try { [EOL]             input_stream.readChar(); [EOL]             input_stream.backup(1); [EOL]         } catch (java.io.IOException e1) { [EOL]             EOFSeen = true; [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]             if (curChar == '\n' || curChar == '\r') { [EOL]                 error_line++; [EOL]                 error_column = 0; [EOL]             } else [EOL]                 error_column++; [EOL]         } [EOL]         if (!EOFSeen) { [EOL]             input_stream.backup(1); [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]         } [EOL]         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public NodeIterator namespaceIterator() { [EOL]     return new DOMNamespaceIterator(this); [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]         String string = (String) TypeUtils.convert(value, String.class); [EOL]         if (string != null && !string.equals("")) { [EOL]             node.setNodeValue(string); [EOL]         } else { [EOL]             node.getParentNode().removeChild(node); [EOL]         } [EOL]     } else { [EOL]         NodeList children = node.getChildNodes(); [EOL]         int count = children.getLength(); [EOL]         for (int i = count; --i >= 0; ) { [EOL]             Node child = children.item(i); [EOL]             node.removeChild(child); [EOL]         } [EOL]         if (value instanceof Node) { [EOL]             Node valueNode = (Node) value; [EOL]             if (valueNode instanceof Element || valueNode instanceof Document) { [EOL]                 children = valueNode.getChildNodes(); [EOL]                 for (int i = 0; i < children.getLength(); i++) { [EOL]                     Node child = children.item(i); [EOL]                     node.appendChild(child.cloneNode(true)); [EOL]                 } [EOL]             } else { [EOL]                 node.appendChild(valueNode.cloneNode(true)); [EOL]             } [EOL]         } else { [EOL]             String string = (String) TypeUtils.convert(value, String.class); [EOL]             if (string != null && !string.equals("")) { [EOL]                 Node textNode = node.getOwnerDocument().createTextNode(string); [EOL]                 node.appendChild(textNode); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } [EOL]     boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index); [EOL]     if (success) { [EOL]         NodeTest nodeTest; [EOL]         String prefix = name.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getNamespaceURI(prefix) : context.getDefaultNamespaceURI(); [EOL]         nodeTest = new NodeNameTest(name, namespaceURI); [EOL]         NodeIterator it = childIterator(nodeTest, false, null); [EOL]         if (it != null && it.setPosition(index + 1)) { [EOL]             return it.getNodePointer(); [EOL]         } [EOL]     } [EOL]     throw new JXPathAbstractFactoryException("Factory could not create a child node for path: " + asPath() + "/" + name + "[" + (index + 1) + "]"); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } [EOL]     boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index); [EOL]     if (success) { [EOL]         NodeTest nodeTest; [EOL]         String prefix = name.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getNamespaceURI(prefix) : context.getDefaultNamespaceURI(); [EOL]         nodeTest = new NodeNameTest(name, namespaceURI); [EOL]         NodeIterator it = childIterator(nodeTest, false, null); [EOL]         if (it != null && it.setPosition(index + 1)) { [EOL]             return it.getNodePointer(); [EOL]         } [EOL]     } [EOL]     throw new JXPathAbstractFactoryException("Factory could not create a child node for path: " + asPath() + "/" + name + "[" + (index + 1) + "]"); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } [EOL]     boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index); [EOL]     if (success) { [EOL]         NodeTest nodeTest; [EOL]         String prefix = name.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getNamespaceURI(prefix) : context.getDefaultNamespaceURI(); [EOL]         nodeTest = new NodeNameTest(name, namespaceURI); [EOL]         NodeIterator it = childIterator(nodeTest, false, null); [EOL]         if (it != null && it.setPosition(index + 1)) { [EOL]             return it.getNodePointer(); [EOL]         } [EOL]     } [EOL]     throw new JXPathAbstractFactoryException("Factory could not create a child node for path: " + asPath() + "/" + name + "[" + (index + 1) + "]"); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         String ns = getNamespaceURI(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         element.setAttributeNS(ns, name.toString(), ""); [EOL]     } else { [EOL]         if (!element.hasAttribute(name.getName())) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         String ns = getNamespaceURI(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         element.setAttributeNS(ns, name.toString(), ""); [EOL]     } else { [EOL]         if (!element.hasAttribute(name.getName())) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         String ns = getNamespaceURI(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         element.setAttributeNS(ns, name.toString(), ""); [EOL]     } else { [EOL]         if (!element.hasAttribute(name.getName())) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         String ns = getNamespaceURI(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         element.setAttributeNS(ns, name.toString(), ""); [EOL]     } else { [EOL]         if (!element.hasAttribute(name.getName())) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     if (!(node instanceof Element)) { [EOL]         return super.createAttribute(context, name); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String prefix = name.getPrefix(); [EOL]     if (prefix != null) { [EOL]         String ns = getNamespaceURI(prefix); [EOL]         if (ns == null) { [EOL]             throw new JXPathException("Unknown namespace prefix: " + prefix); [EOL]         } [EOL]         element.setAttributeNS(ns, name.toString(), ""); [EOL]     } else { [EOL]         if (!element.hasAttribute(name.getName())) { [EOL]             element.setAttribute(name.getName(), ""); [EOL]         } [EOL]     } [EOL]     NodeIterator it = attributeIterator(name); [EOL]     it.setPosition(1); [EOL]     return it.getNodePointer(); [EOL] }
public void remove() { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent == null) { [EOL]         throw new JXPathException("Cannot remove root DOM node"); [EOL]     } [EOL]     parent.removeChild(node); [EOL] }
public void remove() { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent == null) { [EOL]         throw new JXPathException("Cannot remove root DOM node"); [EOL]     } [EOL]     parent.removeChild(node); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.TEXT_NODE || n.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.TEXT_NODE || n.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfTextNode() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.TEXT_NODE || n.getNodeType() == Node.CDATA_SECTION_NODE) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
public int hashCode() { [EOL]     return System.identityHashCode(node); [EOL] }
public static String getLocalName(Node node) { [EOL]     String localName = node.getLocalName(); [EOL]     if (localName != null) { [EOL]         return localName; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return name; [EOL]     } [EOL]     return name.substring(index + 1); [EOL] }
public static String getLocalName(Node node) { [EOL]     String localName = node.getLocalName(); [EOL]     if (localName != null) { [EOL]         return localName; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return name; [EOL]     } [EOL]     return name.substring(index + 1); [EOL] }
public static String getLocalName(Node node) { [EOL]     String localName = node.getLocalName(); [EOL]     if (localName != null) { [EOL]         return localName; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return name; [EOL]     } [EOL]     return name.substring(index + 1); [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - " + "cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
public ClassFunctions(Class functionClass, String namespace) { [EOL]     this.functionClass = functionClass; [EOL]     this.namespace = namespace; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL]     this.namespaceURI = namespaceURI; [EOL] }
public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     this.node = (Node) parent.getNode(); [EOL]     if (startWith != null) { [EOL]         this.child = (Node) startWith.getNode(); [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     this.node = (Node) parent.getNode(); [EOL]     if (startWith != null) { [EOL]         this.child = (Node) startWith.getNode(); [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             if (child == null) { [EOL]                 child = node.getFirstChild(); [EOL]             } else { [EOL]                 child = child.getNextSibling(); [EOL]             } [EOL]         } else { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } else { [EOL]         if (position == 1) { [EOL]             if (child == null) { [EOL]                 child = node.getLastChild(); [EOL]             } else { [EOL]                 child = child.getPreviousSibling(); [EOL]             } [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
public QName getName() { [EOL]     return new QName(DOMNodePointer.getPrefix(attr), DOMNodePointer.getLocalName(attr)); [EOL] }
public QName getName() { [EOL]     return new QName(DOMNodePointer.getPrefix(attr), DOMNodePointer.getLocalName(attr)); [EOL] }
public void remove() { [EOL]     attr.getOwnerElement().removeAttributeNode(attr); [EOL] }
public void remove() { [EOL]     attr.getOwnerElement().removeAttributeNode(attr); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append('@'); [EOL]     buffer.append(getName()); [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append('@'); [EOL]     buffer.append(getName()); [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append('@'); [EOL]     buffer.append(getName()); [EOL]     return buffer.toString(); [EOL] }
private void prepare() { [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (startFromParentLocation) { [EOL]         NodePointer pointer = parent.getParent(); [EOL]         iterator = pointer.childIterator(nodeTest, reverse, parent); [EOL]     } else { [EOL]         iterator = parent.childIterator(nodeTest, reverse, null); [EOL]     } [EOL] }
private void prepare() { [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (startFromParentLocation) { [EOL]         NodePointer pointer = parent.getParent(); [EOL]         iterator = pointer.childIterator(nodeTest, reverse, parent); [EOL]     } else { [EOL]         iterator = parent.childIterator(nodeTest, reverse, null); [EOL]     } [EOL] }
private void prepare() { [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (startFromParentLocation) { [EOL]         NodePointer pointer = parent.getParent(); [EOL]         iterator = pointer.childIterator(nodeTest, reverse, parent); [EOL]     } else { [EOL]         iterator = parent.childIterator(nodeTest, reverse, null); [EOL]     } [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer((Node) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer((Node) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
private boolean testAttr(Attr attr, QName testName) { [EOL]     String nodePrefix = DOMNodePointer.getPrefix(attr); [EOL]     String nodeLocalName = DOMNodePointer.getLocalName(attr); [EOL]     if (nodePrefix != null && nodePrefix.equals("xmlns")) { [EOL]         return false; [EOL]     } [EOL]     if (nodePrefix == null && nodeLocalName.equals("xmlns")) { [EOL]         return false; [EOL]     } [EOL]     String testLocalName = name.getName(); [EOL]     if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (equalStrings(testPrefix, nodePrefix)) { [EOL]             return true; [EOL]         } [EOL]         String testNS = null; [EOL]         if (testPrefix != null) { [EOL]             testNS = parent.getNamespaceURI(testPrefix); [EOL]         } [EOL]         String nodeNS = null; [EOL]         if (nodePrefix != null) { [EOL]             nodeNS = parent.getNamespaceURI(nodePrefix); [EOL]         } [EOL]         return equalStrings(testNS, nodeNS); [EOL]     } [EOL]     return false; [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         propertyIndex = index; [EOL]         setIndex(WHOLE_COLLECTION); [EOL]     } [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         propertyIndex = index; [EOL]         setIndex(WHOLE_COLLECTION); [EOL]     } [EOL] }
public boolean isCollection() { [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public int getLength() { [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public int getLength() { [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (getImmediateNode() == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         int inx = (index == WHOLE_COLLECTION ? 0 : index); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), inx); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory " + factory + " could not create an object for path: " + asPath()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (getImmediateNode() == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         int inx = (index == WHOLE_COLLECTION ? 0 : index); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), inx); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory " + factory + " could not create an object for path: " + asPath()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (getImmediateNode() == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         int inx = (index == WHOLE_COLLECTION ? 0 : index); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), inx); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory " + factory + " could not create an object for path: " + asPath()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index != WHOLE_COLLECTION && index >= getLength()) { [EOL]         createPath(context); [EOL]     } [EOL]     setValue(value); [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     PropertyPointer prop = (PropertyPointer) clone(); [EOL]     if (name != null) { [EOL]         prop.setPropertyName(name.toString()); [EOL]     } [EOL]     prop.setIndex(index); [EOL]     return prop.createPath(context, value); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     PropertyPointer prop = (PropertyPointer) clone(); [EOL]     if (name != null) { [EOL]         prop.setPropertyName(name.toString()); [EOL]     } [EOL]     prop.setIndex(index); [EOL]     return prop.createPath(context, value); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     PropertyPointer prop = (PropertyPointer) clone(); [EOL]     if (name != null) { [EOL]         prop.setPropertyName(name.toString()); [EOL]     } [EOL]     prop.setIndex(index); [EOL]     return prop.createPath(context); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     PropertyPointer prop = (PropertyPointer) clone(); [EOL]     if (name != null) { [EOL]         prop.setPropertyName(name.toString()); [EOL]     } [EOL]     prop.setIndex(index); [EOL]     return prop.createPath(context); [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the " + "JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
public CoreOperationAdd(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperationAdd(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperationAdd(Expression[] args) { [EOL]     super(args); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double s = 0.0; [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         s += InfoSetUtil.doubleValue(args[i].computeValue(context)); [EOL]     } [EOL]     return new Double(s); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double s = 0.0; [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         s += InfoSetUtil.doubleValue(args[i].computeValue(context)); [EOL]     } [EOL]     return new Double(s); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double s = 0.0; [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         s += InfoSetUtil.doubleValue(args[i].computeValue(context)); [EOL]     } [EOL]     return new Double(s); [EOL] }
protected int getPrecedence() { [EOL]     return 4; [EOL] }
public String getSymbol() { [EOL]     return "+"; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer((Container) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer((Container) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public LangAttributePointer(NodePointer parent) { [EOL]     super(parent); [EOL] }
public Object getBaseValue() { [EOL]     return parent.getLocale().toString().replace('_', '-'); [EOL] }
public Object getBaseValue() { [EOL]     return parent.getLocale().toString().replace('_', '-'); [EOL] }
public Object getImmediateNode() { [EOL]     return getBaseValue(); [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof DynaBean) { [EOL]         return new DynaBeanPointer(name, (DynaBean) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof DynaBean) { [EOL]         return new DynaBeanPointer(name, (DynaBean) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (ValueUtils.isCollection(bean)) { [EOL]         return new CollectionPointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (ValueUtils.isCollection(bean)) { [EOL]         return new CollectionPointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean, Pointer contextPointer) { [EOL]     super(parentContext, contextBean); [EOL]     synchronized (nodeFactories) { [EOL]         createNodeFactoryArray(); [EOL]     } [EOL]     if (contextPointer != null) { [EOL]         this.contextPointer = contextPointer; [EOL]         this.rootPointer = NodePointer.newNodePointer(new QName(null, "root"), contextPointer.getRootNode(), getLocale()); [EOL]     } else { [EOL]         this.contextPointer = NodePointer.newNodePointer(new QName(null, "root"), contextBean, getLocale()); [EOL]         this.rootPointer = this.contextPointer; [EOL]     } [EOL]     NamespaceResolver parentNR = null; [EOL]     if (parentContext instanceof JXPathContextReferenceImpl) { [EOL]         parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver(); [EOL]     } [EOL]     namespaceResolver = new NamespaceResolver(parentNR); [EOL]     namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer); [EOL] }
public JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean, Pointer contextPointer) { [EOL]     super(parentContext, contextBean); [EOL]     synchronized (nodeFactories) { [EOL]         createNodeFactoryArray(); [EOL]     } [EOL]     if (contextPointer != null) { [EOL]         this.contextPointer = contextPointer; [EOL]         this.rootPointer = NodePointer.newNodePointer(new QName(null, "root"), contextPointer.getRootNode(), getLocale()); [EOL]     } else { [EOL]         this.contextPointer = NodePointer.newNodePointer(new QName(null, "root"), contextBean, getLocale()); [EOL]         this.rootPointer = this.contextPointer; [EOL]     } [EOL]     NamespaceResolver parentNR = null; [EOL]     if (parentContext instanceof JXPathContextReferenceImpl) { [EOL]         parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver(); [EOL]     } [EOL]     namespaceResolver = new NamespaceResolver(parentNR); [EOL]     namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer); [EOL] }
public JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean, Pointer contextPointer) { [EOL]     super(parentContext, contextBean); [EOL]     synchronized (nodeFactories) { [EOL]         createNodeFactoryArray(); [EOL]     } [EOL]     if (contextPointer != null) { [EOL]         this.contextPointer = contextPointer; [EOL]         this.rootPointer = NodePointer.newNodePointer(new QName(null, "root"), contextPointer.getRootNode(), getLocale()); [EOL]     } else { [EOL]         this.contextPointer = NodePointer.newNodePointer(new QName(null, "root"), contextBean, getLocale()); [EOL]         this.rootPointer = this.contextPointer; [EOL]     } [EOL]     NamespaceResolver parentNR = null; [EOL]     if (parentContext instanceof JXPathContextReferenceImpl) { [EOL]         parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver(); [EOL]     } [EOL]     namespaceResolver = new NamespaceResolver(parentNR); [EOL]     namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer); [EOL] }
private static void createNodeFactoryArray() { [EOL]     if (nodeFactoryArray == null) { [EOL]         nodeFactoryArray = (NodePointerFactory[]) nodeFactories.toArray(new NodePointerFactory[0]); [EOL]         Arrays.sort(nodeFactoryArray, new Comparator() { [EOL]  [EOL]             public int compare(Object a, Object b) { [EOL]                 int orderA = ((NodePointerFactory) a).getOrder(); [EOL]                 int orderB = ((NodePointerFactory) b).getOrder(); [EOL]                 return orderA - orderB; [EOL]             } [EOL]         }); [EOL]     } [EOL] }
private static void createNodeFactoryArray() { [EOL]     if (nodeFactoryArray == null) { [EOL]         nodeFactoryArray = (NodePointerFactory[]) nodeFactories.toArray(new NodePointerFactory[0]); [EOL]         Arrays.sort(nodeFactoryArray, new Comparator() { [EOL]  [EOL]             public int compare(Object a, Object b) { [EOL]                 int orderA = ((NodePointerFactory) a).getOrder(); [EOL]                 int orderB = ((NodePointerFactory) b).getOrder(); [EOL]                 return orderA - orderB; [EOL]             } [EOL]         }); [EOL]     } [EOL] }
protected Compiler getCompiler() { [EOL]     return COMPILER; [EOL] }
protected CompiledExpression compilePath(String xpath) { [EOL]     return new JXPathCompiledExpression(xpath, compileExpression(xpath)); [EOL] }
protected CompiledExpression compilePath(String xpath) { [EOL]     return new JXPathCompiledExpression(xpath, compileExpression(xpath)); [EOL] }
private Expression compileExpression(String xpath) { [EOL]     Expression expr; [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             expr = null; [EOL]             SoftReference ref = (SoftReference) compiled.get(xpath); [EOL]             if (ref != null) { [EOL]                 expr = (Expression) ref.get(); [EOL]             } [EOL]         } else { [EOL]             expr = (Expression) compiled.get(xpath); [EOL]         } [EOL]     } [EOL]     if (expr != null) { [EOL]         return expr; [EOL]     } [EOL]     expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL]                 Iterator it = compiled.entrySet().iterator(); [EOL]                 while (it.hasNext()) { [EOL]                     Entry me = (Entry) it.next(); [EOL]                     if (((SoftReference) me.getValue()).get() == null) { [EOL]                         it.remove(); [EOL]                     } [EOL]                 } [EOL]                 cleanupCount = 0; [EOL]             } [EOL]             compiled.put(xpath, new SoftReference(expr)); [EOL]         } else { [EOL]             compiled.put(xpath, expr); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] }
public void setValue(String xpath, Object value) { [EOL]     setValue(xpath, compileExpression(xpath), value); [EOL] }
public void setValue(String xpath, Object value) { [EOL]     setValue(xpath, compileExpression(xpath), value); [EOL] }
public void setValue(String xpath, Object value) { [EOL]     setValue(xpath, compileExpression(xpath), value); [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPathAndSetValue(String xpath, Object value) { [EOL]     return createPathAndSetValue(xpath, compileExpression(xpath), value); [EOL] }
public Pointer createPathAndSetValue(String xpath, Object value) { [EOL]     return createPathAndSetValue(xpath, compileExpression(xpath), value); [EOL] }
public Pointer createPathAndSetValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         return setValue(xpath, expr, value, true); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPathAndSetValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         return setValue(xpath, expr, value, true); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
public JXPathContext getRelativeContext(Pointer pointer) { [EOL]     Object contextBean = pointer.getNode(); [EOL]     if (contextBean == null) { [EOL]         throw new JXPathException("Cannot create a relative context for a non-existent node: " + pointer); [EOL]     } [EOL]     return new JXPathContextReferenceImpl(this, contextBean, pointer); [EOL] }
public JXPathContext getRelativeContext(Pointer pointer) { [EOL]     Object contextBean = pointer.getNode(); [EOL]     if (contextBean == null) { [EOL]         throw new JXPathException("Cannot create a relative context for a non-existent node: " + pointer); [EOL]     } [EOL]     return new JXPathContextReferenceImpl(this, contextBean, pointer); [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     String namespace = functionName.getPrefix(); [EOL]     String name = functionName.getName(); [EOL]     JXPathContext funcCtx = this; [EOL]     Function func = null; [EOL]     Functions funcs; [EOL]     while (funcCtx != null) { [EOL]         funcs = funcCtx.getFunctions(); [EOL]         if (funcs != null) { [EOL]             func = funcs.getFunction(namespace, name, parameters); [EOL]             if (func != null) { [EOL]                 return func; [EOL]             } [EOL]         } [EOL]         funcCtx = funcCtx.getParentContext(); [EOL]     } [EOL]     throw new JXPathFunctionNotFoundException("Undefined function: " + functionName.toString()); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     String namespace = functionName.getPrefix(); [EOL]     String name = functionName.getName(); [EOL]     JXPathContext funcCtx = this; [EOL]     Function func = null; [EOL]     Functions funcs; [EOL]     while (funcCtx != null) { [EOL]         funcs = funcCtx.getFunctions(); [EOL]         if (funcs != null) { [EOL]             func = funcs.getFunction(namespace, name, parameters); [EOL]             if (func != null) { [EOL]                 return func; [EOL]             } [EOL]         } [EOL]         funcCtx = funcCtx.getParentContext(); [EOL]     } [EOL]     throw new JXPathFunctionNotFoundException("Undefined function: " + functionName.toString()); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     String namespace = functionName.getPrefix(); [EOL]     String name = functionName.getName(); [EOL]     JXPathContext funcCtx = this; [EOL]     Function func = null; [EOL]     Functions funcs; [EOL]     while (funcCtx != null) { [EOL]         funcs = funcCtx.getFunctions(); [EOL]         if (funcs != null) { [EOL]             func = funcs.getFunction(namespace, name, parameters); [EOL]             if (func != null) { [EOL]                 return func; [EOL]             } [EOL]         } [EOL]         funcCtx = funcCtx.getParentContext(); [EOL]     } [EOL]     throw new JXPathFunctionNotFoundException("Undefined function: " + functionName.toString()); [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public static Object parseExpression(String expression, Compiler compiler) { [EOL]     synchronized (parser) { [EOL]         parser.setCompiler(compiler); [EOL]         Object expr = null; [EOL]         try { [EOL]             parser.ReInit(new StringReader(expression)); [EOL]             expr = parser.parseExpression(); [EOL]         } catch (TokenMgrError e) { [EOL]             throw new JXPathInvalidSyntaxException("Invalid XPath: '" + addEscapes(expression) + "'. Invalid symbol '" + addEscapes(String.valueOf(e.getCharacter())) + "' " + describePosition(expression, e.getPosition())); [EOL]         } catch (ParseException e) { [EOL]             throw new JXPathInvalidSyntaxException("Invalid XPath: '" + addEscapes(expression) + "'. Syntax error " + describePosition(expression, e.currentToken.beginColumn)); [EOL]         } [EOL]         return expr; [EOL]     } [EOL] }
public static Object parseExpression(String expression, Compiler compiler) { [EOL]     synchronized (parser) { [EOL]         parser.setCompiler(compiler); [EOL]         Object expr = null; [EOL]         try { [EOL]             parser.ReInit(new StringReader(expression)); [EOL]             expr = parser.parseExpression(); [EOL]         } catch (TokenMgrError e) { [EOL]             throw new JXPathInvalidSyntaxException("Invalid XPath: '" + addEscapes(expression) + "'. Invalid symbol '" + addEscapes(String.valueOf(e.getCharacter())) + "' " + describePosition(expression, e.getPosition())); [EOL]         } catch (ParseException e) { [EOL]             throw new JXPathInvalidSyntaxException("Invalid XPath: '" + addEscapes(expression) + "'. Syntax error " + describePosition(expression, e.currentToken.beginColumn)); [EOL]         } [EOL]         return expr; [EOL]     } [EOL] }
public static Object parseExpression(String expression, Compiler compiler) { [EOL]     synchronized (parser) { [EOL]         parser.setCompiler(compiler); [EOL]         Object expr = null; [EOL]         try { [EOL]             parser.ReInit(new StringReader(expression)); [EOL]             expr = parser.parseExpression(); [EOL]         } catch (TokenMgrError e) { [EOL]             throw new JXPathInvalidSyntaxException("Invalid XPath: '" + addEscapes(expression) + "'. Invalid symbol '" + addEscapes(String.valueOf(e.getCharacter())) + "' " + describePosition(expression, e.getPosition())); [EOL]         } catch (ParseException e) { [EOL]             throw new JXPathInvalidSyntaxException("Invalid XPath: '" + addEscapes(expression) + "'. Syntax error " + describePosition(expression, e.currentToken.beginColumn)); [EOL]         } [EOL]         return expr; [EOL]     } [EOL] }
public Object getValue() { [EOL]     if (document == null) { [EOL]         try { [EOL]             InputStream stream = null; [EOL]             try { [EOL]                 if (xmlURL != null) { [EOL]                     stream = xmlURL.openStream(); [EOL]                 } [EOL]                 document = parseXML(stream); [EOL]             } finally { [EOL]                 if (stream != null) { [EOL]                     stream.close(); [EOL]                 } [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot read XML from: " + xmlURL.toString(), ex); [EOL]         } [EOL]     } [EOL]     return document; [EOL] }
public Object getValue() { [EOL]     if (document == null) { [EOL]         try { [EOL]             InputStream stream = null; [EOL]             try { [EOL]                 if (xmlURL != null) { [EOL]                     stream = xmlURL.openStream(); [EOL]                 } [EOL]                 document = parseXML(stream); [EOL]             } finally { [EOL]                 if (stream != null) { [EOL]                     stream.close(); [EOL]                 } [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot read XML from: " + xmlURL.toString(), ex); [EOL]         } [EOL]     } [EOL]     return document; [EOL] }
public Object getValue() { [EOL]     if (document == null) { [EOL]         try { [EOL]             InputStream stream = null; [EOL]             try { [EOL]                 if (xmlURL != null) { [EOL]                     stream = xmlURL.openStream(); [EOL]                 } [EOL]                 document = parseXML(stream); [EOL]             } finally { [EOL]                 if (stream != null) { [EOL]                     stream.close(); [EOL]                 } [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot read XML from: " + xmlURL.toString(), ex); [EOL]         } [EOL]     } [EOL]     return document; [EOL] }
public Object getValue() { [EOL]     if (document == null) { [EOL]         try { [EOL]             InputStream stream = null; [EOL]             try { [EOL]                 if (xmlURL != null) { [EOL]                     stream = xmlURL.openStream(); [EOL]                 } [EOL]                 document = parseXML(stream); [EOL]             } finally { [EOL]                 if (stream != null) { [EOL]                     stream.close(); [EOL]                 } [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot read XML from: " + xmlURL.toString(), ex); [EOL]         } [EOL]     } [EOL]     return document; [EOL] }
public Operation(Expression[] args) { [EOL]     this.args = args; [EOL] }
public Operation(Expression[] args) { [EOL]     this.args = args; [EOL] }
public Operation(Expression[] args) { [EOL]     this.args = args; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
