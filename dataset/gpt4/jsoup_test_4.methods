public String attr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     if (hasAttr(attributeKey)) [EOL]         return attributes.get(attributeKey); [EOL]     else if (attributeKey.toLowerCase().startsWith("abs:")) [EOL]         return absUrl(attributeKey.substring("abs:".length())); [EOL]     else [EOL]         return ""; [EOL] }
public String attr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     if (hasAttr(attributeKey)) [EOL]         return attributes.get(attributeKey); [EOL]     else if (attributeKey.toLowerCase().startsWith("abs:")) [EOL]         return absUrl(attributeKey.substring("abs:".length())); [EOL]     else [EOL]         return ""; [EOL] }
public String attr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     if (hasAttr(attributeKey)) [EOL]         return attributes.get(attributeKey); [EOL]     else if (attributeKey.toLowerCase().startsWith("abs:")) [EOL]         return absUrl(attributeKey.substring("abs:".length())); [EOL]     else [EOL]         return ""; [EOL] }
public boolean hasAttr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     return attributes.hasKey(attributeKey); [EOL] }
public boolean hasAttr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     return attributes.hasKey(attributeKey); [EOL] }
public String absUrl(String attributeKey) { [EOL]     Validate.notEmpty(attributeKey); [EOL]     String relUrl = attr(attributeKey); [EOL]     if (!hasAttr(attributeKey)) { [EOL]         return ""; [EOL]     } else { [EOL]         URL base; [EOL]         try { [EOL]             try { [EOL]                 base = new URL(baseUri); [EOL]             } catch (MalformedURLException e) { [EOL]                 URL abs = new URL(relUrl); [EOL]                 return abs.toExternalForm(); [EOL]             } [EOL]             URL abs = new URL(base, relUrl); [EOL]             return abs.toExternalForm(); [EOL]         } catch (MalformedURLException e) { [EOL]             return ""; [EOL]         } [EOL]     } [EOL] }
public String absUrl(String attributeKey) { [EOL]     Validate.notEmpty(attributeKey); [EOL]     String relUrl = attr(attributeKey); [EOL]     if (!hasAttr(attributeKey)) { [EOL]         return ""; [EOL]     } else { [EOL]         URL base; [EOL]         try { [EOL]             try { [EOL]                 base = new URL(baseUri); [EOL]             } catch (MalformedURLException e) { [EOL]                 URL abs = new URL(relUrl); [EOL]                 return abs.toExternalForm(); [EOL]             } [EOL]             URL abs = new URL(base, relUrl); [EOL]             return abs.toExternalForm(); [EOL]         } catch (MalformedURLException e) { [EOL]             return ""; [EOL]         } [EOL]     } [EOL] }
public String absUrl(String attributeKey) { [EOL]     Validate.notEmpty(attributeKey); [EOL]     String relUrl = attr(attributeKey); [EOL]     if (!hasAttr(attributeKey)) { [EOL]         return ""; [EOL]     } else { [EOL]         URL base; [EOL]         try { [EOL]             try { [EOL]                 base = new URL(baseUri); [EOL]             } catch (MalformedURLException e) { [EOL]                 URL abs = new URL(relUrl); [EOL]                 return abs.toExternalForm(); [EOL]             } [EOL]             URL abs = new URL(base, relUrl); [EOL]             return abs.toExternalForm(); [EOL]         } catch (MalformedURLException e) { [EOL]             return ""; [EOL]         } [EOL]     } [EOL] }
public String absUrl(String attributeKey) { [EOL]     Validate.notEmpty(attributeKey); [EOL]     String relUrl = attr(attributeKey); [EOL]     if (!hasAttr(attributeKey)) { [EOL]         return ""; [EOL]     } else { [EOL]         URL base; [EOL]         try { [EOL]             try { [EOL]                 base = new URL(baseUri); [EOL]             } catch (MalformedURLException e) { [EOL]                 URL abs = new URL(relUrl); [EOL]                 return abs.toExternalForm(); [EOL]             } [EOL]             URL abs = new URL(base, relUrl); [EOL]             return abs.toExternalForm(); [EOL]         } catch (MalformedURLException e) { [EOL]             return ""; [EOL]         } [EOL]     } [EOL] }
public String absUrl(String attributeKey) { [EOL]     Validate.notEmpty(attributeKey); [EOL]     String relUrl = attr(attributeKey); [EOL]     if (!hasAttr(attributeKey)) { [EOL]         return ""; [EOL]     } else { [EOL]         URL base; [EOL]         try { [EOL]             try { [EOL]                 base = new URL(baseUri); [EOL]             } catch (MalformedURLException e) { [EOL]                 URL abs = new URL(relUrl); [EOL]                 return abs.toExternalForm(); [EOL]             } [EOL]             URL abs = new URL(base, relUrl); [EOL]             return abs.toExternalForm(); [EOL]         } catch (MalformedURLException e) { [EOL]             return ""; [EOL]         } [EOL]     } [EOL] }
public String attr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasAttr(attributeKey)) [EOL]             return element.attr(attributeKey); [EOL]     } [EOL]     return ""; [EOL] }
public String attr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasAttr(attributeKey)) [EOL]             return element.attr(attributeKey); [EOL]     } [EOL]     return ""; [EOL] }
public String outerHtml() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append("\n"); [EOL]         sb.append(element.outerHtml()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String outerHtml() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append("\n"); [EOL]         sb.append(element.outerHtml()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String outerHtml() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append("\n"); [EOL]         sb.append(element.outerHtml()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public Elements wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     for (Element element : contents) { [EOL]         element.wrap(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     for (Element element : contents) { [EOL]         element.wrap(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     for (Element element : contents) { [EOL]         element.wrap(html); [EOL]     } [EOL]     return this; [EOL] }
public int size() { [EOL]     return contents.size(); [EOL] }
public int size() { [EOL]     return contents.size(); [EOL] }
public boolean equals(Object o) { [EOL]     return contents.equals(o); [EOL] }
public boolean equals(Object o) { [EOL]     return contents.equals(o); [EOL] }
public boolean equals(Object o) { [EOL]     return contents.equals(o); [EOL] }
public boolean equals(Object o) { [EOL]     return contents.equals(o); [EOL] }
public ListIterator<Element> listIterator() { [EOL]     return contents.listIterator(); [EOL] }
public ListIterator<Element> listIterator() { [EOL]     return contents.listIterator(); [EOL] }
public boolean matches(Element element) { [EOL]     return true; [EOL] }
public String title() { [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     return titleEl != null ? titleEl.text().trim() : ""; [EOL] }
public String title() { [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     return titleEl != null ? titleEl.text().trim() : ""; [EOL] }
public String title() { [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     return titleEl != null ? titleEl.text().trim() : ""; [EOL] }
public String title() { [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     return titleEl != null ? titleEl.text().trim() : ""; [EOL] }
public String title() { [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     return titleEl != null ? titleEl.text().trim() : ""; [EOL] }
public void title(String title) { [EOL]     Validate.notNull(title); [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     if (titleEl == null) { [EOL]         head().appendElement("title").text(title); [EOL]     } else { [EOL]         titleEl.text(title); [EOL]     } [EOL] }
public void title(String title) { [EOL]     Validate.notNull(title); [EOL]     Element titleEl = getElementsByTag("title").first(); [EOL]     if (titleEl == null) { [EOL]         head().appendElement("title").text(title); [EOL]     } else { [EOL]         titleEl.text(title); [EOL]     } [EOL] }
private Selector(String query, Element root) { [EOL]     Validate.notNull(query); [EOL]     query = query.trim(); [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(root); [EOL]     this.elements = new LinkedHashSet<Element>(); [EOL]     this.query = query; [EOL]     this.root = root; [EOL]     this.tq = new TokenQueue(query); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Selector(String query, Element root) { [EOL]     Validate.notNull(query); [EOL]     query = query.trim(); [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(root); [EOL]     this.elements = new LinkedHashSet<Element>(); [EOL]     this.query = query; [EOL]     this.root = root; [EOL]     this.tq = new TokenQueue(query); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Selector(String query, Element root) { [EOL]     Validate.notNull(query); [EOL]     query = query.trim(); [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(root); [EOL]     this.elements = new LinkedHashSet<Element>(); [EOL]     this.query = query; [EOL]     this.root = root; [EOL]     this.tq = new TokenQueue(query); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Selector(String query, Element root) { [EOL]     Validate.notNull(query); [EOL]     query = query.trim(); [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(root); [EOL]     this.elements = new LinkedHashSet<Element>(); [EOL]     this.query = query; [EOL]     this.root = root; [EOL]     this.tq = new TokenQueue(query); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Element root) { [EOL]     return new Selector(query, root).select(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Element root) { [EOL]     return new Selector(query, root).select(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Element root) { [EOL]     return new Selector(query, root).select(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Iterable<Element> roots) { [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(roots); [EOL]     LinkedHashSet<Element> elements = new LinkedHashSet<Element>(); [EOL]     for (Element root : roots) { [EOL]         elements.addAll(select(query, root)); [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Iterable<Element> roots) { [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(roots); [EOL]     LinkedHashSet<Element> elements = new LinkedHashSet<Element>(); [EOL]     for (Element root : roots) { [EOL]         elements.addAll(select(query, root)); [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Iterable<Element> roots) { [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(roots); [EOL]     LinkedHashSet<Element> elements = new LinkedHashSet<Element>(); [EOL]     for (Element root : roots) { [EOL]         elements.addAll(select(query, root)); [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Iterable<Element> roots) { [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(roots); [EOL]     LinkedHashSet<Element> elements = new LinkedHashSet<Element>(); [EOL]     for (Element root : roots) { [EOL]         elements.addAll(select(query, root)); [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public static Elements select(String query, Iterable<Element> roots) { [EOL]     Validate.notEmpty(query); [EOL]     Validate.notNull(roots); [EOL]     LinkedHashSet<Element> elements = new LinkedHashSet<Element>(); [EOL]     for (Element root : roots) { [EOL]         elements.addAll(select(query, root)); [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements select() { [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchesAny(combinators)) { [EOL]         elements.add(root); [EOL]         combinator(tq.consume().toString()); [EOL]     } else { [EOL]         addElements(findElements()); [EOL]     } [EOL]     while (!tq.isEmpty()) { [EOL]         boolean seenWhite = tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(",")) { [EOL]             while (!tq.isEmpty()) { [EOL]                 String subQuery = tq.chompTo(","); [EOL]                 elements.addAll(select(subQuery, root)); [EOL]             } [EOL]         } else if (tq.matchesAny(combinators)) { [EOL]             combinator(tq.consume().toString()); [EOL]         } else if (seenWhite) { [EOL]             combinator(" "); [EOL]         } else { [EOL]             Elements candidates = findElements(); [EOL]             intersectElements(filterForSelf(elements, candidates)); [EOL]         } [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void addElements(Collection<Element> add) { [EOL]     elements.addAll(add); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byTag() { [EOL]     String tagName = tq.consumeWord(); [EOL]     Validate.notEmpty(tagName); [EOL]     return root.getElementsByTag(tagName); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byTag() { [EOL]     String tagName = tq.consumeWord(); [EOL]     Validate.notEmpty(tagName); [EOL]     return root.getElementsByTag(tagName); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements allElements() { [EOL]     return root.getAllElements(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements allElements() { [EOL]     return root.getAllElements(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements allElements() { [EOL]     return root.getAllElements(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements allElements() { [EOL]     return root.getAllElements(); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         for (Element p : parents) { [EOL]             if (c.parent() != null && c.parent().equals(p)) { [EOL]                 children.add(c); [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         for (Element p : parents) { [EOL]             if (c.parent() != null && c.parent().equals(p)) { [EOL]                 children.add(c); [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         for (Element p : parents) { [EOL]             if (c.parent() != null && c.parent().equals(p)) { [EOL]                 children.add(c); [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         for (Element p : parents) { [EOL]             if (c.parent() != null && c.parent().equals(p)) { [EOL]                 children.add(c); [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public Element prependText(String text) { [EOL]     TextNode node = new TextNode(text, baseUri()); [EOL]     prependChild(node); [EOL]     return this; [EOL] }
public Element prependText(String text) { [EOL]     TextNode node = new TextNode(text, baseUri()); [EOL]     prependChild(node); [EOL]     return this; [EOL] }
public Element prependText(String text) { [EOL]     TextNode node = new TextNode(text, baseUri()); [EOL]     prependChild(node); [EOL]     return this; [EOL] }
private Element getDeepChild(Element el) { [EOL]     List<Element> children = el.children(); [EOL]     if (children.size() > 0) [EOL]         return getDeepChild(children.get(0)); [EOL]     else [EOL]         return el; [EOL] }
public String data() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Node childNode : childNodes) { [EOL]         if (childNode instanceof DataNode) { [EOL]             DataNode data = (DataNode) childNode; [EOL]             sb.append(data.getWholeData()); [EOL]         } else if (childNode instanceof Element) { [EOL]             Element element = (Element) childNode; [EOL]             String elementData = element.data(); [EOL]             sb.append(elementData); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String data() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Node childNode : childNodes) { [EOL]         if (childNode instanceof DataNode) { [EOL]             DataNode data = (DataNode) childNode; [EOL]             sb.append(data.getWholeData()); [EOL]         } else if (childNode instanceof Element) { [EOL]             Element element = (Element) childNode; [EOL]             String elementData = element.data(); [EOL]             sb.append(elementData); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String data() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Node childNode : childNodes) { [EOL]         if (childNode instanceof DataNode) { [EOL]             DataNode data = (DataNode) childNode; [EOL]             sb.append(data.getWholeData()); [EOL]         } else if (childNode instanceof Element) { [EOL]             Element element = (Element) childNode; [EOL]             String elementData = element.data(); [EOL]             sb.append(elementData); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String html() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     html(accum); [EOL]     return accum.toString().trim(); [EOL] }
public String html() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     html(accum); [EOL]     return accum.toString().trim(); [EOL] }
public String html() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     html(accum); [EOL]     return accum.toString().trim(); [EOL] }
private void parseComment() { [EOL]     tq.consume("<!--"); [EOL]     String data = tq.chompTo("->"); [EOL]     if (data.endsWith("-")) [EOL]         data = data.substring(0, data.length() - 1); [EOL]     Comment comment = new Comment(data, baseUri); [EOL]     last().appendChild(comment); [EOL] }
private void parseComment() { [EOL]     tq.consume("<!--"); [EOL]     String data = tq.chompTo("->"); [EOL]     if (data.endsWith("-")) [EOL]         data = data.substring(0, data.length() - 1); [EOL]     Comment comment = new Comment(data, baseUri); [EOL]     last().appendChild(comment); [EOL] }
public void setValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] }
public void setValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] }
public String html() { [EOL]     return String.format("%s=\"%s\"", key, StringEscapeUtils.escapeHtml(value)); [EOL] }
public String html() { [EOL]     return String.format("%s=\"%s\"", key, StringEscapeUtils.escapeHtml(value)); [EOL] }
public String html() { [EOL]     return String.format("%s=\"%s\"", key, StringEscapeUtils.escapeHtml(value)); [EOL] }
public static Whitelist basicWithImages() { [EOL]     return basic().addTags("img").addAttributes("img", "align", "alt", "height", "src", "title", "width").addProtocols("img", "src", "http", "https"); [EOL] }
public String get(String key) { [EOL]     Validate.notEmpty(key); [EOL]     Attribute attr = attributes.get(key.toLowerCase()); [EOL]     return attr != null ? attr.getValue() : ""; [EOL] }
public String get(String key) { [EOL]     Validate.notEmpty(key); [EOL]     Attribute attr = attributes.get(key.toLowerCase()); [EOL]     return attr != null ? attr.getValue() : ""; [EOL] }
public String get(String key) { [EOL]     Validate.notEmpty(key); [EOL]     Attribute attr = attributes.get(key.toLowerCase()); [EOL]     return attr != null ? attr.getValue() : ""; [EOL] }
public String get(String key) { [EOL]     Validate.notEmpty(key); [EOL]     Attribute attr = attributes.get(key.toLowerCase()); [EOL]     return attr != null ? attr.getValue() : ""; [EOL] }
public void put(Attribute attribute) { [EOL]     Validate.notNull(attribute); [EOL]     attributes.put(attribute.getKey(), attribute); [EOL] }
public void put(Attribute attribute) { [EOL]     Validate.notNull(attribute); [EOL]     attributes.put(attribute.getKey(), attribute); [EOL] }
public boolean hasKey(String key) { [EOL]     return attributes.containsKey(key.toLowerCase()); [EOL] }
public boolean hasKey(String key) { [EOL]     return attributes.containsKey(key.toLowerCase()); [EOL] }
public boolean hasKey(String key) { [EOL]     return attributes.containsKey(key.toLowerCase()); [EOL] }
public void addAll(Attributes incoming) { [EOL]     attributes.putAll(incoming.attributes); [EOL] }
public void addAll(Attributes incoming) { [EOL]     attributes.putAll(incoming.attributes); [EOL] }
public void addAll(Attributes incoming) { [EOL]     attributes.putAll(incoming.attributes); [EOL] }
public Iterator<Attribute> iterator() { [EOL]     return asList().iterator(); [EOL] }
public Iterator<Attribute> iterator() { [EOL]     return asList().iterator(); [EOL] }
public Iterator<Attribute> iterator() { [EOL]     return asList().iterator(); [EOL] }
public List<Attribute> asList() { [EOL]     List<Attribute> list = new ArrayList<Attribute>(attributes.size()); [EOL]     for (Map.Entry<String, Attribute> entry : attributes.entrySet()) { [EOL]         list.add(entry.getValue()); [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public List<Attribute> asList() { [EOL]     List<Attribute> list = new ArrayList<Attribute>(attributes.size()); [EOL]     for (Map.Entry<String, Attribute> entry : attributes.entrySet()) { [EOL]         list.add(entry.getValue()); [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public List<Attribute> asList() { [EOL]     List<Attribute> list = new ArrayList<Attribute>(attributes.size()); [EOL]     for (Map.Entry<String, Attribute> entry : attributes.entrySet()) { [EOL]         list.add(entry.getValue()); [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public String html() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     for (Attribute attribute : this) { [EOL]         accum.append(" "); [EOL]         accum.append(attribute.html()); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String html() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     for (Attribute attribute : this) { [EOL]         accum.append(" "); [EOL]         accum.append(attribute.html()); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String html() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     for (Attribute attribute : this) { [EOL]         accum.append(" "); [EOL]         accum.append(attribute.html()); [EOL]     } [EOL]     return accum.toString(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return attributes != null ? attributes.hashCode() : 0; [EOL] }
public DataNode(String data, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(DATA_KEY, data); [EOL] }
public DataNode(String data, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(DATA_KEY, data); [EOL] }
public DataNode(String data, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(DATA_KEY, data); [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
