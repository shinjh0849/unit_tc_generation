public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes("UTF-8")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = "AB\u00A0\u1AE9\uFFFC"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString("UTF-8"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testInvalidBooleanAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBooleanValue(); [EOL]         fail("Expected error trying to call getBooleanValue on non-boolean value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "not of boolean type"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidBooleanAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBooleanValue(); [EOL]         fail("Expected error trying to call getBooleanValue on non-boolean value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "not of boolean type"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidBooleanAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBooleanValue(); [EOL]         fail("Expected error trying to call getBooleanValue on non-boolean value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "not of boolean type"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSpecExampleFully() throws Exception { [EOL]     doTestSpec(true); [EOL] }
public void testSpecExampleFully() throws Exception { [EOL]     doTestSpec(true); [EOL] }
public void testSpecExampleFully() throws Exception { [EOL]     doTestSpec(true); [EOL] }
public void testSpecExampleFully() throws Exception { [EOL]     doTestSpec(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, "SNAPSHOT", "foo.bar", "foo-bar"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), "foo.bar", "foo-bar")); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, "SNAPSHOT", "foo.bar", "foo-bar"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), "foo.bar", "foo-bar")); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, "SNAPSHOT", "foo.bar", "foo-bar"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), "foo.bar", "foo-bar")); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, "SNAPSHOT", "foo.bar", "foo-bar"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), "foo.bar", "foo-bar")); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals("{} {} []", _generateRoot(jf, null)); [EOL]     assertEquals("{ } { } [ ]", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals("{ }|{ }|[ ]", _generateRoot(jf, new DefaultPrettyPrinter("|"))); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals("{} {} []", _generateRoot(jf, null)); [EOL]     assertEquals("{ } { } [ ]", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals("{ }|{ }|[ ]", _generateRoot(jf, new DefaultPrettyPrinter("|"))); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals("{} {} []", _generateRoot(jf, null)); [EOL]     assertEquals("{ } { } [ ]", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals("{ }|{ }|[ ]", _generateRoot(jf, new DefaultPrettyPrinter("|"))); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals("{} {} []", _generateRoot(jf, null)); [EOL]     assertEquals("{ } { } [ ]", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals("{ }|{ }|[ ]", _generateRoot(jf, new DefaultPrettyPrinter("|"))); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings("unused") [EOL] public void testErrors() throws Exception { [EOL]     try { [EOL]         Base64Variant b = new Base64Variant("foobar", "xyz", false, '!', 24); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         verifyException(iae, "length must be exactly"); [EOL]     } [EOL] }
@SuppressWarnings("unused") [EOL] public void testErrors() throws Exception { [EOL]     try { [EOL]         Base64Variant b = new Base64Variant("foobar", "xyz", false, '!', 24); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         verifyException(iae, "length must be exactly"); [EOL]     } [EOL] }
@SuppressWarnings("unused") [EOL] public void testErrors() throws Exception { [EOL]     try { [EOL]         Base64Variant b = new Base64Variant("foobar", "xyz", false, '!', 24); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         verifyException(iae, "length must be exactly"); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals("{} {} []", _generateRoot(jf, null)); [EOL]     assertEquals("{ } { } [ ]", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals("{ }|{ }|[ ]", _generateRoot(jf, new DefaultPrettyPrinter("|"))); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = "X" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = "" + letter + index; [EOL]                     } else { [EOL]                         name = "__" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(" "); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail("Expected '" + exp + "', got '" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(" "); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail("Expected '" + exp + "', got '" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(" "); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail("Expected '" + exp + "', got '" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, "\n"); [EOL]     assertEquals("\\n", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, "\u0000"); [EOL]     assertEquals("\\u0000", sb.toString()); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, "\n"); [EOL]     assertEquals("\\n", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, "\u0000"); [EOL]     assertEquals("\\u0000", sb.toString()); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals("\\u0000\\u0001\\u0002\\u0003\\u0004", new String(quoted)); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals("\\u0000\\u0001\\u0002\\u0003\\u0004", new String(quoted)); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals("\\u0000\\u0001\\u0002\\u0003\\u0004", new String(quoted)); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals("\\u0000\\u0001\\u0002\\u0003\\u0004", new String(quoted)); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("dec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("ob", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("arr", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy("ABCDE".getBytes("UTF-8"), 0, first, 99, 5); [EOL]     byte[] second = "FGHIJ".getBytes("UTF-8"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
