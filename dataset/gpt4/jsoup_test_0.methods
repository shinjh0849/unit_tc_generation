protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] }
protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] }
protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] }
protected Node(String baseUri) { [EOL]     this(baseUri, new Attributes()); [EOL] }
public Node attr(String attributeKey, String attributeValue) { [EOL]     attributes.put(attributeKey, attributeValue); [EOL]     return this; [EOL] }
public Node childNode(int index) { [EOL]     return childNodes.get(index); [EOL] }
public Node childNode(int index) { [EOL]     return childNodes.get(index); [EOL] }
public Node parent() { [EOL]     return parentNode; [EOL] }
public Node parent() { [EOL]     return parentNode; [EOL] }
protected void setParentNode(Node parentNode) { [EOL]     if (this.parentNode != null) [EOL]         throw new NotImplementedException("Cannot (yet) move nodes in tree"); [EOL]     this.parentNode = parentNode; [EOL] }
protected void setParentNode(Node parentNode) { [EOL]     if (this.parentNode != null) [EOL]         throw new NotImplementedException("Cannot (yet) move nodes in tree"); [EOL]     this.parentNode = parentNode; [EOL] }
protected void setParentNode(Node parentNode) { [EOL]     if (this.parentNode != null) [EOL]         throw new NotImplementedException("Cannot (yet) move nodes in tree"); [EOL]     this.parentNode = parentNode; [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected void addChild(Node in) { [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     childNodes.add(in); [EOL]     in.parentNode = this; [EOL] }
public String outerHtml() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     outerHtml(accum); [EOL]     return accum.toString(); [EOL] }
public String outerHtml() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     outerHtml(accum); [EOL]     return accum.toString(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] }
public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [EOL]     super(baseUri); [EOL]     attributes.put(DECL_KEY, data); [EOL]     this.isProcessingInstruction = isProcessingInstruction; [EOL] }
public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [EOL]     super(baseUri); [EOL]     attributes.put(DECL_KEY, data); [EOL]     this.isProcessingInstruction = isProcessingInstruction; [EOL] }
public String val() { [EOL]     if (size() > 0) [EOL]         return first().val(); [EOL]     else [EOL]         return ""; [EOL] }
public String val() { [EOL]     if (size() > 0) [EOL]         return first().val(); [EOL]     else [EOL]         return ""; [EOL] }
public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] }
public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] }
public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] }
public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] }
public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] }
public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] }
public boolean is(String query) { [EOL]     Elements children = this.select(query); [EOL]     return !children.isEmpty(); [EOL] }
public Element last() { [EOL]     return !contents.isEmpty() ? contents.get(contents.size() - 1) : null; [EOL] }
public Element last() { [EOL]     return !contents.isEmpty() ? contents.get(contents.size() - 1) : null; [EOL] }
AttributeWithValueNot(String key, String value) { [EOL]     super(key, value); [EOL] }
AttributeWithValueNot(String key, String value) { [EOL]     super(key, value); [EOL] }
AttributeWithValueNot(String key, String value) { [EOL]     super(key, value); [EOL] }
public boolean matches(Element element) { [EOL]     return (!value.equalsIgnoreCase(element.attr(key))); [EOL] }
AttributeWithValueStarting(String key, String value) { [EOL]     super(key, value); [EOL] }
AttributeWithValueStarting(String key, String value) { [EOL]     super(key, value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().startsWith(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().startsWith(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().startsWith(value); [EOL] }
AttributeWithValueEnding(String key, String value) { [EOL]     super(key, value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] }
IndexLessThan(int index) { [EOL]     super(index); [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() < index; [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() < index; [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() < index; [EOL] }
IndexGreaterThan(int index) { [EOL]     super(index); [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() > index; [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() > index; [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() > index; [EOL] }
IndexEvaluator(int index) { [EOL]     this.index = index; [EOL] }
public Cleaner(Whitelist whitelist) { [EOL]     Validate.notNull(whitelist); [EOL]     this.whitelist = whitelist; [EOL] }
public Cleaner(Whitelist whitelist) { [EOL]     Validate.notNull(whitelist); [EOL]     this.whitelist = whitelist; [EOL] }
public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] }
public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] }
public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
ElementMeta(Element el, int numAttribsDiscarded) { [EOL]     this.el = el; [EOL]     this.numAttribsDiscarded = numAttribsDiscarded; [EOL] }
public void addFirst(Character c) { [EOL]     queue.addFirst(c); [EOL] }
public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] }
public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] }
public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements indexLessThan() { [EOL]     return root.getElementsByIndexLessThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements indexGreaterThan() { [EOL]     return root.getElementsByIndexGreaterThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements indexGreaterThan() { [EOL]     return root.getElementsByIndexGreaterThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements indexGreaterThan() { [EOL]     return root.getElementsByIndexGreaterThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] }
public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] }
public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] }
public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] }
public String text() { [EOL]     return outerHtml(); [EOL] }
public TextNode text(String text) { [EOL]     attributes.put(TEXT_KEY, text); [EOL]     return this; [EOL] }
public TextNode text(String text) { [EOL]     attributes.put(TEXT_KEY, text); [EOL]     return this; [EOL] }
public String getWholeText() { [EOL]     return attributes.get(TEXT_KEY); [EOL] }
public String getWholeText() { [EOL]     return attributes.get(TEXT_KEY); [EOL] }
public boolean isBlank() { [EOL]     return StringUtils.isBlank(normaliseWhitespace(getWholeText())); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] }
public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] }
public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] }
public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] }
public Element attr(String attributeKey, String attributeValue) { [EOL]     super.attr(attributeKey, attributeValue); [EOL]     return this; [EOL] }
public Element child(int index) { [EOL]     return children().get(index); [EOL] }
public Element child(int index) { [EOL]     return children().get(index); [EOL] }
public Element child(int index) { [EOL]     return children().get(index); [EOL] }
public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] }
public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] }
public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] }
public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
private Element getDeepChild(Element el) { [EOL]     List<Element> children = el.children(); [EOL]     if (children.size() > 0) [EOL]         return getDeepChild(children.get(0)); [EOL]     else [EOL]         return el; [EOL] }
public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] }
public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] }
public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] }
public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] }
public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] }
public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] }
public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] }
public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] }
public Elements getElementsByAttributeValueNot(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [EOL] }
public Elements getElementsByAttributeValueNot(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [EOL] }
public Elements getElementsByAttributeValueNot(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [EOL] }
public Elements getElementsByAttributeValueNot(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [EOL] }
public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] }
public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] }
public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] }
public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] }
public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] }
public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); [EOL] }
public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); [EOL] }
public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); [EOL] }
public Elements getElementsByIndexLessThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexLessThan(index), this); [EOL] }
public Elements getElementsByIndexLessThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexLessThan(index), this); [EOL] }
public Elements getElementsByIndexLessThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexLessThan(index), this); [EOL] }
public Elements getElementsByIndexGreaterThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [EOL] }
public Elements getElementsByIndexGreaterThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [EOL] }
public Elements getElementsByIndexGreaterThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [EOL] }
public Elements getElementsByIndexGreaterThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [EOL] }
public Elements getAllElements() { [EOL]     return Collector.collect(new Evaluator.AllElements(), this); [EOL] }
public Elements getAllElements() { [EOL]     return Collector.collect(new Evaluator.AllElements(), this); [EOL] }
public Elements getAllElements() { [EOL]     return Collector.collect(new Evaluator.AllElements(), this); [EOL] }
public String val() { [EOL]     if (tagName().equals("textarea")) [EOL]         return text(); [EOL]     else [EOL]         return attr("value"); [EOL] }
public String val() { [EOL]     if (tagName().equals("textarea")) [EOL]         return text(); [EOL]     else [EOL]         return attr("value"); [EOL] }
public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] }
public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] }
private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] }
private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] }
private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] }
private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] }
public static Document parse(String html, String baseUri) { [EOL]     Parser parser = new Parser(html, baseUri, false); [EOL]     return parser.parse(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] }
private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private void parseTextNode() { [EOL]     String text = tq.consumeTo("<"); [EOL]     TextNode textNode = TextNode.createFromEncoded(text, baseUri); [EOL]     last().appendChild(textNode); [EOL] }
private void parseTextNode() { [EOL]     String text = tq.consumeTo("<"); [EOL]     TextNode textNode = TextNode.createFromEncoded(text, baseUri); [EOL]     last().appendChild(textNode); [EOL] }
private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] }
private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] }
private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] }
private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] }
private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] }
private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] }
private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] }
private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] }
private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] }
private Element last() { [EOL]     return stack.getLast(); [EOL] }
private Element last() { [EOL]     return stack.getLast(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] }
public static Whitelist simpleText() { [EOL]     return new Whitelist().addTags("b", "em", "i", "strong", "u"); [EOL] }
public static Whitelist relaxed() { [EOL]     return new Whitelist().addTags("a", "b", "blockquote", "br", "caption", "cite", "code", "col", "colgroup", "dd", "div", "dl", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "i", "img", "li", "ol", "p", "pre", "q", "small", "strike", "strong", "sub", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "u", "ul").addAttributes("a", "href", "title").addAttributes("blockquote", "cite").addAttributes("col", "span", "width").addAttributes("colgroup", "span", "width").addAttributes("img", "align", "alt", "height", "src", "title", "width").addAttributes("ol", "start", "type").addAttributes("q", "cite").addAttributes("table", "summary", "width").addAttributes("td", "abbr", "axis", "colspan", "rowspan", "width").addAttributes("th", "abbr", "axis", "colspan", "rowspan", "scope", "width").addAttributes("ul", "type").addProtocols("a", "href", "ftp", "http", "https", "mailto").addProtocols("blockquote", "cite", "http", "https").addProtocols("img", "src", "http", "https").addProtocols("q", "cite", "http", "https"); [EOL] }
public Whitelist() { [EOL]     tagNames = new HashSet<TagName>(); [EOL]     attributes = new HashMap<TagName, Set<AttributeKey>>(); [EOL]     enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [EOL]     protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [EOL] }
public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] }
boolean isSafeTag(String tag) { [EOL]     return tagNames.contains(TagName.valueOf(tag)); [EOL] }
boolean isSafeTag(String tag) { [EOL]     return tagNames.contains(TagName.valueOf(tag)); [EOL] }
boolean isSafeTag(String tag) { [EOL]     return tagNames.contains(TagName.valueOf(tag)); [EOL] }
boolean isSafeTag(String tag) { [EOL]     return tagNames.contains(TagName.valueOf(tag)); [EOL] }
boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] }
Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] }
TagName(String value) { [EOL]     super(value); [EOL] }
static TagName valueOf(String value) { [EOL]     return new TagName(value); [EOL] }
static TagName valueOf(String value) { [EOL]     return new TagName(value); [EOL] }
AttributeKey(String value) { [EOL]     super(value); [EOL] }
static AttributeKey valueOf(String value) { [EOL]     return new AttributeKey(value); [EOL] }
static AttributeKey valueOf(String value) { [EOL]     return new AttributeKey(value); [EOL] }
static AttributeKey valueOf(String value) { [EOL]     return new AttributeKey(value); [EOL] }
Protocol(String value) { [EOL]     super(value); [EOL] }
static Protocol valueOf(String value) { [EOL]     return new Protocol(value); [EOL] }
static Protocol valueOf(String value) { [EOL]     return new Protocol(value); [EOL] }
static Protocol valueOf(String value) { [EOL]     return new Protocol(value); [EOL] }
TypedValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] }
TypedValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public String toString() { [EOL]     return value; [EOL] }
public String getWholeData() { [EOL]     return attributes.get(DATA_KEY); [EOL] }
public String getWholeData() { [EOL]     return attributes.get(DATA_KEY); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     accum.append(getWholeData()); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     accum.append(getWholeData()); [EOL] }
public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] }
public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] }
public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] }
public static String clean(String bodyHtml, Whitelist whitelist) { [EOL]     return clean(bodyHtml, "", whitelist); [EOL] }
public static String clean(String bodyHtml, Whitelist whitelist) { [EOL]     return clean(bodyHtml, "", whitelist); [EOL] }
public static String clean(String bodyHtml, Whitelist whitelist) { [EOL]     return clean(bodyHtml, "", whitelist); [EOL] }
private Tag(String tagName) { [EOL]     this.tagName = tagName.toLowerCase(); [EOL] }
private Tag(String tagName) { [EOL]     this.tagName = tagName.toLowerCase(); [EOL] }
private Tag(String tagName) { [EOL]     this.tagName = tagName.toLowerCase(); [EOL] }
public String getName() { [EOL]     return tagName; [EOL] }
public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] }
public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] }
public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] }
public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
public boolean isData() { [EOL]     return !canContainInline && !isEmpty(); [EOL] }
public boolean isData() { [EOL]     return !canContainInline && !isEmpty(); [EOL] }
public boolean isData() { [EOL]     return !canContainInline && !isEmpty(); [EOL] }
public boolean isData() { [EOL]     return !canContainInline && !isEmpty(); [EOL] }
public boolean isEmpty() { [EOL]     return empty; [EOL] }
public boolean isEmpty() { [EOL]     return empty; [EOL] }
public boolean preserveWhitespace() { [EOL]     return preserveWhitespace; [EOL] }
public boolean preserveWhitespace() { [EOL]     return preserveWhitespace; [EOL] }
Tag getImplicitParent() { [EOL]     return (!ancestors.isEmpty()) ? ancestors.get(0) : null; [EOL] }
Tag getImplicitParent() { [EOL]     return (!ancestors.isEmpty()) ? ancestors.get(0) : null; [EOL] }
boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] }
private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
