public void testVersion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Version version = mapper.version(); [EOL] assertNotNull(version); [EOL] assertEquals(com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION, version); [EOL] }
public void testFindRootNameWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonRootName.class)).thenReturn(null); [EOL] PropertyName result = findRootName(ac); [EOL] assertNull(result); [EOL] }
public void testFindRootNameWithAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonRootName ann = mock(JsonRootName.class); [EOL] when(ac.getAnnotation(JsonRootName.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn("TestRoot"); [EOL] PropertyName result = findRootName(ac); [EOL] assertNotNull(result); [EOL] assertEquals("TestRoot", result.getSimpleName()); [EOL] }
public void testFindKeySerializerWithNonNullAnnotationAndKeyUsing() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyUsing()).thenReturn((Class)CustomKeySerializer.class); [EOL] JsonSerializer<?> result = findKeySerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomKeySerializer.class, result); [EOL] }
public void testFindKeySerializerWithNonNullAnnotationAndDefaultKeyUsing() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyUsing()).thenReturn((Class)JsonSerializer.None.class); [EOL] JsonSerializer<?> result = findKeySerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindKeySerializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonSerializer<?> result = findKeySerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithNonNullAnnotationAndNonDefaultSerializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentUsing()).thenReturn((Class)CustomSerializer.class); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomSerializer.class, result); [EOL] }
public void testFindContentSerializerWithNonNullAnnotationAndDefaultSerializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentUsing()).thenReturn((Class)JsonSerializer.None.class); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationKeyTypeWithNonNullAnnotationAndKeyAsNoClass() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyAs()).thenReturn(NoClass.class); [EOL] Class<?> result = findSerializationKeyType(annotated, baseType); [EOL] assertNull(result); [EOL] }
public void testFindSerializationKeyTypeWithNonNullAnnotationAndValidKeyAs() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] Class<?> expectedClass = String.class; [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyAs()).thenReturn(expectedClass); [EOL] Class<?> result = findSerializationKeyType(annotated, baseType); [EOL] assertSame(expectedClass, result); [EOL] }
public void testFindSerializationKeyTypeWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Class<?> result = findSerializationKeyType(annotated, baseType); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentTypeWithAnnotationPresentAndContentAsNotNoClass() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentAs()).thenReturn(String.class); [EOL] Class<?> result = findSerializationContentType(annotated, null); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindSerializationContentTypeWithAnnotationPresentAndContentAsNoClass() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentAs()).thenReturn(NoClass.class); [EOL] Class<?> result = findSerializationContentType(annotated, null); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentTypeWithAnnotationAbsent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Class<?> result = findSerializationContentType(annotated, null); [EOL] assertNull(result); [EOL] }
public void testFindSerializationConverterWithNonNullConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.converter()).thenReturn((Class)DummyConverter.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(DummyConverter.class, result); [EOL] }
public void testFindSerializationConverterWithNoneClassConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.converter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationConverterWithNoAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentConverterWithNonNullConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotatedMember.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentConverter()).thenReturn((Class)DummyConverter.class); [EOL] Object result = findSerializationContentConverter(annotatedMember); [EOL] assertNotNull(result); [EOL] assertEquals(DummyConverter.class, result); [EOL] }
public void testFindSerializationContentConverterWithNoneClassConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotatedMember.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentConverter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findSerializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentConverterWithNoAnnotation() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(annotatedMember.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Object result = findSerializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNonNullAnnotationAndValidKeyDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.keyUsing()).thenReturn((Class)SomeKeyDeserializer.class); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(SomeKeyDeserializer.class, result); [EOL] }
public void testFindKeyDeserializerWithNonNullAnnotationAndNoneKeyDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.keyUsing()).thenReturn((Class)KeyDeserializer.None.class); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationConverterWithNonNullConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.converter()).thenReturn((Class)DummyConverter.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(DummyConverter.class, result); [EOL] }
public void testFindDeserializationConverterWithNoneClassConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.converter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationConverterWithNoAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentConverterWithNonNullAnnotationAndValidConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentConverter()).thenReturn((Class)SomeConverter.class); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNotNull(result); [EOL] assertEquals(SomeConverter.class, result); [EOL] }
public void testFindDeserializationContentConverterWithNonNullAnnotationAndNoneConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentConverter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentConverterWithNullAnnotation() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindPOJOBuilderConfigWithNoAnnotation() { [EOL] AnnotatedClass ac = createAnnotatedClassWithoutPOJOBuilderAnnotation(); [EOL] JsonPOJOBuilder.Value result = findPOJOBuilderConfig(ac); [EOL] assertNull(result); [EOL] } [EOL] public void testFindPOJOBuilderConfigWithAnnotation() { [EOL] AnnotatedClass ac = createAnnotatedClassWithPOJOBuilderAnnotation(); [EOL] JsonPOJOBuilder.Value result = findPOJOBuilderConfig(ac); [EOL] assertNotNull(result); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL] TypeResolverBuilder<?> b; [EOL] JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL] JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL] if (resAnn != null) { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL] } else { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] if (info.use() == JsonTypeInfo.Id.NONE) { [EOL] return _constructNoTypeResolverBuilder(); [EOL] } [EOL] b = _constructStdTypeResolverBuilder(); [EOL] } [EOL] JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL] TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL] if (idRes != null) { [EOL] idRes.init(baseType); [EOL] } [EOL] b = b.init(info.use(), idRes); [EOL] JsonTypeInfo.As inclusion = info.include(); [EOL] if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL] inclusion = JsonTypeInfo.As.PROPERTY; [EOL] } [EOL] b = b.inclusion(inclusion); [EOL] b = b.typeProperty(info.property()); [EOL] Class<?> defaultImpl = info.defaultImpl(); [EOL] if (defaultImpl != JsonTypeInfo.None.class) { [EOL] b = b.defaultImpl(defaultImpl); [EOL] } [EOL] b = b.typeIdVisibility(info.visible()); [EOL] return b; [EOL] }
protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() { [EOL] return StdTypeResolverBuilder.noTypeInfoBuilder(); [EOL] }
public void testWithAlwaysAsIdWhenStateIsSame() { [EOL] ObjectIdInfo original = new ObjectIdInfo("propName", Object.class, ObjectIdGenerators.PropertyGenerator.class, false); [EOL] ObjectIdInfo result = original.withAlwaysAsId(false); [EOL] assertSame("Should return the same object when state is the same", original, result); [EOL] }
public void testWithAlwaysAsIdWhenStateIsDifferent() { [EOL] ObjectIdInfo original = new ObjectIdInfo("propName", Object.class, ObjectIdGenerators.PropertyGenerator.class, false); [EOL] ObjectIdInfo result = original.withAlwaysAsId(true); [EOL] assertNotSame("Should return a new object when state is different", original, result); [EOL] assertTrue("The alwaysAsId property should be updated", result.getAlwaysAsId()); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] boolean result = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] assertTrue(result); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] boolean result = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] assertFalse(result); [EOL] }
public void testFindRootValueDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn(null); [EOL] JsonDeserializer<Object> result = context.findRootValueDeserializer(type); [EOL] assertNull(result); [EOL] }
public void testFindRootValueDeserializerWithContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<Object> baseDeserializer = mock(JsonDeserializer.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn((JsonDeserializer<Object>) contextualDeserializer); [EOL] when(contextualDeserializer.createContextual(context, null)).thenReturn(baseDeserializer); [EOL] JsonDeserializer<Object> result = context.findRootValueDeserializer(type); [EOL] assertSame(baseDeserializer, result); [EOL] }
public void testFindRootValueDeserializerWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> baseDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn(baseDeserializer); [EOL] when(factory.findTypeDeserializer(context.getConfig(), type)).thenReturn(typeDeserializer); [EOL] when(typeDeserializer.forProperty(null)).thenReturn(typeDeserializer); [EOL] JsonDeserializer<Object> result = context.findRootValueDeserializer(type); [EOL] assertTrue(result instanceof TypeWrappedDeserializer); [EOL] }
public void testConstructTypeWithNonNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.getTypeFactory().constructType(String.class); [EOL] assertNotNull(javaType); [EOL] assertEquals(String.class, javaType.getRawClass()); [EOL] }
public void testConstructTypeWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getTypeFactory().constructType(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseDateWithValidDate() { [EOL] String validDateStr = "2023-01-01"; [EOL] Date expectedDate = new GregorianCalendar(2023, Calendar.JANUARY, 1).getTime(); [EOL] Date actualDate = parseDate(validDateStr); [EOL] assertEquals(expectedDate, actualDate); [EOL] }
public void testParseDateWithInvalidDate() { [EOL] String invalidDateStr = "invalid-date"; [EOL] try { [EOL] parseDate(invalidDateStr); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Failed to parse Date value 'invalid-date': Unparseable date: \"invalid-date\"", e.getMessage()); [EOL] } [EOL] }
public void testHandleUnknownPropertyWithNullHandlers() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] Object instanceOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] assertFalse(context.handleUnknownProperty(jp, deser, instanceOrClass, propName)); [EOL] }
public void testHandleUnknownPropertyWithNonNullHandlersReturningTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] Object instanceOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] DeserializationProblemHandler handler = mock(DeserializationProblemHandler.class); [EOL] when(handler.handleUnknownProperty(any(DeserializationContext.class), any(JsonParser.class), any(JsonDeserializer.class), any(), anyString())).thenReturn(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.addHandler(handler); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] assertTrue(context.handleUnknownProperty(jp, deser, instanceOrClass, propName)); [EOL] }
public void testHandleUnknownPropertyWithNonNullHandlersReturningFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] Object instanceOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] DeserializationProblemHandler handler = mock(DeserializationProblemHandler.class); [EOL] when(handler.handleUnknownProperty(any(DeserializationContext.class), any(JsonParser.class), any(JsonDeserializer.class), any(), anyString())).thenReturn(false); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.addHandler(handler); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] assertFalse(context.handleUnknownProperty(jp, deser, instanceOrClass, propName)); [EOL] }
public void testWeirdStringExceptionWithValidInput() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String value = "someString"; [EOL] Class<?> instClass = Integer.class; [EOL] String msg = "not a valid integer"; [EOL] try { [EOL] mapper.weirdStringException(value, instClass, msg); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not construct instance of java.lang.Integer from String value 'someString': not a valid integer", e.getOriginalMessage()); [EOL] assertEquals(value, e.getValue()); [EOL] assertEquals(instClass, e.getTargetType()); [EOL] } [EOL] }
public void testGetDateFormatWithNonNullDateFormat() { [EOL] DateFormat initialFormat = new SimpleDateFormat(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper._dateFormat = initialFormat; // Assuming direct access for the test or use reflection if it's private [EOL] DateFormat resultFormat = objectMapper.getDateFormat(); [EOL] assertSame("Expected the initial DateFormat to be returned", initialFormat, resultFormat); [EOL] }
public void testGetDateFormatWithNullDateFormat() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper._dateFormat = null; // Assuming direct access for the test or use reflection if it's private [EOL] DateFormat expectedFormat = DateFormat.getDateInstance(); [EOL] objectMapper._config = new DeserializationConfig(null, null, null, null, null, null, null, expectedFormat); // Mock or create a real instance with the expected DateFormat [EOL] DateFormat resultFormat = objectMapper.getDateFormat(); [EOL] assertNotNull("Expected a non-null DateFormat", resultFormat); [EOL] assertNotSame("Expected a cloned instance of DateFormat", expectedFormat, resultFormat); [EOL] }
public void testValueDescWithValidText() throws Exception { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getText()).thenReturn("valid text"); [EOL] JsonMappingException exception = new JsonMappingException(parser, "Exception message"); [EOL] String result = exception._valueDesc(); [EOL] assertEquals("valid text", result); [EOL] }
public void testValueDescWithException() throws Exception { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getText()).thenThrow(new IOException()); [EOL] JsonMappingException exception = new JsonMappingException(parser, "Exception message"); [EOL] String result = exception._valueDesc(); [EOL] assertEquals("[N/A]", result); [EOL] }
public void testDescWithShortString() { [EOL] String shortDesc = "Short description"; [EOL] String result = _desc(shortDesc); [EOL] assertEquals(shortDesc, result); [EOL] }
public void testDescWithMaxLengthString() { [EOL] String maxDesc = generateStringOfLength(MAX_ERROR_STR_LEN); [EOL] String result = _desc(maxDesc); [EOL] assertEquals(maxDesc, result); [EOL] }
public void testDescWithLongString() { [EOL] String longDesc = generateStringOfLength(MAX_ERROR_STR_LEN + 1); [EOL] String result = _desc(longDesc); [EOL] String expected = longDesc.substring(0, MAX_ERROR_STR_LEN) + "]...[" + longDesc.substring(longDesc.length() - MAX_ERROR_STR_LEN); [EOL] assertEquals(expected, result); [EOL] } [EOL] private String generateStringOfLength(int length) { [EOL] return String.join("", Collections.nCopies(length, "a")); [EOL] }
public void testFormatWithNonNullDateAndBuffer() { [EOL] ISO8601DateFormat df = new ISO8601DateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer result = df.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testFormatWithNullDate() { [EOL] ISO8601DateFormat df = new ISO8601DateFormat(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] try { [EOL] df.format(null, toAppendTo, fieldPosition); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFormatWithNullStringBuffer() { [EOL] ISO8601DateFormat df = new ISO8601DateFormat(); [EOL] Date date = new Date(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] try { [EOL] df.format(date, null, fieldPosition); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testDeserializerInstanceWithNull() { [EOL] JsonDeserializer<Object> result = deserializerInstance(annotated, null); [EOL] assertNull(result); [EOL] }
public void testDeserializerInstanceWithJsonDeserializer() { [EOL] JsonDeserializer<?> jsonDeserializer = new MyJsonDeserializer(); [EOL] JsonDeserializer<Object> result = deserializerInstance(annotated, jsonDeserializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyJsonDeserializer); [EOL] }
public void testDeserializerInstanceWithInvalidType() { [EOL] Object invalidDeserDef = new Object(); [EOL] try { [EOL] deserializerInstance(annotated, invalidDeserDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned deserializer definition of type " + invalidDeserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testDeserializerInstanceWithNoneClass() { [EOL] JsonDeserializer<Object> result = deserializerInstance(annotated, JsonDeserializer.None.class); [EOL] assertNull(result); [EOL] }
public void testDeserializerInstanceWithNoClass() { [EOL] JsonDeserializer<Object> result = deserializerInstance(annotated, NoClass.class); [EOL] assertNull(result); [EOL] }
public void testDeserializerInstanceWithNonJsonDeserializerClass() { [EOL] try { [EOL] deserializerInstance(annotated, String.class); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class " + String.class.getName() + "; expected Class<JsonDeserializer>", e.getMessage()); [EOL] } [EOL] }
public void testDeserializerInstanceWithValidJsonDeserializerClass() { [EOL] JsonDeserializer<Object> result = deserializerInstance(annotated, MyJsonDeserializer.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyJsonDeserializer); [EOL] }
public void testDeserializerInstanceWithResolvableDeserializer() { [EOL] JsonDeserializer<?> resolvableDeserializer = new MyResolvableDeserializer(); [EOL] JsonDeserializer<Object> result = deserializerInstance(annotated, resolvableDeserializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyResolvableDeserializer); [EOL] assertTrue(((MyResolvableDeserializer) result).isResolved()); [EOL] }
public void testKeyDeserializerInstanceWithNull() { [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, null); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithKeyDeserializer() { [EOL] KeyDeserializer expectedDeserializer = new MyKeyDeserializer(); [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, expectedDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testKeyDeserializerInstanceWithInvalidType() { [EOL] Object invalidDeserDef = new Object(); [EOL] try { [EOL] instance.keyDeserializerInstance(null, invalidDeserDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned key deserializer definition of type java.lang.Object; expected type KeyDeserializer or Class<KeyDeserializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testKeyDeserializerInstanceWithNoneClass() { [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, KeyDeserializer.None.class); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithNoClass() { [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, NoClass.class); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithNonKeyDeserializerClass() { [EOL] try { [EOL] instance.keyDeserializerInstance(null, String.class); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class java.lang.String; expected Class<KeyDeserializer>", e.getMessage()); [EOL] } [EOL] }
public void testKeyDeserializerInstanceWithKeyDeserializerSubclass() { [EOL] Class<?> deserClass = MyKeyDeserializerSubclass.class; [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, deserClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyKeyDeserializerSubclass); [EOL] }
public void testKeyDeserializerInstanceWithResolvableDeserializer() { [EOL] Class<?> deserClass = MyResolvableKeyDeserializer.class; [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, deserClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyResolvableKeyDeserializer); [EOL] assertTrue(((MyResolvableKeyDeserializer) result).isResolved()); [EOL] }
public void testSerializeWithType_NullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenReturn(null); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeWithType_NonNullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenReturn("test"); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(valueSerializer); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] verify(valueSerializer).serializeWithType("test", jgen, provider, typeSer); [EOL] }
public void testSerializeWithType_ForceTypeInformation() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenReturn("test"); [EOL] MySerializer serializer = new MySerializer(accessorMethod, valueSerializer, true); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForScalar(bean, jgen); [EOL] verify(valueSerializer).serialize("test", jgen, provider); [EOL] verify(typeSer).writeTypeSuffixForScalar(bean, jgen); [EOL] }
public void testSerializeWithType_ExceptionThrown() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenThrow(new IllegalAccessException()); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] try { [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals(IllegalAccessException.class, e.getCause().getClass()); [EOL] } [EOL] }
public void testIsExplicitlyIncluded_AllFalse() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setFields(false); [EOL] obj.setGetters(false); [EOL] obj.setSetters(false); [EOL] obj.setCtorParameters(false); [EOL] boolean result = obj.isExplicitlyIncluded(); [EOL] assertFalse(result); [EOL] }
public void testIsExplicitlyIncluded_FieldsTrue() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setFields(true); [EOL] obj.setGetters(false); [EOL] obj.setSetters(false); [EOL] obj.setCtorParameters(false); [EOL] boolean result = obj.isExplicitlyIncluded(); [EOL] assertTrue(result); [EOL] }
public void testIsExplicitlyIncluded_GettersTrue() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setFields(false); [EOL] obj.setGetters(true); [EOL] obj.setSetters(false); [EOL] obj.setCtorParameters(false); [EOL] boolean result = obj.isExplicitlyIncluded(); [EOL] assertTrue(result); [EOL] }
public void testIsExplicitlyIncluded_SettersTrue() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setFields(false); [EOL] obj.setGetters(false); [EOL] obj.setSetters(true); [EOL] obj.setCtorParameters(false); [EOL] boolean result = obj.isExplicitlyIncluded(); [EOL] assertTrue(result); [EOL] }
public void testIsExplicitlyIncluded_CtorParametersTrue() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setFields(false); [EOL] obj.setGetters(false); [EOL] obj.setSetters(false); [EOL] obj.setCtorParameters(true); [EOL] boolean result = obj.isExplicitlyIncluded(); [EOL] assertTrue(result); [EOL] }
public void testGetSetterWithNullSetters() { [EOL] instance._setters = null; [EOL] AnnotatedMethod result = instance.getSetter(); [EOL] assertNull(result); [EOL] }
public void testGetSetterWithSingleSetter() { [EOL] AnnotatedMethod singleSetter = createAnnotatedMethod(); [EOL] instance._setters = new Linked<>(singleSetter, null, null); [EOL] AnnotatedMethod result = instance.getSetter(); [EOL] assertSame(singleSetter, result); [EOL] }
public void testGetSetterWithMultipleSettersSameClass() { [EOL] AnnotatedMethod setter1 = createAnnotatedMethod(); [EOL] AnnotatedMethod setter2 = createAnnotatedMethod(); [EOL] instance._setters = new Linked<>(setter1, new Linked<>(setter2, null, null), null); [EOL] try { [EOL] instance.getSetter(); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetSetterWithMultipleSettersDifferentClasses() { [EOL] AnnotatedMethod setter1 = createAnnotatedMethod(SomeClass.class); [EOL] AnnotatedMethod setter2 = createAnnotatedMethod(AnotherClass.class); [EOL] instance._setters = createLinked(setter1, setter2); [EOL] AnnotatedMethod result = instance.getSetter(); [EOL] assertSame(setter2, result); [EOL] }
public void testGetSetterWithMultipleSettersInheritance() { [EOL] AnnotatedMethod setter1 = createAnnotatedMethod(ParentClass.class); [EOL] AnnotatedMethod setter2 = createAnnotatedMethod(ChildClass.class); [EOL] instance._setters = createLinked(setter1, setter2); [EOL] AnnotatedMethod result = instance.getSetter(); [EOL] assertSame(setter2, result); [EOL] }
public void testGetFieldWhenFieldsIsNull() { [EOL] instance._fields = null; [EOL] AnnotatedField result = instance.getField(); [EOL] assertNull(result); [EOL] }
public void testGetFieldWhenFieldsIsNotNullButNoNext() { [EOL] instance._fields = new Linked<>(new AnnotatedField(), null); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(instance._fields.value, result); [EOL] }
public void testGetFieldWhenNextFieldIsSubclass() { [EOL] AnnotatedField field1 = new AnnotatedField(); // Assuming AnnotatedField constructor and a method to set declaring class [EOL] AnnotatedField field2 = new AnnotatedField(); [EOL] field1.setDeclaringClass(ParentClass.class); [EOL] field2.setDeclaringClass(ChildClass.class); // ChildClass extends ParentClass [EOL] instance._fields = new Linked<>(field1, new Linked<>(field2, null)); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(field2, result); [EOL] }
public void testGetFieldWhenNextFieldIsSuperclass() { [EOL] AnnotatedField field1 = new AnnotatedField(); [EOL] AnnotatedField field2 = new AnnotatedField(); [EOL] field1.setDeclaringClass(ChildClass.class); [EOL] field2.setDeclaringClass(ParentClass.class); // ChildClass extends ParentClass [EOL] instance._fields = new Linked<>(field1, new Linked<>(field2, null)); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(field1, result); [EOL] }
public void testGetFieldWhenFieldsRepresentDifferentProperties() { [EOL] AnnotatedField field1 = new AnnotatedField(); [EOL] AnnotatedField field2 = new AnnotatedField(); [EOL] field1.setDeclaringClass(OneClass.class); [EOL] field2.setDeclaringClass(AnotherClass.class); [EOL] instance._fields = new Linked<>(field1, new Linked<>(field2, null)); [EOL] try { [EOL] instance.getField(); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetConstructorParameter_WithNullCtorParameters() { [EOL] YourClass instance = new YourClass(null); [EOL] AnnotatedParameter result = instance.getConstructorParameter(); [EOL] assertNull(result); [EOL] }
public void testGetConstructorParameter_WithNonConstructorOwner() { [EOL] Linked<AnnotatedParameter> nonConstructorParam = new Linked<>( [EOL] new AnnotatedParameter(new Object(), null, null, null), null); [EOL] YourClass instance = new YourClass(nonConstructorParam); [EOL] AnnotatedParameter result = instance.getConstructorParameter(); [EOL] assertEquals(nonConstructorParam.value, result); [EOL] }
public void testGetConstructorParameter_WithConstructorOwner() { [EOL] AnnotatedConstructor owner = new AnnotatedConstructor(null, null, null); [EOL] AnnotatedParameter constructorParam = new AnnotatedParameter(owner, null, null, null); [EOL] Linked<AnnotatedParameter> ctorParameters = new Linked<>(constructorParam, null); [EOL] YourClass instance = new YourClass(ctorParameters); [EOL] AnnotatedParameter result = instance.getConstructorParameter(); [EOL] assertEquals(constructorParam, result); [EOL] }
public void testAnyExplicitNamesWithNullInput() { [EOL] boolean result = _anyExplicitNames(null); [EOL] assertFalse(result); [EOL] }
public void testAnyExplicitNamesWithNoExplicitNames() { [EOL] Linked<Object> n = new Linked<Object>(null, null, null, false); [EOL] boolean result = _anyExplicitNames(n); [EOL] assertFalse(result); [EOL] }
public void testAnyExplicitNamesWithExplicitNames() { [EOL] Linked<Object> n = new Linked<Object>(null, "name", null, false); [EOL] boolean result = _anyExplicitNames(n); [EOL] assertTrue(result); [EOL] }
public void testAnyExplicitNamesWithMultipleItemsNoExplicitNames() { [EOL] Linked<Object> n1 = new Linked<Object>(null, null, null, false); [EOL] Linked<Object> n2 = new Linked<Object>(n1, null, null, false); [EOL] boolean result = _anyExplicitNames(n2); [EOL] assertFalse(result); [EOL] }
public void testAnyExplicitNamesWithMultipleItemsSomeExplicitNames() { [EOL] Linked<Object> n1 = new Linked<Object>(null, null, null, false); [EOL] Linked<Object> n2 = new Linked<Object>(n1, "name", null, false); [EOL] boolean result = _anyExplicitNames(n2); [EOL] assertTrue(result); [EOL] }
public void testTrimByVisibility_WithNextNull() { [EOL] Linked<Object> linked = new Linked<>(null, null, null, false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertSame(linked, result); [EOL] }
public void testTrimByVisibility_WithNextAndExplicitName() { [EOL] Linked<Object> next = new Linked<>(null, null, "nextName", false); [EOL] Linked<Object> linked = new Linked<>(next, null, "explicitName", false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNotNull(result.getNext()); [EOL] assertEquals("explicitName", result.getExplicitName()); [EOL] }
public void testTrimByVisibility_WithNextAndNoExplicitName() { [EOL] Linked<Object> next = new Linked<>(null, null, null, false); [EOL] Linked<Object> linked = new Linked<>(next, null, null, false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNull(result.getNext()); [EOL] }
public void testTrimByVisibility_WithNextAndDifferentVisibility() { [EOL] Linked<Object> next = new Linked<>(null, null, null, true); [EOL] Linked<Object> linked = new Linked<>(next, null, null, false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertSame(next, result); [EOL] }
public void testTrimByVisibility_WithNextAndSameVisibility() { [EOL] Linked<Object> next = new Linked<>(null, null, null, false); [EOL] Linked<Object> linked = new Linked<>(next, null, null, false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNotNull(result.getNext()); [EOL] assertEquals(next, result.getNext()); [EOL] }
public void testNumberTypeReturnsDouble() { [EOL] JsonParser.NumberType expected = JsonParser.NumberType.DOUBLE; [EOL] JsonParser.NumberType actual = new YourConcreteJsonParser().numberType(); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsFloatingPointNumber() { [EOL] JsonNode node = new NumericNode() { [EOL] @Override [EOL] public boolean isFloatingPointNumber() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(node.isFloatingPointNumber()); [EOL] }
public void testIsDouble() { [EOL] JsonNode node = new NumericNode() { [EOL] @Override [EOL] public boolean isDouble() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(node.isDouble()); [EOL] }
public void testCanConvertToIntWithMinValue() { [EOL] long minValue = Integer.MIN_VALUE; [EOL] boolean result = new YourClass(minValue).canConvertToInt(); [EOL] assertTrue(result); [EOL] }
public void testCanConvertToIntWithMaxValue() { [EOL] long maxValue = Integer.MAX_VALUE; [EOL] boolean result = new YourClass(maxValue).canConvertToInt(); [EOL] assertTrue(result); [EOL] }
public void testCanConvertToIntWithBelowMinValue() { [EOL] long belowMinValue = (long) Integer.MIN_VALUE - 1; [EOL] boolean result = new YourClass(belowMinValue).canConvertToInt(); [EOL] assertFalse(result); [EOL] }
public void testCanConvertToIntWithAboveMaxValue() { [EOL] long aboveMaxValue = (long) Integer.MAX_VALUE + 1; [EOL] boolean result = new YourClass(aboveMaxValue).canConvertToInt(); [EOL] assertFalse(result); [EOL] }
public void testCanConvertToLongWithMinValue() { [EOL] DoubleValue doubleValue = new DoubleValue((double) Long.MIN_VALUE); [EOL] boolean result = doubleValue.canConvertToLong(); [EOL] assert(result); [EOL] }
public void testCanConvertToLongWithMaxValue() { [EOL] DoubleValue doubleValue = new DoubleValue((double) Long.MAX_VALUE); [EOL] boolean result = doubleValue.canConvertToLong(); [EOL] assert(result); [EOL] }
public void testCanConvertToLongWithLessThanMinValue() { [EOL] DoubleValue doubleValue = new DoubleValue((double) Long.MIN_VALUE - 1.0); [EOL] boolean result = doubleValue.canConvertToLong(); [EOL] assert(!result); [EOL] }
public void testCanConvertToLongWithMoreThanMaxValue() { [EOL] DoubleValue doubleValue = new DoubleValue((double) Long.MAX_VALUE + 1.0); [EOL] boolean result = doubleValue.canConvertToLong(); [EOL] assert(!result); [EOL] }
public void testNumberValueWithValidInput() { [EOL] TextNode node = new TextNode("123.45"); [EOL] Number result = node.numberValue(); [EOL] assertEquals(123.45, result.doubleValue(), 0.0); [EOL] }
public void testNumberValueWithInvalidInput() { [EOL] TextNode node = new TextNode("notANumber"); [EOL] try { [EOL] node.numberValue(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testIntValue_Positive() { [EOL] JsonNumber jsonNumber = new JsonNumber(123.0); [EOL] int expected = 123; [EOL] int actual = jsonNumber.intValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testIntValue_Negative() { [EOL] JsonNumber jsonNumber = new JsonNumber(-123.0); [EOL] int expected = -123; [EOL] int actual = jsonNumber.intValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testIntValue_Zero() { [EOL] JsonNumber jsonNumber = new JsonNumber(0.0); [EOL] int expected = 0; [EOL] int actual = jsonNumber.intValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Positive() { [EOL] YourClass instance = new YourClass(123.0); [EOL] long expected = 123L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Negative() { [EOL] YourClass instance = new YourClass(-123.0); [EOL] long expected = -123L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Zero() { [EOL] YourClass instance = new YourClass(0.0); [EOL] long expected = 0L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MaxLong() { [EOL] YourClass instance = new YourClass(Long.MAX_VALUE); [EOL] long expected = Long.MAX_VALUE; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MinLong() { [EOL] YourClass instance = new YourClass(Long.MIN_VALUE); [EOL] long expected = Long.MIN_VALUE; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testDoubleValue_Positive() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.valueOf(123.456)); [EOL] double result = node.doubleValue(); [EOL] assertEquals(123.456, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.valueOf(-123.456)); [EOL] double result = node.doubleValue(); [EOL] assertEquals(-123.456, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ZERO); [EOL] double result = node.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testDecimalValue_Positive() { [EOL] LongNode longNode = new LongNode(10L); [EOL] BigDecimal result = longNode.decimalValue(); [EOL] assertEquals(new BigDecimal("10"), result); [EOL] }
public void testDecimalValue_Negative() { [EOL] LongNode longNode = new LongNode(-10L); [EOL] BigDecimal result = longNode.decimalValue(); [EOL] assertEquals(new BigDecimal("-10"), result); [EOL] }
public void testDecimalValue_Zero() { [EOL] LongNode longNode = new LongNode(0L); [EOL] BigDecimal result = longNode.decimalValue(); [EOL] assertEquals(BigDecimal.ZERO, result); [EOL] }
public void testBigIntegerValueWithIntegerValue() { [EOL] JsonNode node = new IntNode(123); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testBigIntegerValueWithDecimalValue() { [EOL] JsonNode node = new DecimalNode(new BigDecimal("123.45")); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testEquals_sameObject() { [EOL] DoubleNode node = new DoubleNode(5.0); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEquals_nullObject() { [EOL] DoubleNode node = new DoubleNode(5.0); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEquals_differentClass() { [EOL] DoubleNode node = new DoubleNode(5.0); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEquals_differentValue() { [EOL] DoubleNode node1 = new DoubleNode(5.0); [EOL] DoubleNode node2 = new DoubleNode(5.1); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testEquals_sameValue() { [EOL] DoubleNode node1 = new DoubleNode(5.0); [EOL] DoubleNode node2 = new DoubleNode(5.0); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testHashCode() { [EOL] DoubleNode node = new DoubleNode(0.0); [EOL] long l = Double.doubleToLongBits(0.0); [EOL] int expectedHashCode = ((int) l) ^ (int) (l >> 32); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCodeWithDifferentValues() { [EOL] DoubleNode node1 = new DoubleNode(1.0); [EOL] DoubleNode node2 = new DoubleNode(Double.MAX_VALUE); [EOL] assertNotEquals(node1.hashCode(), node2.hashCode()); [EOL] }
public void testBuildWithEmptyBuffer() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object beanMock = new Object(); [EOL] when(buffer.getParameters(any())).thenReturn(new Object[0]); [EOL] when(valueInstantiator.createFromObjectWith(eq(ctxt), any())).thenReturn(beanMock); [EOL] when(buffer.buffered()).thenReturn(null); [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(valueInstantiator, null); [EOL] Object result = creator.build(ctxt, buffer); [EOL] assertSame("The created bean should be the same as the mock", beanMock, result); [EOL] }
public void testBuildWithNonEmptyBuffer() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object beanMock = new Object(); [EOL] PropertyValue propertyValueMock = mock(PropertyValue.class); [EOL] when(buffer.getParameters(any())).thenReturn(new Object[0]); [EOL] when(valueInstantiator.createFromObjectWith(eq(ctxt), any())).thenReturn(beanMock); [EOL] when(buffer.buffered()).thenReturn(propertyValueMock); [EOL] when(propertyValueMock.next).thenReturn(null); [EOL] doNothing().when(propertyValueMock).assign(any()); [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(valueInstantiator, null); [EOL] Object result = creator.build(ctxt, buffer); [EOL] verify(propertyValueMock, times(1)).assign(beanMock); [EOL] assertSame("The created bean should be the same as the mock", beanMock, result); [EOL] }
public void testBuildWithIdHandling() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object beanMock = new Object(); [EOL] Object beanWithIdMock = new Object(); [EOL] when(buffer.getParameters(any())).thenReturn(new Object[0]); [EOL] when(valueInstantiator.createFromObjectWith(eq(ctxt), any())).thenReturn(beanMock); [EOL] when(buffer.handleIdValue(eq(ctxt), any())).thenReturn(beanWithIdMock); [EOL] when(buffer.buffered()).thenReturn(null); [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(valueInstantiator, null); [EOL] Object result = creator.build(ctxt, buffer); [EOL] assertSame("The bean should have its ID handled", beanWithIdMock, result); [EOL] }
It appears that the provided input text is for a constructor of a `JsonNode` class that is empty. Since the constructor does not contain any executable lines of code other than the opening and closing braces, there are no lines of code to cover with unit tests. Therefore, no unit test cases can be generated for this specific input. [EOL] If you have another method or a more complex constructor with executable lines of code, please provide that, and I can generate the corresponding unit test cases.
public void testSizeReturnsZero() { [EOL] YourClass instance = new YourClass(); [EOL] int result = instance.size(); [EOL] assertEquals(0, result); [EOL] }
public void testIsContainerNodeWithObjectNode() { [EOL] JsonNode node = JsonNodeFactory.instance.objectNode(); [EOL] assertTrue(node.isContainerNode()); [EOL] }
public void testIsContainerNodeWithArrayNode() { [EOL] JsonNode node = JsonNodeFactory.instance.arrayNode(); [EOL] assertTrue(node.isContainerNode()); [EOL] }
public void testIsContainerNodeWithTextNode() { [EOL] JsonNode node = new TextNode("text"); [EOL] assertFalse(node.isContainerNode()); [EOL] }
public void testFieldNamesReturnsEmptyIterator() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] Iterator<String> fieldNames = node.fieldNames(); [EOL] assertFalse(fieldNames.hasNext()); [EOL] }
public void testIsNumber_NodeTypeNumber() { [EOL] JsonNode node = new NumericNode(); // Assuming NumericNode is a subtype of JsonNode and represents JsonNodeType.NUMBER [EOL] boolean result = node.isNumber(); [EOL] assert result; [EOL] } [EOL] public void testIsNumber_NodeTypeNotNumber() { [EOL] JsonNode node = new TextNode("not a number"); // Assuming TextNode is a subtype of JsonNode and represents a non-number type [EOL] boolean result = node.isNumber(); [EOL] assert !result; [EOL] }
public void testIsBigDecimal() { [EOL] JsonNode node = new TextNode("test"); [EOL] assertFalse(node.isBigDecimal()); [EOL] }
public void testIsBigInteger() { [EOL] JsonNode node = new TextNode("test"); [EOL] assertFalse(node.isBigInteger()); [EOL] }
public void testNumberValueReturnsNull() { [EOL] JsonNode node = new NumericNode(); // Assuming NumericNode is a subclass of JsonNode [EOL] Number result = node.numberValue(); [EOL] assertNull(result); [EOL] }
public int intValue() { [EOL] return 0; [EOL] }
public long longValue() { [EOL] return 0L; [EOL] }
public void testDecimalValueReturnsZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode node = mapper.createObjectNode().numberNode(BigDecimal.ZERO); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals("The decimalValue method should return BigDecimal.ZERO", BigDecimal.ZERO, result); [EOL] }
public void testBigIntegerValueReturnsZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode node = mapper.createObjectNode(); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(BigInteger.ZERO, result); [EOL] }
public int asInt() { [EOL] return asInt(0); [EOL] }
public int asInt(int defaultValue) { [EOL] return defaultValue; [EOL] }
public long asLong() { [EOL] return asLong(0L); [EOL] }
public long asLongTestWithDefaultValue() { [EOL] long defaultValue = 5L; [EOL] long result = asLong(defaultValue); [EOL] assert result == defaultValue; [EOL] }
public double asDouble() { [EOL] return asDouble(0.0); [EOL] }
public double asDoubleTestWithDefaultValue() { [EOL] double defaultValue = 10.0; [EOL] double result = asDouble(defaultValue); [EOL] assert result == defaultValue; [EOL] }
public void testElementsReturnsEmptyIterator() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] Iterator<JsonNode> elements = node.elements(); [EOL] assertFalse(elements.hasNext()); [EOL] }
public void testFindValuesWhenResultIsNull() { [EOL] JsonNode rootNode = createNodeWithNoMatchingField(); // Implement this to create a JsonNode with no field matching 'fieldName' [EOL] List<JsonNode> result = rootNode.findValues("fieldName"); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testFindValuesWhenResultIsNotNull() { [EOL] JsonNode rootNode = createNodeWithMatchingField(); // Implement this to create a JsonNode with a field matching 'fieldName' [EOL] List<JsonNode> result = rootNode.findValues("fieldName"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindValuesAsTextWithNonNullResult() { [EOL] setupDataWithNonNullResultForFieldName("testFieldName"); [EOL] List<String> result = instance.findValuesAsText("testFieldName"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] } [EOL] public void testFindValuesAsTextWithNullResult() { [EOL] setupDataWithNullResultForFieldName("testFieldName"); [EOL] List<String> result = instance.findValuesAsText("testFieldName"); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindParentsWhenResultIsNull() { [EOL] JsonNode rootNode = createRootNodeWithNoMatchingChildren(); // Implement this to create a node with no children matching the fieldName [EOL] List<JsonNode> result = rootNode.findParents("nonExistingField"); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testFindParentsWhenResultIsNotNull() { [EOL] JsonNode rootNode = createRootNodeWithMatchingChildren(); // Implement this to create a node with children matching the fieldName [EOL] List<JsonNode> result = rootNode.findParents("existingField"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testCanBeABeanTypeWithAnnotation() { [EOL] String result = YourClass.canBeABeanType(YourAnnotation.class); [EOL] assertEquals("annotation", result); [EOL] }
public void testCanBeABeanTypeWithArray() { [EOL] String result = YourClass.canBeABeanType(String[].class); [EOL] assertEquals("array", result); [EOL] }
public void testCanBeABeanTypeWithEnum() { [EOL] String result = YourClass.canBeABeanType(YourEnum.class); [EOL] assertEquals("enum", result); [EOL] }
public void testCanBeABeanTypeWithPrimitive() { [EOL] String result = YourClass.canBeABeanType(int.class); [EOL] assertEquals("primitive", result); [EOL] }
public void testCanBeABeanTypeWithRegularClass() { [EOL] String result = YourClass.canBeABeanType(String.class); [EOL] assertNull(result); [EOL] }
public void testIsLocalTypeWithLocalClass() { [EOL] class LocalClass {} [EOL] String result = ClassNameUtils.isLocalType(LocalClass.class, true); [EOL] assertEquals("local/anonymous", result); [EOL] }
public void testIsLocalTypeWithNonStaticMemberClass() { [EOL] class NonStaticMemberClass {} [EOL] String result = ClassNameUtils.isLocalType(NonStaticMemberClass.class, false); [EOL] assertEquals("non-static member class", result); [EOL] }
public void testIsLocalTypeWithStaticMemberClass() { [EOL] static class StaticMemberClass {} [EOL] String result = ClassNameUtils.isLocalType(StaticMemberClass.class, false); [EOL] assertNull(result); [EOL] }
public void testIsLocalTypeWithNonStaticMemberClassAllowingNonStatic() { [EOL] class NonStaticMemberClass {} [EOL] String result = ClassNameUtils.isLocalType(NonStaticMemberClass.class, true); [EOL] assertNull(result); [EOL] }
public void testIsLocalTypeWithNullClass() { [EOL] String result = ClassNameUtils.isLocalType(null, true); [EOL] assertNull(result); [EOL] }
public void testIsLocalTypeWithSecurityException() { [EOL] Class<?> type = createClassWithSecurityExceptionOnEnclosingMethod(); [EOL] String result = ClassNameUtils.isLocalType(type, true); [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithEnclosingMethod() { [EOL] Class<?> innerClass = new Object() { [EOL] void innerMethod() { [EOL] } [EOL] }.getClass(); [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(innerClass); [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithNoEnclosingMethodAndNonStatic() { [EOL] class NonStaticInnerClass { [EOL] } [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(NonStaticInnerClass.class); [EOL] assertNotNull(result); [EOL] assertEquals(NonStaticInnerClass.class.getEnclosingClass(), result); [EOL] }
public void testGetOuterClassWithNoEnclosingMethodAndStatic() { [EOL] static class StaticInnerClass { [EOL] } [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(StaticInnerClass.class); [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithSecurityException() { [EOL] Class<?> type = new Object() { [EOL] void innerMethod() { [EOL] } [EOL] }.getClass(); [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("accessDeclaredMembers".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] Class<?> result = null; [EOL] try { [EOL] result = JacksonDatabindUtils.getOuterClass(type); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithNullPointerException() { [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(null); [EOL] assertNull(result); [EOL] }
public void testIsConcreteWithConcreteClass() { [EOL] boolean result = JacksonDatabindUtils.isConcrete(String.class); [EOL] assertTrue(result); [EOL] }
public void testIsConcreteWithInterface() { [EOL] boolean result = JacksonDatabindUtils.isConcrete(List.class); [EOL] assertFalse(result); [EOL] }
public void testIsConcreteWithAbstractClass() { [EOL] boolean result = JacksonDatabindUtils.isConcrete(AbstractList.class); [EOL] assertFalse(result); [EOL] }
public void testFindClassWithPrimitiveName() throws ClassNotFoundException { [EOL] assertEquals(Integer.TYPE, YourClass.findClass("int")); [EOL] assertEquals(Long.TYPE, YourClass.findClass("long")); [EOL] assertEquals(Float.TYPE, YourClass.findClass("float")); [EOL] assertEquals(Double.TYPE, YourClass.findClass("double")); [EOL] assertEquals(Boolean.TYPE, YourClass.findClass("boolean")); [EOL] assertEquals(Byte.TYPE, YourClass.findClass("byte")); [EOL] assertEquals(Character.TYPE, YourClass.findClass("char")); [EOL] assertEquals(Short.TYPE, YourClass.findClass("short")); [EOL] assertEquals(Void.TYPE, YourClass.findClass("void")); [EOL] }
public void testFindClassWithNonPrimitiveName() { [EOL] try { [EOL] Class<?> clazz = YourClass.findClass("java.lang.String"); [EOL] assertEquals(String.class, clazz); [EOL] } catch (ClassNotFoundException e) { [EOL] fail("Class should be found"); [EOL] } [EOL] }
public void testFindClassWithInvalidName() { [EOL] try { [EOL] YourClass.findClass("invalidClassName"); [EOL] fail("ClassNotFoundException expected"); [EOL] } catch (ClassNotFoundException e) { [EOL] } [EOL] }
public void testFindClassWithNullClassLoader() throws ClassNotFoundException { [EOL] Thread.currentThread().setContextClassLoader(null); [EOL] try { [EOL] Class<?> clazz = YourClass.findClass("java.lang.String"); [EOL] assertEquals(String.class, clazz); [EOL] } finally { [EOL] } [EOL] }
public void testFindClassThrowsRuntimeException() { [EOL] try { [EOL] YourClass.findClass("some.class.ThatCausesRuntimeException"); [EOL] fail("RuntimeException expected"); [EOL] } catch (RuntimeException e) { [EOL] } catch (ClassNotFoundException e) { [EOL] fail("RuntimeException expected, not ClassNotFoundException"); [EOL] } [EOL] }
public void testFindEnumTypeWithNonEmptyEnumSet() { [EOL] EnumSet<TimeUnit> nonEmptyEnumSet = EnumSet.of(TimeUnit.SECONDS); [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(nonEmptyEnumSet); [EOL] assertNotNull(result); [EOL] assertEquals(TimeUnit.class, result); [EOL] }
public void testFindEnumTypeWithEmptyEnumSet() { [EOL] EnumSet<TimeUnit> emptyEnumSet = EnumSet.noneOf(TimeUnit.class); [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(emptyEnumSet); [EOL] assertNotNull(result); [EOL] assertEquals(EnumTypeLocator.instance.enumTypeFor(emptyEnumSet), result); [EOL] }
public void testFindEnumTypeWithEnumSubclass() { [EOL] Enum<?> testEnum = TimeUnit.SECONDS; [EOL] Class<? extends Enum<?>> enumClass = JacksonDatabindUtils.findEnumType(testEnum); [EOL] assertEquals(TimeUnit.class, enumClass); [EOL] }
public void testFindEnumTypeWithDirectEnum() { [EOL] Enum<?> testEnum = Thread.State.NEW; [EOL] Class<? extends Enum<?>> enumClass = JacksonDatabindUtils.findEnumType(testEnum); [EOL] assertEquals(Thread.State.class, enumClass); [EOL] }
public void testFindEnumTypeWithEnumClass() { [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(MyEnum.class); [EOL] assertEquals(MyEnum.class, result); [EOL] } [EOL] public void testFindEnumTypeWithSubclassOfEnum() { [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(MyEnumSubclass.class); [EOL] assertEquals(MyEnum.class, result); [EOL] }
public void testFindEnumTypeWithNonEnumClass() { [EOL] try { [EOL] JacksonDatabindUtils.findEnumType(MyNonEnumClass.class); [EOL] fail("Should have thrown an exception for non-enum class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructWithIllegalArgument() { [EOL] MapperConfig<?> config = null; // Replace with actual MapperConfig instance [EOL] JavaType baseType = null; // Replace with actual JavaType instance [EOL] Collection<NamedType> subtypes = null; // Replace with actual subtypes collection [EOL] try { [EOL] TypeNameIdResolver.construct(config, baseType, subtypes, true, true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructForSerialization() { [EOL] MapperConfig<?> config = null; // Replace with actual MapperConfig instance [EOL] JavaType baseType = null; // Replace with actual JavaType instance [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] subtypes.add(new NamedType(String.class, "string")); // Replace with actual subtype [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, true, false); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructForDeserialization() { [EOL] MapperConfig<?> config = null; // Replace with actual MapperConfig instance [EOL] JavaType baseType = null; // Replace with actual JavaType instance [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] subtypes.add(new NamedType(String.class, "string")); // Replace with actual subtype [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, false, true); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructWithSubtypesForDeserialization() { [EOL] MapperConfig<?> config = null; // Replace with actual MapperConfig instance [EOL] JavaType baseType = null; // Replace with actual JavaType instance [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] subtypes.add(new NamedType(String.class, "string")); // Replace with actual subtype [EOL] subtypes.add(new NamedType(Integer.class, "int")); // Replace with actual subtype [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, false, true); [EOL] assertNotNull(resolver); [EOL] }
public void testIdFromValueWithCachedName() { [EOL] String expectedName = "CachedName"; [EOL] _typeToId.put(String.class.getName(), expectedName); [EOL] String actualName = idFromValue("Test String"); [EOL] assertEquals(expectedName, actualName); [EOL] }
public void testIdFromValueWithAnnotationProcessingEnabledAndNameFound() { [EOL] when(_config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(_config.introspectClassAnnotations(String.class)).thenReturn(beanDesc); [EOL] ClassInfo classInfo = mock(ClassInfo.class); [EOL] when(beanDesc.getClassInfo()).thenReturn(classInfo); [EOL] String expectedName = "AnnotatedName"; [EOL] when(_config.getAnnotationIntrospector().findTypeName(classInfo)).thenReturn(expectedName); [EOL] String actualName = idFromValue("Test String"); [EOL] assertEquals(expectedName, actualName); [EOL] assertEquals(expectedName, _typeToId.get(String.class.getName())); [EOL] }
public void testIdFromValueWithAnnotationProcessingEnabledAndNameNotFound() { [EOL] when(_config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(_config.introspectClassAnnotations(String.class)).thenReturn(beanDesc); [EOL] ClassInfo classInfo = mock(ClassInfo.class); [EOL] when(beanDesc.getClassInfo()).thenReturn(classInfo); [EOL] when(_config.getAnnotationIntrospector().findTypeName(classInfo)).thenReturn(null); [EOL] String expectedName = "DefaultName"; [EOL] when(_defaultTypeId(String.class)).thenReturn(expectedName); [EOL] String actualName = idFromValue("Test String"); [EOL] assertEquals(expectedName, actualName); [EOL] assertEquals(expectedName, _typeToId.get(String.class.getName())); [EOL] }
public void testIdFromValueWithAnnotationProcessingDisabled() { [EOL] when(_config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] String expectedName = "DefaultName"; [EOL] when(_defaultTypeId(String.class)).thenReturn(expectedName); [EOL] String actualName = idFromValue("Test String"); [EOL] assertEquals(expectedName, actualName); [EOL] assertEquals(expectedName, _typeToId.get(String.class.getName())); [EOL] }
public void testWithContentTypeHandler_NewHandler() { [EOL] CollectionType original = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] Object newContentTypeHandler = new Object(); [EOL] CollectionType newType = original.withContentTypeHandler(newContentTypeHandler); [EOL] assertNotNull(newType); [EOL] assertNotSame(original, newType); [EOL] assertSame(newContentTypeHandler, newType.getContentTypeHandler()); [EOL] assertSame(original.getRawClass(), newType.getRawClass()); [EOL] assertSame(original.getValueHandler(), newType.getValueHandler()); [EOL] assertSame(original.getTypeHandler(), newType.getTypeHandler()); [EOL] assertSame(original.isStatic(), newType.isStatic()); [EOL] assertNotSame(original.getContentType(), newType.getContentType()); [EOL] assertSame(newContentTypeHandler, newType.getContentType().getTypeHandler()); [EOL] }

public void testSerializeContentsWithNonNullElementSerializer() throws IOException { [EOL] EnumSet<TestEnum> value = EnumSet.of(TestEnum.VALUE1, TestEnum.VALUE2); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> enumSer = mock(JsonSerializer.class); [EOL] EnumSetSerializer serializer = new EnumSetSerializer(enumSer, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(enumSer, times(2)).serialize(any(Enum.class), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithNullElementSerializer() throws IOException { [EOL] EnumSet<TestEnum> value = EnumSet.of(TestEnum.VALUE1, TestEnum.VALUE2); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] EnumSetSerializer serializer = new EnumSetSerializer(null, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(provider, times(2)).findValueSerializer(any(Class.class), any(BeanProperty.class)); [EOL] verify(provider, times(2)).findValueSerializer(eq(TestEnum.class), any(BeanProperty.class)); [EOL] }
public void testCouldDeserializeWithNonNullMutator() { [EOL] YourClass instance = new YourClass(); [EOL] when(instance.getMutator()).thenReturn(new Mutator()); [EOL] boolean result = instance.couldDeserialize(); [EOL] assertTrue(result); [EOL] }
public void testCouldDeserializeWithNullMutator() { [EOL] YourClass instance = new YourClass(); [EOL] when(instance.getMutator()).thenReturn(null); [EOL] boolean result = instance.couldDeserialize(); [EOL] assertFalse(result); [EOL] }
public void testWithAdditionalSerializersWithNonNull() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] Serializers additional = Mockito.mock(Serializers.class); [EOL] SerializerFactoryConfig newConfig = config.withAdditionalSerializers(additional); [EOL] assertNotNull(newConfig); [EOL] }
public void testWithAdditionalSerializersWithNull() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] try { [EOL] config.withAdditionalSerializers(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null Serializers", e.getMessage()); [EOL] } [EOL] }
public void testHasKeySerializers_WithEmptyKeySerializers() { [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] assertFalse(provider.hasKeySerializers()); [EOL] }
public void testHasKeySerializers_WithNonEmptyKeySerializers() { [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setAdditionalKeySerializers(new JsonSerializer[]{new StdKeySerializer()}); [EOL] assertTrue(provider.hasKeySerializers()); [EOL] }
public void testAddSerializerWithNullHandledType() { [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(ser.handledType()).thenReturn(null); [EOL] try { [EOL] addSerializer(ser); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("JsonSerializer of type " + ser.getClass().getName() + " does not define valid handledType() -- must either register with method that takes type argument or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'", e.getMessage()); [EOL] } [EOL] }
public void testAddSerializerWithObjectHandledType() { [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(ser.handledType()).thenReturn(Object.class); [EOL] try { [EOL] addSerializer(ser); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("JsonSerializer of type " + ser.getClass().getName() + " does not define valid handledType() -- must either register with method that takes type argument or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'", e.getMessage()); [EOL] } [EOL] }
public void testAddSerializerWithValidHandledType() { [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] Class<?> handledType = String.class; [EOL] when(ser.handledType()).thenReturn(handledType); [EOL] addSerializer(ser); [EOL] verify(this, times(1))._addSerializer(handledType, ser); [EOL] }
public void testAddSerializerWithInterface() { [EOL] SerializerProviderImpl provider = new SerializerProviderImpl(); [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] provider._addSerializer(MyInterface.class, serializer); [EOL] assertNotNull(provider._interfaceMappings); [EOL] assertTrue(provider._interfaceMappings.containsKey(new ClassKey(MyInterface.class))); [EOL] assertEquals(serializer, provider._interfaceMappings.get(new ClassKey(MyInterface.class))); [EOL] }
public void testAddSerializerWithNonInterface() { [EOL] SerializerProviderImpl provider = new SerializerProviderImpl(); [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] provider._addSerializer(MyClass.class, serializer); [EOL] assertNotNull(provider._classMappings); [EOL] assertTrue(provider._classMappings.containsKey(new ClassKey(MyClass.class))); [EOL] assertEquals(serializer, provider._classMappings.get(new ClassKey(MyClass.class))); [EOL] }
public void testFindSerializerWithInterface() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(InterfaceClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(InterfaceClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithClass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(ConcreteClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(ConcreteClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithSuperclass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(SubClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(SubClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithNoMapping() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(UnmappedClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(UnmappedClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNull(serializer); [EOL] }
public void testFindInterfaceMappingWithDirectMapping() { [EOL] ClassKey key = new ClassKey(SomeInterface.class); [EOL] JsonSerializer<?> expectedSerializer = new SomeJsonSerializer(); [EOL] _interfaceMappings.put(key, expectedSerializer); [EOL] JsonSerializer<?> result = _findInterfaceMapping(SomeClassImplementingInterface.class, key); [EOL] assertSame("Should find the direct mapping for interface", expectedSerializer, result); [EOL] }
public void testFindInterfaceMappingWithInheritedMapping() { [EOL] ClassKey key = new ClassKey(SomeInterface.class); [EOL] JsonSerializer<?> expectedSerializer = new SomeJsonSerializer(); [EOL] _interfaceMappings.put(key, expectedSerializer); [EOL] JsonSerializer<?> result = _findInterfaceMapping(SomeSubclassImplementingInterface.class, key); [EOL] assertSame("Should find the inherited mapping for interface", expectedSerializer, result); [EOL] }
public void testFindInterfaceMappingWithNoMapping() { [EOL] ClassKey key = new ClassKey(OtherInterface.class); [EOL] JsonSerializer<?> result = _findInterfaceMapping(SomeClassNotImplementingInterface.class, key); [EOL] assertNull("Should not find any mapping for interface", result); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(elementSerializer); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNullTypeSerializerAndNonNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndPropertyWithContentSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> contentSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(contentSerializer); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] when(contentSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] when(((ContextualSerializer) contentSerializer).createContextual(provider, property)).thenReturn(contentSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] assertSame(contentSerializer, result); [EOL] }
public void testCreateContextualWithStaticTypingAndNonNullElementType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(null); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(_staticTyping).thenReturn(true); [EOL] when(provider.findValueSerializer(elementType, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testCreateContextualWithContentTypeAnnotationAndNonNullElementType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(null); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(_staticTyping).thenReturn(false); [EOL] when(hasContentTypeAnnotation(provider, property)).thenReturn(true); [EOL] when(provider.findValueSerializer(elementType, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testFindAndAddDynamicWithNewMap() throws JsonMappingException { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyForProperties(); [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBase())); [EOL] JsonSerializer<Object> serializer = _findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertNotSame(map, _dynamicSerializers); [EOL] }
public void testFindAndAddDynamicWithExistingMap() throws JsonMappingException { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyForProperties(); [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBase())); [EOL] _findAndAddDynamic(map, type, provider); [EOL] JsonSerializer<Object> serializerSecondCall = _findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializerSecondCall); [EOL] assertSame(map, _dynamicSerializers); [EOL] }
public void testDeserializationConfigCopyConstructorWithNullProblemHandlers() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(); [EOL] DeserializationConfig copiedConfig = new DeserializationConfig(originalConfig, null); [EOL] assertEquals(originalConfig._deserFeatures, copiedConfig._deserFeatures); [EOL] assertNull(copiedConfig._problemHandlers); [EOL] assertEquals(originalConfig._nodeFactory, copiedConfig._nodeFactory); [EOL] } [EOL] public void testDeserializationConfigCopyConstructorWithNonNullProblemHandlers() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(); [EOL] LinkedNode<DeserializationProblemHandler> problemHandlers = new LinkedNode<>(new DeserializationProblemHandler() {}, null); [EOL] DeserializationConfig copiedConfig = new DeserializationConfig(originalConfig, problemHandlers); [EOL] assertEquals(originalConfig._deserFeatures, copiedConfig._deserFeatures); [EOL] assertNotNull(copiedConfig._problemHandlers); [EOL] assertEquals(problemHandlers, copiedConfig._problemHandlers); [EOL] assertEquals(originalConfig._nodeFactory, copiedConfig._nodeFactory); [EOL] }
public void testWithHandler_NewHandler() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization parameters [EOL] DeserializationProblemHandler newHandler = new DeserializationProblemHandler() { [EOL] }; [EOL] DeserializationConfig newConfig = config.withHandler(newHandler); [EOL] assertNotSame(config, newConfig); [EOL] assertTrue(LinkedNode.contains(newConfig._problemHandlers, newHandler)); [EOL] }
public void testWithHandler_ExistingHandler() { [EOL] DeserializationProblemHandler existingHandler = new DeserializationProblemHandler() { [EOL] }; [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization parameters [EOL] config = config.withHandler(existingHandler); // Add the handler for the first time [EOL] DeserializationConfig sameConfig = config.withHandler(existingHandler); [EOL] assertSame(config, sameConfig); [EOL] }
public void testWithNoProblemHandlersWhenProblemHandlersIsNull() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] config = config.withNoProblemHandlers(); [EOL] assertNull(config.getProblemHandlers()); [EOL] }
public void testWithNoProblemHandlersWhenProblemHandlersIsNotNull() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] config = config.withSomeProblemHandler(...); // Method to add a problem handler [EOL] DeserializationConfig newConfig = config.withNoProblemHandlers(); [EOL] assertNotSame(config, newConfig); [EOL] assertNull(newConfig.getProblemHandlers()); [EOL] }
public void testGetProblemHandlersWhenNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getDeserializationConfig().getProblemHandlers()); [EOL] }
public void testGetProblemHandlersWhenNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationProblemHandler handler = new DeserializationProblemHandler() {}; [EOL] mapper.addHandler(handler); [EOL] assertNotNull(mapper.getDeserializationConfig().getProblemHandlers()); [EOL] }
public void testGetNodeFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNodeFactory factory = mapper.getNodeFactory(); [EOL] assertNotNull(factory); [EOL] }
public void testIntrospectForBuilderWithValidType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(BeanClassBuilder.class); [EOL] BeanDescription result = mapper.getSerializationConfig().introspectForBuilder(type); [EOL] assertNotNull(result); [EOL] }
public void testIntrospectForBuilderWithInvalidType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(String.class); [EOL] try { [EOL] mapper.getSerializationConfig().introspectForBuilder(type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddWithNonNullAnnotation() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] Annotation ann = new SomeAnnotationImpl(); [EOL] collector.add(ann); [EOL] assertNotNull(collector.getAnnotations()); [EOL] }
public void testAddWithNullAnnotation() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] collector.add(null); [EOL] assertNotNull(collector.getAnnotations()); [EOL] }
public void testTypeParserWithNonNullFactory() { [EOL] TypeFactory factory = TypeFactory.defaultInstance(); [EOL] TypeParser parser = new TypeParser(factory); [EOL] assertNotNull(parser); [EOL] }
public void testTypeParserWithNullFactory() { [EOL] TypeParser parser = new TypeParser(null); [EOL] assertNotNull(parser); [EOL] }
public void testDeserializeWithNonNullText() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("test"); [EOL] String result = deserialize(jp, ctxt); [EOL] assertEquals("test", result); [EOL] }
public void testDeserializeWithEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] String result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEmbeddedObjectByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] byte[] bytes = new byte[] { 1, 2, 3 }; [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(bytes); [EOL] String result = deserialize(jp, ctxt); [EOL] String expected = Base64Variants.getDefaultVariant().encode(bytes, false); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithEmbeddedObjectNonByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object ob = new Object(); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(ob); [EOL] String result = deserialize(jp, ctxt); [EOL] assertEquals(ob.toString(), result); [EOL] }
public void testDeserializeWithMappingException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testAnnotatedParameterNotNull() { [EOL] AnnotatedWithParams owner = mock(AnnotatedWithParams.class); [EOL] Type type = mock(Type.class); [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] int index = 0; [EOL] AnnotatedParameter annotatedParameter = new AnnotatedParameter(owner, type, annotations, index); [EOL] assertNotNull(annotatedParameter); [EOL] assertSame(owner, annotatedParameter.getOwner()); [EOL] assertSame(type, annotatedParameter.getType()); [EOL] assertEquals(index, annotatedParameter.getIndex()); [EOL] }
public void testAnnotatedParameterWithNullOwner() { [EOL] Type type = mock(Type.class); [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] int index = 0; [EOL] AnnotatedParameter annotatedParameter = new AnnotatedParameter(null, type, annotations, index); [EOL] assertNotNull(annotatedParameter); [EOL] assertNull(annotatedParameter.getOwner()); [EOL] assertSame(type, annotatedParameter.getType()); [EOL] assertEquals(index, annotatedParameter.getIndex()); [EOL] }
public void testAnnotatedParameterWithNullType() { [EOL] AnnotatedWithParams owner = mock(AnnotatedWithParams.class); [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] int index = 0; [EOL] AnnotatedParameter annotatedParameter = new AnnotatedParameter(owner, null, annotations, index); [EOL] assertNotNull(annotatedParameter); [EOL] assertSame(owner, annotatedParameter.getOwner()); [EOL] assertNull(annotatedParameter.getType()); [EOL] assertEquals(index, annotatedParameter.getIndex()); [EOL] }
public void testAnnotatedParameterWithNullAnnotations() { [EOL] AnnotatedWithParams owner = mock(AnnotatedWithParams.class); [EOL] Type type = mock(Type.class); [EOL] int index = 0; [EOL] AnnotatedParameter annotatedParameter = new AnnotatedParameter(owner, type, null, index); [EOL] assertNotNull(annotatedParameter); [EOL] assertSame(owner, annotatedParameter.getOwner()); [EOL] assertSame(type, annotatedParameter.getType()); [EOL] assertEquals(index, annotatedParameter.getIndex()); [EOL] assertNull(annotatedParameter.getAnnotations()); [EOL] }
public void testWithAnnotationsSameAnnotations() { [EOL] AnnotationMap originalAnnotations = new AnnotationMap(); [EOL] AnnotatedParameter ap = new AnnotatedParameter(null, null, originalAnnotations, 0); [EOL] AnnotatedParameter result = ap.withAnnotations(originalAnnotations); [EOL] assertSame(ap, result); [EOL] }
public void testWithAnnotationsDifferentAnnotations() { [EOL] AnnotationMap originalAnnotations = new AnnotationMap(); [EOL] AnnotationMap newAnnotations = new AnnotationMap(); [EOL] AnnotatedParameter ap = new AnnotatedParameter(null, null, originalAnnotations, 0); [EOL] AnnotatedParameter result = ap.withAnnotations(newAnnotations); [EOL] assertNotSame(ap, result); [EOL] verify(ap.getOwner()).replaceParameterAnnotations(ap.getIndex(), newAnnotations); [EOL] }
public void testGetAnnotationWithNullAnnotations() { [EOL] AnnotationCollector ac = new AnnotationCollector(null); [EOL] assertNull(ac.getAnnotation(Deprecated.class)); [EOL] }
public void testGetAnnotationWithNonNullAnnotations() { [EOL] AnnotationCollector ac = new AnnotationCollector(new HashMap<Class<? extends Annotation>, Annotation>()); [EOL] ac._annotations.put(Deprecated.class, Deprecated.class.getAnnotation(Deprecated.class)); [EOL] assertNotNull(ac.getAnnotation(Deprecated.class)); [EOL] }
public void testStdDateFormatConstructor() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] assertNotNull(format); [EOL] }
public void testStdDateFormatWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat format = new StdDateFormat(tz); [EOL] assertEquals(tz, format.getTimeZone()); [EOL] }
public void testGetDefaultTimeZone() { [EOL] TimeZone defaultTZ = StdDateFormat.getDefaultTimeZone(); [EOL] assertNotNull(defaultTZ); [EOL] }
public void testWithTimeZone() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat newFormat = format.withTimeZone(tz); [EOL] assertEquals(tz, newFormat.getTimeZone()); [EOL] }
public void testClone() throws CloneNotSupportedException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] StdDateFormat clonedFormat = format.clone(); [EOL] assertNotSame(format, clonedFormat); [EOL] }
public void testGetBlueprintISO8601Format() { [EOL] DateFormat blueprintFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] assertNotNull(blueprintFormat); [EOL] }
public void testGetISO8601Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat iso8601Format = StdDateFormat.getISO8601Format(tz); [EOL] assertNotNull(iso8601Format); [EOL] }
public void testGetBlueprintRFC1123Format() { [EOL] DateFormat blueprintFormat = StdDateFormat.getBlueprintRFC1123Format(); [EOL] assertNotNull(blueprintFormat); [EOL] }
public void testGetRFC1123Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat rfc1123Format = StdDateFormat.getRFC1123Format(tz); [EOL] assertNotNull(rfc1123Format); [EOL] }
public void testSetTimeZone() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] format.setTimeZone(tz); [EOL] assertEquals(tz, format.getTimeZone()); [EOL] }
public void testParseString() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] Date date = format.parse(dateStr); [EOL] assertNotNull(date); [EOL] }
public void testParseStringWithPosition() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = format.parse(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testFormat() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer result = format.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(result); [EOL] }
public void testLooksLikeISO8601() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] boolean result = format.looksLikeISO8601(dateStr); [EOL] assertTrue(result); [EOL] }
public void testParseAsISO8601() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = format.parseAsISO8601(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testParseAsRFC1123() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "Sun, 01 Jan 2023 00:00:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = format.parseAsRFC1123(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testHasTimeZone() { [EOL] String dateStr = "2023-01-01T00:00:00.000+0100"; [EOL] boolean result = StdDateFormat.hasTimeZone(dateStr); [EOL] assertTrue(result); [EOL] }
public void testCloneFormat() { [EOL] DateFormat originalFormat = new SimpleDateFormat(); [EOL] DateFormat clonedFormat = StdDateFormat._cloneFormat(originalFormat); [EOL] assertNotSame(originalFormat, clonedFormat); [EOL] }
public void testCloneFormatWithTimeZone() { [EOL] DateFormat originalFormat = new SimpleDateFormat(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat clonedFormat = StdDateFormat._cloneFormat(originalFormat, tz); [EOL] assertNotSame(originalFormat, clonedFormat); [EOL] assertEquals(tz, clonedFormat.getTimeZone()); [EOL] }
public void testParseValidDateISO8601() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validISO8601Date = "2020-01-01T12:00:00.000+0000"; [EOL] Date result = format.parse(validISO8601Date); [EOL] assertNotNull(result); [EOL] }
public void testParseValidDateISO8601Z() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validISO8601ZDate = "2020-01-01T12:00:00.000Z"; [EOL] Date result = format.parse(validISO8601ZDate); [EOL] assertNotNull(result); [EOL] }
public void testParseValidDateRFC1123() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validRFC1123Date = "Wed, 01 Jan 2020 12:00:00 GMT"; [EOL] Date result = format.parse(validRFC1123Date); [EOL] assertNotNull(result); [EOL] }
public void testParseValidDatePlain() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validPlainDate = "2020-01-01"; [EOL] Date result = format.parse(validPlainDate); [EOL] assertNotNull(result); [EOL] }
public void testParseInvalidDate() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String invalidDate = "not-a-date"; [EOL] try { [EOL] format.parse(invalidDate); [EOL] fail("Should have thrown ParseException"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testParseWithISO8601Format() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String iso8601DateStr = "2023-03-15T16:42:00.000+0000"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(iso8601DateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithNonISO8601Format() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String nonISO8601DateStr = "Wed, 15 Mar 2023 16:42:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(nonISO8601DateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithAllDigits() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String allDigitsDateStr = "20230315164200"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(allDigitsDateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithLongRangeNumber() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String longRangeNumber = String.valueOf(Long.MAX_VALUE); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(longRangeNumber, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithInvalidFormat() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String invalidDateStr = "not-a-date"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(invalidDateStr, pos); [EOL] assertNull(result); [EOL] }
public void testFormatWithNullISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer result = stdDateFormat.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testFormatWithNonNullISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] stdDateFormat._formatISO8601 = StdDateFormat.getBlueprintISO8601Format(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer result = stdDateFormat.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testLooksLikeISO8601_ValidFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String validISO8601Date = "2023-03-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(validISO8601Date); [EOL] assertTrue(result); [EOL] }
public void testLooksLikeISO8601_InvalidFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String invalidISO8601Date = "15-03-2023"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(invalidISO8601Date); [EOL] assertFalse(result); [EOL] }
public void testLooksLikeISO8601_ShortLength() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String shortDateStr = "1234"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(shortDateStr); [EOL] assertFalse(result); [EOL] }
public void testLooksLikeISO8601_NonDigitYear() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String nonDigitYearDate = "ABCD-03-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(nonDigitYearDate); [EOL] assertFalse(result); [EOL] }
public void testLooksLikeISO8601_NonDigitMonth() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String nonDigitMonthDate = "2023-AB-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(nonDigitMonthDate); [EOL] assertFalse(result); [EOL] }
public void testLooksLikeISO8601_MissingDash() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String missingDashDate = "202303-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(missingDashDate); [EOL] assertFalse(result); [EOL] }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL] int len = dateStr.length(); [EOL] char c = dateStr.charAt(len - 1); [EOL] DateFormat df; [EOL] if (len <= 10 && Character.isDigit(c)) { [EOL] df = _formatPlain; [EOL] if (df == null) { [EOL] df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL] } [EOL] } else if (c == 'Z') { [EOL] df = _formatISO8601_z; [EOL] if (df == null) { [EOL] df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL] } [EOL] if (dateStr.charAt(len - 4) == ':') { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.insert(len - 1, ".000"); [EOL] dateStr = sb.toString(); [EOL] } [EOL] } else { [EOL] if (hasTimeZone(dateStr)) { [EOL] c = dateStr.charAt(len - 3); [EOL] if (c == ':') { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.delete(len - 3, len - 2); [EOL] dateStr = sb.toString(); [EOL] } else if (c == '+' || c == '-') { [EOL] dateStr += "00"; [EOL] } [EOL] len = dateStr.length(); [EOL] c = dateStr.charAt(len - 9); [EOL] if (Character.isDigit(c)) { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.insert(len - 5, ".000"); [EOL] dateStr = sb.toString(); [EOL] } [EOL] df = _formatISO8601; [EOL] if (_formatISO8601 == null) { [EOL] df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL] } [EOL] } else { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL] if (timeLen <= 8) { [EOL] sb.append(".000"); [EOL] } [EOL] sb.append('Z'); [EOL] dateStr = sb.toString(); [EOL] df = _formatISO8601_z; [EOL] if (df == null) { [EOL] df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL] } [EOL] } [EOL] } [EOL] return df.parse(dateStr, pos); [EOL] }
protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { [EOL] if (_formatRFC1123 == null) { [EOL] _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123); [EOL] } [EOL] return _formatRFC1123.parse(dateStr, pos); [EOL] } [EOL] public StdDateFormat(); [EOL] public StdDateFormat(TimeZone tz); [EOL] public static TimeZone getDefaultTimeZone(); [EOL] public StdDateFormat withTimeZone(TimeZone tz); [EOL] public StdDateFormat clone(); [EOL] public static DateFormat getBlueprintISO8601Format(); [EOL] public static DateFormat getISO8601Format(TimeZone tz); [EOL] public static DateFormat getBlueprintRFC1123Format(); [EOL] public static DateFormat getRFC1123Format(TimeZone tz); [EOL] public void setTimeZone(TimeZone tz); [EOL] public Date parse(String dateStr) throws ParseException; [EOL] public Date parse(String dateStr, ParsePosition pos); [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); [EOL] protected boolean looksLikeISO8601(String dateStr); [EOL] protected Date parseAsISO8601(String dateStr, ParsePosition pos); [EOL] protected Date parseAsRFC1123(String dateStr, ParsePosition pos); [EOL] private static final boolean hasTimeZone(String str); [EOL] private final DateFormat _cloneFormat(DateFormat df); [EOL] private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); [EOL] String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; [EOL] String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; [EOL] String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; [EOL] String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; [EOL] String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }];
public void testCloneFormatWithNullTimeZone() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] DateFormat originalFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] DateFormat clonedFormat = stdDateFormat._cloneFormat(originalFormat); [EOL] assertNotNull(clonedFormat); [EOL] assertNotSame(originalFormat, clonedFormat); [EOL] }
public void testCloneFormatWithNonNullTimeZone() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(TimeZone.getTimeZone("GMT")); [EOL] DateFormat originalFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] DateFormat clonedFormat = stdDateFormat._cloneFormat(originalFormat); [EOL] assertNotNull(clonedFormat); [EOL] assertNotSame(originalFormat, clonedFormat); [EOL] assertEquals(TimeZone.getTimeZone("GMT"), clonedFormat.getTimeZone()); [EOL] }
public void testDefaultConstructor() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] assertNotNull(stdDateFormat); [EOL] }
public void testConstructorWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(tz); [EOL] assertNotNull(stdDateFormat); [EOL] assertEquals(tz, stdDateFormat.getTimeZone()); [EOL] }
public void testGetDefaultTimeZone() { [EOL] TimeZone defaultTZ = StdDateFormat.getDefaultTimeZone(); [EOL] assertNotNull(defaultTZ); [EOL] }
public void testWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat newStdDateFormat = stdDateFormat.withTimeZone(tz); [EOL] assertNotNull(newStdDateFormat); [EOL] assertEquals(tz, newStdDateFormat.getTimeZone()); [EOL] }
public void testClone() throws Exception { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat clonedFormat = stdDateFormat.clone(); [EOL] assertNotNull(clonedFormat); [EOL] assertNotSame(stdDateFormat, clonedFormat); [EOL] }
public void testGetBlueprintISO8601Format() { [EOL] DateFormat blueprintFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] assertNotNull(blueprintFormat); [EOL] }
public void testGetISO8601FormatWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat iso8601Format = StdDateFormat.getISO8601Format(tz); [EOL] assertNotNull(iso8601Format); [EOL] assertEquals(tz, iso8601Format.getTimeZone()); [EOL] }
public void testGetBlueprintRFC1123Format() { [EOL] DateFormat blueprintFormat = StdDateFormat.getBlueprintRFC1123Format(); [EOL] assertNotNull(blueprintFormat); [EOL] }
public void testGetRFC1123FormatWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat rfc1123Format = StdDateFormat.getRFC1123Format(tz); [EOL] assertNotNull(rfc1123Format); [EOL] assertEquals(tz, rfc1123Format.getTimeZone()); [EOL] }
public void testSetTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] stdDateFormat.setTimeZone(tz); [EOL] assertEquals(tz, stdDateFormat.getTimeZone()); [EOL] }
public void testParseString() throws ParseException { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T00:00:00.000Z"; [EOL] Date parsedDate = stdDateFormat.parse(dateStr); [EOL] assertNotNull(parsedDate); [EOL] }
public void testParseStringWithPosition() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T00:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date parsedDate = stdDateFormat.parse(dateStr, pos); [EOL] assertNotNull(parsedDate); [EOL] }
public void testFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer result = stdDateFormat.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testLooksLikeISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T00:00:00.000Z"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(dateStr); [EOL] assertTrue(result); [EOL] }
public void testParseAsISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T00:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date parsedDate = stdDateFormat.parseAsISO8601(dateStr, pos); [EOL] assertNotNull(parsedDate); [EOL] }
public void testParseAsRFC1123() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "Sat, 01 Apr 2023 00:00:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date parsedDate = stdDateFormat.parseAsRFC1123(dateStr, pos); [EOL] assertNotNull(parsedDate); [EOL] }
public void testHasTimeZone() { [EOL] String dateStr = "2023-04-01T00:00:00.000+0000"; [EOL] boolean result = StdDateFormat.hasTimeZone(dateStr); [EOL] assertTrue(result); [EOL] }
public void testSettableBeanPropertyConstructorWithNewName() { [EOL] String originalName = "originalName"; [EOL] String newName = "newName"; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapperName = mock(PropertyName.class); [EOL] boolean isRequired = true; [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] NullValueProvider nullProvider = mock(NullValueProvider.class); [EOL] String managedReferenceName = "managedReference"; [EOL] int propertyIndex = 1; [EOL] ViewMatcher viewMatcher = mock(ViewMatcher.class); [EOL] SettableBeanProperty src = new ConcreteSettableBeanProperty(originalName, type, wrapperName, isRequired, contextAnnotations, valueDeserializer, valueTypeDeserializer, nullProvider, managedReferenceName, propertyIndex, viewMatcher); [EOL] SettableBeanProperty propertyWithNewName = new SettableBeanProperty(src, newName); [EOL] assertEquals(newName, propertyWithNewName.getName()); [EOL] assertEquals(src.getType(), propertyWithNewName.getType()); [EOL] assertEquals(src.getWrapperName(), propertyWithNewName.getWrapperName()); [EOL] assertEquals(src.isRequired(), propertyWithNewName.isRequired()); [EOL] assertEquals(src.getContextAnnotations(), propertyWithNewName.getContextAnnotations()); [EOL] assertEquals(src.getValueDeserializer(), propertyWithNewName.getValueDeserializer()); [EOL] assertEquals(src.getValueTypeDeserializer(), propertyWithNewName.getValueTypeDeserializer()); [EOL] assertEquals(src.getNullValueProvider(), propertyWithNewName.getNullValueProvider()); [EOL] assertEquals(src.getManagedReferenceName(), propertyWithNewName.getManagedReferenceName()); [EOL] assertEquals(src.getPropertyIndex(), propertyWithNewName.getPropertyIndex()); [EOL] assertEquals(src.getViewMatcher(), propertyWithNewName.getViewMatcher()); [EOL] }
public void testDeserializeWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullTokenAndNullProvider() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueTypeDeserializer vtd = mock(ValueTypeDeserializer.class); [EOL] ValueDeserializer vd = mock(ValueDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(vd.deserializeWithType(jp, ctxt, vtd)).thenReturn(new Object()); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(vd, vtd); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testStdDelegatingSerializerWithNonNullConverter() { [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(Object.class, converter); [EOL] assertNotNull(serializer); [EOL] }
public void testStdDelegatingSerializerWithNullConverter() { [EOL] try { [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(Object.class, null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The converter must not be null", e.getMessage()); [EOL] } [EOL] }
public void testStdDelegatingSerializerWithNonNullConverterDelegateTypeAndDelegateSerializer() { [EOL] Converter<Object, ?> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<?> delegateSerializer = mock(JsonSerializer.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(converter, delegateType, delegateSerializer); [EOL] assertNotNull(serializer); [EOL] assertSame(converter, serializer.getConverter()); [EOL] assertSame(delegateType, serializer.getDelegateType()); [EOL] assertSame(delegateSerializer, serializer.getDelegateSerializer()); [EOL] }
public void testStdDelegatingSerializerWithNullConverter() { [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<?> delegateSerializer = mock(JsonSerializer.class); [EOL] try { [EOL] new StdDelegatingSerializer(null, delegateType, delegateSerializer); [EOL] fail("Expected IllegalArgumentException for null converter"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStdDelegatingSerializerWithNullDelegateType() { [EOL] Converter<Object, ?> converter = mock(Converter.class); [EOL] JsonSerializer<?> delegateSerializer = mock(JsonSerializer.class); [EOL] try { [EOL] new StdDelegatingSerializer(converter, null, delegateSerializer); [EOL] fail("Expected IllegalArgumentException for null delegateType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStdDelegatingSerializerWithNullDelegateSerializer() { [EOL] Converter<Object, ?> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(converter, delegateType, null); [EOL] assertNotNull(serializer); [EOL] assertNull(serializer.getDelegateSerializer()); [EOL] }
public void testWithDelegateUsingStdDelegatingSerializer() { [EOL] Converter<Object, ?> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<?> delegateSerializer = mock(JsonSerializer.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(converter, delegateType, delegateSerializer); [EOL] StdDelegatingSerializer result = serializer.withDelegate(converter, delegateType, delegateSerializer); [EOL] assertNotNull(result); [EOL] assertSame(converter, result.getConverter()); [EOL] assertSame(delegateType, result.getDelegateType()); [EOL] assertSame(delegateSerializer, result.getDelegateSerializer()); [EOL] } [EOL] public void testWithDelegateUsingSubClass() { [EOL] Converter<Object, ?> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<?> delegateSerializer = mock(JsonSerializer.class); [EOL] StdDelegatingSerializer subClassSerializer = new StdDelegatingSerializerSubClass(converter, delegateType, delegateSerializer); [EOL] try { [EOL] subClassSerializer.withDelegate(converter, delegateType, delegateSerializer); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Sub-class " + subClassSerializer.getClass().getName() + " must override 'withDelegate'", e.getMessage()); [EOL] } [EOL] } [EOL] private static class StdDelegatingSerializerSubClass extends StdDelegatingSerializer { [EOL] public StdDelegatingSerializerSubClass(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer) { [EOL] super(converter, delegateType, delegateSerializer); [EOL] } [EOL] }
public void testResolveWithDelegateSerializerBeingResolvable() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ResolvableSerializer delegateSerializer = mock(ResolvableSerializer.class); [EOL] TestSerializer testSerializer = new TestSerializer(delegateSerializer); [EOL] testSerializer.resolve(provider); [EOL] verify(delegateSerializer).resolve(provider); [EOL] }
public void testResolveWithDelegateSerializerNotResolvable() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> delegateSerializer = mock(JsonSerializer.class); [EOL] TestSerializer testSerializer = new TestSerializer(delegateSerializer); [EOL] testSerializer.resolve(provider); [EOL] verify(delegateSerializer, never()).resolve(any(SerializerProvider.class)); [EOL] }
public void testResolveWithNullDelegateSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TestSerializer testSerializer = new TestSerializer(null); [EOL] testSerializer.resolve(provider); [EOL] }
public void testCreateContextualWithNonNullDelegateSerializerAndContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> delegateSerializer = mock(JsonSerializer.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] when(delegateSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(delegateSerializer); [EOL] CustomSerializer customSerializer = new CustomSerializer(delegateSerializer, null, null); [EOL] JsonSerializer<?> result = customSerializer.createContextual(provider, property); [EOL] assertSame(customSerializer, result); [EOL] }
public void testCreateContextualWithNonNullDelegateSerializerAndNonContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> delegateSerializer = mock(JsonSerializer.class); [EOL] CustomSerializer customSerializer = new CustomSerializer(delegateSerializer, null, null); [EOL] JsonSerializer<?> result = customSerializer.createContextual(provider, property); [EOL] assertSame(customSerializer, result); [EOL] }
public void testCreateContextualWithNonNullDelegateSerializerAndChangedContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> delegateSerializer = mock(JsonSerializer.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<Object> newDelegateSerializer = mock(JsonSerializer.class); [EOL] when(delegateSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(newDelegateSerializer); [EOL] when(newDelegateSerializer != delegateSerializer).thenReturn(true); [EOL] CustomSerializer customSerializer = new CustomSerializer(delegateSerializer, null, null); [EOL] JsonSerializer<?> result = customSerializer.createContextual(provider, property); [EOL] assertNotSame(customSerializer, result); [EOL] }
public void testCreateContextualWithNullDelegateSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(converter.getOutputType(any(TypeFactory.class))).thenReturn(delegateType); [EOL] when(provider.findValueSerializer(delegateType, property)).thenReturn(mock(JsonSerializer.class)); [EOL] CustomSerializer customSerializer = new CustomSerializer(null, converter, null); [EOL] JsonSerializer<?> result = customSerializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testSerializeWithNullValue() throws IOException, JsonProcessingException { [EOL] Object value = null; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer( [EOL] mock(Converter.class), [EOL] JavaType.class, [EOL] mock(JsonSerializer.class) [EOL] ); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithNonNullValue() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] Object delegateValue = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JsonSerializer<Object> delegateSerializer = mock(JsonSerializer.class); [EOL] when(converter.convert(value)).thenReturn(delegateValue); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer( [EOL] converter, [EOL] JavaType.class, [EOL] delegateSerializer [EOL] ); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(converter).convert(value); [EOL] verify(delegateSerializer).serialize(delegateValue, jgen, provider); [EOL] verifyNoMoreInteractions(provider); [EOL] }
protected Object convertValue(Object value) { [EOL] return _converter.convert(value); [EOL] }
public void testDeserializeSetAndReturnWithValidInput() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] Object expected = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SimpleModule module = new SimpleModule(); [EOL] module.addDeserializer(Object.class, new JsonDeserializer<Object>() { [EOL] @Override [EOL] public Object deserialize(JsonParser p, DeserializationContext ctxt) { [EOL] return expected; [EOL] } [EOL] }); [EOL] mapper.registerModule(module); [EOL] Object result = mapper.readValue(jp, Object.class); [EOL] assertEquals(expected, result); [EOL] }
public void testSetAndReturnWithValidArguments() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Object expectedResult = new Object(); [EOL] when(_setter.invoke(instance, value)).thenReturn(expectedResult); [EOL] Object result = setAndReturn(instance, value); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testSetAndReturnWithNullResult() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] when(_setter.invoke(instance, value)).thenReturn(null); [EOL] Object result = setAndReturn(instance, value); [EOL] assertSame(instance, result); [EOL] }
public void testSetAndReturnWithInvocationTargetException() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Method setterMethod = mock(Method.class); [EOL] _setter = setterMethod; [EOL] when(_setter.invoke(instance, value)).thenThrow(InvocationTargetException.class); [EOL] try { [EOL] setAndReturn(instance, value); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSetAndReturnWithIllegalAccessException() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Method setterMethod = mock(Method.class); [EOL] _setter = setterMethod; [EOL] when(_setter.invoke(instance, value)).thenThrow(IllegalAccessException.class); [EOL] try { [EOL] setAndReturn(instance, value); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testPrivateConstructorInaccessibility() throws Exception { [EOL] Constructor<NullNode> constructor = NullNode.class.getDeclaredConstructor(); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Expected IllegalAccessException was not thrown"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testGetInstance() { [EOL] NullNode result = NullNode.getInstance(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullNode); [EOL] assertSame(NullNode.getInstance(), result); [EOL] }
public void testGetNodeTypeReturnsNull() { [EOL] JsonNode node = NullNode.getInstance(); [EOL] assertEquals(JsonNodeType.NULL, node.getNodeType()); [EOL] }
public void testAsTokenReturnsValueNull() { [EOL] YourClass instance = new YourClass(); [EOL] JsonToken result = instance.asToken(); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testAsText() { [EOL] JsonNode nullNode = NullNode.getInstance(); [EOL] String result = nullNode.asText(); [EOL] assertEquals("null", result); [EOL] }
public void testEqualsWithSameObject() { [EOL] Object obj = new Object(); [EOL] assertTrue(obj.equals(obj)); [EOL] }
public void testEqualsWithDifferentObject() { [EOL] Object obj1 = new Object(); [EOL] Object obj2 = new Object(); [EOL] assertFalse(obj1.equals(obj2)); [EOL] }
protected BeanSerializer(BeanSerializerBase src, ObjectIdWriter objectIdWriter) { [EOL] super(src, objectIdWriter); [EOL] }
public void testWithObjectIdWriter_Null() { [EOL] BeanSerializer originalSerializer = new BeanSerializer(); // Assuming a constructor exists [EOL] BeanSerializer newSerializer = originalSerializer.withObjectIdWriter(null); [EOL] assertNotNull(newSerializer); [EOL] assertNotSame(originalSerializer, newSerializer); [EOL] }
public void testWithObjectIdWriter_NonNull() { [EOL] BeanSerializer originalSerializer = new BeanSerializer(); // Assuming a constructor exists [EOL] ObjectIdWriter objectIdWriter = new ObjectIdWriter(); // Assuming a constructor exists [EOL] BeanSerializer newSerializer = originalSerializer.withObjectIdWriter(objectIdWriter); [EOL] assertNotNull(newSerializer); [EOL] assertNotSame(originalSerializer, newSerializer); [EOL] assertEquals(objectIdWriter, newSerializer.getObjectIdWriter()); [EOL] }
public void testSerializeWithObjectId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanSerializerBase serializer = createSerializerWithObjectId(); // Method to create a serializer with _objectIdWriter not null [EOL] serializer.serialize(bean, jgen, provider); [EOL] verify(serializer).serialize(bean, jgen, provider); [EOL] verify(serializer)._serializeWithObjectId(bean, jgen, provider, true); [EOL] }
public void testSerializeFieldsFiltered() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanSerializerBase serializer = createSerializerWithPropertyFilterId(); // Method to create a serializer with _propertyFilterId not null [EOL] serializer.serialize(bean, jgen, provider); [EOL] verify(serializer).serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeFields() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanSerializerBase serializer = createSerializerWithoutPropertyFilterId(); // Method to create a serializer with _propertyFilterId null [EOL] serializer.serialize(bean, jgen, provider); [EOL] verify(serializer).serializeFields(bean, jgen, provider); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testJsonSerializerMapWithEmptyMap() { [EOL] Map<TypeKey, JsonSerializer<Object>> serializers = new HashMap<>(); [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(serializers); [EOL] assertEquals(0, serializerMap.size()); [EOL] }
public void testJsonSerializerMapWithSingleElement() { [EOL] Map<TypeKey, JsonSerializer<Object>> serializers = new HashMap<>(); [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] serializers.put(key, serializer); [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(serializers); [EOL] assertEquals(1, serializerMap.size()); [EOL] assertSame(serializer, serializerMap.serializerFor(key)); [EOL] }
public void testJsonSerializerMapWithCollisions() { [EOL] Map<TypeKey, JsonSerializer<Object>> serializers = new HashMap<>(); [EOL] TypeKey key1 = new TypeKey(SomeClass.class, false); [EOL] TypeKey key2 = new TypeKey(AnotherClass.class, false) { [EOL] @Override [EOL] public int hashCode() { [EOL] return key1.hashCode(); [EOL] } [EOL] }; [EOL] JsonSerializer<Object> serializer1 = new SomeJsonSerializer(); [EOL] JsonSerializer<Object> serializer2 = new AnotherJsonSerializer(); [EOL] serializers.put(key1, serializer1); [EOL] serializers.put(key2, serializer2); [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(serializers); [EOL] assertEquals(2, serializerMap.size()); [EOL] assertSame(serializer1, serializerMap.serializerFor(key1)); [EOL] assertSame(serializer2, serializerMap.serializerFor(key2)); [EOL] }
public void testFindSizeForSmallSize() { [EOL] int size = 32; // A small size [EOL] int expected = 64; // Expected result for small size [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindSizeForExactPowerOfTwo() { [EOL] int size = 64; // Exact power of two [EOL] int expected = 128; // Expected result for exact power of two [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindSizeForLargeSize() { [EOL] int size = 128; // A large size [EOL] int expected = 256; // Expected result for large size [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindSizeForSizeJustAbovePowerOfTwo() { [EOL] int size = 65; // Just above power of two [EOL] int expected = 104; // Expected result for size just above power of two [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindWithNullBucket() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNull(result); [EOL] }
public void testFindWithMatchingKeyInFirstBucket() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] Bucket bucket = new Bucket(key, new SomeJsonSerializer(), null); [EOL] _buckets[key.hashCode() & (_buckets.length - 1)] = bucket; [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNotNull(result); [EOL] assertSame(bucket.value, result); [EOL] }
public void testFindWithMatchingKeyInSubsequentBucket() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] TypeKey anotherKey = new TypeKey(AnotherClass.class, false); [EOL] Bucket bucket1 = new Bucket(anotherKey, new AnotherJsonSerializer(), null); [EOL] Bucket bucket2 = new Bucket(key, new SomeJsonSerializer(), bucket1); [EOL] _buckets[key.hashCode() & (_buckets.length - 1)] = bucket2; [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNotNull(result); [EOL] assertSame(bucket2.value, result); [EOL] }
public void testFindWithNoMatchingKey() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] TypeKey anotherKey = new TypeKey(AnotherClass.class, false); [EOL] Bucket bucket = new Bucket(anotherKey, new AnotherJsonSerializer(), null); [EOL] _buckets[key.hashCode() & (_buckets.length - 1)] = bucket; [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNull(result); [EOL] }
public void testBucketConstructorWithNullValues() { [EOL] Bucket bucket = new Bucket(null, null, null); [EOL] assertNull(bucket.next); [EOL] assertNull(bucket.key); [EOL] assertNull(bucket.value); [EOL] }
public void testBucketConstructorWithNonNullValues() { [EOL] TypeKey mockKey = mock(TypeKey.class); [EOL] JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class); [EOL] Bucket nextBucket = new Bucket(null, mockKey, mockSerializer); [EOL] Bucket bucket = new Bucket(nextBucket, mockKey, mockSerializer); [EOL] assertEquals(nextBucket, bucket.next); [EOL] assertEquals(mockKey, bucket.key); [EOL] assertEquals(mockSerializer, bucket.value); [EOL] }
public void testTypeIdResolverInstanceWithHandlerInstantiatorProvidingNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated annotated = mock(Annotated.class); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] TypeIdResolver resolver = mock(TypeIdResolver.class); [EOL] when(hi.typeIdResolverInstance(any(), any(), any())).thenReturn(resolver); [EOL] mapper.setHandlerInstantiator(hi); [EOL] TypeIdResolver result = mapper.typeIdResolverInstance(annotated, TypeIdResolver.class); [EOL] assertSame(resolver, result); [EOL] }
public void testTypeIdResolverInstanceWithHandlerInstantiatorProvidingNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated annotated = mock(Annotated.class); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] when(hi.typeIdResolverInstance(any(), any(), any())).thenReturn(null); [EOL] mapper.setHandlerInstantiator(hi); [EOL] TypeIdResolver result = mapper.typeIdResolverInstance(annotated, TypeIdResolver.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeIdResolver); [EOL] }
public void testTypeIdResolverInstanceWithoutHandlerInstantiator() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated annotated = mock(Annotated.class); [EOL] TypeIdResolver result = mapper.typeIdResolverInstance(annotated, TypeIdResolver.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeIdResolver); [EOL] }
public void testNullifyingDeserializerConstruction() { [EOL] NullifyingDeserializer deserializer = new NullifyingDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeSkipsChildren() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.skipChildren()).thenReturn(jp); [EOL] YourDeserializer deserializer = new YourDeserializer(); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).skipChildren(); [EOL] assertNull(result); [EOL] }
public final boolean has(int index) { [EOL] return false; [EOL] }
public void testPathWithFieldNameReturnsMissingNode() { [EOL] JsonNode node = new TestNode(); // Assuming TestNode extends the class with the path method [EOL] JsonNode result = node.path("anyFieldName"); [EOL] assertTrue(result instanceof MissingNode); [EOL] }
public void testHasWithFieldName() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] assertFalse(node.has("fieldName")); [EOL] }
public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL] return foundSoFar; [EOL] }
public void testNoTypeInfoBuilder() { [EOL] StdTypeResolverBuilder result = JacksonDatabind.noTypeInfoBuilder(); [EOL] assertNotNull(result); [EOL] assertEquals(JsonTypeInfo.Id.NONE, result._idType); [EOL] assertNull(result._customIdResolver); [EOL] }
public void testBuildTypeSerializerWithIdNone() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.NONE; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeSerializerWithWrapperArray() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id for this context [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_ARRAY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.PROPERTY; [EOL] String _typeProperty = "typeProperty"; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithWrapperObject() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_OBJECT; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithExternalProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.EXTERNAL_PROPERTY; [EOL] String _typeProperty = "typeProperty"; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithIllegalStateException() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.OTHER; // Assuming OTHER is a valid As that is not covered by the switch cases [EOL] Exception exception = assertThrows(IllegalStateException.class, () -> { [EOL] buildTypeSerializer(config, baseType, subtypes); [EOL] }); [EOL] assertEquals("Do not know how to construct standard type serializer for inclusion type: " + _includeAs, exception.getMessage()); [EOL] }
public void testBuildTypeDeserializerWithIdTypeNone() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.NONE, null); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeDeserializerWithWrapperArray() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CUSTOM, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_ARRAY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CUSTOM, null); [EOL] builder.inclusion(JsonTypeInfo.As.PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithWrapperObject() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CUSTOM, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_OBJECT); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithExternalProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CUSTOM, null); [EOL] builder.inclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithIllegalStateException() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CUSTOM, null); [EOL] builder.inclusion(null); // This should trigger the default case and throw an IllegalStateException [EOL] assertThrows(IllegalStateException.class, () -> { [EOL] builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] }); [EOL] }
public void testGetDefaultImplWhenDefaultImplIsNull() { [EOL] TestClass testInstance = new TestClass(); // Replace 'TestClass' with the actual class name [EOL] Class<?> result = testInstance.getDefaultImpl(); [EOL] assertNull(result); [EOL] }
public void testGetDefaultImplWhenDefaultImplIsNotNull() { [EOL] Class<?> expectedDefaultImpl = Object.class; // Replace 'Object.class' with the actual default implementation [EOL] TestClass testInstance = new TestClass(expectedDefaultImpl); // Replace with the actual way to set _defaultImpl [EOL] Class<?> result = testInstance.getDefaultImpl(); [EOL] assertEquals(expectedDefaultImpl, result); [EOL] }
It appears that the provided input text is for a constructor `StdSubtypeResolver()` that does not contain any executable code other than the constructor declaration itself. Since constructors that only contain a declaration and no additional logic cannot be directly tested for line coverage, there is no meaningful unit test that can be generated for this specific case. [EOL] However, if the `StdSubtypeResolver` class had methods with logic, you would create test cases for those methods. Since there is no executable code in the constructor, no test case is needed to achieve line coverage for this specific input. [EOL] If you have methods within the `StdSubtypeResolver` class that you would like to generate test cases for, please provide the method signatures and any relevant code, and I can help generate the test cases for those methods.
public void testCollectAndResolveSubtypesWithRegisteredSubtypes() { [EOL] AnnotatedClass type = AnnotatedClass.constructWithoutSuperTypes(SomeBaseClass.class, null, null); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] NamedType registeredSubtype = new NamedType(SomeSubClass.class, null); [EOL] setRegisteredSubtypes(Collections.singletonList(registeredSubtype)); [EOL] Collection<NamedType> result = collectAndResolveSubtypes(type, config, ai); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue(result.contains(registeredSubtype)); [EOL] }
public void testCollectAndResolveSubtypesWithoutRegisteredSubtypes() { [EOL] AnnotatedClass type = AnnotatedClass.constructWithoutSuperTypes(SomeBaseClass.class, null, null); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] setRegisteredSubtypes(null); // No registered subtypes [EOL] Collection<NamedType> result = collectAndResolveSubtypes(type, config, ai); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(new NamedType(SomeBaseClass.class, null))); [EOL] }
public void testCollectAndResolveNamedTypeWithName() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class, "SomeName"); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertTrue(collectedSubtypes.containsKey(namedType)); [EOL] }
public void testCollectAndResolveNamedTypeWithoutName() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] when(ai.findTypeName(annotatedType)).thenReturn("GeneratedName"); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] NamedType expectedNamedType = new NamedType(SomeClass.class, "GeneratedName"); [EOL] assertTrue(collectedSubtypes.containsKey(expectedNamedType)); [EOL] }
public void testCollectAndResolveWithExistingTypeWithoutName() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class, "SomeName"); [EOL] NamedType unnamedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] collectedSubtypes.put(unnamedType, unnamedType); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] NamedType retrievedNamedType = collectedSubtypes.get(unnamedType); [EOL] assertEquals("SomeName", retrievedNamedType.getName()); [EOL] }
public void testCollectAndResolveWithSubtypes() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] Collection<NamedType> subtypes = Arrays.asList( [EOL] new NamedType(SubClass1.class), [EOL] new NamedType(SubClass2.class, "SubName") [EOL] ); [EOL] when(ai.findSubtypes(annotatedType)).thenReturn(subtypes); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertEquals(3, collectedSubtypes.size()); [EOL] assertTrue(collectedSubtypes.containsKey(new NamedType(SubClass1.class))); [EOL] assertTrue(collectedSubtypes.containsKey(new NamedType(SubClass2.class, "SubName"))); [EOL] }
public void testArrayTypeConstructorWithNonNullComponentTypeAndEmptyInstance() { [EOL] JavaType componentType = mock(JavaType.class); [EOL] Object emptyInstance = new int[0]; [EOL] Object valueHandler = null; [EOL] Object typeHandler = null; [EOL] boolean asStatic = false; [EOL] ArrayType arrayType = new ArrayType(componentType, emptyInstance, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(arrayType); [EOL] assertEquals(emptyInstance.getClass(), arrayType.getRawClass()); [EOL] assertEquals(componentType.hashCode(), arrayType.hashCode()); [EOL] assertEquals(componentType, arrayType.getComponentType()); [EOL] assertArrayEquals((int[]) emptyInstance, (int[]) arrayType.getEmptyArray()); [EOL] }
public void testArrayTypeConstructorWithNonNullComponentTypeAndNonNullHandlers() { [EOL] JavaType componentType = mock(JavaType.class); [EOL] Object emptyInstance = new int[0]; [EOL] Object valueHandler = new Object(); [EOL] Object typeHandler = new Object(); [EOL] boolean asStatic = true; [EOL] ArrayType arrayType = new ArrayType(componentType, emptyInstance, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(arrayType); [EOL] assertEquals(emptyInstance.getClass(), arrayType.getRawClass()); [EOL] assertEquals(componentType.hashCode(), arrayType.hashCode()); [EOL] assertEquals(componentType, arrayType.getComponentType()); [EOL] assertArrayEquals((int[]) emptyInstance, (int[]) arrayType.getEmptyArray()); [EOL] assertEquals(valueHandler, arrayType.getValueHandler()); [EOL] assertEquals(typeHandler, arrayType.getTypeHandler()); [EOL] assertTrue(arrayType.isStatic()); [EOL] }
public void testConstructWithNonNullComponentType() { [EOL] JavaType componentType = TypeFactory.defaultInstance().constructType(String[].class); [EOL] ArrayType arrayType = ArrayType.construct(componentType, null, null); [EOL] assertNotNull(arrayType); [EOL] assertEquals(String[].class, arrayType.getRawClass()); [EOL] }
public void testConstructWithPrimitiveComponentType() { [EOL] JavaType componentType = TypeFactory.defaultInstance().constructType(int[].class); [EOL] ArrayType arrayType = ArrayType.construct(componentType, null, null); [EOL] assertNotNull(arrayType); [EOL] assertEquals(int[].class, arrayType.getRawClass()); [EOL] }
public void testNarrowContentsBy_SameClass() { [EOL] JavaType originalComponentType = _componentType; [EOL] Class<?> originalRawClass = originalComponentType.getRawClass(); [EOL] JavaType result = narrowContentsBy(originalRawClass); [EOL] assertSame("narrowContentsBy should return the same object when class is the same", this, result); [EOL] }
public void testNarrowContentsBy_DifferentClass() { [EOL] JavaType originalComponentType = _componentType; [EOL] Class<?> differentClass = String.class; // Use String class for simplicity, assuming it's different from the original [EOL] JavaType result = narrowContentsBy(differentClass); [EOL] assertNotSame("narrowContentsBy should not return the same object when class is different", this, result); [EOL] assertNotNull("The result should not be null", result); [EOL] assertEquals("The component type should be narrowed by the specified class", differentClass, result.containedType(0).getRawClass()); [EOL] }
public void testIsContainerType() { [EOL] ExtendedClass instance = new ExtendedClass(); [EOL] boolean result = instance.isContainerType(); [EOL] assertTrue(result); [EOL] }
public void testToString() { [EOL] ArrayType arrayType = new ArrayType( [EOL] SimpleType.constructUnsafe(String.class), null, null, null, null, false [EOL] ); [EOL] String result = arrayType.toString(); [EOL] assert result.equals("[array type, component type: java.lang.String]"); [EOL] }
public void testEquals_Reflexive() { [EOL] ArrayType arrayType = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] assertTrue(arrayType.equals(arrayType)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ArrayType arrayType = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] assertFalse(arrayType.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] ArrayType arrayType = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] Object other = new Object(); [EOL] assertFalse(arrayType.equals(other)); [EOL] } [EOL] public void testEquals_EqualObjects() { [EOL] ArrayType arrayType1 = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] ArrayType arrayType2 = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] when(arrayType1._componentType.equals(arrayType2._componentType)).thenReturn(true); [EOL] assertTrue(arrayType1.equals(arrayType2)); [EOL] } [EOL] public void testEquals_NonEqualObjects() { [EOL] ArrayType arrayType1 = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] ArrayType arrayType2 = new ArrayType(...); // Provide necessary arguments for instantiation [EOL] when(arrayType1._componentType.equals(arrayType2._componentType)).thenReturn(false); [EOL] assertFalse(arrayType1.equals(arrayType2)); [EOL] }
public void testStringArrayDeserializerConstructor() { [EOL] StringArrayDeserializer deserializer = new StringArrayDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertNull(deserializer._elementDeserializer); [EOL] }
public void testStringArrayDeserializerWithNonNullDeserializer() { [EOL] JsonDeserializer<?> nonNullDeserializer = Mockito.mock(JsonDeserializer.class); [EOL] StringArrayDeserializer deserializer = new StringArrayDeserializer(nonNullDeserializer); [EOL] assertNotNull(deserializer); [EOL] }
public void testStringArrayDeserializerWithNullDeserializer() { [EOL] JsonDeserializer<?> nullDeserializer = null; [EOL] try { [EOL] StringArrayDeserializer deserializer = new StringArrayDeserializer(nullDeserializer); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The deserializer should not be null", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).isExpectedStartArrayToken(); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithCustomDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] deserializer._elementDeserializer = mock(JsonDeserializer.class); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).isExpectedStartArrayToken(); [EOL] verify(deserializer._elementDeserializer).deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithArrayTokenAndStrings() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("string1", "string2"); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp, times(3)).nextToken(); [EOL] verify(jp, times(2)).getText(); [EOL] assertArrayEquals(new String[]{"string1", "string2"}, result); [EOL] }
public void testDeserializeWithArrayTokenAndNulls() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL, JsonToken.END_ARRAY); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp, times(2)).nextToken(); [EOL] assertArrayEquals(new String[]{null}, result); [EOL] }
public void testDeserializeWithArrayTokenAndMixedValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.VALUE_NULL, JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("string1", "string3"); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp, times(4)).nextToken(); [EOL] verify(jp, times(2)).getText(); [EOL] assertArrayEquals(new String[]{"string1", null, "string3"}, result); [EOL] }
protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL] Object[] chunk = buffer.resetAndStart(); [EOL] final JsonDeserializer<String> deser = _elementDeserializer; [EOL] int ix = 0; [EOL] JsonToken t; [EOL] while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL] String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt); [EOL] if (ix >= chunk.length) { [EOL] chunk = buffer.appendCompletedChunk(chunk); [EOL] ix = 0; [EOL] } [EOL] chunk[ix++] = value; [EOL] } [EOL] String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL] ctxt.returnObjectBuffer(buffer); [EOL] return result; [EOL] }
public void testHandleNonArrayWithFeatureDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(false); [EOL] try { [EOL] handleNonArray(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] when(jp.getText()).thenReturn(""); [EOL] String[] result = handleNonArray(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testHandleNonArrayWithSingleValueAsArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] String[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertNull(result[0]); [EOL] }
public void testHandleNonArrayWithNonNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] String[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("test", result[0]); [EOL] }
public void testCreateContextualWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(initialDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(initialDeserializer, result); [EOL] }
public void testCreateContextualWithDefaultDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(initialDeserializer); [EOL] when(this.isDefaultDeserializer(initialDeserializer)).thenReturn(true); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonDefaultDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(initialDeserializer); [EOL] when(this.isDefaultDeserializer(initialDeserializer)).thenReturn(false); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArrayDeserializer); [EOL] }
public void testCreateContextualWithNonDefaultContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<?> contextualResult = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(contextualDeserializer); [EOL] when(contextualDeserializer.createContextual(ctxt, property)).thenReturn(contextualResult); [EOL] when(this.isDefaultDeserializer(contextualResult)).thenReturn(false); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArrayDeserializer); [EOL] }
public void testSetObjectIdReaderWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectIdReader objectIdReader = ObjectIdReader.construct(new SimpleType(Object.class), null, null, null, null, null); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer.setObjectIdReader(objectIdReader); [EOL] assertNotNull(writer._objectIdReader); [EOL] }
public void testSetObjectIdReaderWithNull() { [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer.setObjectIdReader(null); [EOL] assertNull(writer._objectIdReader); [EOL] }
public void testSetPOJOBuilderWithNonNullValues() { [EOL] AnnotatedMethod buildMethod = mock(AnnotatedMethod.class); [EOL] JsonPOJOBuilder.Value config = mock(JsonPOJOBuilder.Value.class); [EOL] TargetClass target = new TargetClass(); [EOL] target.setPOJOBuilder(buildMethod, config); [EOL] assertEquals(buildMethod, target.getBuildMethod()); [EOL] assertEquals(config, target.getBuilderConfig()); [EOL] }
public void testSetPOJOBuilderWithNullValues() { [EOL] TargetClass target = new TargetClass(); [EOL] target.setPOJOBuilder(null, null); [EOL] assertNull(target.getBuildMethod()); [EOL] assertNull(target.getBuilderConfig()); [EOL] }
public void testGetBuildMethod() { [EOL] MyClass myClass = new MyClass(); [EOL] AnnotatedMethod expected = new AnnotatedMethod(); // Assuming AnnotatedMethod has a public constructor [EOL] myClass.setBuildMethod(expected); // Assuming there is a setter for _buildMethod [EOL] AnnotatedMethod actual = myClass.getBuildMethod(); [EOL] assertEquals(expected, actual); [EOL] }
public void testBuildWithDefaultViewInclusionAndNoObjectIdReader() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder.setDefaultViewInclusion(true); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertFalse(beanDeserializer.usesObjectId()); [EOL] assertFalse(beanDeserializer.hasViews()); [EOL] }
public void testBuildWithNonDefaultViewInclusionAndNoObjectIdReader() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder.setDefaultViewInclusion(false); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertFalse(beanDeserializer.usesObjectId()); [EOL] assertTrue(beanDeserializer.hasViews()); [EOL] }
public void testBuildWithObjectIdReader() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] ObjectIdReader objectIdReader = ObjectIdReader.construct(null, null, null); [EOL] builder.setObjectIdReader(objectIdReader); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertTrue(beanDeserializer.usesObjectId()); [EOL] }
public void testBuildBuilderBasedWithNullBuildMethod() { [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc); [EOL] String expectedBuildMethodName = "build"; [EOL] try { [EOL] builder.buildBuilderBased(null, expectedBuildMethodName); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Builder class " + beanDesc.getBeanClass().getName() + " does not have build method '" + expectedBuildMethodName + "()'", e.getMessage()); [EOL] } [EOL] }
public void testBuildBuilderBasedWithIncompatibleReturnType() { [EOL] JavaType valueType = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] Method buildMethod = createMockBuildMethodWithReturnType(String.class); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc, buildMethod); [EOL] String expectedBuildMethodName = "build"; [EOL] try { [EOL] builder.buildBuilderBased(valueType, expectedBuildMethodName); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("has bad return type")); [EOL] assertTrue(e.getMessage().contains("not compatible with POJO type")); [EOL] } [EOL] }
public void testBuildBuilderBasedWithCorrectConditions() { [EOL] JavaType valueType = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] Method buildMethod = createMockBuildMethodWithReturnType(valueType.getRawClass()); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc, buildMethod); [EOL] String expectedBuildMethodName = "build"; [EOL] JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, expectedBuildMethodName); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BuilderBasedDeserializer); [EOL] }
public void testBuildBuilderBasedWithObjectIdReader() { [EOL] JavaType valueType = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] Method buildMethod = createMockBuildMethodWithReturnType(valueType.getRawClass()); [EOL] ObjectIdReader objectIdReader = createMockObjectIdReader(); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc, buildMethod, objectIdReader); [EOL] String expectedBuildMethodName = "build"; [EOL] JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, expectedBuildMethodName); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BuilderBasedDeserializer); [EOL] BuilderBasedDeserializer builderBasedDeserializer = (BuilderBasedDeserializer) deserializer; [EOL] assertTrue(builderBasedDeserializer.getPropertyMap().find("_objectIdReader") != null); [EOL] }
public void testBuildBuilderBasedWithDefaultViewInclusion() { [EOL] JavaType valueType = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] Method buildMethod = createMockBuildMethodWithReturnType(valueType.getRawClass()); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc, buildMethod); [EOL] builder.setDefaultViewInclusion(true); [EOL] String expectedBuildMethodName = "build"; [EOL] JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, expectedBuildMethodName); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BuilderBasedDeserializer); [EOL] BuilderBasedDeserializer builderBasedDeserializer = (BuilderBasedDeserializer) deserializer; [EOL] assertFalse(builderBasedDeserializer.anyViews()); [EOL] }
public void testBuildBuilderBasedWithNonDefaultViewInclusionAndNoViews() { [EOL] JavaType valueType = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] Method buildMethod = createMockBuildMethodWithReturnType(valueType.getRawClass()); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc, buildMethod); [EOL] builder.setDefaultViewInclusion(false); [EOL] String expectedBuildMethodName = "build"; [EOL] JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, expectedBuildMethodName); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BuilderBasedDeserializer); [EOL] BuilderBasedDeserializer builderBasedDeserializer = (BuilderBasedDeserializer) deserializer; [EOL] assertFalse(builderBasedDeserializer.anyViews()); [EOL] }
public void testBuildBuilderBasedWithNonDefaultViewInclusionAndViewProperties() { [EOL] JavaType valueType = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] Method buildMethod = createMockBuildMethodWithReturnType(valueType.getRawClass()); [EOL] SettableBeanProperty propWithView = createMockSettableBeanPropertyWithView(); [EOL] BuilderBasedDeserializerBuilder builder = new BuilderBasedDeserializerBuilder(beanDesc, buildMethod, null, Collections.singletonMap("propWithView", propWithView)); [EOL] builder.setDefaultViewInclusion(false); [EOL] String expectedBuildMethodName = "build"; [EOL] JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, expectedBuildMethodName); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BuilderBasedDeserializer); [EOL] BuilderBasedDeserializer builderBasedDeserializer = (BuilderBasedDeserializer) deserializer; [EOL] assertTrue(builderBasedDeserializer.anyViews()); [EOL] }
public void testAppendCompletedChunkWithEmptyBuffer() { [EOL] LinkedNode<Integer> testInstance = new LinkedNode<>(); [EOL] Integer[] fullChunk = new Integer[]{1, 2, 3}; [EOL] int fullChunkLength = fullChunk.length; [EOL] Integer[] result = testInstance.appendCompletedChunk(fullChunk, fullChunkLength); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= fullChunkLength); [EOL] assertEquals(testInstance._bufferedEntryCount, fullChunkLength); [EOL] assertNotNull(testInstance._bufferHead); [EOL] assertEquals(testInstance._bufferHead, testInstance._bufferTail); [EOL] }
public void testAppendCompletedChunkWithNonEmptyBuffer() { [EOL] LinkedNode<Integer> testInstance = new LinkedNode<>(); [EOL] Integer[] firstChunk = new Integer[]{1, 2, 3}; [EOL] Integer[] secondChunk = new Integer[]{4, 5, 6}; [EOL] int firstChunkLength = firstChunk.length; [EOL] int secondChunkLength = secondChunk.length; [EOL] testInstance.appendCompletedChunk(firstChunk, firstChunkLength); [EOL] Integer[] result = testInstance.appendCompletedChunk(secondChunk, secondChunkLength); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= (firstChunkLength + secondChunkLength)); [EOL] assertEquals(testInstance._bufferedEntryCount, (firstChunkLength + secondChunkLength)); [EOL] assertNotNull(testInstance._bufferHead); [EOL] assertNotNull(testInstance._bufferTail); [EOL] assertNotEquals(testInstance._bufferHead, testInstance._bufferTail); [EOL] }
public void testCompleteAndClearBufferWithEmptyBuffer() { [EOL] BufferHandler<Integer> handler = new BufferHandler<>(); [EOL] Integer[] lastChunk = new Integer[]{1, 2, 3}; [EOL] int lastChunkEntries = 3; [EOL] Integer[] result = handler.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] assertEquals(3, result.length); [EOL] assertArrayEquals(new Integer[]{1, 2, 3}, result); [EOL] }
public void testCompleteAndClearBufferWithNonEmptyBuffer() { [EOL] BufferHandler<Integer> handler = new BufferHandler<>(); [EOL] handler.append(4); // Assuming append method exists to add an element to the buffer [EOL] handler.append(5); [EOL] Integer[] lastChunk = new Integer[]{1, 2, 3}; [EOL] int lastChunkEntries = 3; [EOL] Integer[] result = handler.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] assertEquals(5, result.length); [EOL] assertArrayEquals(new Integer[]{4, 5, 1, 2, 3}, result); [EOL] }
public void testCompleteAndClearBufferWithIncorrectTotalSize() { [EOL] BufferHandler<Integer> handler = new BufferHandler<>(); [EOL] handler.append(4); [EOL] handler.append(5); [EOL] Integer[] lastChunk = new Integer[]{1, 2, 3}; [EOL] int lastChunkEntries = 2; // Intentionally incorrect to trigger the IllegalStateException [EOL] try { [EOL] handler.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Should have gotten 5 entries, got 4", e.getMessage()); [EOL] } [EOL] }
public void testNodeConstructorWithValidData() { [EOL] Object data = new Object(); [EOL] int dataLen = 10; [EOL] Node<Object> node = new Node<>(data, dataLen); [EOL] assertEquals(data, node._data); [EOL] assertEquals(dataLen, node._dataLength); [EOL] }
public void testCopyDataWithValidInput() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setData(new int[]{1, 2, 3}); // Assuming a method to set _data [EOL] instance.setDataLength(3); // Assuming a method to set _dataLength [EOL] int[] destination = new int[5]; [EOL] int pointer = 2; [EOL] int newPointer = instance.copyData(destination, pointer); [EOL] assertEquals(1, destination[2]); [EOL] assertEquals(2, destination[3]); [EOL] assertEquals(3, destination[4]); [EOL] assertEquals(5, newPointer); [EOL] }
public void testCopyDataWithEmptySource() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setData(new int[]{}); // Assuming a method to set _data [EOL] instance.setDataLength(0); // Assuming a method to set _dataLength [EOL] int[] destination = new int[5]; [EOL] int pointer = 2; [EOL] int newPointer = instance.copyData(destination, pointer); [EOL] for (int i = 0; i < destination.length; i++) { [EOL] assertEquals(0, destination[i]); [EOL] } [EOL] assertEquals(2, newPointer); [EOL] }
public void testNextWhenNextIsNull() { [EOL] Node<String> node = new Node<>(null, null); [EOL] assertNull(node.next()); [EOL] }
public void testNextWhenNextIsNotNull() { [EOL] Node<String> nextNode = new Node<>("next", null); [EOL] Node<String> node = new Node<>("current", nextNode); [EOL] assertEquals(nextNode, node.next()); [EOL] }
public void testLinkNextWithNullInitialNext() { [EOL] Node<String> initialNode = new Node<>(null); [EOL] Node<String> nextNode = new Node<>(null); [EOL] initialNode.linkNext(nextNode); [EOL] assertEquals(nextNode, initialNode.getNext()); [EOL] }
public void testLinkNextWithNonNullInitialNext() { [EOL] Node<String> initialNode = new Node<>(null); [EOL] Node<String> nextNode = new Node<>(null); [EOL] initialNode.linkNext(new Node<>(null)); // Set _next to a non-null value [EOL] try { [EOL] initialNode.linkNext(nextNode); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testEquals_Reflexive() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide actual initialization [EOL] assertTrue(mapLikeType.equals(mapLikeType)); [EOL] }
public void testEquals_Null() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide actual initialization [EOL] assertFalse(mapLikeType.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide actual initialization [EOL] Object other = new Object(); [EOL] assertFalse(mapLikeType.equals(other)); [EOL] }
public void testEquals_EqualObjects() { [EOL] MapLikeType mapLikeType1 = new MapLikeType(...); // Provide actual initialization [EOL] MapLikeType mapLikeType2 = new MapLikeType(...); // Provide actual initialization with same properties as mapLikeType1 [EOL] assertTrue(mapLikeType1.equals(mapLikeType2)); [EOL] }
public void testEquals_NotEqualObjects_DifferentClass() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide actual initialization [EOL] OtherType otherType = new OtherType(...); // Provide actual initialization [EOL] assertFalse(mapLikeType.equals(otherType)); [EOL] }
public void testEquals_NotEqualObjects_DifferentKeyType() { [EOL] MapLikeType mapLikeType1 = new MapLikeType(...); // Provide actual initialization [EOL] MapLikeType mapLikeType2 = new MapLikeType(...); // Provide actual initialization with different keyType [EOL] assertFalse(mapLikeType1.equals(mapLikeType2)); [EOL] }
public void testEquals_NotEqualObjects_DifferentValueType() { [EOL] MapLikeType mapLikeType1 = new MapLikeType(...); // Provide actual initialization [EOL] MapLikeType mapLikeType2 = new MapLikeType(...); // Provide actual initialization with different valueType [EOL] assertFalse(mapLikeType1.equals(mapLikeType2)); [EOL] }
public void testAddKeyDeserializerWithNullKeyDeserializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] Class<?> type = Object.class; [EOL] module.addKeyDeserializer(type, keyDeserializer); [EOL] assertNotNull(module.getKeyDeserializers()); [EOL] assertSame(keyDeserializer, module.getKeyDeserializers().find(type)); [EOL] }
public void testAddKeyDeserializerWithNonNullKeyDeserializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] SimpleKeyDeserializers deserializers = new SimpleKeyDeserializers(); [EOL] module._keyDeserializers = deserializers; // Assuming direct access for the sake of the test [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] Class<?> type = Object.class; [EOL] module.addKeyDeserializer(type, keyDeserializer); [EOL] assertSame(deserializers, module.getKeyDeserializers()); [EOL] assertSame(keyDeserializer, module.getKeyDeserializers().find(type)); [EOL] }
public void testSetupModuleWithAllFieldsNull() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] setupModule(context); [EOL] verify(context, never()).addSerializers(any()); [EOL] verify(context, never()).addDeserializers(any()); [EOL] verify(context, never()).addKeySerializers(any()); [EOL] verify(context, never()).addKeyDeserializers(any()); [EOL] verify(context, never()).addAbstractTypeResolver(any()); [EOL] verify(context, never()).addValueInstantiators(any()); [EOL] verify(context, never()).addBeanDeserializerModifier(any()); [EOL] verify(context, never()).addBeanSerializerModifier(any()); [EOL] verify(context, never()).registerSubtypes((NamedType[]) any()); [EOL] verify(context, never()).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullFields() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] when(_serializers != null).thenReturn(true); [EOL] when(_deserializers != null).thenReturn(true); [EOL] when(_keySerializers != null).thenReturn(true); [EOL] when(_keyDeserializers != null).thenReturn(true); [EOL] when(_abstractTypes != null).thenReturn(true); [EOL] when(_valueInstantiators != null).thenReturn(true); [EOL] when(_deserializerModifier != null).thenReturn(true); [EOL] when(_serializerModifier != null).thenReturn(true); [EOL] when(_subtypes != null).thenReturn(true); [EOL] when(_subtypes.size()).thenReturn(1); [EOL] when(_mixins != null).thenReturn(true); [EOL] when(_mixins.entrySet()).thenReturn(new HashSet<Map.Entry<Class<?>, Class<?>>>().iterator()); [EOL] setupModule(context); [EOL] verify(context).addSerializers(_serializers); [EOL] verify(context).addDeserializers(_deserializers); [EOL] verify(context).addKeySerializers(_keySerializers); [EOL] verify(context).addKeyDeserializers(_keyDeserializers); [EOL] verify(context).addAbstractTypeResolver(_abstractTypes); [EOL] verify(context).addValueInstantiators(_valueInstantiators); [EOL] verify(context).addBeanDeserializerModifier(_deserializerModifier); [EOL] verify(context).addBeanSerializerModifier(_serializerModifier); [EOL] verify(context).registerSubtypes((NamedType[]) any()); [EOL] verify(context).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullSubtypesAndMixins() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] when(_subtypes != null).thenReturn(true); [EOL] when(_subtypes.size()).thenReturn(1); [EOL] when(_mixins != null).thenReturn(true); [EOL] Map<Class<?>, Class<?>> mixinsMap = new HashMap<>(); [EOL] mixinsMap.put(Object.class, String.class); [EOL] when(_mixins.entrySet()).thenReturn(mixinsMap.entrySet()); [EOL] setupModule(context); [EOL] verify(context, never()).addSerializers(any()); [EOL] verify(context, never()).addDeserializers(any()); [EOL] verify(context, never()).addKeySerializers(any()); [EOL] verify(context, never()).addKeyDeserializers(any()); [EOL] verify(context, never()).addAbstractTypeResolver(any()); [EOL] verify(context, never()).addValueInstantiators(any()); [EOL] verify(context, never()).addBeanDeserializerModifier(any()); [EOL] verify(context, never()).addBeanSerializerModifier(any()); [EOL] verify(context).registerSubtypes((NamedType[]) any()); [EOL] verify(context).setMixInAnnotations(Object.class, String.class); [EOL] }
public void testSimpleTypeConstructorWithNullTypeNames() { [EOL] Class<?> cls = Object.class; [EOL] SimpleType simpleType = new SimpleType(cls, null, null, null, null, true); [EOL] assertNull(simpleType.getTypeName()); [EOL] assertNull(simpleType.getTypeParameters()); [EOL] }
public void testSimpleTypeConstructorWithEmptyTypeNames() { [EOL] Class<?> cls = Object.class; [EOL] String[] typeNames = {}; [EOL] JavaType[] typeParams = {}; [EOL] SimpleType simpleType = new SimpleType(cls, typeNames, typeParams, null, null, true); [EOL] assertNull(simpleType.getTypeName()); [EOL] assertNull(simpleType.getTypeParameters()); [EOL] }
public void testSimpleTypeConstructorWithNonNullTypeNames() { [EOL] Class<?> cls = Object.class; [EOL] String[] typeNames = {"type1", "type2"}; [EOL] JavaType[] typeParams = {new JavaType(), new JavaType()}; [EOL] SimpleType simpleType = new SimpleType(cls, typeNames, typeParams, null, null, true); [EOL] assertNotNull(simpleType.getTypeName()); [EOL] assertNotNull(simpleType.getTypeParameters()); [EOL] }
public void testConstructWithMapClass() { [EOL] try { [EOL] SimpleType.construct(java.util.HashMap.class); [EOL] fail("Expected IllegalArgumentException for Map class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for a Map (class: java.util.HashMap)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithCollectionClass() { [EOL] try { [EOL] SimpleType.construct(java.util.ArrayList.class); [EOL] fail("Expected IllegalArgumentException for Collection class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for a Collection (class: java.util.ArrayList)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithArrayClass() { [EOL] try { [EOL] SimpleType.construct(String[].class); [EOL] fail("Expected IllegalArgumentException for array class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for an array (class: [Ljava.lang.String;)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithSimpleClass() { [EOL] SimpleType type = SimpleType.construct(String.class); [EOL] assertNotNull(type); [EOL] assertEquals(String.class, type.getRawClass()); [EOL] }
public void testWithStaticTypingAlreadyStatic() { [EOL] SimpleType type = new SimpleType(SomeClass.class, null, null, null, null, true); [EOL] SimpleType result = type.withStaticTyping(); [EOL] assertSame(type, result); [EOL] }
public void testWithStaticTypingNotStatic() { [EOL] SimpleType type = new SimpleType(SomeClass.class, null, null, null, null, false); [EOL] SimpleType result = type.withStaticTyping(); [EOL] assertNotNull(result); [EOL] assertNotSame(type, result); [EOL] assertTrue(result.isStatic()); [EOL] }
public void testContainedTypeWithNegativeIndex() { [EOL] JavaType result = instance.containedType(-1); [EOL] assertNull(result); [EOL] }
public void testContainedTypeWithIndexGreaterThanTypeParametersLength() { [EOL] JavaType result = instance.containedType(_typeParameters.length + 1); [EOL] assertNull(result); [EOL] }
public void testContainedTypeWithNullTypeParameters() { [EOL] JavaType result = instance.containedType(0); [EOL] assertNull(result); [EOL] }
public void testContainedTypeWithValidIndex() { [EOL] JavaType result = instance.containedType(0); [EOL] assertNotNull(result); [EOL] assertEquals(_typeParameters[0], result); [EOL] }
public void testTypeFactoryConstructor() { [EOL] TypeFactory typeFactory = new TypeFactory(); [EOL] assertNotNull(typeFactory); [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassIsArray() { [EOL] JavaType baseType = new SimpleType(String.class); [EOL] Class<?> subclass = String[].class; [EOL] try { [EOL] JavaType result = constructSpecializedType(baseType, subclass); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassIsMap() { [EOL] JavaType baseType = new SimpleType(Map.class); [EOL] Class<?> subclass = HashMap.class; [EOL] JavaType result = constructSpecializedType(baseType, subclass); [EOL] assertNotNull(result); [EOL] assertTrue(result.hasHandlers()); [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassIsCollection() { [EOL] JavaType baseType = new SimpleType(List.class); [EOL] Class<?> subclass = ArrayList.class; [EOL] JavaType result = constructSpecializedType(baseType, subclass); [EOL] assertNotNull(result); [EOL] assertTrue(result.hasHandlers()); [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassNotAssignable() { [EOL] JavaType baseType = new SimpleType(Set.class); [EOL] Class<?> subclass = String.class; [EOL] try { [EOL] JavaType result = constructSpecializedType(baseType, subclass); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSpecializedTypeWithNonSimpleType() { [EOL] JavaType baseType = new ArrayType(String[].class, null, null, null, null); [EOL] Class<?> subclass = String[].class; [EOL] JavaType result = constructSpecializedType(baseType, subclass); [EOL] assertEquals(baseType, result); [EOL] }
public void testFindTypeParametersWithExactType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(List.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, List.class); [EOL] assertNull(typeParameters); [EOL] }
public void testFindTypeParametersWithTypeAndContainedType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.getTypeFactory().constructCollectionType(List.class, String.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, List.class); [EOL] assertNotNull(typeParameters); [EOL] assertEquals(1, typeParameters.length); [EOL] assertEquals(String.class, typeParameters[0].getRawClass()); [EOL] }
public void testFindTypeParametersWithDifferentType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.getTypeFactory().constructCollectionType(List.class, String.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, Set.class); [EOL] assertNull(typeParameters); [EOL] }
public void testConstructTypeWithNullTypeReference() { [EOL] try { [EOL] objectMapper.constructType(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructTypeWithTypeReference() { [EOL] TypeReference<?> typeRef = new TypeReference<List<String>>() {}; [EOL] JavaType javaType = objectMapper.constructType(typeRef); [EOL] assertNotNull(javaType); [EOL] assertEquals(javaType.getRawClass(), List.class); [EOL] }
public void testConstructTypeWithClass() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] JavaType result = _constructType(String.class, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testConstructTypeWithParameterizedType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testConstructTypeWithJavaType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] JavaType type = new SimpleType(String.class); [EOL] JavaType result = _constructType(type, context); [EOL] assertSame(type, result); [EOL] }
public void testConstructTypeWithGenericArrayType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = getClass().getDeclaredField("arrayOfString").getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayType); [EOL] }
public void testConstructTypeWithTypeVariable() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] TypeVariable<?> type = (TypeVariable<?>) getClass().getTypeParameters()[0]; [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeVariableType); [EOL] }
public void testConstructTypeWithWildcardType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Field field = getClass().getDeclaredField("wildcardType"); [EOL] WildcardType type = (WildcardType) field.getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof WildcardType); [EOL] }
public void testConstructTypeWithUnrecognizedType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = new Type() {}; [EOL] try { [EOL] _constructType(type, context); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructArrayTypeWithNonNullClass() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> elementType = String.class; [EOL] ArrayType arrayType = typeFactory.constructArrayType(elementType); [EOL] assertNotNull(arrayType); [EOL] assertEquals(String[].class, arrayType.getRawClass()); [EOL] }
public void testConstructArrayTypeWithPrimitiveType() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> elementType = int.class; [EOL] ArrayType arrayType = typeFactory.constructArrayType(elementType); [EOL] assertNotNull(arrayType); [EOL] assertEquals(int[].class, arrayType.getRawClass()); [EOL] }
public void testConstructArrayTypeWithNull() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] try { [EOL] typeFactory.constructArrayType(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSimpleTypeWithMatchingParameters() { [EOL] Class<?> rawType = Map.class; [EOL] JavaType[] parameterTypes = new JavaType[] { [EOL] TypeFactory.defaultInstance().constructSimpleType(String.class, null), [EOL] TypeFactory.defaultInstance().constructSimpleType(Integer.class, null) [EOL] }; [EOL] JavaType resultType = constructSimpleType(rawType, parameterTypes); [EOL] assertNotNull(resultType); [EOL] assertTrue(resultType instanceof SimpleType); [EOL] assertEquals(rawType, resultType.getRawClass()); [EOL] assertEquals(2, resultType.containedTypeCount()); [EOL] }
public void testConstructSimpleTypeWithMismatchedParameters() { [EOL] Class<?> rawType = Map.class; [EOL] JavaType[] parameterTypes = new JavaType[] { [EOL] TypeFactory.defaultInstance().constructSimpleType(String.class, null) [EOL] }; [EOL] try { [EOL] constructSimpleType(rawType, parameterTypes); [EOL] fail("Expected IllegalArgumentException due to parameter type mismatch"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Parameter type mismatch for java.util.Map: expected 2 parameters, was given 1", e.getMessage()); [EOL] } [EOL] }
public void testConstructSimpleTypeWithNoParameters() { [EOL] Class<?> rawType = List.class; [EOL] JavaType[] parameterTypes = new JavaType[0]; [EOL] try { [EOL] constructSimpleType(rawType, parameterTypes); [EOL] fail("Expected IllegalArgumentException due to parameter type mismatch"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Parameter type mismatch for java.util.List: expected 1 parameters, was given 0", e.getMessage()); [EOL] } [EOL] }
public void test_fromClassWithStringClass() { [EOL] JavaType result = _fromClass(String.class, null); [EOL] assertSame(CORE_TYPE_STRING, result); [EOL] }
public void test_fromClassWithBooleanType() { [EOL] JavaType result = _fromClass(Boolean.TYPE, null); [EOL] assertSame(CORE_TYPE_BOOL, result); [EOL] }
public void test_fromClassWithIntegerType() { [EOL] JavaType result = _fromClass(Integer.TYPE, null); [EOL] assertSame(CORE_TYPE_INT, result); [EOL] }
public void test_fromClassWithLongType() { [EOL] JavaType result = _fromClass(Long.TYPE, null); [EOL] assertSame(CORE_TYPE_LONG, result); [EOL] }
public void test_fromClassWithCachedType() { [EOL] Class<?> clz = SomeClass.class; // Replace SomeClass with an actual class [EOL] ClassKey key = new ClassKey(clz); [EOL] JavaType expectedType = new SimpleType(clz); [EOL] _typeCache.put(key, expectedType); [EOL] JavaType result = _fromClass(clz, null); [EOL] assertSame(expectedType, result); [EOL] }
public void test_fromClassWithArrayType() { [EOL] JavaType result = _fromClass(String[].class, null); [EOL] assertTrue(result instanceof ArrayType); [EOL] assertEquals(String.class, result.getContentType().getRawClass()); [EOL] }
public void test_fromClassWithEnumType() { [EOL] JavaType result = _fromClass(SomeEnum.class, null); // Replace SomeEnum with an actual enum type [EOL] assertTrue(result instanceof SimpleType); [EOL] assertEquals(SomeEnum.class, result.getRawClass()); [EOL] }
public void test_fromClassWithMapType() { [EOL] JavaType result = _fromClass(HashMap.class, null); [EOL] assertTrue(result instanceof MapType); [EOL] assertEquals(HashMap.class, result.getRawClass()); [EOL] }
public void test_fromClassWithCollectionType() { [EOL] JavaType result = _fromClass(ArrayList.class, null); [EOL] assertTrue(result instanceof CollectionType); [EOL] assertEquals(ArrayList.class, result.getRawClass()); [EOL] }
public void test_fromClassWithSimpleType() { [EOL] JavaType result = _fromClass(SomeOtherClass.class, null); // Replace SomeOtherClass with a non-collection, non-map, non-array, non-enum class [EOL] assertTrue(result instanceof SimpleType); [EOL] assertEquals(SomeOtherClass.class, result.getRawClass()); [EOL] }
public void testFromParamTypeWithNoTypeParameters() { [EOL] ParameterizedType type = Mockito.mock(ParameterizedType.class); [EOL] TypeBindings context = Mockito.mock(TypeBindings.class); [EOL] Mockito.when(type.getRawType()).thenReturn((Type) Object.class); [EOL] Mockito.when(type.getActualTypeArguments()).thenReturn(new Type[0]); [EOL] JavaType result = _fromParamType(type, context); [EOL] assertTrue(result instanceof SimpleType); [EOL] assertEquals(Object.class, result.getRawClass()); [EOL] }
public void testFromParamTypeWithMapType() throws Exception { [EOL] ParameterizedType type = Mockito.mock(ParameterizedType.class); [EOL] TypeBindings context = Mockito.mock(TypeBindings.class); [EOL] Mockito.when(type.getRawType()).thenReturn((Type) HashMap.class); [EOL] Mockito.when(type.getActualTypeArguments()).thenReturn(new Type[] {String.class, Integer.class}); [EOL] JavaType result = _fromParamType(type, context); [EOL] assertTrue(result instanceof MapType); [EOL] assertEquals(HashMap.class, result.getRawClass()); [EOL] assertEquals(String.class, ((MapType) result).getKeyType().getRawClass()); [EOL] assertEquals(Integer.class, ((MapType) result).getContentType().getRawClass()); [EOL] }
public void testFromParamTypeWithCollectionType() throws Exception { [EOL] ParameterizedType type = Mockito.mock(ParameterizedType.class); [EOL] TypeBindings context = Mockito.mock(TypeBindings.class); [EOL] Mockito.when(type.getRawType()).thenReturn((Type) ArrayList.class); [EOL] Mockito.when(type.getActualTypeArguments()).thenReturn(new Type[] {String.class}); [EOL] JavaType result = _fromParamType(type, context); [EOL] assertTrue(result instanceof CollectionType); [EOL] assertEquals(ArrayList.class, result.getRawClass()); [EOL] assertEquals(String.class, ((CollectionType) result).getContentType().getRawClass()); [EOL] }
public void testFromParamTypeWithInvalidMapTypeParameters() { [EOL] ParameterizedType type = Mockito.mock(ParameterizedType.class); [EOL] TypeBindings context = Mockito.mock(TypeBindings.class); [EOL] Mockito.when(type.getRawType()).thenReturn((Type) HashMap.class); [EOL] Mockito.when(type.getActualTypeArguments()).thenReturn(new Type[] {String.class}); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] _fromParamType(type, context); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Could not find 2 type parameters for Map class")); [EOL] }
public void testFromParamTypeWithInvalidCollectionTypeParameters() { [EOL] ParameterizedType type = Mockito.mock(ParameterizedType.class); [EOL] TypeBindings context = Mockito.mock(TypeBindings.class); [EOL] Mockito.when(type.getRawType()).thenReturn((Type) ArrayList.class); [EOL] Mockito.when(type.getActualTypeArguments()).thenReturn(new Type[0]); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] _fromParamType(type, context); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Could not find 1 type parameter for Collection class")); [EOL] }
public void testDeserializeTypedFromObjectWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).nextToken(); [EOL] }
public void testDeserializeTypedFromObjectWithStartArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, never()).nextToken(); [EOL] }
public void testDeserializeTypedFromObjectWithFieldNameToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("typePropertyName").thenReturn("otherField"); [EOL] when(_typePropertyName).thenReturn("typePropertyName"); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(jp, times(2)).getCurrentName(); [EOL] }
public void testDeserializeTypedFromObjectWithUnexpectedToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, never()).nextToken(); [EOL] }
public void testDeserializeTypedForIdWithVisibleTypeIdAndNonNullTokenBuffer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(ctxt.findRootValueDeserializer(any(JavaType.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] MyClass instance = new MyClass(); [EOL] instance._typeIdVisible = true; [EOL] Object result = instance._deserializeTypedForId(jp, ctxt, tb); [EOL] verify(tb).writeFieldName("fieldName"); [EOL] verify(tb).writeString("typeId"); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithVisibleTypeIdAndNullTokenBuffer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(ctxt.findRootValueDeserializer(any(JavaType.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] MyClass instance = new MyClass(); [EOL] instance._typeIdVisible = true; [EOL] Object result = instance._deserializeTypedForId(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithoutVisibleTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(ctxt.findRootValueDeserializer(any(JavaType.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] MyClass instance = new MyClass(); [EOL] instance._typeIdVisible = false; [EOL] Object result = instance._deserializeTypedForId(jp, ctxt, tb); [EOL] assertNotNull(result); [EOL] }
public void testAsParserWithNonNullSource() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser src = factory.createParser("{\"key\":\"value\"}"); [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode _first = new ArrayNode(nodeFactory); [EOL] JsonParser result = asParser(src); [EOL] assertNotNull(result); [EOL] assertEquals(src.getCodec(), result.getCodec()); [EOL] assertEquals(src.getTokenLocation(), result.getTokenLocation()); [EOL] }
public void testAsParserWithNullSource() { [EOL] JsonParser src = null; [EOL] ArrayNode _first = new ArrayNode(JsonNodeFactory.instance); [EOL] try { [EOL] JsonParser result = asParser(src); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testWriteFieldNameWithValidName() throws IOException { [EOL] JsonGenerator generator = createGenerator(); // Assuming createGenerator() is a method that creates a JsonGenerator instance [EOL] SerializableString name = new SerializableStringImpl("fieldName"); // Assuming SerializableStringImpl is an implementation of SerializableString [EOL] generator.writeFieldName(name); [EOL] }
public void testWriteFieldNameWithNullName() { [EOL] JsonGenerator generator = createGenerator(); [EOL] try { [EOL] generator.writeFieldName(null); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonGenerationException, but got IOException"); [EOL] } [EOL] }
public void testSetLocationWithNull() { [EOL] JsonLocation location = null; [EOL] JsonParser jp = new JsonParser(); [EOL] jp.setLocation(location); [EOL] assertNull(jp.getLocation()); [EOL] }
public void testSetLocationWithNonNull() { [EOL] JsonLocation location = new JsonLocation(null, 1L, 2, 3, 4); [EOL] JsonParser jp = new JsonParser(); [EOL] jp.setLocation(location); [EOL] assertEquals(location, jp.getLocation()); [EOL] }
public void testGetFloatValueFromInt() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("123"); [EOL] assertEquals(123.0f, parser.getFloatValue(), 0.0f); [EOL] } [EOL] public void testGetFloatValueFromFloat() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("123.45"); [EOL] assertEquals(123.45f, parser.getFloatValue(), 0.0f); [EOL] } [EOL] public void testGetFloatValueFromDouble() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("1234567890.123456789"); [EOL] assertEquals(1234567890.123456789f, parser.getFloatValue(), 0.0f); [EOL] } [EOL] public void testGetFloatValueFromBigInteger() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("123456789012345678901234567890"); [EOL] assertEquals(new BigInteger("123456789012345678901234567890").floatValue(), parser.getFloatValue(), 0.0f); [EOL] } [EOL] public void testGetFloatValueFromBigDecimal() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("1234567890.12345678901234567890"); [EOL] assertEquals(new BigDecimal("1234567890.12345678901234567890").floatValue(), parser.getFloatValue(), 0.0f); [EOL] }
public void testStdKeySerializerConstructor() { [EOL] StdKeySerializer serializer = new StdKeySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithDate() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Date date = new Date(); [EOL] new CustomSerializer().serialize(date, mockJsonGenerator, mockProvider); [EOL] verify(mockProvider).defaultSerializeDateKey(date, mockJsonGenerator); [EOL] }
public void testSerializeWithNonDate() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object nonDateValue = new Object(); [EOL] new CustomSerializer().serialize(nonDateValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeFieldName(nonDateValue.toString()); [EOL] }
public void testAssertSubclassWithAssignableClasses() { [EOL] Class<?> superClass = java.util.ArrayList.class; [EOL] Class<?> subclass = java.util.List.class; [EOL] _assertSubclass(subclass, superClass); [EOL] } [EOL] public void testAssertSubclassWithNonAssignableClasses() { [EOL] try { [EOL] Class<?> superClass = java.util.List.class; [EOL] Class<?> subclass = java.util.ArrayList.class; [EOL] _assertSubclass(subclass, superClass); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Class java.util.ArrayList is not assignable to java.util.List", e.getMessage()); [EOL] } [EOL] }
public void testHashCode() { [EOL] MyClass instance = new MyClass(123); [EOL] int expectedHashCode = 123; // Assuming the _hashCode field is set to 123 in the constructor [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testAsTextWithNullValue() { [EOL] ValueHolder holder = new ValueHolder(null); [EOL] String result = holder.asText(); [EOL] assert "null".equals(result); [EOL] }
public void testAsTextWithNonNullValue() { [EOL] ValueHolder holder = new ValueHolder("testValue"); [EOL] String result = holder.asText(); [EOL] assert "testValue".equals(result); [EOL] }
public void testAsIntWithNumberValue() { [EOL] JsonNode node = new IntNode(5); [EOL] int result = node.asInt(0); [EOL] assertEquals(5, result); [EOL] }
public void testAsIntWithDefaultValue() { [EOL] JsonNode node = new TextNode("not a number"); [EOL] int result = node.asInt(10); [EOL] assertEquals(10, result); [EOL] }
public void testAsLongWithNumberValue() { [EOL] JsonNode node = new LongNode(5L); [EOL] long result = node.asLong(10L); [EOL] assert result == 5L; [EOL] }
public void testAsLongWithDefaultValue() { [EOL] JsonNode node = new TextNode("not a number"); [EOL] long result = node.asLong(10L); [EOL] assert result == 10L; [EOL] }
public void testAsDoubleWithNumberValue() { [EOL] JsonNode node = new NumericNode(new BigDecimal("42.0")); [EOL] double result = node.asDouble(0.0); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testAsDoubleWithNonNumberValue() { [EOL] JsonNode node = new TextNode("not a number"); [EOL] double result = node.asDouble(1.0); [EOL] assertEquals(1.0, result, 0.0); [EOL] }
public void testEquals_Reflexive() { [EOL] POJONode node = new POJONode("test"); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEquals_Null() { [EOL] POJONode node = new POJONode("test"); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] POJONode node = new POJONode("test"); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEquals_EqualPOJONodes() { [EOL] POJONode node1 = new POJONode("test"); [EOL] POJONode node2 = new POJONode("test"); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testEquals_NonEqualPOJONodes() { [EOL] POJONode node1 = new POJONode("test"); [EOL] POJONode node2 = new POJONode("different"); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testEquals_WithNullValue() { [EOL] POJONode node1 = new POJONode(null); [EOL] POJONode node2 = new POJONode(null); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testEquals_WithOneNullValue() { [EOL] POJONode node1 = new POJONode(null); [EOL] POJONode node2 = new POJONode("test"); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testHashCodeWithNonNullValue() { [EOL] SomeClass instance = new SomeClass("testValue"); [EOL] int expectedHashCode = "testValue".hashCode(); [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWithNullValue() { [EOL] SomeClass instance = new SomeClass(null); [EOL] int expectedHashCode = 0; // Assuming the hashCode for null _value is 0 [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testToStringWithNonNullValue() { [EOL] MyClass instance = new MyClass(); [EOL] instance._value = "TestValue"; [EOL] String result = instance.toString(); [EOL] assert "TestValue".equals(result); [EOL] } [EOL] public void testToStringWithNullValue() { [EOL] MyClass instance = new MyClass(); [EOL] instance._value = null; [EOL] String result = instance.toString(); [EOL] assert "null".equals(result); [EOL] }
public void testDateSerializerDefaultConstructor() { [EOL] DateSerializer serializer = new DateSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testDateSerializerWithTimestamp() { [EOL] boolean useTimestamp = true; [EOL] DateFormat customFormat = null; [EOL] DateSerializer serializer = new DateSerializer(useTimestamp, customFormat); [EOL] assertNotNull(serializer); [EOL] }
public void testDateSerializerWithCustomFormat() { [EOL] boolean useTimestamp = false; [EOL] DateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] DateSerializer serializer = new DateSerializer(useTimestamp, customFormat); [EOL] assertNotNull(serializer); [EOL] }
public void testGetOutputTypeWithValidTypeParameters() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Converter<?, ?> converter = new ConverterSubtype(); [EOL] JavaType outputType = converter.getOutputType(typeFactory); [EOL] assertNotNull(outputType); [EOL] } [EOL] public void testGetOutputTypeWithInvalidTypeParameters() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Converter<?, ?> converter = new ConverterWithInvalidTypeParameters(); [EOL] try { [EOL] converter.getOutputType(typeFactory); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Can not find OUT type parameter for Converter of type " + converter.getClass().getName(), e.getMessage()); [EOL] } [EOL] }

public void testWithValueTypeSerializer_NullVts() { [EOL] ContainerSerializer<?> originalSerializer = getContainerSerializer(); // Assume this method provides the original ContainerSerializer [EOL] ContainerSerializer<?> resultSerializer = originalSerializer.withValueTypeSerializer(null); [EOL] assertSame("Expected same instance when vts is null", originalSerializer, resultSerializer); [EOL] }
public void testWithValueTypeSerializer_NonNullVts() { [EOL] ContainerSerializer<?> originalSerializer = getContainerSerializer(); // Assume this method provides the original ContainerSerializer [EOL] TypeSerializer vts = getTypeSerializer(); // Assume this method provides a non-null TypeSerializer [EOL] ContainerSerializer<?> resultSerializer = originalSerializer.withValueTypeSerializer(vts); [EOL] assertNotSame("Expected different instance when vts is non-null", originalSerializer, resultSerializer); [EOL] }
public ObjectMapper registerModule(Module module) { [EOL] String name = module.getModuleName(); [EOL] if (name == null) { [EOL] throw new IllegalArgumentException("Module without defined name"); [EOL] } [EOL] Version version = module.version(); [EOL] if (version == null) { [EOL] throw new IllegalArgumentException("Module without defined version"); [EOL] } [EOL] final ObjectMapper mapper = this; [EOL] module.setupModule(new Module.SetupContext() { [EOL] @Override [EOL] public Version getMapperVersion() { [EOL] return version(); [EOL] } [EOL] @Override [EOL] public <C extends ObjectCodec> C getOwner() { [EOL] return (C) mapper; [EOL] } [EOL] @Override [EOL] public TypeFactory getTypeFactory() { [EOL] return _typeFactory; [EOL] } [EOL] @Override [EOL] public boolean isEnabled(MapperFeature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(DeserializationFeature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(JsonFactory.Feature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(JsonParser.Feature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(JsonGenerator.Feature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public void addDeserializers(Deserializers d) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addKeyDeserializers(KeyDeserializers d) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addSerializers(Serializers s) { [EOL] mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL] } [EOL] @Override [EOL] public void addKeySerializers(Serializers s) { [EOL] mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL] } [EOL] @Override [EOL] public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL] mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL] } [EOL] @Override [EOL] public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addTypeModifier(TypeModifier modifier) { [EOL] TypeFactory f = mapper._typeFactory; [EOL] f = f.withModifier(modifier); [EOL] mapper.setTypeFactory(f); [EOL] } [EOL] @Override [EOL] public void addValueInstantiators(ValueInstantiators instantiators) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void setClassIntrospector(ClassIntrospector ci) { [EOL] mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL] mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL] } [EOL] @Override [EOL] public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL] mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL] mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL] } [EOL] @Override [EOL] public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL] mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL] mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL] } [EOL] @Override [EOL] public void registerSubtypes(Class<?>... subtypes) { [EOL] mapper.registerSubtypes(subtypes); [EOL] } [EOL] @Override [EOL] public void registerSubtypes(NamedType... subtypes) { [EOL] mapper.registerSubtypes(subtypes); [EOL] } [EOL] @Override [EOL] public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL] mapper.addMixInAnnotations(target, mixinSource); [EOL] } [EOL] @Override [EOL] public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL] mapper.addHandler(handler); [EOL] } [EOL] }); [EOL] return this; [EOL] }
public void testAddHandlerWithNonNullHandler() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationProblemHandler handler = new DeserializationProblemHandler() {}; [EOL] ObjectMapper result = mapper.addHandler(handler); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] }
public void testAddHandlerWithNullHandler() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.addHandler(null); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] }
public void testClearProblemHandlers() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] int originalHandlerCount = originalConfig.getProblemHandlers().size(); [EOL] mapper = mapper.clearProblemHandlers(); [EOL] DeserializationConfig newConfig = mapper.getDeserializationConfig(); [EOL] int newHandlerCount = newConfig.getProblemHandlers().size(); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertEquals(0, newHandlerCount); [EOL] assertTrue(originalHandlerCount > newHandlerCount); [EOL] }
public void testReadTreeWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNull(result); [EOL] }
public void testReadTreeWithNonNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonNode); [EOL] }
public void testReadTreeWithInitialNullThenNonNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonNode); [EOL] }
public void testCreateObjectNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectNode node = mapper.createObjectNode(); [EOL] assertNotNull(node); [EOL] assertTrue(node instanceof ObjectNode); [EOL] }
public void testReadValueWithValidStringAndType() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "{\"name\":\"John\", \"age\":30}"; [EOL] JavaType valueType = mapper.getTypeFactory().constructType(User.class); [EOL] User result = mapper.readValue(jsonContent, valueType); [EOL] assertNotNull(result); [EOL] assertEquals("John", result.getName()); [EOL] assertEquals(30, result.getAge()); [EOL] }
public void testReadValueWithInvalidJsonString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String invalidJsonContent = "Invalid JSON"; [EOL] JavaType valueType = mapper.getTypeFactory().constructType(User.class); [EOL] assertThrows(JsonParseException.class, () -> { [EOL] mapper.readValue(invalidJsonContent, valueType); [EOL] }); [EOL] }
public void testReadValueWithNullString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType valueType = mapper.getTypeFactory().constructType(User.class); [EOL] assertThrows(NullPointerException.class, () -> { [EOL] mapper.readValue(null, valueType); [EOL] }); [EOL] }
public void testReadValueWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "{\"name\":\"John\", \"age\":30}"; [EOL] assertThrows(NullPointerException.class, () -> { [EOL] mapper.readValue(jsonContent, null); [EOL] }); [EOL] }
public void testReadValueWithValidReaderAndClass() throws IOException { [EOL] Reader src = new StringReader("{\"key\":\"value\"}"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Map<String, String> result = mapper.readValue(src, Map.class); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] } [EOL] public void testReadValueWithNullReader() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue((Reader) null, Map.class); [EOL] fail("Should not pass when reader is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalArgumentException, not IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithInvalidContent() { [EOL] Reader src = new StringReader("invalid json"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue(src, Map.class); [EOL] fail("Should not pass when content is invalid"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, not IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithIncompatibleType() { [EOL] Reader src = new StringReader("{\"key\":\"value\"}"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue(src, Integer.class); [EOL] fail("Should not pass when asked to read incompatible type"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonMappingException, not IOException"); [EOL] } [EOL] }
public void testWriteValueAsStringWithValidObject() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String result = mapper.writeValueAsString(new MyObject()); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] } [EOL] public void testWriteValueAsStringWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.writeValueAsString(null); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] } [EOL] public void testWriteValueAsStringWithIOException() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public ObjectWriter writer() { [EOL] return new ObjectWriter(this, getSerializationConfig()) { [EOL] @Override [EOL] protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { [EOL] return new DefaultSerializerProvider.Impl() { [EOL] @Override [EOL] public void serializeValue(JsonGenerator gen, Object value) throws IOException { [EOL] throw new IOException("simulated IOException"); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] try { [EOL] mapper.writeValueAsString(new MyObject()); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testWriterWithType_NullTypeReference() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithType((TypeReference<?>) null); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithType_NonNullTypeReference() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeReference<?> typeRef = new TypeReference<List<String>>() {}; [EOL] ObjectWriter writer = mapper.writerWithType(typeRef); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithDefaultBase64() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Base64Variant defaultBase64 = Base64Variants.MIME_NO_LINEFEEDS; [EOL] ObjectWriter writer = mapper.writer(defaultBase64); [EOL] assertNotNull(writer); [EOL] assertEquals(defaultBase64, writer.getConfig().getBase64Variant()); [EOL] }
public void testWriterWithNullBase64() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writer((Base64Variant) null); [EOL] assertNotNull(writer); [EOL] assertEquals(Base64Variants.getDefaultVariant(), writer.getConfig().getBase64Variant()); [EOL] }
public void testReaderNotNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] ObjectReader reader = objectMapper.reader(); [EOL] assertNotNull(reader); [EOL] }
public void testReaderWithInjectableValues() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] InjectableValues injectableValues = new InjectableValues.Std().addValue(String.class, "testValue"); [EOL] objectMapper.setInjectableValues(injectableValues); [EOL] ObjectReader reader = objectMapper.reader(); [EOL] assertEquals(injectableValues, reader.getInjectableValues()); [EOL] }
public void testReaderWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; [EOL] ObjectReader reader = mapper.reader(feature); [EOL] assertTrue(reader.getDeserializationConfig().hasDeserializationFeatures(feature.getMask())); [EOL] }
public void testReaderWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] ObjectReader reader = mapper.reader(feature); [EOL] assertFalse(reader.getDeserializationConfig().without(feature).hasDeserializationFeatures(feature.getMask())); [EOL] }
public void testConfigAndWriteValue_IndentOutputEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] verify(cfg, never()).isEnabled(SerializationFeature.CLOSE_CLOSEABLE); [EOL] }
public void testConfigAndWriteValue_CloseCloseableEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(true); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(value).close(); [EOL] }
public void testConfigAndWriteValue_NoFeaturesEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValue_ExceptionThrown() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] doThrow(new IOException()).when(jgen).close(); [EOL] try { [EOL] _configAndWriteValue(jgen, value); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(jgen).close(); [EOL] }
public void testReadValueWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] DeserializationConfig cfg = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(deser.getNullValue()).thenReturn(null); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(deser); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertNull(result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] DeserializationConfig cfg = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] JavaType valueType = mock(JavaType.class); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertNull(result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] DeserializationConfig cfg = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] JavaType valueType = mock(JavaType.class); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertNull(result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithRootWrapping() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] DeserializationConfig cfg = mock(DeserializationConfig.class); [EOL] when(cfg.useRootWrapping()).thenReturn(true); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(deser); [EOL] Object expected = new Object(); [EOL] when(_unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser)).thenReturn(expected); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertSame(expected, result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithoutRootWrapping() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] DeserializationConfig cfg = mock(DeserializationConfig.class); [EOL] when(cfg.useRootWrapping()).thenReturn(false); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(deser); [EOL] Object expected = new Object(); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(expected); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertSame(expected, result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL] try { [EOL] Object result; [EOL] JsonToken t = _initForReading(jp); [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL] result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL] } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL] result = null; [EOL] } else { [EOL] DeserializationConfig cfg = getDeserializationConfig(); [EOL] DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL] JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL] if (cfg.useRootWrapping()) { [EOL] result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL] } else { [EOL] result = deser.deserialize(jp, ctxt); [EOL] } [EOL] } [EOL] jp.clearCurrentToken(); [EOL] return result; [EOL] } finally { [EOL] try { [EOL] jp.close(); [EOL] } catch (IOException ioe) { [EOL] } [EOL] } [EOL] }
public void testUnwrapAndDeserializeWithNullRootName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] RootNameLookup rootNames = mock(RootNameLookup.class); [EOL] SerializedString sstr = new SerializedString("testName"); [EOL] when(config.getRootName()).thenReturn(null); [EOL] when(rootNames.findRootName(rootType, config)).thenReturn(sstr); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("testName"); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = _unwrapAndDeserialize(jp, ctxt, config, rootType, deser); [EOL] assertNotNull(result); [EOL] }
public void testUnwrapAndDeserializeWithNonNullRootName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(config.getRootName()).thenReturn("testName"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("testName"); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = _unwrapAndDeserialize(jp, ctxt, config, rootType, deser); [EOL] assertNotNull(result); [EOL] }
public void testUnwrapAndDeserializeWithMismatchingRootName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(config.getRootName()).thenReturn("expectedName"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("actualName"); [EOL] assertThrows(JsonMappingException.class, () -> _unwrapAndDeserialize(jp, ctxt, config, rootType, deser)); [EOL] }
public void testUnwrapAndDeserializeWithInvalidStartToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(config.getRootName()).thenReturn("testName"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonMappingException.class, () -> _unwrapAndDeserialize(jp, ctxt, config, rootType, deser)); [EOL] }
public void testUnwrapAndDeserializeWithInvalidSecondToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(config.getRootName()).thenReturn("testName"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonMappingException.class, () -> _unwrapAndDeserialize(jp, ctxt, config, rootType, deser)); [EOL] }
public void testUnwrapAndDeserializeWithInvalidEndToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] SerializedString sstr = new SerializedString("testName"); [EOL] when(config.getRootName()).thenReturn(null); [EOL] when(rootNames.findRootName(rootType, config)).thenReturn(sstr); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("testName"); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonMappingException.class, () -> _unwrapAndDeserialize(jp, ctxt, config, rootType, deser)); [EOL] }
public void testCalendarSerializerDefaultConstructor() { [EOL] CalendarSerializer serializer = new CalendarSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testCalendarSerializerWithTimestamp() { [EOL] boolean useTimestamp = true; [EOL] DateFormat customFormat = null; [EOL] CalendarSerializer serializer = new CalendarSerializer(useTimestamp, customFormat); [EOL] assertNotNull(serializer); [EOL] }
public void testCalendarSerializerWithoutTimestamp() { [EOL] boolean useTimestamp = false; [EOL] DateFormat customFormat = null; [EOL] CalendarSerializer serializer = new CalendarSerializer(useTimestamp, customFormat); [EOL] assertNotNull(serializer); [EOL] }
public void testCalendarSerializerWithCustomFormat() { [EOL] boolean useTimestamp = false; [EOL] DateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] CalendarSerializer serializer = new CalendarSerializer(useTimestamp, customFormat); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithTimestamp() throws IOException { [EOL] Calendar value = Calendar.getInstance(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CalendarSerializer serializer = new CalendarSerializer(true, null); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(jgen).writeNumber(anyLong()); [EOL] }
public void testSerializeWithCustomFormat() throws IOException { [EOL] Calendar value = Calendar.getInstance(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DateFormat customFormat = new SimpleDateFormat(); [EOL] CalendarSerializer serializer = new CalendarSerializer(false, customFormat); [EOL] serializer.serialize(value, jgen, provider); [EOL] synchronized (customFormat) { [EOL] verify(jgen).writeString(customFormat.format(value)); [EOL] } [EOL] }
public void testSerializeWithoutTimestampOrCustomFormat() throws IOException { [EOL] Calendar value = Calendar.getInstance(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CalendarSerializer serializer = new CalendarSerializer(false, null); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(provider).defaultSerializeDateValue(value.getTime(), jgen); [EOL] }
public void testCanCreateFromInt() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.canCreateFromInt(); [EOL] assertFalse(result); [EOL] }
public void testCanCreateUsingDefaultWithNonNullDefaultCreator() { [EOL] instance.setDefaultCreator(someNonNullCreator); [EOL] boolean result = instance.canCreateUsingDefault(); [EOL] assert result; // Assert that the result is true when default creator is not null [EOL] }
public void testCanCreateUsingDefaultWithNullDefaultCreator() { [EOL] instance.setDefaultCreator(null); [EOL] boolean result = instance.canCreateUsingDefault(); [EOL] assert !result; // Assert that the result is false when default creator is null [EOL] }
public AnnotatedWithParams getDefaultCreator() { [EOL] return null; [EOL] }
public AnnotatedWithParams getDelegateCreator() { [EOL] return null; [EOL] }
public void testAsTokenWhenValueIsTrue() { [EOL] JsonBoolean jsonBoolean = new JsonBoolean(true); [EOL] JsonToken result = jsonBoolean.asToken(); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testAsTokenWhenValueIsFalse() { [EOL] JsonBoolean jsonBoolean = new JsonBoolean(false); [EOL] JsonToken result = jsonBoolean.asToken(); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public String testTransformIdentity() { [EOL] NameTransformer transformer = NameTransformer.NOP; [EOL] String originalName = "testName"; [EOL] String transformedName = transformer.transform(originalName); [EOL] assertEquals(originalName, transformedName); [EOL] } [EOL] public String testReverseIdentity() { [EOL] NameTransformer transformer = NameTransformer.NOP; [EOL] String originalName = "testName"; [EOL] String reversedName = transformer.reverse(originalName); [EOL] assertEquals(originalName, reversedName); [EOL] }
protected NonTypedScalarSerializerBase(Class<T> t) { [EOL] super(t); [EOL] }
public void testStdDeserializerWithNullValueType() { [EOL] StdDeserializer deserializer = new StdDeserializer(null); [EOL] assertNull(deserializer._valueClass); [EOL] }
public void testStdDeserializerWithNonNullValueType() { [EOL] JavaType mockJavaType = Mockito.mock(JavaType.class); [EOL] Class<?> expectedClass = Object.class; [EOL] Mockito.when(mockJavaType.getRawClass()).thenReturn(expectedClass); [EOL] StdDeserializer deserializer = new StdDeserializer(mockJavaType); [EOL] assertEquals(expectedClass, deserializer._valueClass); [EOL] }
public void testParseBooleanPrimitiveWithTrueValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithFalseValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithNumberIntNonZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithNumberIntZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithNumberNotInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); // Assuming _parseBooleanFromNumber handles other types [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] }
public void testParseBooleanPrimitiveWithStringTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("true"); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithStringFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("false"); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithStringEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithStringInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] try { [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] fail("Expected weirdStringException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseBooleanPrimitiveWithNonHandledToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); // Any non-handled token [EOL] try { [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] fail("Expected mappingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseBooleanWithTrueValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testParseBooleanWithFalseValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testParseBooleanWithNumberIntZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testParseBooleanWithNumberIntNonZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testParseBooleanWithNumberNonInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); // Assuming _parseBooleanFromNumber handles different NumberTypes [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseBoolean(jp, ctxt)); [EOL] }
public void testParseBooleanWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseBooleanWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(Boolean.FALSE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testParseBooleanWithTrueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("true"); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testParseBooleanWithFalseString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("false"); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testParseBooleanWithInvalidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseBoolean(jp, ctxt)); [EOL] }
public void testParseBooleanWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))).thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> _parseBoolean(jp, ctxt)); [EOL] }
public void testParseBooleanFromNumberWithLongTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(1L); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] boolean result = _parseBooleanFromNumber(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanFromNumberWithLongFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(0L); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] boolean result = _parseBooleanFromNumber(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanFromNumberWithNonLongZeroDotZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); // or any non-LONG type [EOL] when(jp.getText()).thenReturn("0.0"); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] boolean result = _parseBooleanFromNumber(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanFromNumberWithNonLongZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); // or any non-LONG type [EOL] when(jp.getText()).thenReturn("0"); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] boolean result = _parseBooleanFromNumber(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanFromNumberWithNonLongNonZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); // or any non-LONG type [EOL] when(jp.getText()).thenReturn("1"); // or any non-zero string [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] boolean result = _parseBooleanFromNumber(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseIntPrimitiveWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntPrimitiveWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getIntValue()).thenReturn(456); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(456, result); [EOL] }
public void testParseIntPrimitiveWithStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("789"); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(789, result); [EOL] }
public void testParseIntPrimitiveWithEmptyStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntPrimitiveWithLongStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("2147483648"); [EOL] try { [EOL] _parseIntPrimitive(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseIntPrimitiveWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntPrimitiveWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _parseIntPrimitive(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getLongValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return (Long) getEmptyValue(); [EOL] } [EOL] try { [EOL] return Long.valueOf(NumberInput.parseLong(text)); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return (Long) getNullValue(); [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
public void testParseFloatPrimitiveWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(10.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(20.0f); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(20.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(Float.POSITIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(Float.NEGATIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(Float.NaN, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenValidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(123.45f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenInvalidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a float"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonMappingException("not a valid float value")); [EOL] assertThrows(JsonMappingException.class, () -> _parseFloatPrimitive(jp, ctxt)); [EOL] }
public void testParseFloatPrimitiveWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("Invalid token")); [EOL] assertThrows(JsonMappingException.class, () -> _parseFloatPrimitive(jp, ctxt)); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getDoubleValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return (Double) getEmptyValue(); [EOL] } [EOL] switch(text.charAt(0)) { [EOL] case 'I': [EOL] if ("Infinity".equals(text) || "INF".equals(text)) { [EOL] return Double.POSITIVE_INFINITY; [EOL] } [EOL] break; [EOL] case 'N': [EOL] if ("NaN".equals(text)) { [EOL] return Double.NaN; [EOL] } [EOL] break; [EOL] case '-': [EOL] if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL] return Double.NEGATIVE_INFINITY; [EOL] } [EOL] break; [EOL] } [EOL] try { [EOL] return parseDouble(text); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return (Double) getNullValue(); [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
public void testParseDateWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getLongValue()).thenReturn(1451606400000L); // Example timestamp for January 1, 2016 [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertEquals(new Date(1451606400000L), result); [EOL] }
public void testParseDateWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseDateWithEmptyStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertEquals(ctxt.getEmptyValue(), result); [EOL] }
public void testParseDateWithValidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("2016-01-01"); [EOL] when(ctxt.parseDate("2016-01-01")).thenReturn(new Date(1451606400000L)); [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertEquals(new Date(1451606400000L), result); [EOL] }
public void testParseDateWithInvalidStringToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid-date"); [EOL] when(ctxt.parseDate("invalid-date")).thenThrow(new IllegalArgumentException("not a valid representation")); [EOL] try { [EOL] _parseDate(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonProcessingException, not IOException"); [EOL] } [EOL] }
public void testParseDateWithUnexpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); // An unexpected token type [EOL] try { [EOL] _parseDate(jp, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonMappingException, not IOException"); [EOL] } [EOL] }
public void testParseDoubleWithNastySmallDouble() { [EOL] String numStr = NumberInput.NASTY_SMALL_DOUBLE; [EOL] double result = parseDouble(numStr); [EOL] assertEquals(Double.MIN_VALUE, result, 0.0); [EOL] }
public void testParseDoubleWithRegularNumber() { [EOL] String numStr = "0.123"; [EOL] double result = parseDouble(numStr); [EOL] assertEquals(0.123, result, 0.0); [EOL] }
public void testParseDoubleWithInvalidNumber() { [EOL] String numStr = "notANumber"; [EOL] try { [EOL] parseDouble(numStr); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException { [EOL] return ctxt.findContextualValueDeserializer(type, property); [EOL] }
public void testHandleUnknownPropertyWithNullInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "unknownProperty"; [EOL] when(ctxt.handleUnknownProperty(jp, this, null, propName)).thenReturn(true); [EOL] handleUnknownProperty(jp, ctxt, null, propName); [EOL] verify(ctxt, times(1)).handleUnknownProperty(jp, this, getValueClass(), propName); [EOL] verify(ctxt, never()).reportUnknownProperty(any(), anyString(), any()); [EOL] verify(jp, never()).skipChildren(); [EOL] }
public void testHandleUnknownPropertyWithKnownInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] String propName = "unknownProperty"; [EOL] when(ctxt.handleUnknownProperty(jp, this, instance, propName)).thenReturn(false); [EOL] handleUnknownProperty(jp, ctxt, instance, propName); [EOL] verify(ctxt, times(1)).handleUnknownProperty(jp, this, instance, propName); [EOL] verify(ctxt, times(1)).reportUnknownProperty(instance, propName, this); [EOL] verify(jp, times(1)).skipChildren(); [EOL] }
public void testSerializationConfigWithNonNullArgs() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null); [EOL] SubtypeResolver subtypeResolver = new StdSubtypeResolver(); [EOL] Map<ClassKey, Class<?>> mixins = new HashMap<>(); [EOL] mixins.put(new ClassKey(String.class), Object.class); [EOL] SerializationConfig config = new SerializationConfig(baseSettings, subtypeResolver, mixins); [EOL] assertNotNull(config); [EOL] assertEquals(Object.class, config.findMixInClassFor(String.class)); [EOL] }
public void testSerializationConfigWithNullArgs() { [EOL] BaseSettings baseSettings = null; [EOL] SubtypeResolver subtypeResolver = null; [EOL] Map<ClassKey, Class<?>> mixins = null; [EOL] try { [EOL] SerializationConfig config = new SerializationConfig(baseSettings, subtypeResolver, mixins); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithBase64Variant() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] Base64Variant base64Variant = new Base64Variant(Base64Variants.MIME, "MIME", true); [EOL] SerializationConfig newConfig = config.with(base64Variant); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(base64Variant, newConfig.getBase64Variant()); [EOL] }
public void testWithDefaultBase64Variant() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] Base64Variant defaultBase64Variant = Base64Variants.getDefaultVariant(); [EOL] SerializationConfig newConfig = config.with(defaultBase64Variant); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(defaultBase64Variant, newConfig.getBase64Variant()); [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_GETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getIsGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_GettersDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_GETTERS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getIsGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_IsGettersDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getIsGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_FieldsDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getIsGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_GETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getIsGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testFindWithUnregisteredClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(String.class, "UnregisteredClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithURI() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "java.net.URI"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URIDeserializer); [EOL] }
public void testFindWithURL() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URL.class, "java.net.URL"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URLDeserializer); [EOL] }
public void testFindWithFile() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(File.class, "java.io.File"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FileDeserializer); [EOL] }
public void testFindWithUUID() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(UUID.class, "java.util.UUID"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof UUIDDeserializer); [EOL] }
public void testFindWithCurrency() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Currency.class, "java.util.Currency"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CurrencyDeserializer); [EOL] }
public void testFindWithPattern() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Pattern.class, "java.util.regex.Pattern"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof PatternDeserializer); [EOL] }
public void testFindWithLocale() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Locale.class, "java.util.Locale"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LocaleDeserializer); [EOL] }
public void testFindWithInetAddress() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(InetAddress.class, "java.net.InetAddress"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof InetAddressDeserializer); [EOL] }
public void testFindWithCharset() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Charset.class, "java.nio.charset.Charset"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharsetDeserializer); [EOL] }
public void testFindWithClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Class.class, "java.lang.Class"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ClassDeserializer); [EOL] }
public void testFindWithStackTraceElement() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(StackTraceElement.class, "java.lang.StackTraceElement"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StackTraceElementDeserializer); [EOL] }
public void testFindWithAtomicBoolean() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(AtomicBoolean.class, "java.util.concurrent.atomic.AtomicBoolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof AtomicBooleanDeserializer); [EOL] }
public void testFindWithIllegalArgumentException() { [EOL] try { [EOL] YourClass.find(Object.class, "java.lang.Object"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testInetAddressDeserializerConstructor() { [EOL] InetAddressDeserializer deserializer = new InetAddressDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(InetAddress.class, deserializer.handledType()); [EOL] }
public void testDeserializeValidInetAddress() throws IOException { [EOL] String validInetAddressString = "127.0.0.1"; [EOL] InetAddressDeserializer deserializer = new InetAddressDeserializer(); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] InetAddress result = deserializer._deserialize(validInetAddressString, ctxt); [EOL] assertEquals(InetAddress.getByName(validInetAddressString), result); [EOL] }
public void testDeserializeInvalidInetAddress() { [EOL] String invalidInetAddressString = "invalid.inet.address"; [EOL] InetAddressDeserializer deserializer = new InetAddressDeserializer(); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] try { [EOL] deserializer._deserialize(invalidInetAddressString, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testAtomicBooleanDeserializerConstructor() { [EOL] AtomicBooleanDeserializer deserializer = new AtomicBooleanDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(AtomicBoolean.class, deserializer.handledType()); [EOL] }
public void testDeserializeWithTrueValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("true"); [EOL] AtomicBooleanDeserializer deserializer = new AtomicBooleanDeserializer(); [EOL] AtomicBoolean result = deserializer.deserialize(jp, ctxt); [EOL] assertTrue(result.get()); [EOL] }
public void testDeserializeWithFalseValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("false"); [EOL] AtomicBooleanDeserializer deserializer = new AtomicBooleanDeserializer(); [EOL] AtomicBoolean result = deserializer.deserialize(jp, ctxt); [EOL] assertFalse(result.get()); [EOL] }
public void testDeserializeWithNonBooleanValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("not a boolean"); [EOL] AtomicBooleanDeserializer deserializer = new AtomicBooleanDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDateTimeSerializerBaseWithTimestamp() { [EOL] DateTimeSerializerBase serializer = new DateTimeSerializerBase(Date.class, true, null); [EOL] assertTrue(serializer._useTimestamp); [EOL] assertNull(serializer._customFormat); [EOL] }
public void testDateTimeSerializerBaseWithoutTimestamp() { [EOL] DateTimeSerializerBase serializer = new DateTimeSerializerBase(Date.class, false, null); [EOL] assertFalse(serializer._useTimestamp); [EOL] assertNull(serializer._customFormat); [EOL] }
public void testDateTimeSerializerBaseWithCustomFormat() { [EOL] DateFormat customFormat = new SimpleDateFormat(); [EOL] DateTimeSerializerBase serializer = new DateTimeSerializerBase(Date.class, false, customFormat); [EOL] assertFalse(serializer._useTimestamp); [EOL] assertNotNull(serializer._customFormat); [EOL] }
protected FieldProperty(FieldProperty src, String newName) { [EOL] super(src, newName); [EOL] _annotated = src._annotated; [EOL] _field = src._field; [EOL] }
public void testWithNameNull() { [EOL] FieldProperty original = new FieldProperty(/* provide constructor arguments */); [EOL] FieldProperty result = original.withName(null); [EOL] assertNull(result.getName()); [EOL] }
public void testWithNameNewName() { [EOL] FieldProperty original = new FieldProperty(/* provide constructor arguments */); [EOL] String newName = "newName"; [EOL] FieldProperty result = original.withName(newName); [EOL] assertEquals(newName, result.getName()); [EOL] }
public void testBeanDeserializerBaseWithUnwrapper() { [EOL] NameTransformer unwrapper = NameTransformer.simpleTransformer("prefix_", null); [EOL] BeanDeserializerBase original = createBeanDeserializerBase(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, unwrapper); [EOL] assertNotNull(copy._beanType); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(original._ignorableProps, copy._ignorableProps); [EOL] assertTrue(copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._objectIdReader, copy._objectIdReader); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertNotNull(copy._unwrappedPropertyHandler); [EOL] assertNotNull(copy._beanProperties); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertFalse(copy._vanillaProcessing); [EOL] }
public void testBeanDeserializerBaseWithoutUnwrapper() { [EOL] NameTransformer unwrapper = null; [EOL] BeanDeserializerBase original = createBeanDeserializerBase(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, unwrapper); [EOL] assertNotNull(copy._beanType); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(original._ignorableProps, copy._ignorableProps); [EOL] assertEquals(original._ignoreAllUnknown, copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._objectIdReader, copy._objectIdReader); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._beanProperties, copy._beanProperties); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertFalse(copy._vanillaProcessing); [EOL] }
public void testResolveWithCanCreateFromObjectWith() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(_valueInstantiator.getFromObjectArguments(any())).thenReturn(creatorProps); [EOL] new TestClass().resolve(ctxt); [EOL] assertNotNull(_propertyBasedCreator); [EOL] }
public void testResolveWithCanCreateUsingDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] JavaType delegateType = createJavaType(); [EOL] when(_valueInstantiator.getDelegateType(any())).thenReturn(delegateType); [EOL] AnnotatedWithParams delegateCreator = createAnnotatedWithParams(); [EOL] when(_valueInstantiator.getDelegateCreator()).thenReturn(delegateCreator); [EOL] new TestClass().resolve(ctxt); [EOL] assertNotNull(_delegateDeserializer); [EOL] }
public void testResolveWithExternalTypeProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithExternalType(); [EOL] _beanProperties = new BeanPropertyMap(false, Collections.singletonList(prop)); [EOL] new TestClass().resolve(ctxt); [EOL] assertNotNull(_externalTypeIdHandler); [EOL] assertTrue(_nonStandardCreation); [EOL] }
public void testResolveWithUnwrappedProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithUnwrapped(); [EOL] _beanProperties = new BeanPropertyMap(false, Collections.singletonList(prop)); [EOL] new TestClass().resolve(ctxt); [EOL] assertNotNull(_unwrappedPropertyHandler); [EOL] assertTrue(_nonStandardCreation); [EOL] }
public void testResolveWithVanillaProcessing() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] _beanProperties = new BeanPropertyMap(false, Collections.emptyList()); [EOL] new TestClass().resolve(ctxt); [EOL] assertTrue(_vanillaProcessing); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithDelegateDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt))).thenReturn(new Object()); [EOL] Object result = deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithPropertyBasedCreator() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator propertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] when(_propertyBasedCreator).thenReturn(propertyBasedCreator); [EOL] Object result = deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithAbstractBeanType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(_beanType.isAbstract()).thenReturn(true); [EOL] when(_beanType.toString()).thenReturn("abstractBeanType"); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Can not instantiate abstract type abstractBeanType")); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithNoSuitableConstructor() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_beanType.toString()).thenReturn("noConstructorBeanType"); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("No suitable constructor found for type noConstructorBeanType")); [EOL] }
public void testDeserializeFromNumberWithObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] when(deserializeFromObjectId(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerAndInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(true); [EOL] when(_valueInstantiator.createFromInt(ctxt, jp.getIntValue())).thenReturn(new Object()); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerAndLong() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithLong() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(true); [EOL] when(_valueInstantiator.createFromLong(ctxt, jp.getLongValue())).thenReturn(new Object()); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerNoMatch() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberInstantiationException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(ctxt.instantiationException(any(Class.class), anyString())).thenThrow(new JsonMappingException("no suitable creator method found to deserialize from JSON integer number")); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromNumber(jp, ctxt); [EOL] }); [EOL] assertEquals("no suitable creator method found to deserialize from JSON integer number", exception.getMessage()); [EOL] }
public void testDeserializeFromStringWithObjectId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] Object expected = new Object(); [EOL] when(deserializeFromObjectId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromStringWithDelegate() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(expected); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromStringWithInjectables() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(bean); [EOL] _injectables = new InjectableValues.Std().addValue("key", "value"); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromStringCreateFromString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(true); [EOL] String text = "some text"; [EOL] when(jp.getText()).thenReturn(text); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createFromString(ctxt, text)).thenReturn(expected); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromDoubleWithDelegateDeserializerAndCannotCreateFromDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(_valueInstantiator.canCreateFromDouble()).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] Object result = deserializeFromDouble(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator, times(1)).createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL] }
public void testDeserializeFromDoubleWithDelegateDeserializerAndCanCreateFromDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(0.0); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(_valueInstantiator.canCreateFromDouble()).thenReturn(true); [EOL] Object result = deserializeFromDouble(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator, times(1)).createFromDouble(ctxt, jp.getDoubleValue()); [EOL] }
public void testDeserializeFromDoubleWithoutDelegateDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(0.0); [EOL] when(_valueInstantiator.canCreateFromDouble()).thenReturn(true); [EOL] Object result = deserializeFromDouble(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator, times(1)).createFromDouble(ctxt, jp.getDoubleValue()); [EOL] }
public void testDeserializeFromDoubleThrowsException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); // Use a type that is not FLOAT or DOUBLE [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromDouble(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromBooleanWithDelegateDeserializerAndCannotCreateFromBoolean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] Object expectedBean = new Object(); [EOL] Object delegateBean = new Object(); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(_valueInstantiator).thenReturn(valueInstantiator); [EOL] when(valueInstantiator.canCreateFromBoolean()).thenReturn(false); [EOL] when(delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateBean); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, delegateBean)).thenReturn(expectedBean); [EOL] Object result = deserializeFromBoolean(jp, ctxt); [EOL] verify(valueInstantiator).createUsingDelegate(ctxt, delegateBean); [EOL] assertEquals(expectedBean, result); [EOL] }
public void testDeserializeFromBooleanWithDelegateDeserializerAndCanCreateFromBoolean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(_valueInstantiator).thenReturn(valueInstantiator); [EOL] when(valueInstantiator.canCreateFromBoolean()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] boolean value = true; [EOL] Object expectedBean = new Object(); [EOL] when(valueInstantiator.createFromBoolean(ctxt, value)).thenReturn(expectedBean); [EOL] Object result = deserializeFromBoolean(jp, ctxt); [EOL] verify(valueInstantiator).createFromBoolean(ctxt, value); [EOL] assertEquals(expectedBean, result); [EOL] }
public void testDeserializeFromBooleanWithoutDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_valueInstantiator).thenReturn(valueInstantiator); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] boolean value = true; [EOL] Object expectedBean = new Object(); [EOL] when(valueInstantiator.createFromBoolean(ctxt, value)).thenReturn(expectedBean); [EOL] Object result = deserializeFromBoolean(jp, ctxt); [EOL] verify(valueInstantiator).createFromBoolean(ctxt, value); [EOL] assertEquals(expectedBean, result); [EOL] }
public void testHandleUnknownPropertyWithIgnoreAllUnknown() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object beanOrClass = new Object(); [EOL] String propName = "unknownProp"; [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._ignoreAllUnknown = true; [EOL] deserializer.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] verify(jp).skipChildren(); [EOL] }
public void testHandleUnknownPropertyWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object beanOrClass = new Object(); [EOL] String propName = "ignorableProp"; [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._ignorableProps = new HashSet<>(); [EOL] deserializer._ignorableProps.add(propName); [EOL] deserializer.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] verify(jp).skipChildren(); [EOL] }
public void testHandleUnknownPropertyWithoutIgnore() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object beanOrClass = new Object(); [EOL] String propName = "notIgnoredProp"; [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._ignoreAllUnknown = false; [EOL] deserializer._ignorableProps = null; [EOL] deserializer.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] verify(jp, never()).skipChildren(); [EOL] }
public void testWrapAndThrowWithInvocationTargetException() throws IOException { [EOL] Throwable cause = new IOException("Inner exception"); [EOL] Throwable t = new InvocationTargetException(cause); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = null; // Assuming DeserializationContext can be null or a mock if required [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertSame("The cause should be the inner exception", cause, e); [EOL] } [EOL] }
public void testWrapAndThrowWithError() { [EOL] Throwable t = new Error("Serious error"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = null; [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected Error to be thrown"); [EOL] } catch (Error e) { [EOL] assertEquals("The error should be the one thrown", "Serious error", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithIOExceptionAndWrapDisabled() throws IOException { [EOL] Throwable t = new IOException("IO exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(false); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("The exception should be the one thrown", "IO exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithRuntimeExceptionAndWrapDisabled() { [EOL] Throwable t = new RuntimeException("Runtime exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(false); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("The exception should be the one thrown", "Runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithJsonMappingExceptionAndWrapEnabled() throws IOException { [EOL] Throwable t = new JsonMappingException("JsonMapping exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(true); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("The exception should be wrapped with path", "JsonMapping exception", e.getOriginalMessage()); [EOL] assertNotNull("Path reference should be added to the exception", e.getPathReference()); [EOL] } [EOL] }
public void testWrapAndThrowWithOtherExceptionAndWrapEnabled() throws IOException { [EOL] Throwable t = new Exception("Other exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(true); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("The exception should be wrapped with path", "Other exception", e.getCause().getMessage()); [EOL] assertNotNull("Path reference should be added to the exception", e.getPathReference()); [EOL] } [EOL] }
public void testBuilderBasedDeserializerWithObjectIdReader() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = new HashMap<>(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] boolean ignoreAllUnknown = false; [EOL] boolean hasViews = false; [EOL] when(builder.getBuildMethod()).thenReturn(null); [EOL] when(beanDesc.getType()).thenReturn(mock(JavaType.class)); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(builder.getObjectIdReader()).thenReturn(objectIdReader); [EOL] try { [EOL] new BuilderBasedDeserializer(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBuilderBasedDeserializerWithoutObjectIdReader() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = new HashMap<>(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] boolean ignoreAllUnknown = false; [EOL] boolean hasViews = false; [EOL] when(builder.getBuildMethod()).thenReturn(null); [EOL] when(builder.getObjectIdReader()).thenReturn(null); [EOL] BuilderBasedDeserializer deserializer = new BuilderBasedDeserializer(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] assertNotNull(deserializer); [EOL] }
public void testFinishBuildWithValidBuilder() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] Method buildMethod = Object.class.getMethod("toString"); [EOL] MemberMethod memberMethod = new MemberMethod(buildMethod, null); [EOL] BeanPropertyBuilder beanPropertyBuilder = new BeanPropertyBuilder(null, null, null, memberMethod); [EOL] Object result = beanPropertyBuilder.finishBuild(ctxt, builder); [EOL] assertNotNull(result); [EOL] assertEquals(builder.toString(), result); [EOL] }
public void testFinishBuildWithInvocationTargetException() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] Method buildMethod = Object.class.getMethod("toString"); [EOL] MemberMethod memberMethod = new MemberMethod(buildMethod, null) { [EOL] @Override [EOL] public Object invoke(Object bean) throws IllegalAccessException, InvocationTargetException { [EOL] throw new InvocationTargetException(new Exception()); [EOL] } [EOL] }; [EOL] BeanPropertyBuilder beanPropertyBuilder = new BeanPropertyBuilder(null, null, null, memberMethod); [EOL] try { [EOL] beanPropertyBuilder.finishBuild(ctxt, builder); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof IOException); [EOL] } [EOL] }
public void testFinishBuildWithIllegalAccessException() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] Method buildMethod = Object.class.getMethod("toString"); [EOL] MemberMethod memberMethod = new MemberMethod(buildMethod, null) { [EOL] @Override [EOL] public Object invoke(Object bean) throws IllegalAccessException, InvocationTargetException { [EOL] throw new IllegalAccessException(); [EOL] } [EOL] }; [EOL] BeanPropertyBuilder beanPropertyBuilder = new BeanPropertyBuilder(null, null, null, memberMethod); [EOL] try { [EOL] beanPropertyBuilder.finishBuild(ctxt, builder); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof IOException); [EOL] } [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("mapping exception")); [EOL] setField(deserializer, "_vanillaProcessing", true); [EOL] Object expected = new Object(); [EOL] when(deserializer.vanillaDeserialize(jp, ctxt, JsonToken.FIELD_NAME)).thenReturn(expected); [EOL] when(deserializer.finishBuild(ctxt, expected)).thenReturn(expected); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithNonStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("mapping exception")); [EOL] Object expected = new Object(); [EOL] when(deserializer.deserializeFromString(jp, ctxt)).thenReturn(expected); [EOL] when(deserializer.finishBuild(ctxt, expected)).thenReturn(expected); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithEmbeddedObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object expected = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(expected); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("mapping exception")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithUnwrapped(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expected = new Object(); [EOL] when(deserializeWithUnwrapped(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithExternalTypeId(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expected = new Object(); [EOL] when(deserializeWithExternalTypeId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationUsingNonDefault() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationUsingNonDefault(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expected = new Object(); [EOL] when(deserializeFromObjectUsingNonDefault(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromObjectWithStandardCreation() throws IOException, JsonProcessingException { [EOL] setupStandardCreation(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propertyName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(_beanProperties.find("propertyName")).thenReturn(prop); [EOL] when(prop.deserializeSetAndReturn(jp, ctxt, bean)).thenReturn(bean); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeFromObjectWithViewProcessing() throws IOException, JsonProcessingException { [EOL] setupViewProcessing(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> view = Object.class; [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(ctxt.getActiveView()).thenReturn(view); [EOL] Object expected = new Object(); [EOL] when(deserializeWithView(jp, ctxt, bean, view)).thenReturn(expected); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromObjectWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] setupIgnorableProps(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorableProperty"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_ignorableProps.contains("ignorableProperty")).thenReturn(true); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] setupAnySetter(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("anySetterProperty"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] doNothing().when(_anySetter).deserializeAndSet(jp, ctxt, bean, "anySetterProperty"); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeFromObjectWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] setupUnknownProperty(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProperty"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_beanProperties.find("unknownProperty")).thenReturn(null); [EOL] when(_ignorableProps.contains("unknownProperty")).thenReturn(false); [EOL] when(_anySetter).thenReturn(null); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] ObjectNode result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] ObjectNode result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testGetNullValueReturnsSingletonInstance() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode nullNode = mapper.getSerializerProvider().getNullValue(); [EOL] assertNotNull(nullNode); [EOL] assertTrue(nullNode instanceof NullNode); [EOL] assertSame(NullNode.getInstance(), nullNode); [EOL] }
protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL] ArrayNode node = nodeFactory.arrayNode(); [EOL] while (true) { [EOL] JsonToken t = jp.nextToken(); [EOL] if (t == null) { [EOL] throw ctxt.mappingException("Unexpected end-of-input when binding data into ArrayNode"); [EOL] } [EOL] switch(t) { [EOL] case START_OBJECT: [EOL] node.add(deserializeObject(jp, ctxt, nodeFactory)); [EOL] break; [EOL] case START_ARRAY: [EOL] node.add(deserializeArray(jp, ctxt, nodeFactory)); [EOL] break; [EOL] case END_ARRAY: [EOL] return node; [EOL] case VALUE_STRING: [EOL] node.add(nodeFactory.textNode(jp.getText())); [EOL] break; [EOL] default: [EOL] node.add(deserializeAny(jp, ctxt, nodeFactory)); [EOL] break; [EOL] } [EOL] } [EOL] }
public void testDeserializeAnyWithStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] }
public void testDeserializeAnyWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(data); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBinary()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectPojo() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] Object pojo = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(pojo); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isPojo()); [EOL] }
public void testDeserializeAnyWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isTextual()); [EOL] }
public void testDeserializeAnyWithValueNumberIntBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345678901234567890")); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBigInteger()); [EOL] }
public void testDeserializeAnyWithValueNumberIntInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isInt()); [EOL] }
public void testDeserializeAnyWithValueNumberIntLong() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isLong()); [EOL] }
public void testDeserializeAnyWithValueNumberFloatBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBigDecimal()); [EOL] }
public void testDeserializeAnyWithValueNumberFloatDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isDouble()); [EOL] }
public void testDeserializeAnyWithValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertTrue(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertFalse(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(null); // Invalid token [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeAny(jp, ctxt, nodeFactory); [EOL] }); [EOL] }
public void testWithConfigSameInstance() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(config); [EOL] DeserializerFactory result = factory.withConfig(config); [EOL] assertSame("Should return the same instance when config is the same", factory, result); [EOL] }
public void testWithConfigDifferentInstance() { [EOL] DeserializerFactoryConfig config1 = new DeserializerFactoryConfig(); [EOL] DeserializerFactoryConfig config2 = new DeserializerFactoryConfig(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(config1); [EOL] DeserializerFactory result = factory.withConfig(config2); [EOL] assertNotSame("Should return a new instance when config is different", factory, result); [EOL] assertTrue("Result should be an instance of BeanDeserializerFactory", result instanceof BeanDeserializerFactory); [EOL] }
public void testWithConfigSubtypeOverrideError() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(config) { [EOL] }; [EOL] try { [EOL] factory.withConfig(new DeserializerFactoryConfig()); [EOL] fail("Expected IllegalStateException for subtype not overriding withConfig"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL] for (Deserializers d : _factoryConfig.deserializers()) { [EOL] JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc); [EOL] if (deser != null) { [EOL] return (JsonDeserializer<Object>) deser; [EOL] } [EOL] } [EOL] return null; [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=1; [EOL] Class<?>[] INIT_CAUSE_PARAMS=new Class<?>[] { Throwable.class };
@Override [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc); [EOL] if (custom != null) { [EOL] return custom; [EOL] } [EOL] if (type.isThrowable()) { [EOL] return buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] if (type.isAbstract()) { [EOL] JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc); [EOL] if (concreteType != null) { [EOL] beanDesc = config.introspect(concreteType); [EOL] return buildBeanDeserializer(ctxt, concreteType, beanDesc); [EOL] } [EOL] } [EOL] @SuppressWarnings("unchecked") [EOL] JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] if (!isPotentialBeanType(type.getRawClass())) { [EOL] return null; [EOL] } [EOL] return buildBeanDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
@Override [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException { [EOL] JavaType builderType = ctxt.constructType(builderClass); [EOL] BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType); [EOL] return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] Class<?> cls = type.getRawClass(); [EOL] if (AtomicReference.class.isAssignableFrom(cls)) { [EOL] TypeFactory tf = ctxt.getTypeFactory(); [EOL] JavaType[] params = tf.findTypeParameters(type, AtomicReference.class); [EOL] JavaType referencedType; [EOL] if (params == null || params.length < 1) { [EOL] referencedType = TypeFactory.unknownType(); [EOL] } else { [EOL] referencedType = params[0]; [EOL] } [EOL] return new JdkDeserializers.AtomicReferenceDeserializer(referencedType); [EOL] } [EOL] return findOptionalStdDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
It seems there was a misunderstanding. The provided input text does not contain any comments, NL descriptions, or @Test annotations to remove. The text appears to be a series of method signatures and field declarations from a Java class, possibly related to JSON deserialization using the Jackson library. [EOL] If you need assistance with something else, such as generating unit test cases for the methods provided, please let me know, and I'll be happy to help.
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc); [EOL] BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL] builder.setValueInstantiator(valueInstantiator); [EOL] addBeanProps(ctxt, beanDesc, builder); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] builder = mod.updateBuilder(config, beanDesc, builder); [EOL] } [EOL] } [EOL] JsonDeserializer<?> deserializer; [EOL] if (type.isAbstract() && !valueInstantiator.canInstantiate()) { [EOL] deserializer = builder.buildAbstract(); [EOL] } else { [EOL] deserializer = builder.build(); [EOL] } [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL] } [EOL] } [EOL] return (JsonDeserializer<Object>) deserializer; [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException { [EOL] ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc); [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc); [EOL] builder.setValueInstantiator(valueInstantiator); [EOL] addBeanProps(ctxt, builderDesc, builder); [EOL] addObjectIdReader(ctxt, builderDesc, builder); [EOL] addReferenceProperties(ctxt, builderDesc, builder); [EOL] addInjectables(ctxt, builderDesc, builder); [EOL] JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig(); [EOL] final String buildMethodName = (builderConfig == null) ? "build" : builderConfig.buildMethodName; [EOL] AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null); [EOL] if (buildMethod != null) { [EOL] if (config.canOverrideAccessModifiers()) { [EOL] ClassUtil.checkAndFixAccess(buildMethod.getMember()); [EOL] } [EOL] } [EOL] builder.setPOJOBuilder(buildMethod, builderConfig); [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] builder = mod.updateBuilder(config, builderDesc, builder); [EOL] } [EOL] } [EOL] JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName); [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] deserializer = mod.modifyDeserializer(config, builderDesc, deserializer); [EOL] } [EOL] } [EOL] return (JsonDeserializer<Object>) deserializer; [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=1; [EOL] Class<?>[] INIT_CAUSE_PARAMS=new Class<?>[] { Throwable.class };
public void testAddObjectIdReaderWithNullObjectIdInfo() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(null); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] verify(builder, never()).setObjectIdReader(any(ObjectIdReader.class)); [EOL] }
public void testAddObjectIdReaderWithPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] when(builder.findProperty("id")).thenReturn(idProp); [EOL] when(idProp.getType()).thenReturn(mock(JavaType.class)); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] verify(builder).setObjectIdReader(any(ObjectIdReader.class)); [EOL] }
public void testAddObjectIdReaderWithNonPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(ctxt.constructType(ObjectIdGenerators.IntSequenceGenerator.class)).thenReturn(type); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.findTypeParameters(type, ObjectIdGenerator.class)).thenReturn(new JavaType[]{mock(JavaType.class)}); [EOL] ObjectIdGenerator<?> gen = mock(ObjectIdGenerator.class); [EOL] when(ctxt.objectIdGeneratorInstance(any(Annotated.class), eq(objectIdInfo))).thenReturn(gen); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] verify(builder).setObjectIdReader(any(ObjectIdReader.class)); [EOL] }
public void testAddObjectIdReaderWithPropertyGeneratorAndMissingProperty() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("missingProperty"); [EOL] when(beanDesc.getBeanClass()).thenReturn((Class)Object.class); [EOL] when(builder.findProperty("missingProperty")).thenReturn(null); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] }); [EOL] String expectedMessage = "Invalid Object Id definition for java.lang.Object: can not find property with name 'missingProperty'"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { [EOL] return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL] final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] boolean ignoreAny = false; [EOL] { [EOL] Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL] if (B != null) { [EOL] ignoreAny = B.booleanValue(); [EOL] builder.setIgnoreUnknownProperties(ignoreAny); [EOL] } [EOL] } [EOL] Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL] for (String propName : ignored) { [EOL] builder.addIgnorable(propName); [EOL] } [EOL] AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL] if (anySetter != null) { [EOL] builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL] } [EOL] if (anySetter == null) { [EOL] Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL] if (ignored2 != null) { [EOL] for (String propName : ignored2) { [EOL] builder.addIgnorable(propName); [EOL] } [EOL] } [EOL] } [EOL] final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL] List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL] } [EOL] } [EOL] for (BeanPropertyDefinition propDef : propDefs) { [EOL] SettableBeanProperty prop = null; [EOL] if (propDef.hasConstructorParameter()) { [EOL] final String name = propDef.getName(); [EOL] if (creatorProps != null) { [EOL] for (SettableBeanProperty cp : creatorProps) { [EOL] if (name.equals(cp.getName())) { [EOL] prop = cp; [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (prop == null) { [EOL] throw ctxt.mappingException("Could not find creator property with name '" + name + "' (in class " + beanDesc.getBeanClass().getName() + ")"); [EOL] } [EOL] builder.addCreatorProperty(prop); [EOL] continue; [EOL] } [EOL] if (propDef.hasSetter()) { [EOL] Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL] prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL] } else if (propDef.hasField()) { [EOL] Type propertyType = propDef.getField().getGenericType(); [EOL] prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL] } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL] AnnotatedMethod getter = propDef.getGetter(); [EOL] Class<?> rawPropertyType = getter.getRawType(); [EOL] if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL] prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL] } [EOL] } [EOL] if (prop != null) { [EOL] Class<?>[] views = propDef.findViews(); [EOL] if (views == null) { [EOL] if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL] views = NO_VIEWS; [EOL] } [EOL] } [EOL] prop.setViews(views); [EOL] builder.addProperty(prop); [EOL] } [EOL] } [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=1; [EOL] Class<?>[] INIT_CAUSE_PARAMS=new Class<?>[] { Throwable.class };
protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL] ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL] HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL] for (BeanPropertyDefinition property : propDefsIn) { [EOL] String name = property.getName(); [EOL] if (ignored.contains(name)) { [EOL] continue; [EOL] } [EOL] if (!property.hasConstructorParameter()) { [EOL] Class<?> rawPropertyType = null; [EOL] if (property.hasSetter()) { [EOL] rawPropertyType = property.getSetter().getRawParameterType(0); [EOL] } else if (property.hasField()) { [EOL] rawPropertyType = property.getField().getRawType(); [EOL] } [EOL] if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL] builder.addIgnorable(name); [EOL] continue; [EOL] } [EOL] } [EOL] result.add(property); [EOL] } [EOL] return result; [EOL] }
public void testAddReferencePropertiesWithNonNullRefsAndMethodMember() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithBackReferenceProperties(true); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(beanDesc, ctxt); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] assertNotNull(builder.getProperties()); [EOL] assertFalse(builder.getProperties().isEmpty()); [EOL] assertTrue(builder.hasBackReferenceProperties()); [EOL] } [EOL] public void testAddReferencePropertiesWithNonNullRefsAndNonMethodMember() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithBackReferenceProperties(false); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(beanDesc, ctxt); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] assertNotNull(builder.getProperties()); [EOL] assertFalse(builder.getProperties().isEmpty()); [EOL] assertTrue(builder.hasBackReferenceProperties()); [EOL] } [EOL] public void testAddReferencePropertiesWithNullRefs() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithNullBackReferenceProperties(); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(beanDesc, ctxt); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] assertTrue(builder.getProperties().isEmpty()); [EOL] assertFalse(builder.hasBackReferenceProperties()); [EOL] }

public void testAddInjectablesWithNonNullRawAndFixAccessTrue() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] Map<Object, AnnotatedMember> raw = new HashMap<>(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] raw.put("key", member); [EOL] when(beanDesc.findInjectables()).thenReturn(raw); [EOL] when(ctxt.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(member.getName()).thenReturn("memberName"); [EOL] when(member.getGenericType()).thenReturn(mock(Type.class)); [EOL] when(beanDesc.resolveType(any(Type.class))).thenReturn(mock(JavaType.class)); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] verify(member).fixAccess(); [EOL] verify(builder).addInjectable(anyString(), any(JavaType.class), any(Annotations.class), any(AnnotatedMember.class), any()); [EOL] }
public void testAddInjectablesWithNonNullRawAndFixAccessFalse() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] Map<Object, AnnotatedMember> raw = new HashMap<>(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] raw.put("key", member); [EOL] when(beanDesc.findInjectables()).thenReturn(raw); [EOL] when(ctxt.canOverrideAccessModifiers()).thenReturn(false); [EOL] when(member.getName()).thenReturn("memberName"); [EOL] when(member.getGenericType()).thenReturn(mock(Type.class)); [EOL] when(beanDesc.resolveType(any(Type.class))).thenReturn(mock(JavaType.class)); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] verify(member, never()).fixAccess(); [EOL] verify(builder).addInjectable(anyString(), any(JavaType.class), any(Annotations.class), any(AnnotatedMember.class), any()); [EOL] }
public void testAddInjectablesWithNullRaw() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(beanDesc.findInjectables()).thenReturn(null); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] verify(builder, never()).addInjectable(anyString(), any(JavaType.class), any(Annotations.class), any(AnnotatedMember.class), any()); [EOL] }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL] AnnotatedMember mutator = propDef.getMutator(); [EOL] if (ctxt.canOverrideAccessModifiers()) { [EOL] mutator.fixAccess(); [EOL] } [EOL] JavaType t0 = beanDesc.resolveType(jdkType); [EOL] BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL] JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL] if (type != t0) { [EOL] property = property.withType(type); [EOL] } [EOL] JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL] type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL] TypeDeserializer typeDeser = type.getTypeHandler(); [EOL] SettableBeanProperty prop; [EOL] if (mutator instanceof AnnotatedMethod) { [EOL] prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL] } else { [EOL] prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL] } [EOL] if (propDeser != null) { [EOL] prop = prop.withValueDeserializer(propDeser); [EOL] } [EOL] AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL] if (ref != null && ref.isManagedReference()) { [EOL] prop.setManagedReferenceName(ref.getName()); [EOL] } [EOL] return prop; [EOL] }
public void testIsPotentialBeanTypeWithNonBeanClass() { [EOL] try { [EOL] isPotentialBeanType(SomeNonBeanClass.class); [EOL] fail("Should not pass for non-bean class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsPotentialBeanTypeWithProxyClass() { [EOL] try { [EOL] isPotentialBeanType(Proxy.newProxyInstance( [EOL] this.getClass().getClassLoader(), [EOL] new Class<?>[]{SomeInterface.class}, [EOL] (proxy, method, args) -> null [EOL] ).getClass()); [EOL] fail("Should not pass for proxy class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsPotentialBeanTypeWithLocalClass() { [EOL] class LocalClass {} [EOL] try { [EOL] isPotentialBeanType(LocalClass.class); [EOL] fail("Should not pass for local class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsPotentialBeanTypeWithValidBeanClass() { [EOL] assertTrue("Should return true for valid bean class", isPotentialBeanType(SomeBeanClass.class)); [EOL] }
protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes) { [EOL] Boolean status = ignoredTypes.get(type); [EOL] if (status == null) { [EOL] BeanDescription desc = config.introspectClassAnnotations(type); [EOL] status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo()); [EOL] if (status == null) { [EOL] status = Boolean.FALSE; [EOL] } [EOL] } [EOL] return status; [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
public void testStdConstructorWithNonNullValues() { [EOL] String name = "testName"; [EOL] JavaType type = new SimpleType(String.class); [EOL] PropertyName wrapperName = new PropertyName("wrapper"); [EOL] Annotations contextAnnotations = new AnnotationCollector.EmptyCollector(); [EOL] AnnotatedMember member = new AnnotatedField(null, String.class.getDeclaredFields()[0], null, null); [EOL] boolean isRequired = true; [EOL] Std std = new Std(name, type, wrapperName, contextAnnotations, member, isRequired); [EOL] assertNotNull(std); [EOL] assertEquals(name, std.getName()); [EOL] assertEquals(type, std.getType()); [EOL] assertEquals(wrapperName, std.getWrapperName()); [EOL] assertTrue(std.isRequired()); [EOL] assertEquals(member, std.getMember()); [EOL] assertEquals(contextAnnotations, std.getContextAnnotations()); [EOL] }
public void testStdConstructorWithNullValues() { [EOL] String name = null; [EOL] JavaType type = null; [EOL] PropertyName wrapperName = null; [EOL] Annotations contextAnnotations = null; [EOL] AnnotatedMember member = null; [EOL] boolean isRequired = false; [EOL] Std std = new Std(name, type, wrapperName, contextAnnotations, member, isRequired); [EOL] assertNotNull(std); [EOL] assertNull(std.getName()); [EOL] assertNull(std.getType()); [EOL] assertNull(std.getWrapperName()); [EOL] assertFalse(std.isRequired()); [EOL] assertNull(std.getMember()); [EOL] assertNull(std.getContextAnnotations()); [EOL] }
public void testToStringSerializerConstructor() { [EOL] ToStringSerializer serializer = new ToStringSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testGetStdKeySerializerWithNullType() { [EOL] JsonSerializer<Object> serializer = getStdKeySerializer(null); [EOL] assertSame(DEFAULT_KEY_SERIALIZER, serializer); [EOL] }
public void testGetStdKeySerializerWithStringType() { [EOL] JavaType stringType = SimpleType.constructUnsafe(String.class); [EOL] JsonSerializer<Object> serializer = getStdKeySerializer(stringType); [EOL] assertSame(DEFAULT_STRING_SERIALIZER, serializer); [EOL] }
public void testGetStdKeySerializerWithObjectType() { [EOL] JavaType objectType = SimpleType.constructUnsafe(Object.class); [EOL] JsonSerializer<Object> serializer = getStdKeySerializer(objectType); [EOL] assertSame(DEFAULT_KEY_SERIALIZER, serializer); [EOL] }
public void testGetStdKeySerializerWithDateType() { [EOL] JavaType dateType = SimpleType.constructUnsafe(Date.class); [EOL] JsonSerializer<Object> serializer = getStdKeySerializer(dateType); [EOL] assertSame(DateKeySerializer.instance, serializer); [EOL] }
public void testGetStdKeySerializerWithCalendarType() { [EOL] JavaType calendarType = SimpleType.constructUnsafe(Calendar.class); [EOL] JsonSerializer<Object> serializer = getStdKeySerializer(calendarType); [EOL] assertSame(CalendarKeySerializer.instance, serializer); [EOL] }
public void testGetStdKeySerializerWithOtherType() { [EOL] JavaType otherType = SimpleType.constructUnsafe(SomeOtherClass.class); [EOL] JsonSerializer<Object> serializer = getStdKeySerializer(otherType); [EOL] assertSame(DEFAULT_KEY_SERIALIZER, serializer); [EOL] }
public void testStringKeySerializerConstructor() { [EOL] StringKeySerializer serializer = new StringKeySerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(String.class, serializer.handledType()); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] String testValue = "testFieldName"; [EOL] new JsonSerializer().serialize(testValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeFieldName(testValue); [EOL] }
public void testPropertyValueConstructorWithNullNext() { [EOL] Object testValue = new Object(); [EOL] PropertyValue result = new PropertyValue(null, testValue); [EOL] assertNull(result.next); [EOL] assertEquals(testValue, result.value); [EOL] } [EOL] public void testPropertyValueConstructorWithNonNullNext() { [EOL] PropertyValue next = new PropertyValue(null, null); [EOL] Object testValue = new Object(); [EOL] PropertyValue result = new PropertyValue(next, testValue); [EOL] assertEquals(next, result.next); [EOL] assertEquals(testValue, result.value); [EOL] }
public void testRegularConstructorWithNullNext() { [EOL] Object value = new Object(); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] PropertyValue result = new Regular(null, value, prop); [EOL] assertNull(result.next); [EOL] assertEquals(value, result.value); [EOL] assertEquals(prop, ((Regular) result)._property); [EOL] }
public void testRegularConstructorWithNonNullNext() { [EOL] PropertyValue next = mock(PropertyValue.class); [EOL] Object value = new Object(); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] PropertyValue result = new Regular(next, value, prop); [EOL] assertEquals(next, result.next); [EOL] assertEquals(value, result.value); [EOL] assertEquals(prop, ((Regular) result)._property); [EOL] }
public void testAssignWithValidBeanAndValue() throws IOException, JsonProcessingException { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(property, value); [EOL] writer.assign(bean); [EOL] verify(property).set(bean, value); [EOL] }
public void testAssignWithNullBean() throws IOException, JsonProcessingException { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Object value = new Object(); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(property, value); [EOL] assertThrows(NullPointerException.class, () -> writer.assign(null)); [EOL] verify(property, never()).set(any(), eq(value)); [EOL] }
public void testAssignWithIOException() throws IOException, JsonProcessingException { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(property, value); [EOL] doThrow(IOException.class).when(property).set(bean, value); [EOL] assertThrows(IOException.class, () -> writer.assign(bean)); [EOL] }
public void testAssignWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(property, value); [EOL] doThrow(JsonProcessingException.class).when(property).set(bean, value); [EOL] assertThrows(JsonProcessingException.class, () -> writer.assign(bean)); [EOL] }
public void testWithAdditionalSerializers_Null() { [EOL] SerializerFactory factory = new StdSerializerFactory(); [EOL] SerializerFactory result = factory.withAdditionalSerializers(null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testWithAdditionalSerializers_NonNull() { [EOL] SerializerFactory factory = new StdSerializerFactory(); [EOL] Serializers additionalSerializers = new SimpleSerializers(); [EOL] SerializerFactory result = factory.withAdditionalSerializers(additionalSerializers); [EOL] assertNotNull(result); [EOL] assertNotSame(factory, result); [EOL] }
public void testCreateKeySerializerWithKeySerializers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = new JsonSerializer<Object>() {}; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = null; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (factoryConfig.hasKeySerializers()) { [EOL] for (Serializers serializers : factoryConfig.keySerializers()) { [EOL] ser = serializers.findSerializer(config, keyType, beanDesc); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] ser = defaultImpl; [EOL] if (ser == null) { [EOL] ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL] } [EOL] } [EOL] if (factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertNotNull(result); [EOL] }
public void testCreateKeySerializerWithDefaultImpl() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = new JsonSerializer<Object>() {}; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = null; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (ser == null) { [EOL] ser = defaultImpl; [EOL] if (ser == null) { [EOL] ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL] } [EOL] } [EOL] if (factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertSame(defaultImpl, result); [EOL] }
public void testCreateKeySerializerWithStdKeySerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = null; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = null; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (ser == null) { [EOL] ser = defaultImpl; [EOL] if (ser == null) { [EOL] ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL] } [EOL] } [EOL] if (factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertNotNull(result); [EOL] assertNotSame(defaultImpl, result); [EOL] }
public void testCreateKeySerializerWithSerializerModifiers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = new JsonSerializer<Object>() {}; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = defaultImpl; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertNotNull(result); [EOL] assertNotSame(defaultImpl, result); [EOL] }
public void testFindSerializerByPrimaryTypeWithInetAddress() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(InetAddress.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof InetAddressSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithTimeZone() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(TimeZone.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithCharset() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.nio.charset.Charset.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof ToStringSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithNumber() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Number.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof NumberSerializers.NumberSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithEnum() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Enum.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithCalendar() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof CalendarSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithDate() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.util.Date.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof DateSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithOptionalStdSerializer() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(MyCustomType.class); // Replace with a type that triggers the optional std serializer [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeReturnsNull() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); // Use a type that does not match any condition [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNull(result); [EOL] }
public void testFindSerializerByIteratorType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = new JavaType(Iterator.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof IteratorSerializer); [EOL] }
public void testFindSerializerByIterableType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = new JavaType(Iterable.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof IterableSerializer); [EOL] }
public void testFindSerializerByCharSequenceType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = new JavaType(CharSequence.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNotNull(serializer); [EOL] assertSame(ToStringSerializer.instance, serializer); [EOL] }
public void testFindSerializerByUnknownType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = new JavaType(Object.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNull(serializer); [EOL] }
public void testBuildContainerSerializerWithStaticTypingAndNonContainerType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, true, false, Object.class); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] } [EOL] public void testBuildContainerSerializerWithStaticTypingAndContainerType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, true, false, String.class); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildContainerSerializerWithMapLikeType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, false, true, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] } [EOL] public void testBuildContainerSerializerWithTrueMapType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, false, true, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] when(type.isTrueMapType()).thenReturn(true); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildContainerSerializerWithCollectionLikeType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, true, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] } [EOL] public void testBuildContainerSerializerWithTrueCollectionType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, true, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] when(type.isTrueCollectionType()).thenReturn(true); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildContainerSerializerWithArrayType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, false, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] when(type.isArrayType()).thenReturn(true); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildCollectionSerializerWithCustomSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndEnumSet() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(EnumSet.class, new JavaType(Enum.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertTrue(result instanceof StdContainerSerializers.EnumSetSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndIndexedList() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(ArrayList.class, new JavaType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndStringCollection() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndOtherCollection() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(Object.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertFalse(result instanceof StringCollectionSerializer); [EOL] assertFalse(result instanceof IndexedStringListSerializer); [EOL] }
public void testBuildCollectionSerializerWithSerializerModifiers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] _factoryConfig.addSerializerModifier(new BeanSerializerModifier()); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL] JsonSerializer<?> ser = null; [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL] JavaType keyType = type.getKeyType(); [EOL] EnumValues enums = null; [EOL] if (keyType.isEnumType()) { [EOL] Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL] enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL] } [EOL] ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL] } else { [EOL] ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL] } [EOL] } [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL] } [EOL] } [EOL] return ser; [EOL] }
public void testBuildEnumSerializerWithFormatShapeObject() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.OBJECT); [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertNull(result); [EOL] verify((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL] }
public void testBuildEnumSerializerWithoutFormatShapeObject() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // Any shape other than OBJECT [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testBuildEnumSerializerWithSerializerModifiers() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // Any shape other than OBJECT [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] BeanSerializerModifier modifier = mock(BeanSerializerModifier.class); [EOL] when(_factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonSerializer<?> modifiedSerializer = mock(JsonSerializer.class); [EOL] when(modifier.modifyEnumSerializer(any(), any(), any(), any())).thenReturn(modifiedSerializer); [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertSame(modifiedSerializer, result); [EOL] }
public void testFindKeySerializerWithNonNullSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findKeySerializer(a)).thenReturn(expectedSerializer); [EOL] when(prov.serializerInstance(a, expectedSerializer)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = _findKeySerializer(prov, a); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindKeySerializerWithNullSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findKeySerializer(a)).thenReturn(null); [EOL] JsonSerializer<Object> result = _findKeySerializer(prov, a); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithNonNullSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findContentSerializer(a)).thenReturn(expectedSerializer); [EOL] when(prov.serializerInstance(a, expectedSerializer)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = _findContentSerializer(prov, a); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindContentSerializerWithNullSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findContentSerializer(a)).thenReturn(null); [EOL] JsonSerializer<Object> result = _findContentSerializer(prov, a); [EOL] assertNull(result); [EOL] }
public void testAddOrOverrideWithNonNullAnnotation() { [EOL] AnnotationMap map = new AnnotationMap(); [EOL] Annotation annotation = new SomeAnnotationImpl(); [EOL] map.addOrOverride(annotation); [EOL] assertTrue(map.has(annotation.getClass())); [EOL] }
public void testAddOrOverrideWithNullAnnotation() { [EOL] AnnotationMap map = new AnnotationMap(); [EOL] try { [EOL] map.addOrOverride(null); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testUnknownSerializerConstructor() { [EOL] UnknownSerializer unknownSerializer = new UnknownSerializer(); [EOL] assertNotNull(unknownSerializer); [EOL] assertEquals(Object.class, unknownSerializer.handledType()); [EOL] }
public void testGetRawType() { [EOL] JavaType javaType = new SimpleType(String.class); [EOL] Class<?> rawType = javaType.getRawType(); [EOL] assertEquals(String.class, rawType); [EOL] }
public void testGetAnnotationsWhenClassAnnotationsAreNull() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj._classAnnotations = null; // Assuming direct access for the sake of the example [EOL] Annotations result = obj.getAnnotations(); [EOL] assertNotNull(result); [EOL] }
public void testGetAnnotationsWhenClassAnnotationsAreNotNull() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] Annotations expectedAnnotations = new Annotations(); // Assuming a constructor for Annotations [EOL] obj._classAnnotations = expectedAnnotations; [EOL] Annotations result = obj.getAnnotations(); [EOL] assertSame(expectedAnnotations, result); [EOL] }
public void testResolveCreatorsWithNoDeclaredConstructorsAndNoDeclaredMethods() { [EOL] _class = SomeClassWithNoDeclaredConstructorsOrMethods.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] } [EOL] public void testResolveCreatorsWithDefaultConstructorOnly() { [EOL] _class = SomeClassWithDefaultConstructorOnly.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] } [EOL] public void testResolveCreatorsWithMultipleConstructors() { [EOL] _class = SomeClassWithMultipleConstructors.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor); [EOL] assertFalse(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] } [EOL] public void testResolveCreatorsWithIgnoredConstructors() { [EOL] _class = SomeClassWithMultipleConstructors.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospectorMethod(); [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertNull(_defaultConstructor); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] } [EOL] public void testResolveCreatorsWithStaticMethods() { [EOL] _class = SomeClassWithStaticMethods.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertFalse(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] } [EOL] public void testResolveCreatorsWithIgnoredStaticMethods() { [EOL] _class = SomeClassWithStaticMethods.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospectorMethod(); [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveMemberMethods_NoMixinsNoAnnotationIntrospector() { [EOL] initTestEnvironment(null, null, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertTrue(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_WithMixinsNoAnnotationIntrospector() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] initTestEnvironment(mockMixInResolver, null, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertFalse(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_NoMixinsWithAnnotationIntrospector() { [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(null, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] }
public void testResolveMemberMethods_WithMixinsAndAnnotationIntrospector() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(mockMixInResolver, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertFalse(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_WithExceptionInMixIn() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(mockMixInResolver, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] }
public void testAddConstructorMixIns_NoConstructors() { [EOL] _addConstructorMixIns(Mockito.mock(Class.class)); [EOL] } [EOL] public void testAddConstructorMixIns_WithDefaultConstructor() { [EOL] _defaultConstructor = Mockito.mock(AnnotatedConstructor.class); [EOL] Class<?> mixin = Mockito.mock(Class.class); [EOL] Constructor<?> defaultCtor = Mockito.mock(Constructor.class); [EOL] Mockito.when(mixin.getDeclaredConstructors()).thenReturn(new Constructor<?>[]{defaultCtor}); [EOL] Mockito.when(defaultCtor.getParameterTypes()).thenReturn(new Class<?>[0]); [EOL] _addConstructorMixIns(mixin); [EOL] } [EOL] public void testAddConstructorMixIns_WithNonDefaultConstructors() { [EOL] _constructors = new ArrayList<>(); [EOL] _constructors.add(Mockito.mock(AnnotatedConstructor.class)); [EOL] Class<?> mixin = Mockito.mock(Class.class); [EOL] Constructor<?> nonDefaultCtor = Mockito.mock(Constructor.class); [EOL] Mockito.when(mixin.getDeclaredConstructors()).thenReturn(new Constructor<?>[]{nonDefaultCtor}); [EOL] Mockito.when(nonDefaultCtor.getParameterTypes()).thenReturn(new Class<?>[]{String.class}); [EOL] _addConstructorMixIns(mixin); [EOL] } [EOL] public void testAddConstructorMixIns_WithMatchingNonDefaultConstructor() { [EOL] _constructors = new ArrayList<>(); [EOL] AnnotatedConstructor annotatedConstructor = Mockito.mock(AnnotatedConstructor.class); [EOL] _constructors.add(annotatedConstructor); [EOL] Class<?> mixin = Mockito.mock(Class.class); [EOL] Constructor<?> matchingCtor = Mockito.mock(Constructor.class); [EOL] Mockito.when(mixin.getDeclaredConstructors()).thenReturn(new Constructor<?>[]{matchingCtor}); [EOL] Mockito.when(matchingCtor.getParameterTypes()).thenReturn(new Class<?>[]{String.class}); [EOL] Mockito.when(annotatedConstructor.getAnnotated()).thenReturn(matchingCtor); [EOL] _addConstructorMixIns(mixin); [EOL] }
public void testAddFactoryMixIns_withNoStaticMethods() { [EOL] Class<?> mixin = NoStaticMethodsClass.class; [EOL] _addFactoryMixIns(mixin); [EOL] } [EOL] public void testAddFactoryMixIns_withStaticMethodsWithoutParameters() { [EOL] Class<?> mixin = StaticMethodsWithoutParametersClass.class; [EOL] _addFactoryMixIns(mixin); [EOL] } [EOL] public void testAddFactoryMixIns_withStaticMethodsWithParametersAndNoMatch() { [EOL] Class<?> mixin = StaticMethodsWithParametersAndNoMatchClass.class; [EOL] _creatorMethods = new ArrayList<>(); [EOL] _addFactoryMixIns(mixin); [EOL] } [EOL] public void testAddFactoryMixIns_withStaticMethodsWithParametersAndMatch() { [EOL] Class<?> mixin = StaticMethodsWithParametersAndMatchClass.class; [EOL] _creatorMethods = new ArrayList<>(); [EOL] AnnotatedMethod matchedMethod = // create an instance that matches a method in mixin [EOL] _creatorMethods.add(matchedMethod); [EOL] _addFactoryMixIns(mixin); [EOL] }
public void testAddMemberMethods_WithNonNullMixInCls() { [EOL] Class<?> cls = SomeClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = SomeMixinClass.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithNullMixInCls() { [EOL] Class<?> cls = SomeClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_WithNullCls() { [EOL] _addMemberMethods(null, new AnnotatedMethodMap(), SomeMixinClass.class, new AnnotatedMethodMap()); [EOL] }
public void testAddMemberMethods_WithIncludableMemberMethod() { [EOL] Class<?> cls = SomeClassWithIncludableMethods.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_WithNonIncludableMemberMethod() { [EOL] Class<?> cls = SomeClassWithNonIncludableMethods.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] }
public void testAddMemberMethods_WithOldMethodPresent() { [EOL] Class<?> cls = SomeClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Method oldMethod = cls.getDeclaredMethods()[0]; [EOL] methods.add(_constructMethod(oldMethod)); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_WithOldMethodNotPresent() { [EOL] Class<?> cls = SomeClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] }
public void testAddMemberMethods_WithOldMethodFromInterface() { [EOL] Class<?> cls = SomeClassImplementingInterface.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> interfaceCls = SomeInterface.class; [EOL] for (Method m : interfaceCls.getDeclaredMethods()) { [EOL] if (_isIncludableMemberMethod(m)) { [EOL] methods.add(_constructMethod(m)); [EOL] } [EOL] } [EOL] _addMemberMethods(cls, methods, null, null); [EOL] }
public void testAddMethodMixIns_WithValidMixIn() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = MixInClass.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] }
public void testAddMethodMixIns_WithInheritedMixIn() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = InheritedMixInClass.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] }
public void testAddMethodMixIns_WithNoMethodsInMixIn() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = EmptyMixInClass.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] }
public void testAddMethodMixIns_WithExcludedMethods() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = MixInWithExcludedMethods.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] }
public void testConstructConstructorWithNullIntrospectorAndDefaultCtor() { [EOL] Constructor<?> ctor = Object.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, true); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithNullIntrospectorAndNonDefaultCtor() { [EOL] Constructor<?> ctor = String.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithMismatchedAnnotations() { [EOL] Constructor<?> ctor = CustomEnum.class.getDeclaredConstructors()[0]; [EOL] try { [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Internal error: constructor for CustomEnum has mismatch: 2 parameters; 0 sets of annotations", e.getMessage()); [EOL] } [EOL] }
public void testConstructConstructorWithEnumAndCorrectAnnotations() { [EOL] Constructor<?> ctor = CustomEnumWithAnnotations.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithMemberClassAndCorrectAnnotations() { [EOL] Constructor<?> ctor = MemberClassWithAnnotations.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testIsIncludableMemberMethod_StaticMethod() { [EOL] Method staticMethod = MyClass.class.getDeclaredMethod("staticMethod", null); [EOL] boolean result = _isIncludableMemberMethod(staticMethod); [EOL] assertFalse(result); [EOL] }
public void testIsIncludableMemberMethod_SyntheticMethod() { [EOL] Method syntheticMethod = MySyntheticClass.class.getDeclaredMethod("syntheticMethod", null); [EOL] boolean result = _isIncludableMemberMethod(syntheticMethod); [EOL] assertFalse(result); [EOL] }
public void testIsIncludableMemberMethod_BridgeMethod() { [EOL] Method bridgeMethod = MyBridgeClass.class.getDeclaredMethod("bridgeMethod", null); [EOL] boolean result = _isIncludableMemberMethod(bridgeMethod); [EOL] assertFalse(result); [EOL] }
public void testIsIncludableMemberMethod_WithZeroParameters() { [EOL] Method zeroParamMethod = MyClass.class.getDeclaredMethod("zeroParamMethod", null); [EOL] boolean result = _isIncludableMemberMethod(zeroParamMethod); [EOL] assertTrue(result); [EOL] }
public void testIsIncludableMemberMethod_WithOneParameter() { [EOL] Method oneParamMethod = MyClass.class.getDeclaredMethod("oneParamMethod", String.class); [EOL] boolean result = _isIncludableMemberMethod(oneParamMethod); [EOL] assertTrue(result); [EOL] }
public void testIsIncludableMemberMethod_WithTwoParameters() { [EOL] Method twoParamMethod = MyClass.class.getDeclaredMethod("twoParamMethod", String.class, Integer.TYPE); [EOL] boolean result = _isIncludableMemberMethod(twoParamMethod); [EOL] assertTrue(result); [EOL] }
public void testIsIncludableMemberMethod_WithThreeParameters() { [EOL] Method threeParamMethod = MyClass.class.getDeclaredMethod("threeParamMethod", String.class, Integer.TYPE, Boolean.TYPE); [EOL] boolean result = _isIncludableMemberMethod(threeParamMethod); [EOL] assertFalse(result); [EOL] }
public void testAddAnnotationsIfNotPresentWithNullAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addAnnotationsIfNotPresent(target, null); [EOL] verify(target, never()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddAnnotationsIfNotPresentWithEmptyAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[0]); [EOL] verify(target, never()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddAnnotationsIfNotPresentWithNonBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation ann = mock(Annotation.class); [EOL] when(_isAnnotationBundle(ann)).thenReturn(false); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[]{ann}); [EOL] verify(target).addIfNotPresent(ann); [EOL] }
public void testAddAnnotationsIfNotPresentWithBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation bundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(bundleAnn)).thenReturn(true); [EOL] when(bundleAnn.annotationType()).thenReturn((Class) DummyAnnotation.class); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[]{bundleAnn}); [EOL] verify(target, never()).addIfNotPresent(bundleAnn); [EOL] verify(target, atLeastOnce()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddAnnotationsIfNotPresentWithMixedAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation bundleAnn = mock(Annotation.class); [EOL] Annotation nonBundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(bundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nonBundleAnn)).thenReturn(false); [EOL] when(bundleAnn.annotationType()).thenReturn((Class) DummyAnnotation.class); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[]{bundleAnn, nonBundleAnn}); [EOL] verify(target).addIfNotPresent(nonBundleAnn); [EOL] verify(target, atLeastOnce()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithNullAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addOrOverrideAnnotations(target, null); [EOL] verify(target, never()).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithEmptyAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addOrOverrideAnnotations(target, new Annotation[0]); [EOL] verify(target, never()).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithNonBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation ann = mock(Annotation.class); [EOL] when(_isAnnotationBundle(ann)).thenReturn(false); [EOL] _addOrOverrideAnnotations(target, new Annotation[]{ann}); [EOL] verify(target).addOrOverride(ann); [EOL] }
public void testAddOrOverrideAnnotationsWithBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation bundleAnn = mock(Annotation.class); [EOL] Annotation nonBundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(bundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nonBundleAnn)).thenReturn(false); [EOL] when(bundleAnn.annotationType().getDeclaredAnnotations()).thenReturn(new Annotation[]{nonBundleAnn}); [EOL] _addOrOverrideAnnotations(target, new Annotation[]{bundleAnn, nonBundleAnn}); [EOL] verify(target).addOrOverride(nonBundleAnn); [EOL] verify(target, times(2)).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithNestedBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation outerBundleAnn = mock(Annotation.class); [EOL] Annotation innerBundleAnn = mock(Annotation.class); [EOL] Annotation nonBundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(outerBundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(innerBundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nonBundleAnn)).thenReturn(false); [EOL] when(outerBundleAnn.annotationType().getDeclaredAnnotations()).thenReturn(new Annotation[]{innerBundleAnn}); [EOL] when(innerBundleAnn.annotationType().getDeclaredAnnotations()).thenReturn(new Annotation[]{nonBundleAnn}); [EOL] _addOrOverrideAnnotations(target, new Annotation[]{outerBundleAnn}); [EOL] verify(target).addOrOverride(nonBundleAnn); [EOL] verify(target, times(1)).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddMixOversWithoutParamAnnotations() { [EOL] Constructor<?> mixin = getMockMixinConstructor(); [EOL] AnnotatedConstructor target = getMockAnnotatedConstructor(); [EOL] boolean addParamAnnotations = false; [EOL] _addMixOvers(mixin, target, addParamAnnotations); [EOL] }
public void testAddMixOversWithParamAnnotations() { [EOL] Constructor<?> mixin = getMockMixinConstructorWithParamAnnotations(); [EOL] AnnotatedConstructor target = getMockAnnotatedConstructor(); [EOL] boolean addParamAnnotations = true; [EOL] _addMixOvers(mixin, target, addParamAnnotations); [EOL] }
public void testAddMixOversWithoutParamAnnotations() { [EOL] Method mixinMethod = ...; // Obtain a method instance from a mixin class [EOL] AnnotatedMethod targetMethod = ...; // Create an instance of AnnotatedMethod for the target [EOL] boolean addParamAnnotations = false; [EOL] _addMixOvers(mixinMethod, targetMethod, addParamAnnotations); [EOL] }
public void testAddMixOversWithParamAnnotations() { [EOL] Method mixinMethod = ...; // Obtain a method instance from a mixin class with parameter annotations [EOL] AnnotatedMethod targetMethod = ...; // Create an instance of AnnotatedMethod for the target [EOL] boolean addParamAnnotations = true; [EOL] _addMixOvers(mixinMethod, targetMethod, addParamAnnotations); [EOL] }
protected void _addAnnotationsIfNotPresent(AnnotatedMethod target, Annotation[] anns) { [EOL] for (Annotation ann : anns) { [EOL] if (!target.hasAnnotation(ann.annotationType())) { [EOL] target.addIfNotPresent(ann); [EOL] } [EOL] } [EOL] } [EOL] public void testAddMixUndersWithNoAnnotations() { [EOL] Method src = Object.class.getDeclaredMethods()[0]; [EOL] AnnotatedMethod target = new AnnotatedMethod(null, src, null, null); [EOL] _addMixUnders(src, target); [EOL] assertEquals(0, target.getAnnotationCount()); [EOL] }
public void testAddMixUndersWithAnnotationsNotPresent() { [EOL] Method src = SomeClassWithAnnotations.class.getDeclaredMethods()[0]; [EOL] AnnotatedMethod target = new AnnotatedMethod(null, src, null, null); [EOL] _addMixUnders(src, target); [EOL] assertEquals(1, target.getAnnotationCount()); [EOL] }
public void testAddMixUndersWithSomeAnnotationsPresent() { [EOL] Method src = SomeClassWithMultipleAnnotations.class.getDeclaredMethods()[0]; [EOL] AnnotatedMethod target = new AnnotatedMethod(null, src, null, null); [EOL] target.addIfNotPresent(src.getDeclaredAnnotations()[0]); [EOL] _addMixUnders(src, target); [EOL] assertEquals(2, target.getAnnotationCount()); [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeDisabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(false); [EOL] BeanDeserializerBase deserializerBase = new BeanDeserializerBase() { [EOL] }; [EOL] JsonDeserializer<Object> result = deserializerBase._findDefaultImplDeserializer(ctxt); [EOL] assertSame(NullifyingDeserializer.instance, result); [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeEnabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(true); [EOL] BeanDeserializerBase deserializerBase = new BeanDeserializerBase() { [EOL] }; [EOL] JsonDeserializer<Object> result = deserializerBase._findDefaultImplDeserializer(ctxt); [EOL] assertNull(result); [EOL] }
public void testFindDefaultImplDeserializerWithNoClassAsDefaultImpl() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType defaultImpl = mock(JavaType.class); [EOL] when(defaultImpl.getRawClass()).thenReturn(NoClass.class); [EOL] BeanDeserializerBase deserializerBase = new BeanDeserializerBase() { [EOL] { [EOL] this._defaultImpl = defaultImpl; [EOL] } [EOL] }; [EOL] JsonDeserializer<Object> result = deserializerBase._findDefaultImplDeserializer(ctxt); [EOL] assertSame(NullifyingDeserializer.instance, result); [EOL] }
public void testFindDefaultImplDeserializerWithNonNullDefaultImpl() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType defaultImpl = mock(JavaType.class); [EOL] when(defaultImpl.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(defaultImpl, null)).thenReturn(expectedDeserializer); [EOL] BeanDeserializerBase deserializerBase = new BeanDeserializerBase() { [EOL] { [EOL] this._defaultImpl = defaultImpl; [EOL] } [EOL] }; [EOL] JsonDeserializer<Object> result = deserializerBase._findDefaultImplDeserializer(ctxt); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testDeserializerForCreatorWithStringParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = createAnnotatedMethodWithStringParameter(); // Mock or create AnnotatedMethod with String parameter [EOL] JsonDeserializer<?> deserializer = deserializerForCreator(config, enumClass, factory); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FactoryBasedDeserializer); [EOL] }
public void testDeserializerForCreatorWithIntegerParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = createAnnotatedMethodWithIntegerParameter(); // Mock or create AnnotatedMethod with Integer parameter [EOL] JsonDeserializer<?> deserializer = deserializerForCreator(config, enumClass, factory); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FactoryBasedDeserializer); [EOL] }
public void testDeserializerForCreatorWithLongParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = createAnnotatedMethodWithLongParameter(); // Mock or create AnnotatedMethod with Long parameter [EOL] JsonDeserializer<?> deserializer = deserializerForCreator(config, enumClass, factory); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FactoryBasedDeserializer); [EOL] }
public void testDeserializerForCreatorWithInvalidParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = createAnnotatedMethodWithInvalidParameter(); // Mock or create AnnotatedMethod with an invalid parameter [EOL] try { [EOL] deserializerForCreator(config, enumClass, factory); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithValidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("VALID_ENUM_NAME"); [EOL] when(_resolver.findEnum("VALID_ENUM_NAME")).thenReturn(TestEnum.VALID_ENUM_NAME); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(TestEnum.VALID_ENUM_NAME, result); [EOL] }
public void testDeserializeWithEmptyStringAndAcceptEmptyAsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithUnknownStringAndReadUnknownAsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM_NAME"); [EOL] when(_resolver.findEnum("UNKNOWN_ENUM_NAME")).thenReturn(null); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithUnknownStringAndException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM_NAME"); [EOL] when(_resolver.findEnum("UNKNOWN_ENUM_NAME")).thenReturn(null); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithValidNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] when(_resolver.getEnum(0)).thenReturn(TestEnum.VALID_ENUM_NAME); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)).thenReturn(false); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(TestEnum.VALID_ENUM_NAME, result); [EOL] }
public void testDeserializeWithInvalidNumberAndException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(999); [EOL] when(_resolver.getEnum(999)).thenReturn(null); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] when(_resolver.lastValidIndex()).thenReturn(5); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithNumberAndFailOnNumbersForEnums() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)).thenReturn(true); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); // Any token that is not VALUE_STRING, FIELD_NAME, or VALUE_NUMBER_INT [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithNullInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("test"); [EOL] CustomDeserializer deserializer = new CustomDeserializer(null, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals("test", result); [EOL] }
public void testDeserializeWithIntegerInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsInt()).thenReturn(123); [EOL] CustomDeserializer deserializer = new CustomDeserializer(Integer.class, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Integer.valueOf(123), result); [EOL] }
public void testDeserializeWithLongInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsLong()).thenReturn(123L); [EOL] CustomDeserializer deserializer = new CustomDeserializer(Long.class, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Long.valueOf(123L), result); [EOL] }
public void testDeserializeWithUnsupportedType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("Unsupported type")); [EOL] CustomDeserializer deserializer = new CustomDeserializer(String.class, null, null); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithInvocationTargetException() throws IOException, IllegalAccessException, InvocationTargetException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Method factory = CustomEnum.class.getDeclaredMethod("fromValue", Object.class); [EOL] when(jp.getText()).thenReturn("test"); [EOL] when(factory.invoke(any(), any())).thenThrow(new InvocationTargetException(new Exception("Invocation error"))); [EOL] CustomDeserializer deserializer = new CustomDeserializer(null, factory, CustomEnum.class); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testForDeserializationWithBuilder() { [EOL] DeserializationConfig cfg = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType type = new JavaType(...); // Provide actual initialization [EOL] MixInResolver r = new MixInResolver(...); // Provide actual initialization [EOL] BasicBeanDescription result = forDeserializationWithBuilder(cfg, type, r); [EOL] assertNotNull(result); [EOL] }
public void testCollectPropertiesWithBuilder_AnnotationsEnabled_Serialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass annotatedClass = mock(AnnotatedClass.class); [EOL] JsonPOJOBuilder.Value builderConfig = mock(JsonPOJOBuilder.Value.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(config.getAnnotationIntrospector()).thenReturn(annotationIntrospector); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(AnnotatedClass.construct(any(Class.class), any(AnnotationIntrospector.class), any(MixInResolver.class))).thenReturn(annotatedClass); [EOL] when(annotationIntrospector.findPOJOBuilderConfig(annotatedClass)).thenReturn(builderConfig); [EOL] when(builderConfig.withPrefix()).thenReturn("with"); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(); [EOL] POJOPropertiesCollector result = collector.collectPropertiesWithBuilder(config, type, mixInResolver, true); [EOL] assertNotNull(result); [EOL] }
public void testCollectPropertiesWithBuilder_AnnotationsDisabled() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(AnnotatedClass.construct(any(Class.class), any(AnnotationIntrospector.class), any(MixInResolver.class))).thenReturn(null); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(); [EOL] POJOPropertiesCollector result = collector.collectPropertiesWithBuilder(config, type, mixInResolver, false); [EOL] assertNull(result); [EOL] }
public void testCollectPropertiesWithBuilder_AnnotationsEnabled_NoBuilderConfig() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass annotatedClass = mock(AnnotatedClass.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(config.getAnnotationIntrospector()).thenReturn(annotationIntrospector); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(AnnotatedClass.construct(any(Class.class), any(AnnotationIntrospector.class), any(MixInResolver.class))).thenReturn(annotatedClass); [EOL] when(annotationIntrospector.findPOJOBuilderConfig(annotatedClass)).thenReturn(null); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(); [EOL] POJOPropertiesCollector result = collector.collectPropertiesWithBuilder(config, type, mixInResolver, true); [EOL] assertNotNull(result); [EOL] }
public void testTypeFromIdWithGenerics() { [EOL] String id = "java.util.List<String>"; [EOL] JavaType result = typeFromId(id); [EOL] assertNotNull(result); [EOL] assertEquals("java.util.List", result.getRawClass().getName()); [EOL] }
public void testTypeFromIdWithClassNotFound() { [EOL] String id = "com.nonexistent.FakeClass"; [EOL] try { [EOL] typeFromId(id); [EOL] fail("Expected IllegalArgumentException for class not found"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("no such class found")); [EOL] } [EOL] }
public void testTypeFromIdWithOtherException() { [EOL] String id = "java.util.List<<String>>"; // This should cause a generic parsing exception [EOL] try { [EOL] typeFromId(id); [EOL] fail("Expected IllegalArgumentException for invalid type id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Invalid type id")); [EOL] } [EOL] }
public void testIdFromWithEnumClass() { [EOL] Object value = EnumSet.noneOf(Thread.State.class); [EOL] String result = _idFrom(value, Thread.State.class); [EOL] assertEquals("java.util.EnumSet<java.lang.Thread$State>", result); [EOL] }
public void testIdFromWithEnumMap() { [EOL] Object value = new EnumMap<Thread.State, String>(Thread.State.class); [EOL] String result = _idFrom(value, Thread.State.class); [EOL] assertEquals("java.util.EnumMap<java.lang.Thread$State,java.lang.Object>", result); [EOL] }
public void testIdFromWithNonEnumClass() { [EOL] Object value = new Object(); [EOL] String result = _idFrom(value, Object.class); [EOL] assertEquals("java.lang.Object", result); [EOL] }
public void testIdFromWithInnerClass() { [EOL] Object value = new InnerClass(); [EOL] String result = _idFrom(value, InnerClass.class); [EOL] assertEquals("com.example.OuterClass$InnerClass", result); [EOL] }
public void testIdFromWithJavaUtilClass() { [EOL] Object value = Arrays.asList("a", "b"); [EOL] String result = _idFrom(value, value.getClass()); [EOL] assertEquals("java.util.ArrayList", result); [EOL] }
public void testWithAdditionalDeserializers_NullInput() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] try { [EOL] config.withAdditionalDeserializers(null); [EOL] fail("Expected IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null Deserializers", e.getMessage()); [EOL] } [EOL] }
public void testWithAdditionalDeserializers_ValidInput() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] Deserializers mockDeserializers = mock(Deserializers.class); [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalDeserializers(mockDeserializers); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertTrue(newConfig.hasDeserializers()); [EOL] }
public void testWithDeserializerModifier_NullModifier() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] try { [EOL] config.withDeserializerModifier(null); [EOL] fail("Expected IllegalArgumentException for null modifier"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null modifier", e.getMessage()); [EOL] } [EOL] }
public void testWithDeserializerModifier_NonNullModifier() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withDeserializerModifier(modifier); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertTrue(newConfig.hasDeserializerModifiers()); [EOL] }
public void testHasDeserializerModifiers_WithModifiers() { [EOL] BeanDeserializerModifier[] modifiers = new BeanDeserializerModifier[] { new BeanDeserializerModifier() {} }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, modifiers, null, null); [EOL] assertTrue(config.hasDeserializerModifiers()); [EOL] }
public void testHasDeserializerModifiers_WithoutModifiers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializerModifiers()); [EOL] }
public void testHasValueInstantiators_WithValueInstantiators() { [EOL] ValueInstantiators[] valueInstantiators = new ValueInstantiators[] { mock(ValueInstantiators.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig( [EOL] new Deserializers[0], new KeyDeserializers[0], new BeanDeserializerModifier[0], [EOL] new AbstractTypeResolver[0], valueInstantiators [EOL] ); [EOL] assertTrue(config.hasValueInstantiators()); [EOL] } [EOL] public void testHasValueInstantiators_WithoutValueInstantiators() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasValueInstantiators()); [EOL] }
public void testHasDeserializers_WithDeserializers() { [EOL] Deserializers[] deserializers = new Deserializers[] { mock(Deserializers.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig( [EOL] deserializers, new KeyDeserializers[0], new BeanDeserializerModifier[0], [EOL] new AbstractTypeResolver[0], new ValueInstantiators[0] [EOL] ); [EOL] assertTrue(config.hasDeserializers()); [EOL] } [EOL] public void testHasDeserializers_WithoutDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializers()); [EOL] }
public void testHasKeyDeserializers_WithKeyDeserializers() { [EOL] KeyDeserializers[] keyDeserializers = new KeyDeserializers[] { mock(KeyDeserializers.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig( [EOL] new Deserializers[0], keyDeserializers, new BeanDeserializerModifier[0], [EOL] new AbstractTypeResolver[0], new ValueInstantiators[0] [EOL] ); [EOL] assertTrue(config.hasKeyDeserializers()); [EOL] } [EOL] public void testHasKeyDeserializers_WithoutKeyDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasKeyDeserializers()); [EOL] }
public void testHasDeserializerModifiers_WithModifiers() { [EOL] BeanDeserializerModifier[] modifiers = new BeanDeserializerModifier[] { mock(BeanDeserializerModifier.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig( [EOL] new Deserializers[0], new KeyDeserializers[0], modifiers, [EOL] new AbstractTypeResolver[0], new ValueInstantiators[0] [EOL] ); [EOL] assertTrue(config.hasDeserializerModifiers()); [EOL] } [EOL] public void testHasDeserializerModifiers_WithoutModifiers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializerModifiers()); [EOL] }
public void testHasAbstractTypeResolvers_WithAbstractTypeResolvers() { [EOL] AbstractTypeResolver[] abstractTypeResolvers = new AbstractTypeResolver[] { mock(AbstractTypeResolver.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig( [EOL] new Deserializers[0], new KeyDeserializers[0], new BeanDeserializerModifier[0], [EOL] abstractTypeResolvers, new ValueInstantiators[0] [EOL] ); [EOL] assertTrue(config.hasAbstractTypeResolvers()); [EOL] } [EOL] public void testHasAbstractTypeResolvers_WithoutAbstractTypeResolvers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasAbstractTypeResolvers()); [EOL] }
public void testDeserializersWithNoAdditionalDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] Iterable<Deserializers> deserializers = config.deserializers(); [EOL] assertNotNull(deserializers); [EOL] assertFalse(deserializers.iterator().hasNext()); [EOL] }
public void testDeserializersWithAdditionalDeserializers() { [EOL] Deserializers additional = mock(Deserializers.class); [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig().withAdditionalDeserializers(additional); [EOL] Iterable<Deserializers> deserializers = config.deserializers(); [EOL] assertNotNull(deserializers); [EOL] assertTrue(deserializers.iterator().hasNext()); [EOL] assertSame(additional, deserializers.iterator().next()); [EOL] }
public void testDeserializerModifiersWithNonNullModifiers() { [EOL] BeanDeserializerModifier[] modifiers = new BeanDeserializerModifier[] { new BeanDeserializerModifier() {} }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, modifiers, null, null); [EOL] Iterable<BeanDeserializerModifier> result = config.deserializerModifiers(); [EOL] assertNotNull(result); [EOL] assertTrue(result.iterator().hasNext()); [EOL] assertEquals(modifiers[0], result.iterator().next()); [EOL] }
public void testDeserializerModifiersWithNullModifiers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] Iterable<BeanDeserializerModifier> result = config.deserializerModifiers(); [EOL] assertNotNull(result); [EOL] assertFalse(result.iterator().hasNext()); [EOL] }
public void testDeserializerModifiersWithEmptyModifiers() { [EOL] BeanDeserializerModifier[] modifiers = new BeanDeserializerModifier[0]; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, modifiers, null, null); [EOL] Iterable<BeanDeserializerModifier> result = config.deserializerModifiers(); [EOL] assertNotNull(result); [EOL] assertFalse(result.iterator().hasNext()); [EOL] }
public void testInvalidFormatExceptionWithNullValues() { [EOL] String msg = "Invalid format"; [EOL] JsonLocation loc = null; [EOL] Object value = null; [EOL] Class<?> targetType = null; [EOL] InvalidFormatException exception = new InvalidFormatException(msg, loc, value, targetType); [EOL] assertNull(exception.getLocation()); [EOL] assertNull(exception.getValue()); [EOL] assertNull(exception.getTargetType()); [EOL] }
public void testInvalidFormatExceptionWithNonNullValues() { [EOL] String msg = "Invalid format"; [EOL] JsonLocation loc = new JsonLocation(null, -1, -1, -1, -1); [EOL] Object value = "testValue"; [EOL] Class<?> targetType = String.class; [EOL] InvalidFormatException exception = new InvalidFormatException(msg, loc, value, targetType); [EOL] assertEquals(loc, exception.getLocation()); [EOL] assertEquals(value, exception.getValue()); [EOL] assertEquals(targetType, exception.getTargetType()); [EOL] }
public void testInvalidFormatExceptionWithNullParser() { [EOL] String msg = "Invalid format"; [EOL] Object value = "Some value"; [EOL] Class<?> targetType = String.class; [EOL] InvalidFormatException exception = InvalidFormatException.from(null, msg, value, targetType); [EOL] assertNull(exception.getProcessor()); [EOL] assertEquals(msg, exception.getOriginalMessage()); [EOL] assertNull(exception.getLocation()); [EOL] assertEquals(value, exception.getValue()); [EOL] assertEquals(targetType, exception.getTargetType()); [EOL] }
public void testInvalidFormatExceptionWithNonNullParser() { [EOL] JsonParser jp = new MockJsonParser(); [EOL] String msg = "Invalid format"; [EOL] Object value = "Some value"; [EOL] Class<?> targetType = String.class; [EOL] InvalidFormatException exception = InvalidFormatException.from(jp, msg, value, targetType); [EOL] assertNotNull(exception.getProcessor()); [EOL] assertEquals(msg, exception.getOriginalMessage()); [EOL] assertNotNull(exception.getLocation()); [EOL] assertEquals(value, exception.getValue()); [EOL] assertEquals(targetType, exception.getTargetType()); [EOL] }
public void testGetValueWhenValueIsNull() { [EOL] YourClass instance = new YourClass(null); [EOL] assertNull(instance.getValue()); [EOL] }
public void testGetValueWhenValueIsNotNull() { [EOL] Object expectedValue = new Object(); [EOL] YourClass instance = new YourClass(expectedValue); [EOL] assertSame(expectedValue, instance.getValue()); [EOL] }
public Class<?> getTargetType() { [EOL] return _targetType; [EOL] }
public void testFindConvertingSerializerWithNonNullIntrospectorAndConverter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] Object convDef = new Object(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationConverter(member)).thenReturn(convDef); [EOL] when(provider.converterInstance(member, convDef)).thenReturn(conv); [EOL] when(conv.getOutputType(provider.getTypeFactory())).thenReturn(delegateType); [EOL] when(provider.findValueSerializer(delegateType, prop)).thenReturn(ser); [EOL] when(prop.getMember()).thenReturn(member); [EOL] JsonSerializer<Object> result = findConvertingSerializer(provider, prop); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindConvertingSerializerWithNullIntrospector() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonSerializer<Object> result = findConvertingSerializer(provider, prop); [EOL] assertNull(result); [EOL] }
public void testFindConvertingSerializerWithNonNullIntrospectorAndNullConverter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationConverter(member)).thenReturn(null); [EOL] when(prop.getMember()).thenReturn(member); [EOL] JsonSerializer<Object> result = findConvertingSerializer(provider, prop); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNullPropertyAndIntr() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullIntr() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithIgnorals() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findPropertiesToIgnore(accessor)).thenReturn(new String[]{"propToIgnore"}); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithObjectIdInfoAndPropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithObjectIdInfoAndNonPropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(intr.findObjectReferenceInfo(accessor, objectIdInfo)).thenReturn(objectIdInfo); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithArraySerializationShape() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findFormat(accessor)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testSerializeWithTypeWithObjectId() throws IOException { [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithTypeWithoutObjectIdAndWithoutCustomTypeId() throws IOException { [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithTypeWithoutObjectIdAndWithCustomTypeId() throws IOException { [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithTypeWithPropertyFilterId() throws IOException { [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithObjectIdWhenObjectIdWritesAsId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(true); [EOL] _serializeWithObjectId(bean, jgen, provider, true); [EOL] verify(objectId).writeAsId(jgen, provider, objectIdWriter); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithObjectIdWhenAlwaysAsId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] Object id = new Object(); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectId.generateId(bean)).thenReturn(id); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(true); [EOL] _serializeWithObjectId(bean, jgen, provider, true); [EOL] verify(objectIdWriter.serializer).serialize(id, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithObjectIdWithStartEndObject() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] _serializeWithObjectId(bean, jgen, provider, true); [EOL] verify(jgen).writeStartObject(); [EOL] verify(objectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeWithObjectIdWithoutStartEndObject() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] _serializeWithObjectId(bean, jgen, provider, false); [EOL] verify(objectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeWithObjectIdWithPropertyFilterId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] when(_propertyFilterId).thenReturn(new Object()); [EOL] _serializeWithObjectId(bean, jgen, provider, false); [EOL] verify(objectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(this).serializeFieldsFiltered(bean, jgen, provider); [EOL] }
public void testSerializeWithObjectIdWithoutPropertyFilterId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] when(_propertyFilterId).thenReturn(null); [EOL] _serializeWithObjectId(bean, jgen, provider, false); [EOL] verify(objectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(this).serializeFields(bean, jgen, provider); [EOL] }
public void testSerializeWithObjectIdWhenWriteAsIdReturnsTrue() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(true); [EOL] _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL] verify(objectId).writeAsId(jgen, provider, objectIdWriter); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithObjectIdWhenAlwaysAsIdIsTrue() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(true); [EOL] _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL] verify(objectIdWriter.serializer).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeWithObjectIdWithTypeStrNotNull() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] when(_typeId).thenReturn(null); [EOL] when(_customTypeId(bean)).thenReturn("customType"); [EOL] _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL] verify(typeSer).writeCustomTypePrefixForObject(bean, jgen, "customType"); [EOL] verify(typeSer).writeCustomTypeSuffixForObject(bean, jgen, "customType"); [EOL] }
public void testSerializeWithObjectIdWithPropertyFilterIdNotNull() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId objectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(objectId); [EOL] when(objectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] when(_typeId).thenReturn(null); [EOL] when(_customTypeId(bean)).thenReturn(null); [EOL] when(_propertyFilterId).thenReturn(new Object()); [EOL] _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(bean, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(bean, jgen); [EOL] verify(this).serializeFieldsFiltered(bean, jgen, provider); [EOL] }
public void testPOJOPropertiesCollectorWithNullMutatorPrefixAndAnnotationProcessingEnabled() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.getDefaultVisibilityChecker()).thenReturn(mock(VisibilityChecker.class)); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, type, classDef, null); [EOL] assertEquals("set", collector.getMutatorPrefix()); [EOL] assertNotNull(collector.getAnnotationIntrospector()); [EOL] assertNotNull(collector.getVisibilityChecker()); [EOL] }
public void testPOJOPropertiesCollectorWithNonNullMutatorPrefixAndAnnotationProcessingDisabled() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(config.getDefaultVisibilityChecker()).thenReturn(mock(VisibilityChecker.class)); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, type, classDef, "add"); [EOL] assertEquals("add", collector.getMutatorPrefix()); [EOL] assertNull(collector.getAnnotationIntrospector()); [EOL] assertNotNull(collector.getVisibilityChecker()); [EOL] }
public void testGetConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertNotNull(config); [EOL] assertSame(config, mapper.getSerializationConfig()); [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] JavaType expectedType = new JavaType(); // Replace with actual type initialization [EOL] instance.setType(expectedType); // Replace with actual method to set the type [EOL] JavaType result = instance.getType(); [EOL] assertEquals(expectedType, result); [EOL] }
public void testGetClassDef() { [EOL] Class<?> clazz = Object.class; // Use any class for testing [EOL] AnnotatedClass annotatedClass = AnnotatedClass.construct(clazz, null, null); [EOL] AnnotatedClass classDef = annotatedClass.getClassDef(); [EOL] assertNotNull(classDef); [EOL] assertEquals(clazz, classDef.getRawType()); [EOL] }
public void testGetProperties_EmptyProperties() { [EOL] BeanDescription beanDesc = new BeanDescription(); // Assuming a constructor or a factory method [EOL] assertTrue(beanDesc.getProperties().isEmpty()); [EOL] }
public void testGetProperties_NonEmptyProperties() { [EOL] BeanDescription beanDesc = new BeanDescription(); // Assuming a constructor or a factory method [EOL] beanDesc.addProperty(new BeanPropertyDefinition()); // Assuming a method to add a property [EOL] assertFalse(beanDesc.getProperties().isEmpty()); [EOL] assertEquals(1, beanDesc.getProperties().size()); [EOL] }
public void testGetInjectablesWhenInjectablesIsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InjectableValues injectableValues = null; [EOL] mapper.setInjectableValues(injectableValues); [EOL] AnnotatedClass annotatedClass = AnnotatedClass.construct(mapper.constructType(Object.class), mapper.getSerializationConfig()); [EOL] Map<Object, AnnotatedMember> result = annotatedClass.getInjectables(); [EOL] assertNull(result); [EOL] }
public void testGetInjectablesWhenInjectablesIsNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] injectableValues.addValue("key", "value"); [EOL] mapper.setInjectableValues(injectableValues); [EOL] AnnotatedClass annotatedClass = AnnotatedClass.construct(mapper.constructType(Object.class), mapper.getSerializationConfig()); [EOL] Map<Object, AnnotatedMember> result = annotatedClass.getInjectables(); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key").getValue()); [EOL] }
public void testGetJsonValueMethodWithNullGetters() { [EOL] assertNull(objectUnderTest.getJsonValueMethod()); [EOL] }
public void testGetJsonValueMethodWithEmptyGetters() { [EOL] objectUnderTest.setJsonValueGetters(new ArrayList<>()); [EOL] assertNull(objectUnderTest.getJsonValueMethod()); [EOL] }
public void testGetJsonValueMethodWithOneGetter() { [EOL] List<AnnotatedMethod> getters = new ArrayList<>(); [EOL] AnnotatedMethod getter = mock(AnnotatedMethod.class); // Assuming the use of a mocking framework [EOL] getters.add(getter); [EOL] objectUnderTest.setJsonValueGetters(getters); [EOL] assertEquals(getter, objectUnderTest.getJsonValueMethod()); [EOL] }
public void testGetJsonValueMethodWithMultipleGetters() { [EOL] List<AnnotatedMethod> getters = new ArrayList<>(); [EOL] AnnotatedMethod getter1 = mock(AnnotatedMethod.class); [EOL] AnnotatedMethod getter2 = mock(AnnotatedMethod.class); [EOL] getters.add(getter1); [EOL] getters.add(getter2); [EOL] objectUnderTest.setJsonValueGetters(getters); [EOL] Exception exception = null; [EOL] try { [EOL] objectUnderTest.getJsonValueMethod(); [EOL] } catch (Exception e) { [EOL] exception = e; [EOL] } [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Multiple value properties defined")); [EOL] }
public void testGetAnyGetterWithNullAnyGetters() { [EOL] AnnotatedMember result = instance.getAnyGetter(); [EOL] assertNull(result); [EOL] }
public void testGetAnyGetterWithEmptyAnyGetters() { [EOL] instance.setAnyGetters(new LinkedList<>()); [EOL] AnnotatedMember result = instance.getAnyGetter(); [EOL] assertNull(result); [EOL] }
public void testGetAnyGetterWithOneAnyGetter() { [EOL] AnnotatedMember mockMember = mock(AnnotatedMember.class); [EOL] instance.addAnyGetter(mockMember); [EOL] AnnotatedMember result = instance.getAnyGetter(); [EOL] assertSame(mockMember, result); [EOL] }
public void testGetAnyGetterWithMultipleAnyGetters() { [EOL] AnnotatedMember mockMember1 = mock(AnnotatedMember.class); [EOL] AnnotatedMember mockMember2 = mock(AnnotatedMember.class); [EOL] instance.addAnyGetter(mockMember1); [EOL] instance.addAnyGetter(mockMember2); [EOL] try { [EOL] instance.getAnyGetter(); [EOL] fail("Expected an exception to be thrown due to multiple any-getters"); [EOL] } catch (Exception e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testGetAnySetterMethodWithNoAnySetters() { [EOL] assertNull(objectUnderTest.getAnySetterMethod()); [EOL] }
public void testGetAnySetterMethodWithOneAnySetter() { [EOL] objectUnderTest.addAnySetter(mock(AnnotatedMethod.class)); [EOL] assertNotNull(objectUnderTest.getAnySetterMethod()); [EOL] }
public void testGetAnySetterMethodWithMultipleAnySetters() { [EOL] objectUnderTest.addAnySetter(mock(AnnotatedMethod.class)); [EOL] objectUnderTest.addAnySetter(mock(AnnotatedMethod.class)); [EOL] try { [EOL] objectUnderTest.getAnySetterMethod(); [EOL] fail("Expected an exception due to multiple any-setters"); [EOL] } catch (Exception e) { [EOL] assertEquals("Multiple 'any-setters' defined (...)", e.getMessage()); [EOL] } [EOL] }
public void testGetIgnoredPropertyNames_Null() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(SomeClass.class, config); [EOL] assertNull(ac.getIgnoredPropertyNames()); [EOL] } [EOL] public void testGetIgnoredPropertyNames_NonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(SomeClass.class, config); [EOL] ac._ignoredPropertyNames = new HashSet<>(); [EOL] ac._ignoredPropertyNames.add("propertyName"); [EOL] Set<String> ignoredPropertyNames = ac.getIgnoredPropertyNames(); [EOL] assertNotNull(ignoredPropertyNames); [EOL] assertTrue(ignoredPropertyNames.contains("propertyName")); [EOL] }
public void testGetObjectIdInfoWithNullIntrospector() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(null); [EOL] ObjectIdInfo result = instance.getObjectIdInfo(); [EOL] assertNull(result); [EOL] }
public void testGetObjectIdInfoWithNonNullIntrospectorButNoObjectIdInfo() { [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.findObjectIdInfo(any())).thenReturn(null); [EOL] MyClassUnderTest instance = new MyClassUnderTest(introspector); [EOL] ObjectIdInfo result = instance.getObjectIdInfo(); [EOL] assertNull(result); [EOL] }
public void testGetObjectIdInfoWithNonNullIntrospectorAndObjectIdInfo() { [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(...); // Provide necessary arguments [EOL] when(introspector.findObjectIdInfo(any())).thenReturn(objectIdInfo); [EOL] when(introspector.findObjectReferenceInfo(any(), any())).thenReturn(objectIdInfo); [EOL] MyClassUnderTest instance = new MyClassUnderTest(introspector); [EOL] ObjectIdInfo result = instance.getObjectIdInfo(); [EOL] assertNotNull(result); [EOL] assertSame(objectIdInfo, result); [EOL] }
public void testSortPropertiesWithNullIntrAndAlpha() { [EOL] _annotationIntrospector = null; [EOL] _classDef = null; // Assuming _classDef is a field that can be set to null [EOL] _config = mock(SerializationConfig.class); [EOL] when(_config.shouldSortPropertiesAlphabetically()).thenReturn(false); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue(_properties.isEmpty(), "Properties should remain unchanged when intr is null and alpha is null."); [EOL] }
public void testSortPropertiesWithNonNullIntrAndAlphaTrue() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.TRUE); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] POJOPropertyBuilder prop1 = mock(POJOPropertyBuilder.class); [EOL] when(prop1.getName()).thenReturn("a"); [EOL] _properties.put("a", prop1); [EOL] _sortProperties(); [EOL] assertTrue(_properties.containsKey("a"), "Properties should contain the key 'a'."); [EOL] assertEquals(_properties.firstKey(), "a", "The first key should be 'a' when sorted alphabetically."); [EOL] }
public void testSortPropertiesWithNonNullIntrAndAlphaFalse() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.FALSE); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] POJOPropertyBuilder prop1 = mock(POJOPropertyBuilder.class); [EOL] when(prop1.getName()).thenReturn("b"); [EOL] _properties.put("b", prop1); [EOL] _sortProperties(); [EOL] assertTrue(_properties.containsKey("b"), "Properties should contain the key 'b'."); [EOL] assertEquals(_properties.keySet().iterator().next(), "b", "The first key should be 'b' when not sorted."); [EOL] }
public void testSortPropertiesWithPropertyOrder() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); [EOL] when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(new String[]{"b", "a"}); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] POJOPropertyBuilder prop1 = mock(POJOPropertyBuilder.class); [EOL] when(prop1.getName()).thenReturn("a"); [EOL] when(prop1.getInternalName()).thenReturn("a"); [EOL] POJOPropertyBuilder prop2 = mock(POJOPropertyBuilder.class); [EOL] when(prop2.getName()).thenReturn("b"); [EOL] when(prop2.getInternalName()).thenReturn("b"); [EOL] _properties.put("a", prop1); [EOL] _properties.put("b", prop2); [EOL] _sortProperties(); [EOL] Iterator<POJOPropertyBuilder> iterator = _properties.values().iterator(); [EOL] assertEquals(iterator.next().getName(), "b", "The first property should be 'b'."); [EOL] assertEquals(iterator.next().getName(), "a", "The second property should be 'a'."); [EOL] }
public void testSortPropertiesWithCreatorProperties() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = new ArrayList<>(); [EOL] POJOPropertyBuilder creatorProp = mock(POJOPropertyBuilder.class); [EOL] when(creatorProp.getName()).thenReturn("c"); [EOL] _creatorProperties.add(creatorProp); [EOL] POJOPropertyBuilder prop1 = mock(POJOPropertyBuilder.class); [EOL] when(prop1.getName()).thenReturn("a"); [EOL] _properties.put("a", prop1); [EOL] _sortProperties(); [EOL] assertTrue(_properties.containsKey("c"), "Properties should contain the key 'c' from creator properties."); [EOL] }
public void testAddFieldsWithNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = null; [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = createMockAnnotationIntrospectorForSerialization(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndDeserialization() { [EOL] _forSerialization = false; [EOL] _annotationIntrospector = createMockAnnotationIntrospectorForDeserialization(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithPruneFinalFields() { [EOL] _forSerialization = false; [EOL] _config = createConfigWithFeature(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS, false); [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithVisibleFields() { [EOL] _visibilityChecker = createVisibilityCheckerThatMakesCertainFieldsVisible(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithIgnoredFields() { [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addFields(); [EOL] }
public void testAddCreatorsWithNullAnnotationIntrospector() { [EOL] setupEnvironmentWithNullAnnotationIntrospector(); [EOL] _addCreators(); [EOL] assertNull(_creatorProperties); [EOL] }
public void testAddCreatorsWithConstructors() { [EOL] setupEnvironmentWithConstructors(); [EOL] _addCreators(); [EOL] assertNotNull(_creatorProperties); [EOL] assertFalse(_creatorProperties.isEmpty()); [EOL] }
public void testAddCreatorsWithStaticMethods() { [EOL] setupEnvironmentWithStaticMethods(); [EOL] _addCreators(); [EOL] assertNotNull(_creatorProperties); [EOL] assertFalse(_creatorProperties.isEmpty()); [EOL] }
public void testAddGetterMethodWithNullAnnotationIntrospector() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] _addGetterMethod(m, null); [EOL] assertNull(_anyGetters); [EOL] assertNull(_jsonValueGetters); [EOL] } [EOL] public void testAddGetterMethodWithAnyGetterAnnotation() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithAnyGetter(); [EOL] _addGetterMethod(m, ai); [EOL] assertNotNull(_anyGetters); [EOL] assertTrue(_anyGetters.contains(m)); [EOL] assertNull(_jsonValueGetters); [EOL] } [EOL] public void testAddGetterMethodWithJsonValueAnnotation() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithJsonValue(); [EOL] _addGetterMethod(m, ai); [EOL] assertNull(_anyGetters); [EOL] assertNotNull(_jsonValueGetters); [EOL] assertTrue(_jsonValueGetters.contains(m)); [EOL] } [EOL] public void testAddGetterMethodWithRegularGetter() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithRegularGetter(); [EOL] _addGetterMethod(m, ai); [EOL] assertNull(_anyGetters); [EOL] assertNull(_jsonValueGetters); [EOL] } [EOL] public void testAddGetterMethodWithIsGetter() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithIsGetter(); [EOL] _addGetterMethod(m, ai); [EOL] assertNull(_anyGetters); [EOL] assertNull(_jsonValueGetters); [EOL] } [EOL] public void testAddGetterMethodWithExplicitName() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithExplicitName(); [EOL] _addGetterMethod(m, ai); [EOL] assertNull(_anyGetters); [EOL] assertNull(_jsonValueGetters); [EOL] } [EOL] public void testAddGetterMethodWithIgnoreMarker() { [EOL] AnnotatedMethod m = createAnnotatedMethod(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addGetterMethod(m, ai); [EOL] assertNull(_anyGetters); [EOL] assertNull(_jsonValueGetters); [EOL] }
protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL] String implName; [EOL] boolean visible; [EOL] PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL] String explName = (pn == null) ? null : pn.getSimpleName(); [EOL] if (explName == null) { [EOL] implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL] if (implName == null) { [EOL] return; [EOL] } [EOL] visible = _visibilityChecker.isSetterVisible(m); [EOL] } else { [EOL] implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL] if (implName == null) { [EOL] implName = m.getName(); [EOL] } [EOL] if (explName.length() == 0) { [EOL] explName = implName; [EOL] } [EOL] visible = true; [EOL] } [EOL] boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL] _property(implName).addSetter(m, explName, visible, ignore); [EOL] }
public void testAddInjectablesWithNullAnnotationIntrospector() { [EOL] _annotationIntrospector = null; [EOL] _addInjectables(); [EOL] assertTrue(_injectables.isEmpty()); [EOL] }
public void testAddInjectablesWithFields() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] AnnotatedField mockField = createMockAnnotatedField(); [EOL] when(_classDef.fields()).thenReturn(Collections.singletonList(mockField)); [EOL] when(_annotationIntrospector.findInjectableValueId(mockField)).thenReturn("fieldId"); [EOL] _addInjectables(); [EOL] assertFalse(_injectables.isEmpty()); [EOL] assertEquals("fieldId", _injectables.get(mockField)); [EOL] }
public void testAddInjectablesWithMethods() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] AnnotatedMethod mockMethod = createMockAnnotatedMethod(); [EOL] when(mockMethod.getParameterCount()).thenReturn(1); [EOL] when(_classDef.memberMethods()).thenReturn(Collections.singletonList(mockMethod)); [EOL] when(_annotationIntrospector.findInjectableValueId(mockMethod)).thenReturn("methodId"); [EOL] _addInjectables(); [EOL] assertFalse(_injectables.isEmpty()); [EOL] assertEquals("methodId", _injectables.get(mockMethod)); [EOL] }
public void testAddInjectablesWithMultiParameterMethods() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] AnnotatedMethod mockMethod = createMockAnnotatedMethod(); [EOL] when(mockMethod.getParameterCount()).thenReturn(2); // Method with more than one parameter [EOL] when(_classDef.memberMethods()).thenReturn(Collections.singletonList(mockMethod)); [EOL] _addInjectables(); [EOL] assertTrue(_injectables.isEmpty()); [EOL] }
public void testRemoveUnwantedProperties_AllPropertiesVisible() { [EOL] POJOPropertyBuilder visibleProp = mock(POJOPropertyBuilder.class); [EOL] when(visibleProp.anyVisible()).thenReturn(true); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("visibleProp", visibleProp); [EOL] _removeUnwantedProperties(properties, false); [EOL] assertEquals(1, properties.size()); [EOL] assertTrue(properties.containsKey("visibleProp")); [EOL] }
public void testRemoveUnwantedProperties_SomePropertiesInvisible() { [EOL] POJOPropertyBuilder visibleProp = mock(POJOPropertyBuilder.class); [EOL] when(visibleProp.anyVisible()).thenReturn(true); [EOL] POJOPropertyBuilder invisibleProp = mock(POJOPropertyBuilder.class); [EOL] when(invisibleProp.anyVisible()).thenReturn(false); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("visibleProp", visibleProp); [EOL] properties.put("invisibleProp", invisibleProp); [EOL] _removeUnwantedProperties(properties, false); [EOL] assertEquals(1, properties.size()); [EOL] assertTrue(properties.containsKey("visibleProp")); [EOL] assertFalse(properties.containsKey("invisibleProp")); [EOL] }
public void testRemoveUnwantedProperties_WithIgnoredProperties() { [EOL] POJOPropertyBuilder ignoredProp = mock(POJOPropertyBuilder.class); [EOL] when(ignoredProp.anyVisible()).thenReturn(true); [EOL] when(ignoredProp.anyIgnorals()).thenReturn(true); [EOL] when(ignoredProp.isExplicitlyIncluded()).thenReturn(false); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("ignoredProp", ignoredProp); [EOL] _removeUnwantedProperties(properties, false); [EOL] assertEquals(0, properties.size()); [EOL] }
public void testRemoveUnwantedProperties_WithExplicitlyIncludedIgnoredProperties() { [EOL] POJOPropertyBuilder includedIgnoredProp = mock(POJOPropertyBuilder.class); [EOL] when(includedIgnoredProp.anyVisible()).thenReturn(true); [EOL] when(includedIgnoredProp.anyIgnorals()).thenReturn(true); [EOL] when(includedIgnoredProp.isExplicitlyIncluded()).thenReturn(true); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("includedIgnoredProp", includedIgnoredProp); [EOL] _removeUnwantedProperties(properties, false); [EOL] assertEquals(1, properties.size()); [EOL] assertTrue(properties.containsKey("includedIgnoredProp")); [EOL] }
public void testRemoveUnwantedProperties_WithNonVisibleRemoval() { [EOL] POJOPropertyBuilder nonVisibleProp = mock(POJOPropertyBuilder.class); [EOL] when(nonVisibleProp.anyVisible()).thenReturn(true); [EOL] when(nonVisibleProp.anyIgnorals()).thenReturn(false); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("nonVisibleProp", nonVisibleProp); [EOL] _removeUnwantedProperties(properties, true); [EOL] verify(nonVisibleProp).removeNonVisible(true); [EOL] }
public void testConstructUsingMethodWithValidAccessor() throws Exception { [EOL] Method accessor = SampleEnum.class.getMethod("toString"); [EOL] EnumResolver<SampleEnum> resolver = EnumResolver.constructUsingMethod(SampleEnum.class, accessor); [EOL] assertNotNull(resolver); [EOL] assertEquals(SampleEnum.class, resolver.getEnumClass()); [EOL] assertEquals(SampleEnum.VALUE1, resolver.getEnum("Value 1")); [EOL] assertEquals(SampleEnum.VALUE2, resolver.getEnum("Value 2")); [EOL] } [EOL] public void testConstructUsingMethodWithInvalidAccessor() { [EOL] try { [EOL] Method accessor = SampleEnum.class.getMethod("nonExistentMethod"); [EOL] EnumResolver.constructUsingMethod(SampleEnum.class, accessor); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Failed to access @JsonValue of Enum value")); [EOL] } [EOL] } [EOL] public void testConstructUsingMethodWithNullAccessor() { [EOL] try { [EOL] EnumResolver.constructUsingMethod(SampleEnum.class, null); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
enum SampleEnum { [EOL] VALUE1, VALUE2; [EOL] @Override [EOL] public String toString() { [EOL] return "Value " + this.ordinal() + 1; [EOL] } [EOL] }
public void testConstructUnsafeUsingMethodWithValidEnumAndAccessor() { [EOL] Class<?> rawEnumCls = MyEnum.class; [EOL] Method accessor = rawEnumCls.getMethod("name"); [EOL] EnumResolver<?> resolver = EnumResolver.constructUnsafeUsingMethod(rawEnumCls, accessor); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructUnsafeUsingMethodWithInvalidAccessor() { [EOL] Class<?> rawEnumCls = MyEnum.class; [EOL] Method accessor = String.class.getMethod("toString"); [EOL] try { [EOL] EnumResolver.constructUnsafeUsingMethod(rawEnumCls, accessor); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructUnsafeUsingMethodWithNonEnumClass() { [EOL] Class<?> rawEnumCls = String.class; [EOL] Method accessor = rawEnumCls.getMethod("toString"); [EOL] try { [EOL] EnumResolver.constructUnsafeUsingMethod(rawEnumCls, accessor); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetEnumWithNegativeIndex() { [EOL] EnumContainer container = new EnumContainer(); // Assuming EnumContainer is the class containing getEnum [EOL] T result = container.getEnum(-1); [EOL] assertNull(result); [EOL] } [EOL] public void testGetEnumWithIndexOutOfBounds() { [EOL] EnumContainer container = new EnumContainer(); // Assuming EnumContainer is the class containing getEnum [EOL] T result = container.getEnum(container.size()); // Assuming size() returns the length of _enums [EOL] assertNull(result); [EOL] } [EOL] public void testGetEnumWithValidIndex() { [EOL] EnumContainer container = new EnumContainer(); // Assuming EnumContainer is the class containing getEnum [EOL] T expectedEnum = /* some valid enum value */; [EOL] int validIndex = /* the index of expectedEnum in _enums */; [EOL] T result = container.getEnum(validIndex); [EOL] assertEquals(expectedEnum, result); [EOL] }
public void testDeserializeWithTypeWithObjectId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] Object expected = new Object(); [EOL] when(_deserializeFromObjectId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeWithTypeWithNaturalType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] when(_deserializeIfNatural(jp, ctxt)).thenReturn("naturalValue"); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertEquals("naturalValue", result); [EOL] }
public void testDeserializeWithTypeDelegatingToTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] when(_deserializeIfNatural(jp, ctxt)).thenReturn(null); [EOL] Object expected = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromObject(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromObjectIdWithResolvedId() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] Object expectedPojo = new Object(); [EOL] when(objectIdReader.deserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(ctxt.findObjectId(any(), eq(objectIdReader.generator))).thenReturn(roid); [EOL] when(roid.item).thenReturn(expectedPojo); [EOL] Object result = _deserializeFromObjectId(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertSame(expectedPojo, result); [EOL] }
public void testDeserializeFromObjectIdWithUnresolvedId() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] when(objectIdReader.deserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(ctxt.findObjectId(any(), eq(objectIdReader.generator))).thenReturn(roid); [EOL] when(roid.item).thenReturn(null); [EOL] Exception exception = assertThrows(IllegalStateException.class, () -> { [EOL] _deserializeFromObjectId(jp, ctxt); [EOL] }); [EOL] String expectedMessage = "Could not resolve Object Id"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) { [EOL] this(mapper, config, null, null, null, null); [EOL] }
public void testObjectReaderConstructorWithNonNullValues() { [EOL] DeserializationConfig config = new DeserializationConfig(...); [EOL] JavaType valueType = ...; // Construct a valid JavaType instance [EOL] JsonDeserializer<Object> rootDeser = ...; // Mock or create a JsonDeserializer instance [EOL] Object valueToUpdate = new Object(); [EOL] FormatSchema schema = ...; // Mock or create a FormatSchema instance [EOL] InjectableValues injectableValues = ...; // Mock or create an InjectableValues instance [EOL] DataFormatReaders dataFormatReaders = ...; // Mock or create a DataFormatReaders instance [EOL] ObjectReader base = new ObjectReader(...); // Create a base ObjectReader with necessary initialization [EOL] ObjectReader reader = new ObjectReader(base, config, valueType, rootDeser, valueToUpdate, schema, injectableValues, dataFormatReaders); [EOL] assertNotNull(reader); [EOL] assertEquals(config, reader.getConfig()); [EOL] assertEquals(valueType, reader.getValueType()); [EOL] assertEquals(rootDeser, reader.getRootDeserializer()); [EOL] assertEquals(valueToUpdate, reader.getValueToUpdate()); [EOL] assertEquals(schema, reader.getSchema()); [EOL] assertEquals(injectableValues, reader.getInjectableValues()); [EOL] assertEquals(dataFormatReaders, reader.getDataFormatReaders()); [EOL] assertEquals(base.getFactory(), reader.getFactory()); [EOL] assertEquals(base.getRootNames(), reader.getRootNames()); [EOL] assertEquals(config.useRootWrapping(), reader.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL] }
public void testObjectReaderConstructorWithArrayValueToUpdate() { [EOL] DeserializationConfig config = new DeserializationConfig(...); [EOL] JavaType valueType = ...; // Construct a JavaType instance that represents an array type [EOL] JsonDeserializer<Object> rootDeser = ...; // Mock or create a JsonDeserializer instance [EOL] Object valueToUpdate = new Object[0]; // Array instance to trigger the IllegalArgumentException [EOL] FormatSchema schema = ...; // Mock or create a FormatSchema instance [EOL] InjectableValues injectableValues = ...; // Mock or create an InjectableValues instance [EOL] DataFormatReaders dataFormatReaders = ...; // Mock or create a DataFormatReaders instance [EOL] ObjectReader base = new ObjectReader(...); // Create a base ObjectReader with necessary initialization [EOL] try { [EOL] new ObjectReader(base, config, valueType, rootDeser, valueToUpdate, schema, injectableValues, dataFormatReaders); [EOL] fail("Expected IllegalArgumentException for array valueToUpdate"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithSameInjectableValues() { [EOL] InjectableValues injectableValues = new InjectableValues.Std(); [EOL] ObjectReader reader = new ObjectReader(); [EOL] ObjectReader result = reader.with(injectableValues); [EOL] assertSame(reader, result); [EOL] }
public void testWithDifferentInjectableValues() { [EOL] InjectableValues injectableValues1 = new InjectableValues.Std(); [EOL] InjectableValues injectableValues2 = new InjectableValues.Std(); [EOL] ObjectReader reader = new ObjectReader(); [EOL] ObjectReader result = reader.with(injectableValues2); [EOL] assertNotSame(reader, result); [EOL] assertNotNull(result); [EOL] }
public void testWithTypeSameValue() { [EOL] JavaType valueType = _valueType; // Assuming _valueType is already defined and initialized [EOL] ObjectReader reader = new ObjectReader(); // Assuming a constructor exists [EOL] ObjectReader result = reader.withType(valueType); [EOL] assertSame(reader, result); [EOL] }
public void testWithTypeDifferentValue() { [EOL] JavaType valueType = mock(JavaType.class); // Assuming you can use mocking frameworks like Mockito [EOL] when(valueType.equals(_valueType)).thenReturn(false); // Assuming _valueType is already defined and initialized [EOL] JsonDeserializer<Object> rootDeser = mock(JsonDeserializer.class); // Mocking the deserializer [EOL] DataFormatReaders det = mock(DataFormatReaders.class); // Mocking DataFormatReaders [EOL] when(_prefetchRootDeserializer(_config, valueType)).thenReturn(rootDeser); // Assuming _config is a field [EOL] when(_dataFormatReaders.withType(valueType)).thenReturn(det); // Assuming _dataFormatReaders is a field [EOL] ObjectReader reader = new ObjectReader(); // Assuming a constructor exists [EOL] reader._prefetchRootDeserializer = this::_prefetchRootDeserializer; // Assuming method reference is possible [EOL] reader._dataFormatReaders = _dataFormatReaders; [EOL] reader._config = _config; [EOL] reader._valueType = _valueType; [EOL] reader._valueToUpdate = _valueToUpdate; // Assuming _valueToUpdate is a field [EOL] reader._schema = _schema; // Assuming _schema is a field [EOL] reader._injectableValues = _injectableValues; // Assuming _injectableValues is a field [EOL] ObjectReader result = reader.withType(valueType); [EOL] assertNotNull(result); [EOL] assertNotSame(reader, result); [EOL] assertEquals(valueType, result._valueType); [EOL] assertSame(rootDeser, result._rootDeser); [EOL] assertSame(det, result._dataFormatReaders); [EOL] }
public void testWithType_TypeReferenceNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeReference<?> valueTypeRef = new TypeReference<List<String>>() {}; [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.withType(valueTypeRef); [EOL] assertNotNull(newReader); [EOL] }
public void testWithType_TypeReferenceNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeReference<?> valueTypeRef = null; [EOL] ObjectReader reader = mapper.reader(); [EOL] try { [EOL] reader.withType(valueTypeRef); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadValuesWithNonNullDataFormatReaders() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.readerFor(String.class).withFormatReaders(new DataFormatReaders()); [EOL] String json = "\"test\""; [EOL] try { [EOL] reader.readValues(json); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testReadValuesWithNullDataFormatReadersAndNonNullSchema() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.readerFor(String.class); [EOL] JsonSchema schema = JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909)).build().schemaFromString("{}"); [EOL] reader = reader.with(schema); [EOL] String json = "\"test\""; [EOL] MappingIterator<String> iterator = reader.readValues(json); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("test", iterator.next()); [EOL] }
public void testReadValuesWithNullDataFormatReadersAndNullSchema() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.readerFor(String.class); [EOL] String json = "\"test\""; [EOL] MappingIterator<String> iterator = reader.readValues(json); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("test", iterator.next()); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] assertEquals(_findRootDeserializer(any(DeserializationContext.class), any(JavaType.class)).getNullValue(), result); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] assertSame(valueToUpdate, result); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNull(result); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] assertSame(valueToUpdate, result); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenNotEndArrayOrObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_ARRAY); // Assuming START_ARRAY for coverage [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] assertEquals(_findRootDeserializer(any(DeserializationContext.class), any(JavaType.class)).deserialize(jp, createDeserializationContext(jp, _config)), result); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNotEndArrayOrObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_ARRAY); // Assuming START_ARRAY for coverage [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] assertSame(valueToUpdate, result); [EOL] }
public void test_bindAndClose_withoutSchemaAndValueToUpdateNullAndTokenNotEndArrayOrObjectUnwrapRoot() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_ARRAY); // Assuming START_ARRAY for coverage [EOL] when(_unwrapRoot).thenReturn(true); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp, never()).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] assertEquals(_unwrapAndDeserialize(jp, createDeserializationContext(jp, _config), _valueType, _findRootDeserializer(any(DeserializationContext.class), any(JavaType.class))), result); [EOL] }
public void test_bindAndClose_withIOExceptionOnClose() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] doThrow(new IOException()).when(jp).close(); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertNotNull(result); [EOL] assertEquals(_findRootDeserializer(any(DeserializationContext.class), any(JavaType.class)).getNullValue(), result); [EOL] }
public void testPrefetchRootDeserializerWithValueTypeNull() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType valueType = null; [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithEagerDeserializerFetchDisabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.disable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithCacheHit() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] JsonDeserializer<Object> expectedDeserializer = new JsonDeserializer<>() { ... }; // Provide actual deserializer [EOL] _rootDeserializers.put(valueType, expectedDeserializer); [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertSame(expectedDeserializer, result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithCacheMissAndSuccessfulFetch() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] JsonDeserializer<Object> expectedDeserializer = new JsonDeserializer<>() { ... }; // Provide actual deserializer [EOL] DeserializationContext ctxt = createDeserializationContext(null, config); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertSame(expectedDeserializer, result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithCacheMissAndException() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] DeserializationContext ctxt = createDeserializationContext(null, config); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenThrow(new JsonProcessingException("")); [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testDetectBindAndCloseWithNoMatch() throws IOException { [EOL] byte[] src = new byte[] { /* some byte array that does not match any format */ }; [EOL] int offset = 0; [EOL] int length = src.length; [EOL] try { [EOL] _detectBindAndClose(src, offset, length); [EOL] fail("Should not pass as no format match is expected."); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDetectBindAndCloseWithMatch() throws IOException { [EOL] byte[] src = new byte[] { /* some byte array that matches a known format */ }; [EOL] int offset = 0; [EOL] int length = src.length; [EOL] Object result = _detectBindAndClose(src, offset, length); [EOL] assertNotNull("The result should not be null as a format match is expected.", result); [EOL] }
public void testEquals_Reflexive() { [EOL] CollectionLikeType clt = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] assertTrue(clt.equals(clt)); [EOL] }
public void testEquals_Null() { [EOL] CollectionLikeType clt = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] assertFalse(clt.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] CollectionLikeType clt = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] Object other = new Object(); [EOL] assertFalse(clt.equals(other)); [EOL] }
public void testEquals_EqualObjects() { [EOL] CollectionLikeType clt1 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] CollectionLikeType clt2 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] assertTrue(clt1.equals(clt2)); [EOL] }
public void testEquals_DifferentElementType() { [EOL] CollectionLikeType clt1 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] CollectionLikeType clt2 = new CollectionLikeType(String.class, new SimpleType(Double.class)); [EOL] assertFalse(clt1.equals(clt2)); [EOL] }
public void testEquals_DifferentClassType() { [EOL] CollectionLikeType clt1 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] CollectionLikeType clt2 = new CollectionLikeType(Integer.class, new SimpleType(Integer.class)); [EOL] assertFalse(clt1.equals(clt2)); [EOL] }
public void testObjectWriterWithNonNullRootType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] JavaType rootType = mapper.constructType(String.class); [EOL] PrettyPrinter pp = new DefaultPrettyPrinter(); [EOL] ObjectWriter writer = new ObjectWriter(mapper, config, rootType, pp); [EOL] assertNotNull(writer); [EOL] assertEquals(rootType.withStaticTyping(), writer._rootType); [EOL] assertEquals(pp, writer._prettyPrinter); [EOL] assertNotNull(writer._rootSerializer); [EOL] }
public void testObjectWriterWithNullRootType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] JavaType rootType = null; [EOL] PrettyPrinter pp = new DefaultPrettyPrinter(); [EOL] ObjectWriter writer = new ObjectWriter(mapper, config, rootType, pp); [EOL] assertNotNull(writer); [EOL] assertNull(writer._rootType); [EOL] assertEquals(pp, writer._prettyPrinter); [EOL] assertNull(writer._rootSerializer); [EOL] }
public void testWriteValueWithCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(value).close(); [EOL] }
public void testWriteValueWithNonCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, false); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).close(); [EOL] }
public void testWriteValueFlushAfterWrite() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, true); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen).flush(); [EOL] }
public void testWriteValueWithoutFlushAfterWrite() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, false); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).flush(); [EOL] }
public void testWriteValueWithRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> rootSerializer = mock(JsonSerializer.class); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, false); [EOL] objectMapper.setConfig(objectMapper.getSerializationConfig().with(rootType).with(rootSerializer)); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(rootSerializer).serialize(eq(value), eq(jgen), any(SerializerProvider.class)); [EOL] }
public void testConfigAndWriteValueWithCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] config = config.with(SerializationFeature.CLOSE_CLOSEABLE); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(value).close(); [EOL] verify(jgen, never()).close(); [EOL] }
public void testConfigAndWriteValueWithNonCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValueWithRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> rootSerializer = mock(JsonSerializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] _rootType = rootType; [EOL] _rootSerializer = rootSerializer; [EOL] _configAndWriteValue(jgen, value); [EOL] verify(_serializerProvider(config)).serializeValue(jgen, value, rootType, rootSerializer); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValueExceptionHandling() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] doThrow(new IOException()).when(jgen).close(); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testArrayNodeCreationWithNonNullFactory() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(true); [EOL] ArrayNode arrayNode = new ArrayNode(factory); [EOL] assertNotNull(arrayNode); [EOL] assertSame(factory, arrayNode.getNodeFactory()); [EOL] }
public void testArrayNodeCreationWithNullFactory() { [EOL] try { [EOL] ArrayNode arrayNode = new ArrayNode(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeepCopyEmptyArrayNode() { [EOL] ArrayNode original = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode copy = original.deepCopy(); [EOL] assertNotNull(copy); [EOL] assertNotSame(original, copy); [EOL] assertTrue(copy.isEmpty()); [EOL] }
public void testDeepCopyNonEmptyArrayNode() { [EOL] ArrayNode original = new ArrayNode(JsonNodeFactory.instance); [EOL] original.add(1); [EOL] original.add("string"); [EOL] original.add(false); [EOL] ArrayNode copy = original.deepCopy(); [EOL] assertNotNull(copy); [EOL] assertNotSame(original, copy); [EOL] assertEquals(original.size(), copy.size()); [EOL] for (int i = 0; i < original.size(); i++) { [EOL] assertNotSame(original.get(i), copy.get(i)); [EOL] assertEquals(original.get(i), copy.get(i)); [EOL] } [EOL] }
public void testGetNodeType() { [EOL] JsonNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] assertEquals(JsonNodeType.ARRAY, arrayNode.getNodeType()); [EOL] }
public void testSizeWhenEmpty() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = new ArrayNode(nodeFactory); [EOL] assertEquals(0, arrayNode.size()); [EOL] }
public void testSizeWithElements() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = new ArrayNode(nodeFactory); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] assertEquals(2, arrayNode.size()); [EOL] }
public void testElementsWhenChildrenAreEmpty() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] Iterator<JsonNode> elements = arrayNode.elements(); [EOL] assertFalse(elements.hasNext()); [EOL] }
public void testElementsWhenChildrenAreNotEmpty() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode.add(1); [EOL] Iterator<JsonNode> elements = arrayNode.elements(); [EOL] assertTrue(elements.hasNext()); [EOL] assertEquals(1, elements.next().intValue()); [EOL] }
public void testGetWithValidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode result = arrayNode.get(0); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.intValue()); [EOL] }
public void testGetWithInvalidIndexNegative() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode result = arrayNode.get(-1); [EOL] assertNull(result); [EOL] }
public void testGetWithInvalidIndexOutOfBounds() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode result = arrayNode.get(1); [EOL] assertNull(result); [EOL] }
public void testGetWithNullFieldName() { [EOL] JsonNode node = new TestJsonNode(); [EOL] JsonNode result = node.get(null); [EOL] assertNull(result); [EOL] }
public void testPathWithFieldName() { [EOL] JsonNode node = new TestNode(); [EOL] JsonNode result = node.path("anyFieldName"); [EOL] assertTrue(result instanceof MissingNode); [EOL] }
public void testSerializeEmptyArrayNode() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = nodeFactory.arrayNode(); [EOL] JsonGenerator jg = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] arrayNode.serialize(jg, provider); [EOL] verify(jg).writeStartArray(); [EOL] verify(jg).writeEndArray(); [EOL] verifyNoMoreInteractions(jg); [EOL] }
public void testSerializeNonEmptyArrayNode() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = nodeFactory.arrayNode(); [EOL] arrayNode.add(nodeFactory.numberNode(1)); [EOL] arrayNode.add(nodeFactory.textNode("text")); [EOL] JsonGenerator jg = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] arrayNode.serialize(jg, provider); [EOL] verify(jg).writeStartArray(); [EOL] verify(jg, times(2)).writeNumber(anyInt()); [EOL] verify(jg).writeString(anyString()); [EOL] verify(jg).writeEndArray(); [EOL] verifyNoMoreInteractions(jg); [EOL] }
public void testFindValuesWithEmptyList() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] objectNode.put("key1", "value1"); [EOL] objectNode.put("key2", "value2"); [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(objectNode); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = arrayNode.findValues("key1", foundSoFar); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("value1", result.get(0).asText()); [EOL] }
public void testFindValuesWithNonEmptyList() { [EOL] ObjectNode objectNode1 = JsonNodeFactory.instance.objectNode(); [EOL] objectNode1.put("key1", "value1"); [EOL] ObjectNode objectNode2 = JsonNodeFactory.instance.objectNode(); [EOL] objectNode2.put("key1", "value3"); [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(objectNode1); [EOL] arrayNode.add(objectNode2); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] foundSoFar.add(JsonNodeFactory.instance.textNode("existingValue")); [EOL] List<JsonNode> result = arrayNode.findValues("key1", foundSoFar); [EOL] assertEquals(3, result.size()); [EOL] assertEquals("existingValue", result.get(0).asText()); [EOL] assertEquals("value1", result.get(1).asText()); [EOL] assertEquals("value3", result.get(2).asText()); [EOL] }
public void testFindValuesWithNoMatch() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] objectNode.put("key2", "value2"); [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(objectNode); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = arrayNode.findValues("key1", foundSoFar); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindValuesAsTextWithEmptyChildren() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] List<String> result = arrayNode.findValuesAsText("fieldName", new ArrayList<>()); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindValuesAsTextWithSingleChild() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ObjectNode child = arrayNode.addObject(); [EOL] child.put("fieldName", "value1"); [EOL] List<String> result = arrayNode.findValuesAsText("fieldName", new ArrayList<>()); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("value1", result.get(0)); [EOL] }
public void testFindValuesAsTextWithMultipleChildren() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ObjectNode child1 = arrayNode.addObject(); [EOL] child1.put("fieldName", "value1"); [EOL] ObjectNode child2 = arrayNode.addObject(); [EOL] child2.put("fieldName", "value2"); [EOL] List<String> result = arrayNode.findValuesAsText("fieldName", new ArrayList<>()); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains("value1")); [EOL] assertTrue(result.contains("value2")); [EOL] }
public void testFindValuesAsTextWithNestedChildren() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ObjectNode child1 = arrayNode.addObject(); [EOL] child1.put("fieldName", "value1"); [EOL] ArrayNode nestedArray = child1.putArray("nested"); [EOL] ObjectNode nestedChild = nestedArray.addObject(); [EOL] nestedChild.put("fieldName", "nestedValue"); [EOL] List<String> result = arrayNode.findValuesAsText("fieldName", new ArrayList<>()); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains("value1")); [EOL] assertTrue(result.contains("nestedValue")); [EOL] }
public void testFindParents_NullFoundSoFar() { [EOL] JsonNode rootNode = createRootNodeWithChildren(); [EOL] List<JsonNode> result = rootNode.findParents("someField", null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testFindParents_EmptyFoundSoFar() { [EOL] JsonNode rootNode = createRootNodeWithChildren(); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = rootNode.findParents("someField", foundSoFar); [EOL] assertSame(foundSoFar, result); [EOL] } [EOL] public void testFindParents_NonEmptyFoundSoFar() { [EOL] JsonNode rootNode = createRootNodeWithChildren(); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = rootNode.findParents("someField", foundSoFar); [EOL] assertSame(foundSoFar, result); [EOL] } [EOL] public void testFindParents_NoMatchingFieldName() { [EOL] JsonNode rootNode = createRootNodeWithChildren(); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = rootNode.findParents("nonExistingField", foundSoFar); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindParents_WithMatchingFieldName() { [EOL] JsonNode rootNode = createRootNodeWithChildren(); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = rootNode.findParents("matchingField", foundSoFar); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testSetWithNullValue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode result = arrayNode.set(0, null); [EOL] assertNotNull(result); [EOL] assertEquals(arrayNode.get(0), arrayNode.nullNode()); [EOL] }
public void testSetWithValidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode newValue = JsonNodeFactory.instance.numberNode(2); [EOL] JsonNode result = arrayNode.set(0, newValue); [EOL] assertNotNull(result); [EOL] assertEquals(arrayNode.get(0), newValue); [EOL] }
public void testSetWithInvalidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] try { [EOL] arrayNode.set(2, JsonNodeFactory.instance.numberNode(2)); [EOL] fail("Expected IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddWithNullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] JsonNode nullValue = null; [EOL] ArrayNode result = arrayNode.add(nullValue); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 1); [EOL] assertTrue(result.get(0).isNull()); [EOL] }
public void testAddWithNonNullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] JsonNode nonNullValue = new TextNode("test"); [EOL] ArrayNode result = arrayNode.add(nonNullValue); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 1); [EOL] assertEquals("test", result.get(0).asText()); [EOL] }
public void testAddAllWithNonNullArrayNode() { [EOL] ArrayNode arrayNode1 = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode arrayNode2 = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode1.add(1); [EOL] arrayNode2.add(2); [EOL] ArrayNode result = arrayNode1.addAll(arrayNode2); [EOL] assertEquals(2, result.size()); [EOL] assertEquals(1, result.get(0).intValue()); [EOL] assertEquals(2, result.get(1).intValue()); [EOL] }
public void testAddAllWithEmptyArrayNode() { [EOL] ArrayNode arrayNode1 = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode arrayNode2 = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode result = arrayNode1.addAll(arrayNode2); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddAllToEmptyArrayNode() { [EOL] ArrayNode arrayNode1 = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode arrayNode2 = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode2.add(1); [EOL] ArrayNode result = arrayNode1.addAll(arrayNode2); [EOL] assertEquals(1, result.size()); [EOL] assertEquals(1, result.get(0).intValue()); [EOL] }
public void testAddAllWithEmptyCollection() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] Collection<JsonNode> emptyCollection = Collections.emptyList(); [EOL] ArrayNode result = arrayNode.addAll(emptyCollection); [EOL] assertTrue(result == arrayNode); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testAddAllWithNonEmptyCollection() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] Collection<JsonNode> nodes = new ArrayList<>(); [EOL] nodes.add(new TextNode("test")); [EOL] nodes.add(IntNode.valueOf(123)); [EOL] ArrayNode result = arrayNode.addAll(nodes); [EOL] assertTrue(result == arrayNode); [EOL] assertTrue(result.size() == nodes.size()); [EOL] }
public void testInsertWithNonNullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] JsonNode value = TextNode.valueOf("test"); [EOL] int index = 0; [EOL] ArrayNode result = arrayNode.insert(index, value); [EOL] assertSame(arrayNode, result); [EOL] assertEquals(value, arrayNode.get(index)); [EOL] }
public void testInsertWithNullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] JsonNode value = null; [EOL] int index = 0; [EOL] ArrayNode result = arrayNode.insert(index, value); [EOL] assertSame(arrayNode, result); [EOL] assertTrue(arrayNode.get(index).isNull()); [EOL] }
public void testRemove_ValidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] arrayNode.add(3); [EOL] JsonNode removedNode = arrayNode.remove(1); [EOL] assertEquals(2, arrayNode.size()); [EOL] assertEquals(2, removedNode.asInt()); [EOL] }
public void testRemove_InvalidIndexNegative() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] arrayNode.add(3); [EOL] JsonNode removedNode = arrayNode.remove(-1); [EOL] assertEquals(3, arrayNode.size()); [EOL] assertNull(removedNode); [EOL] }
public void testRemove_InvalidIndexTooLarge() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] arrayNode.add(3); [EOL] JsonNode removedNode = arrayNode.remove(5); [EOL] assertEquals(3, arrayNode.size()); [EOL] assertNull(removedNode); [EOL] }
public void testRemoveAll_EmptyArrayNode() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode result = arrayNode.removeAll(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testRemoveAll_NonEmptyArrayNode() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] ArrayNode result = arrayNode.removeAll(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddInt() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode result = arrayNode.add(5); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals(5, result.get(0).intValue()); [EOL] }

public void testAddWithNullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode result = arrayNode.add((String) null); [EOL] assertNotNull(result); [EOL] assertTrue(result.get(0).isNull()); [EOL] }
public void testAddWithNonNullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] String testValue = "testString"; [EOL] ArrayNode result = arrayNode.add(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.get(0).asText()); [EOL] }
public void testEqualsWithSameObject() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] boolean result = arrayNode.equals(arrayNode); [EOL] assert result; [EOL] } [EOL] public void testEqualsWithNull() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] boolean result = arrayNode.equals(null); [EOL] assert !result; [EOL] } [EOL] public void testEqualsWithDifferentClass() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] Object other = new Object(); [EOL] boolean result = arrayNode.equals(other); [EOL] assert !result; [EOL] } [EOL] public void testEqualsWithEqualArrayNodes() { [EOL] ArrayNode arrayNode1 = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode arrayNode2 = new ArrayNode(JsonNodeFactory.instance); [EOL] boolean result = arrayNode1.equals(arrayNode2); [EOL] assert result; [EOL] } [EOL] public void testEqualsWithDifferentArrayNodes() { [EOL] ArrayNode arrayNode1 = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode arrayNode2 = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode2.add("value"); [EOL] boolean result = arrayNode1.equals(arrayNode2); [EOL] assert !result; [EOL] }
public void testHashCode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode1 = factory.arrayNode(); [EOL] ArrayNode arrayNode2 = factory.arrayNode(); [EOL] arrayNode1.add(1); [EOL] arrayNode2.add(1); [EOL] int hashCode1 = arrayNode1.hashCode(); [EOL] int hashCode2 = arrayNode2.hashCode(); [EOL] assertEquals(hashCode1, hashCode2); [EOL] }
public void testHashCodeWithDifferentChildren() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode1 = factory.arrayNode(); [EOL] ArrayNode arrayNode2 = factory.arrayNode(); [EOL] arrayNode1.add(1); [EOL] arrayNode2.add(2); [EOL] int hashCode1 = arrayNode1.hashCode(); [EOL] int hashCode2 = arrayNode2.hashCode(); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testAddWithNonNullNode() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] JsonNode nodeToAdd = TextNode.valueOf("test"); [EOL] ArrayNode result = arrayNode._add(nodeToAdd); [EOL] assertEquals(arrayNode, result); [EOL] assertTrue(arrayNode.contains(nodeToAdd)); [EOL] }
public void testAddWithNullNode() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] ArrayNode result = arrayNode._add(null); [EOL] assertEquals(arrayNode, result); [EOL] assertTrue(arrayNode.contains(NullNode.getInstance())); [EOL] }
public void testCreateDeserializerWithAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType abstractType = mock(JavaType.class); [EOL] when(abstractType.isAbstract()).thenReturn(true); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factory.mapAbstractType(config, abstractType)).thenReturn(abstractType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(abstractType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createBuilderBasedDeserializer(eq(ctxt), eq(abstractType), eq(beanDesc), any())).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._createDeserializer(ctxt, factory, abstractType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateDeserializerWithMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType mapLikeType = mock(JavaType.class); [EOL] when(mapLikeType.isMapLikeType()).thenReturn(true); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factory.mapAbstractType(config, mapLikeType)).thenReturn(mapLikeType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(mapLikeType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createBuilderBasedDeserializer(eq(ctxt), eq(mapLikeType), eq(beanDesc), any())).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._createDeserializer(ctxt, factory, mapLikeType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateDeserializerWithCollectionLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType collectionLikeType = mock(JavaType.class); [EOL] when(collectionLikeType.isCollectionLikeType()).thenReturn(true); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factory.mapAbstractType(config, collectionLikeType)).thenReturn(collectionLikeType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(collectionLikeType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createBuilderBasedDeserializer(eq(ctxt), eq(collectionLikeType), eq(beanDesc), any())).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._createDeserializer(ctxt, factory, collectionLikeType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateDeserializerWithNonAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType nonAbstractType = mock(JavaType.class); [EOL] when(nonAbstractType.isAbstract()).thenReturn(false); [EOL] when(nonAbstractType.isMapLikeType()).thenReturn(false); [EOL] when(nonAbstractType.isCollectionLikeType()).thenReturn(false); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(nonAbstractType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createBuilderBasedDeserializer(eq(ctxt), eq(nonAbstractType), eq(beanDesc), any())).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._createDeserializer(ctxt, factory, nonAbstractType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateDeserializerWithConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType typeWithConverter = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(typeWithConverter)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] when(beanDesc.findDeserializationConverter()).thenReturn(converter); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(converter.getInputType(ctxt.getTypeFactory())).thenReturn(delegateType); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createBuilderBasedDeserializer(eq(ctxt), eq(delegateType), eq(beanDesc), any())).thenReturn(delegateDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._createDeserializer(ctxt, factory, typeWithConverter); [EOL] assertTrue(result instanceof StdDelegatingDeserializer); [EOL] }
public void testCreateDeserializer2WithEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(true); [EOL] when(factory.createEnumDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithArrayType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isArrayType()).thenReturn(true); [EOL] when(factory.createArrayDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithMapType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapType type = mock(MapType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(((MapLikeType) type).isTrueMapType()).thenReturn(true); [EOL] when(factory.createMapDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(type.isTrueMapType()).thenReturn(false); [EOL] when(factory.createMapLikeDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithCollectionType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(((CollectionLikeType) type).isTrueCollectionType()).thenReturn(true); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(null); [EOL] when(factory.createCollectionDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithCollectionLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(((CollectionLikeType) type).isTrueCollectionType()).thenReturn(false); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] when(factory.createCollectionLikeDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithJsonNode() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(true); [EOL] when(factory.createTreeDeserializer(config, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithBeanType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(false); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(false); [EOL] when(factory.createBeanDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testFindDeserializerFromAnnotationWithNullDeserializerDef() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(null); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerFromAnnotationWithNonNullDeserializerDef() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] Object deserDef = new Object(); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(deserDef); [EOL] when(ctxt.deserializerInstance(ann, deserDef)).thenReturn(deser); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(deserDef); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertNotNull(result); [EOL] assertSame(deser, result); [EOL] }
public void testFindConvertingDeserializerWithNullConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated a = mock(Annotated.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(findConverter(ctxt, a)).thenReturn(null); [EOL] JsonDeserializer<Object> result = findConvertingDeserializer(ctxt, a, deser); [EOL] assertSame(deser, result); [EOL] }
public void testFindConvertingDeserializerWithNonNullConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated a = mock(Annotated.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(findConverter(ctxt, a)).thenReturn(conv); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] when(conv.getInputType(typeFactory)).thenReturn(delegateType); [EOL] JsonDeserializer<Object> result = findConvertingDeserializer(ctxt, a, deser); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingDeserializer); [EOL] }
public void testFindConverterWithNullConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findDeserializationConverter(a)).thenReturn(null); [EOL] Converter<Object, Object> result = findConverter(ctxt, a); [EOL] assertNull(result); [EOL] }
public void testFindConverterWithNonNullConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated a = mock(Annotated.class); [EOL] Object convDef = new Object(); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findDeserializationConverter(a)).thenReturn(convDef); [EOL] when(ctxt.converterInstance(a, convDef)).thenReturn(converter); [EOL] Converter<Object, Object> result = findConverter(ctxt, a); [EOL] assertSame(converter, result); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] Class<?> subclass = intr.findDeserializationType(a, type); [EOL] if (subclass != null) { [EOL] try { [EOL] type = type.narrowBy(subclass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] if (type.isContainerType()) { [EOL] Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL] if (keyClass != null) { [EOL] if (!(type instanceof MapLikeType)) { [EOL] throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL] } [EOL] try { [EOL] type = ((MapLikeType) type).narrowKey(keyClass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] JavaType keyType = type.getKeyType(); [EOL] if (keyType != null && keyType.getValueHandler() == null) { [EOL] Object kdDef = intr.findKeyDeserializer(a); [EOL] if (kdDef != null) { [EOL] KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL] if (kd != null) { [EOL] type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL] keyType = type.getKeyType(); [EOL] } [EOL] } [EOL] } [EOL] Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL] if (cc != null) { [EOL] try { [EOL] type = type.narrowContentsBy(cc); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] JavaType contentType = type.getContentType(); [EOL] if (contentType.getValueHandler() == null) { [EOL] Object cdDef = intr.findContentDeserializer(a); [EOL] if (cdDef != null) { [EOL] JsonDeserializer<?> cd = null; [EOL] if (cdDef instanceof JsonDeserializer<?>) { [EOL] cdDef = (JsonDeserializer<?>) cdDef; [EOL] } else { [EOL] Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL] if (cdClass != null) { [EOL] cd = ctxt.deserializerInstance(a, cdClass); [EOL] } [EOL] } [EOL] if (cd != null) { [EOL] type = type.withContentValueHandler(cd); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] return type; [EOL] }
public void testGetCurrentLocationWhenParserIsNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser(""); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode node = mapper.readTree(parser); [EOL] JsonLocation location = node.getCurrentLocation(); [EOL] assertNull(location); [EOL] }
public void testGetCurrentLocationWhenParserIsNotNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{\"key\":\"value\"}"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode node = mapper.readTree(parser); [EOL] JsonLocation location = node.getCurrentLocation(); [EOL] assertNotNull(location); [EOL] }
public void testMinimalClassNameIdResolverWithNoPackage() { [EOL] JavaType baseType = TypeFactory.defaultInstance().constructType(NoPackageClass.class); [EOL] MinimalClassNameIdResolver resolver = new MinimalClassNameIdResolver(baseType, TypeFactory.defaultInstance()); [EOL] assertEquals("", resolver._basePackageName); [EOL] assertEquals(".", resolver._basePackagePrefix); [EOL] } [EOL] public void testMinimalClassNameIdResolverWithPackage() { [EOL] JavaType baseType = TypeFactory.defaultInstance().constructType(SomePackageClass.class); [EOL] MinimalClassNameIdResolver resolver = new MinimalClassNameIdResolver(baseType, TypeFactory.defaultInstance()); [EOL] assertTrue(resolver._basePackageName.contains("some.package")); [EOL] assertTrue(resolver._basePackagePrefix.contains("some.package.")); [EOL] }

public void testIdFromValueWithBasePackagePrefix() { [EOL] String basePackagePrefix = "com.example."; [EOL] CustomIdResolver resolver = new CustomIdResolver(basePackagePrefix); [EOL] String className = "com.example.MyClass"; [EOL] Object value = new MyClass(); [EOL] String result = resolver.idFromValue(value); [EOL] assertEquals("MyClass", result); [EOL] }
public void testIdFromValueWithoutBasePackagePrefix() { [EOL] String basePackagePrefix = "com.example."; [EOL] CustomIdResolver resolver = new CustomIdResolver(basePackagePrefix); [EOL] String className = "com.otherpackage.OtherClass"; [EOL] Object value = new OtherClass(); [EOL] String result = resolver.idFromValue(value); [EOL] assertEquals("com.otherpackage.OtherClass", result); [EOL] }
public void testTypeFromIdWithLeadingDotAndEmptyBasePackage() { [EOL] _basePackageName = ""; [EOL] String id = ".TypeName"; [EOL] JavaType result = typeFromId(id); [EOL] assertEquals("TypeName", result.getRawClass().getName()); [EOL] }
public void testTypeFromIdWithLeadingDotAndNonEmptyBasePackage() { [EOL] _basePackageName = "com.example"; [EOL] String id = ".TypeName"; [EOL] JavaType result = typeFromId(id); [EOL] assertEquals("com.example.TypeName", result.getRawClass().getName()); [EOL] }
public void testTypeFromIdWithoutLeadingDot() { [EOL] _basePackageName = "com.example"; [EOL] String id = "TypeName"; [EOL] JavaType result = typeFromId(id); [EOL] assertEquals("TypeName", result.getRawClass().getName()); [EOL] }
public void testBinaryNodeWithFullArray() { [EOL] byte[] inputData = new byte[] {1, 2, 3, 4, 5}; [EOL] int offset = 0; [EOL] int length = inputData.length; [EOL] BinaryNode node = new BinaryNode(inputData, offset, length); [EOL] assertArrayEquals(inputData, node._data); [EOL] }
public void testBinaryNodeWithSubArray() { [EOL] byte[] inputData = new byte[] {1, 2, 3, 4, 5}; [EOL] int offset = 1; [EOL] int length = 3; [EOL] BinaryNode node = new BinaryNode(inputData, offset, length); [EOL] byte[] expectedData = {2, 3, 4}; [EOL] assertArrayEquals(expectedData, node._data); [EOL] }
public void testValueOfWithNullData() { [EOL] BinaryNode result = BinaryNode.valueOf(null); [EOL] assertNull(result); [EOL] }
public void testValueOfWithEmptyData() { [EOL] byte[] data = new byte[0]; [EOL] BinaryNode result = BinaryNode.valueOf(data); [EOL] assertSame(BinaryNode.EMPTY_BINARY_NODE, result); [EOL] }
public void testValueOfWithNonEmptyData() { [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] BinaryNode result = BinaryNode.valueOf(data); [EOL] assertNotNull(result); [EOL] assertNotSame(BinaryNode.EMPTY_BINARY_NODE, result); [EOL] assertTrue(Arrays.equals(data, result.data())); [EOL] }
public void testValueOfWithNullData() { [EOL] byte[] data = null; [EOL] int offset = 0; [EOL] int length = 10; [EOL] BinaryNode result = BinaryNode.valueOf(data, offset, length); [EOL] assertNull(result); [EOL] }
public void testValueOfWithZeroLength() { [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] int offset = 0; [EOL] int length = 0; [EOL] BinaryNode result = BinaryNode.valueOf(data, offset, length); [EOL] assertSame(BinaryNode.EMPTY_BINARY_NODE, result); [EOL] }
public void testValueOfWithNonEmptyData() { [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] int offset = 1; [EOL] int length = 2; [EOL] BinaryNode result = BinaryNode.valueOf(data, offset, length); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length()); [EOL] assertEquals(1, result.byteAt(0)); [EOL] assertEquals(2, result.byteAt(1)); [EOL] }
public void testEquals_Reflexive() { [EOL] BinaryNode node = new BinaryNode(new byte[]{1, 2, 3}); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_Null() { [EOL] BinaryNode node = new BinaryNode(new byte[]{1, 2, 3}); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] BinaryNode node = new BinaryNode(new byte[]{1, 2, 3}); [EOL] assertFalse(node.equals(new Object())); [EOL] } [EOL] public void testEquals_EqualData() { [EOL] BinaryNode node1 = new BinaryNode(new byte[]{1, 2, 3}); [EOL] BinaryNode node2 = new BinaryNode(new byte[]{1, 2, 3}); [EOL] assertTrue(node1.equals(node2)); [EOL] } [EOL] public void testEquals_DifferentData() { [EOL] BinaryNode node1 = new BinaryNode(new byte[]{1, 2, 3}); [EOL] BinaryNode node2 = new BinaryNode(new byte[]{4, 5, 6}); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testHashCodeWithDataNull() { [EOL] MyClass instance = new MyClass(null); [EOL] int expected = -1; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCodeWithDataNotEmpty() { [EOL] byte[] data = new byte[] {1, 2, 3}; [EOL] MyClass instance = new MyClass(data); [EOL] int expected = data.length; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStringWithDefaultVariant() { [EOL] byte[] data = new byte[] { /* some test data */ }; [EOL] Base64Variant variant = Base64Variants.getDefaultVariant(); [EOL] String expected = variant.encode(data, true); [EOL] Base64Data base64Data = new Base64Data(data); [EOL] String result = base64Data.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testObjectBufferConstructor() { [EOL] new ObjectBuffer(); [EOL] }
public void testResetAndStartWithNullFreeBuffer() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setFreeBuffer(null); // Assuming there is a setter for _freeBuffer [EOL] Object[] result = instance.resetAndStart(); [EOL] assertNotNull(result); [EOL] assertEquals(YourClass.INITIAL_CHUNK_SIZE, result.length); [EOL] }
public void testResetAndStartWithNonNullFreeBuffer() { [EOL] YourClass instance = new YourClass(); [EOL] Object[] preallocatedBuffer = new Object[YourClass.INITIAL_CHUNK_SIZE]; [EOL] instance.setFreeBuffer(preallocatedBuffer); // Assuming there is a setter for _freeBuffer [EOL] Object[] result = instance.resetAndStart(); [EOL] assertSame(preallocatedBuffer, result); [EOL] }
public void testAppendCompletedChunkWithSmallChunk() { [EOL] final int SMALL_CHUNK_SIZE = 16; // Example value, adjust according to actual SMALL_CHUNK_SIZE [EOL] Object[] smallChunk = new Object[SMALL_CHUNK_SIZE - 1]; // One less than SMALL_CHUNK_SIZE to trigger the first condition [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name that contains the method [EOL] Object[] result = instance.appendCompletedChunk(smallChunk); [EOL] assertNotNull(result); [EOL] assertEquals(smallChunk.length * 2, result.length); [EOL] }
public void testAppendCompletedChunkWithLargeChunk() { [EOL] final int SMALL_CHUNK_SIZE = 16; // Example value, adjust according to actual SMALL_CHUNK_SIZE [EOL] Object[] largeChunk = new Object[SMALL_CHUNK_SIZE + 1]; // One more than SMALL_CHUNK_SIZE to trigger the second condition [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name that contains the method [EOL] Object[] result = instance.appendCompletedChunk(largeChunk); [EOL] assertNotNull(result); [EOL] assertEquals(largeChunk.length + (largeChunk.length >> 2), result.length); [EOL] }
public void testAppendCompletedChunkWhenBufferHeadIsNull() { [EOL] Object[] chunk = new Object[1]; [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name that contains the method [EOL] instance._bufferHead = null; // Assuming direct access to _bufferHead is possible, otherwise use a setter or constructor [EOL] Object[] result = instance.appendCompletedChunk(chunk); [EOL] assertNotNull(instance._bufferHead); [EOL] assertNotNull(instance._bufferTail); [EOL] assertEquals(instance._bufferHead, instance._bufferTail); [EOL] assertEquals(1, instance._bufferedEntryCount); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= chunk.length); [EOL] }
public void testAppendCompletedChunkWhenBufferHeadIsNotNull() { [EOL] Object[] firstChunk = new Object[1]; [EOL] Object[] secondChunk = new Object[1]; [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name that contains the method [EOL] instance.appendCompletedChunk(firstChunk); [EOL] Object[] result = instance.appendCompletedChunk(secondChunk); [EOL] assertNotNull(instance._bufferHead); [EOL] assertNotEquals(instance._bufferHead, instance._bufferTail); [EOL] assertEquals(2, instance._bufferedEntryCount); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= secondChunk.length); [EOL] }
public void testCompleteAndClearBufferWithEmptyBuffer() { [EOL] Object[] lastChunk = new Object[] {"a", "b", "c"}; [EOL] int lastChunkEntries = lastChunk.length; [EOL] Class<String> componentType = String.class; [EOL] String[] result = completeAndClearBuffer(lastChunk, lastChunkEntries, componentType); [EOL] assertEquals("Result array should have the same size as lastChunk", lastChunkEntries, result.length); [EOL] for (int i = 0; i < lastChunkEntries; i++) { [EOL] assertEquals("Result array should contain the same elements as lastChunk", lastChunk[i], result[i]); [EOL] } [EOL] }
public void testCompleteAndClearBufferWithNonEmptyBuffer() { [EOL] _bufferedEntries = new Object[] {"x", "y"}; [EOL] _bufferedEntryCount = _bufferedEntries.length; [EOL] Object[] lastChunk = new Object[] {"a", "b", "c"}; [EOL] int lastChunkEntries = lastChunk.length; [EOL] Class<String> componentType = String.class; [EOL] String[] result = completeAndClearBuffer(lastChunk, lastChunkEntries, componentType); [EOL] int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL] assertEquals("Result array should have the combined size of lastChunk and buffered entries", totalSize, result.length); [EOL] for (int i = 0; i < _bufferedEntryCount; i++) { [EOL] assertEquals("First part of result array should contain buffered entries", _bufferedEntries[i], result[i]); [EOL] } [EOL] for (int i = 0; i < lastChunkEntries; i++) { [EOL] assertEquals("Second part of result array should contain lastChunk entries", lastChunk[i], result[_bufferedEntryCount + i]); [EOL] } [EOL] }
public void testResetWithNonNullBufferTail() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null); [EOL] JsonToken token = JsonToken.VALUE_STRING; [EOL] tokenBuffer.writeToken(token); [EOL] assertNotNull(tokenBuffer._bufferTail); [EOL] tokenBuffer._reset(); [EOL] assertNull(tokenBuffer._bufferHead); [EOL] assertNull(tokenBuffer._bufferTail); [EOL] assertEquals(0, tokenBuffer._bufferedEntryCount); [EOL] assertNotNull(tokenBuffer._freeBuffer); [EOL] }
public void testResetWithNullBufferTail() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null); [EOL] assertNull(tokenBuffer._bufferTail); [EOL] tokenBuffer._reset(); [EOL] assertNull(tokenBuffer._bufferHead); [EOL] assertNull(tokenBuffer._bufferTail); [EOL] assertEquals(0, tokenBuffer._bufferedEntryCount); [EOL] assertNull(tokenBuffer._freeBuffer); [EOL] }
public void testCopyToWithEmptyBuffer() { [EOL] Object resultArray = new Object[10]; [EOL] Object[] lastChunk = new Object[5]; [EOL] int totalSize = 5; [EOL] int lastChunkEntries = 5; [EOL] _copyTo(resultArray, totalSize, lastChunk, lastChunkEntries); [EOL] }
public void testCopyToWithNonEmptyBuffer() { [EOL] Object resultArray = new Object[10]; [EOL] Object[] lastChunk = new Object[5]; [EOL] int totalSize = 10; [EOL] int lastChunkEntries = 5; [EOL] _bufferHead = new Node(new Object[]{1, 2, 3, 4, 5}, null); [EOL] _copyTo(resultArray, totalSize, lastChunk, lastChunkEntries); [EOL] }
public void testCopyToWithIncorrectTotalSize() { [EOL] Object resultArray = new Object[10]; [EOL] Object[] lastChunk = new Object[5]; [EOL] int totalSize = 9; // Incorrect total size [EOL] int lastChunkEntries = 5; [EOL] try { [EOL] _copyTo(resultArray, totalSize, lastChunk, lastChunkEntries); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNodeConstructorWithNullData() { [EOL] Node node = new Node(null); [EOL] assertNull(node._data); [EOL] }
public void testNodeConstructorWithEmptyArray() { [EOL] Node node = new Node(new Object[]{}); [EOL] assertEquals(0, node._data.length); [EOL] }
public void testNodeConstructorWithNonEmptyArray() { [EOL] Object[] dataArray = new Object[]{"data1", "data2"}; [EOL] Node node = new Node(dataArray); [EOL] assertArrayEquals(dataArray, node._data); [EOL] }
public void testGetDataWhenDataIsNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance._data = null; [EOL] Object[] result = instance.getData(); [EOL] assertNull(result); [EOL] }
public void testGetDataWhenDataIsNotEmpty() { [EOL] YourClass instance = new YourClass(); [EOL] instance._data = new Object[] { "data1", "data2" }; [EOL] Object[] result = instance.getData(); [EOL] assertNotNull(result); [EOL] assertEquals("data1", result[0]); [EOL] assertEquals("data2", result[1]); [EOL] }
public Node next() { [EOL] return _next; [EOL] }
public void testLinkNextWithNullInitialNext() { [EOL] Node node = new Node(); [EOL] Node nextNode = new Node(); [EOL] node.linkNext(nextNode); [EOL] assertEquals(nextNode, node.getNext()); [EOL] } [EOL] public void testLinkNextWithNonNullInitialNext() { [EOL] Node node = new Node(); [EOL] Node initialNext = new Node(); [EOL] node.linkNext(initialNext); [EOL] try { [EOL] Node newNext = new Node(); [EOL] node.linkNext(newNext); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithValueEmbeddedObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = deserialize(jp, null); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeWithValueStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String text = "test"; [EOL] when(jp.getText()).thenReturn(text); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(text, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] BigInteger bigInteger = new BigInteger("12345"); [EOL] when(jp.getBigIntegerValue()).thenReturn(bigInteger); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigInteger, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number number = 12345; [EOL] when(jp.getNumberValue()).thenReturn(number); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(number, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] BigDecimal bigDecimal = new BigDecimal("123.45"); [EOL] when(jp.getDecimalValue()).thenReturn(bigDecimal); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigDecimal, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] double value = 123.45; [EOL] when(jp.getDoubleValue()).thenReturn(value); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(value), result); [EOL] }
public void testDeserializeWithValueTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeWithValueFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeWithValueNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserialize(jp, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithDefaultCaseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); // A token that does not match any case [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithTypeStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(typeDeserializer.deserializeTypedFromAny(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(typeDeserializer).deserializeTypedFromAny(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(typeDeserializer.deserializeTypedFromAny(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(typeDeserializer).deserializeTypedFromAny(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(typeDeserializer.deserializeTypedFromAny(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(typeDeserializer).deserializeTypedFromAny(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("testString"); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeWithTypeValueNumberIntUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("123")); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testDeserializeWithTypeValueNumberIntDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(123); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeWithTypeValueNumberFloatUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithTypeValueNumberFloatDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertEquals(Double.valueOf(123.45), result); [EOL] }
public void testDeserializeWithTypeValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeWithTypeValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeWithTypeValueEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeWithTypeValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithTypeDefaultCase() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(Object.class)).thenThrow(new JsonMappingException("error")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeWithType(jp, ctxt, null); [EOL] }); [EOL] }
public void testFindWithUnlistedClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "UnlistedClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "java.util.Calendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithUtilDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.util.Date.class, "java.util.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DateDeserializer); [EOL] }
public void testFindWithSqlDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.sql.Date.class, "java.sql.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof SqlDateDeserializer); [EOL] }
public void testFindWithTimestampClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Timestamp.class, "java.sql.Timestamp"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimestampDeserializer); [EOL] }
public void testFindWithTimeZoneClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(TimeZone.class, "java.util.TimeZone"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimeZoneDeserializer); [EOL] }
public void testFindWithGregorianCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(GregorianCalendar.class, "java.util.GregorianCalendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(String.class, "java.lang.String"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithNullDate() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_parseDate(jp, ctxt)).thenReturn(null); [EOL] Calendar result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullDateAndNullCalendarClass() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] when(_parseDate(jp, ctxt)).thenReturn(d); [EOL] when(ctxt.constructCalendar(d)).thenReturn(Calendar.getInstance()); [EOL] Calendar result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(d.getTime(), result.getTimeInMillis()); [EOL] }
public void testDeserializeWithNonNullDateAndNonNullCalendarClass() throws IOException, IllegalAccessException, InstantiationException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] when(_parseDate(jp, ctxt)).thenReturn(d); [EOL] when(_calendarClass.newInstance()).thenReturn(Calendar.getInstance()); [EOL] Calendar result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(d.getTime(), result.getTimeInMillis()); [EOL] }
public void testDeserializeWithNonNullDateAndNonNullCalendarClassAndTimeZone() throws IOException, IllegalAccessException, InstantiationException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] when(_parseDate(jp, ctxt)).thenReturn(d); [EOL] when(_calendarClass.newInstance()).thenReturn(Calendar.getInstance()); [EOL] when(ctxt.getTimeZone()).thenReturn(tz); [EOL] Calendar result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(d.getTime(), result.getTimeInMillis()); [EOL] assertEquals(tz, result.getTimeZone()); [EOL] }
public void testDeserializeWithInstantiationException() throws IOException, IllegalAccessException, InstantiationException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] when(_parseDate(jp, ctxt)).thenReturn(d); [EOL] when(_calendarClass.newInstance()).thenThrow(new InstantiationException()); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testEmptyIteratorPrivateConstructor() throws Exception { [EOL] Constructor<EmptyIterator> constructor = EmptyIterator.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Expected IllegalAccessException to be thrown"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testInstanceReturnsSingletonIterator() { [EOL] Iterator<?> iterator1 = SingletonIterator.instance(); [EOL] Iterator<?> iterator2 = SingletonIterator.instance(); [EOL] assertSame(iterator1, iterator2); [EOL] }
public void testHasNext_AlwaysReturnsFalse() { [EOL] YourIteratorClass iterator = new YourIteratorClass(); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testAnnotatedMethodWithNonNullMethod() { [EOL] Method method = String.class.getMethod("isEmpty"); [EOL] AnnotationMap classAnn = new AnnotationMap(); [EOL] AnnotationMap[] paramAnnotations = new AnnotationMap[0]; [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(method, classAnn, paramAnnotations); [EOL] assertNotNull(annotatedMethod); [EOL] }
public void testAnnotatedMethodWithNullMethod() { [EOL] try { [EOL] new AnnotatedMethod(null, new AnnotationMap(), new AnnotationMap[0]); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct AnnotatedMethod with null Method", e.getMessage()); [EOL] } [EOL] }
public void testWithAnnotationsNull() { [EOL] AnnotatedMethod original = new AnnotatedMethod(_method, _annotations, _paramAnnotations); [EOL] AnnotatedMethod newMethod = original.withAnnotations(null); [EOL] assertNotNull(newMethod); [EOL] assertNull(newMethod.getAnnotations()); [EOL] }
public void testWithAnnotationsNonNull() { [EOL] AnnotatedMethod original = new AnnotatedMethod(_method, _annotations, _paramAnnotations); [EOL] AnnotationMap newAnnotations = new AnnotationMap(); [EOL] AnnotatedMethod newMethod = original.withAnnotations(newAnnotations); [EOL] assertNotNull(newMethod); [EOL] assertEquals(newAnnotations, newMethod.getAnnotations()); [EOL] }
public void testGetAnnotated() { [EOL] Method exampleMethod = ExampleClass.class.getMethod("exampleMethodName"); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(exampleMethod); [EOL] Method result = annotatedMethod.getAnnotated(); [EOL] assertNotNull(result); [EOL] assertEquals(exampleMethod, result); [EOL] }
public void testGetName() { [EOL] YourClass instance = new YourClass(); [EOL] String expectedName = "expectedMethodName"; // Replace with the actual method name you expect [EOL] when(instance._method.getName()).thenReturn(expectedName); [EOL] String actualName = instance.getName(); [EOL] assertEquals(expectedName, actualName); [EOL] }
public void testCall1WithValidArg() throws Exception { [EOL] Method mockMethod = mock(Method.class); [EOL] Object expected = new Object(); [EOL] when(mockMethod.invoke(null, validArg)).thenReturn(expected); [EOL] YourClass instance = new YourClass(mockMethod); [EOL] Object result = instance.call1(validArg); [EOL] assertEquals(expected, result); [EOL] }
public void testCall1WithInvalidArg() throws Exception { [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(null, invalidArg)).thenThrow(new IllegalArgumentException()); [EOL] YourClass instance = new YourClass(mockMethod); [EOL] try { [EOL] instance.call1(invalidArg); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCall1WithNullException() throws Exception { [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(null, null)).thenThrow(new NullPointerException()); [EOL] YourClass instance = new YourClass(mockMethod); [EOL] try { [EOL] instance.call1(null); [EOL] fail("Expected a NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetDeclaringClass() { [EOL] Method method = MyClass.class.getMethod("myMethod"); [EOL] MemberMethod memberMethod = new MemberMethod(method); [EOL] Class<?> declaringClass = memberMethod.getDeclaringClass(); [EOL] assertEquals(MyClass.class, declaringClass); [EOL] }
public void testGetMember() { [EOL] YourClass instance = new YourClass(); [EOL] Method expected = instance._method; // You need to set this value to the expected method [EOL] Method result = instance.getMember(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetParameterCountWithNoParameters() { [EOL] TestClass testInstance = new TestClass(); // Replace with actual constructor or factory method [EOL] int parameterCount = testInstance.getParameterCount(); [EOL] assertEquals(0, parameterCount); [EOL] }
public void testGetParameterCountWithParameters() { [EOL] TestClass testInstance = new TestClass(param1, param2, param3); // Replace with actual parameters [EOL] int parameterCount = testInstance.getParameterCount(); [EOL] assertEquals(3, parameterCount); // Replace 3 with the actual number of parameters [EOL] }
public void testGetRawParameterTypes_WithNullParamClasses() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] Method method = obj.getClass().getMethod("myMethod", String.class, Integer.TYPE); [EOL] obj.setMethod(method); // Assuming there is a way to set the method [EOL] Class<?>[] paramClasses = obj.getRawParameterTypes(); [EOL] assertNotNull(paramClasses); [EOL] assertEquals(2, paramClasses.length); [EOL] assertEquals(String.class, paramClasses[0]); [EOL] assertEquals(Integer.TYPE, paramClasses[1]); [EOL] }
public void testGetRawParameterTypes_WithNonNullParamClasses() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] Method method = obj.getClass().getMethod("myMethod", String.class, Integer.TYPE); [EOL] obj.setMethod(method); // Assuming there is a way to set the method [EOL] Class<?>[] expectedParamClasses = new Class<?>[] {String.class, Integer.TYPE}; [EOL] obj.setParamClasses(expectedParamClasses); // Assuming there is a way to set the _paramClasses [EOL] Class<?>[] paramClasses = obj.getRawParameterTypes(); [EOL] assertSame(expectedParamClasses, paramClasses); [EOL] }
public void testGetRawParameterTypeWithValidIndex() { [EOL] Class<?>[] expectedTypes = instance.getRawParameterTypes(); [EOL] for (int i = 0; i < expectedTypes.length; i++) { [EOL] Class<?> result = instance.getRawParameterType(i); [EOL] assertEquals(expectedTypes[i], result); [EOL] } [EOL] } [EOL] public void testGetRawParameterTypeWithInvalidIndex() { [EOL] Class<?>[] types = instance.getRawParameterTypes(); [EOL] int invalidIndex = types.length; [EOL] Class<?> result = instance.getRawParameterType(invalidIndex); [EOL] assertNull(result); [EOL] }
public void testGetGenericParameterTypeWithValidIndex() { [EOL] Type result = instance.getGenericParameterType(0); [EOL] assertNotNull(result); [EOL] }
public void testGetGenericParameterTypeWithInvalidIndex() { [EOL] Type result = instance.getGenericParameterType(Integer.MAX_VALUE); [EOL] assertNull(result); [EOL] }
public void testGetGenericParameterTypeWithExactIndex() { [EOL] Type result = instance.getGenericParameterType(1); [EOL] assertNotNull(result); [EOL] }
public void testGetRawReturnType() { [EOL] Method m = MyTestClass.class.getMethod("myTestMethod"); [EOL] AnnotatedMethod am = new AnnotatedMethod(null, m, null, null); [EOL] Class<?> returnType = am.getRawReturnType(); [EOL] assertEquals(returnType, MyTestClass.class); [EOL] }
public void testBooleanSerializerWithPrimitive() { [EOL] BooleanSerializer serializer = new BooleanSerializer(true); [EOL] assertTrue(serializer._forPrimitive); [EOL] }
public void testBooleanSerializerWithNonPrimitive() { [EOL] BooleanSerializer serializer = new BooleanSerializer(false); [EOL] assertFalse(serializer._forPrimitive); [EOL] }
public void testSerializeTrue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Boolean value = true; [EOL] new BooleanSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBoolean(true); [EOL] }
public void testSerializeFalse() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Boolean value = false; [EOL] new BooleanSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBoolean(false); [EOL] }
public void testTreeTraversingParserWithArrayNode() { [EOL] JsonNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(arrayNode, codec); [EOL] assertEquals(JsonToken.START_ARRAY, parser.nextToken()); [EOL] assertTrue(parser.getNodeCursor() instanceof NodeCursor.Array); [EOL] }
public void testTreeTraversingParserWithObjectNode() { [EOL] JsonNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(objectNode, codec); [EOL] assertEquals(JsonToken.START_OBJECT, parser.nextToken()); [EOL] assertTrue(parser.getNodeCursor() instanceof NodeCursor.Object); [EOL] }
public void testTreeTraversingParserWithRootValueNode() { [EOL] JsonNode valueNode = JsonNodeFactory.instance.textNode("value"); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(valueNode, codec); [EOL] assertNull(parser.nextToken()); [EOL] assertTrue(parser.getNodeCursor() instanceof NodeCursor.RootValue); [EOL] }
public void testSetCodecWithNull() { [EOL] JsonParser jp = new JsonParser(); [EOL] jp.setCodec(null); [EOL] assertNull(jp.getCodec()); [EOL] }
public void testSetCodecWithNonNull() { [EOL] JsonParser jp = new JsonParser(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] jp.setCodec(codec); [EOL] assertEquals(codec, jp.getCodec()); [EOL] }
public void testGetCodecWhenCodecIsNull() { [EOL] JsonParser jp = new JsonParser(null); [EOL] assertNull(jp.getCodec()); [EOL] }
public void testGetCodecWhenCodecIsNotNull() { [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] JsonParser jp = new JsonParser(codec); [EOL] assertSame(codec, jp.getCodec()); [EOL] }
public void testNextTokenWithNextTokenNotNull() throws IOException, JsonParseException { [EOL] JsonToken expectedToken = JsonToken.VALUE_STRING; [EOL] TestParser parser = new TestParser(expectedToken, null, false, null, false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(expectedToken, actualToken); [EOL] assertNull(parser.peekNextToken()); [EOL] }
public void testNextTokenWithStartContainerAndNoChildren() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(null, JsonToken.START_OBJECT, true, new TestNodeCursor(false), false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, actualToken); [EOL] assertFalse(parser.isStartContainer()); [EOL] }
public void testNextTokenWithStartContainerAndHasChildren() throws IOException, JsonParseException { [EOL] TestNodeCursor childCursor = new TestNodeCursor(true); [EOL] childCursor.setNextToken(JsonToken.START_OBJECT); [EOL] TestParser parser = new TestParser(null, JsonToken.START_ARRAY, true, childCursor, false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.START_OBJECT, actualToken); [EOL] assertTrue(parser.isStartContainer()); [EOL] }
public void testNextTokenWithNodeCursorNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(null, null, false, null, false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNull(actualToken); [EOL] assertTrue(parser.isClosed()); [EOL] }
public void testNextTokenWithNodeCursorNotNullAndNextTokenNotNull() throws IOException, JsonParseException { [EOL] TestNodeCursor nodeCursor = new TestNodeCursor(true); [EOL] nodeCursor.setNextToken(JsonToken.VALUE_STRING); [EOL] TestParser parser = new TestParser(null, null, false, nodeCursor, false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, actualToken); [EOL] assertFalse(parser.isStartContainer()); [EOL] }
public void testNextTokenWithNodeCursorNotNullAndNextTokenNull() throws IOException, JsonParseException { [EOL] TestNodeCursor nodeCursor = new TestNodeCursor(true); [EOL] nodeCursor.setNextToken(null); [EOL] nodeCursor.setEndToken(JsonToken.END_OBJECT); [EOL] TestParser parser = new TestParser(null, null, false, nodeCursor, false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, actualToken); [EOL] assertEquals(nodeCursor.getParent(), parser.getNodeCursor()); [EOL] }
public void testSkipChildrenWithStartObject() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_OBJECT); [EOL] JsonParser result = parser.skipChildren(); [EOL] assertEquals(JsonToken.END_OBJECT, parser.getCurrentToken()); [EOL] assertSame(parser, result); [EOL] }
public void testSkipChildrenWithStartArray() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_ARRAY); [EOL] JsonParser result = parser.skipChildren(); [EOL] assertEquals(JsonToken.END_ARRAY, parser.getCurrentToken()); [EOL] assertSame(parser, result); [EOL] }
public void testSkipChildrenWithOtherToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] JsonParser result = parser.skipChildren(); [EOL] assertNotEquals(JsonToken.START_OBJECT, parser.getCurrentToken()); [EOL] assertNotEquals(JsonToken.START_ARRAY, parser.getCurrentToken()); [EOL] assertSame(parser, result); [EOL] }
public void testGetParsingContextWhenCursorIsNull() { [EOL] JsonParser parser = new JsonParser(); // Assuming JsonParser is the class where getParsingContext is defined [EOL] parser._nodeCursor = null; // Assuming _nodeCursor is accessible, otherwise use a method or constructor to set it [EOL] assertNull(parser.getParsingContext()); [EOL] }
public void testGetParsingContextWhenCursorIsNotNull() { [EOL] JsonParser parser = new JsonParser(); [EOL] JsonStreamContext context = new JsonStreamContextImpl(); // Assuming JsonStreamContextImpl is a concrete implementation of JsonStreamContext [EOL] parser._nodeCursor = context; [EOL] assertSame(context, parser.getParsingContext()); [EOL] }
public void testGetTokenLocation() { [EOL] JsonParser parser = new JsonFactory().createParser(""); [EOL] JsonLocation location = parser.getTokenLocation(); [EOL] assertNotNull(location); [EOL] assertEquals(JsonLocation.NA, location); [EOL] }
public void testGetCurrentLocation() { [EOL] JsonParser parser = new JsonFactory().createParser(""); [EOL] JsonLocation location = parser.getCurrentLocation(); [EOL] assertEquals(JsonLocation.NA, location); [EOL] }
public void testGetTextWhenClosed() { [EOL] JsonParser parser = createParserWithClosedState(); [EOL] String result = parser.getText(); [EOL] assertNull(result); [EOL] }
public void testGetTextWithFieldNameToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME, "fieldName"); [EOL] String result = parser.getText(); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetTextWithValueStringToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING, "stringValue"); [EOL] String result = parser.getText(); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetTextWithValueNumberIntToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_INT, 123); [EOL] String result = parser.getText(); [EOL] assertEquals("123", result); [EOL] }
public void testGetTextWithValueNumberFloatToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT, 123.45); [EOL] String result = parser.getText(); [EOL] assertEquals("123.45", result); [EOL] }
public void testGetTextWithValueEmbeddedObjectTokenBinary() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_EMBEDDED_OBJECT, new byte[]{1, 2, 3}); [EOL] String result = parser.getText(); [EOL] assertNotNull(result); [EOL] assertEquals("AQID", result); [EOL] }
public void testGetTextWithValueEmbeddedObjectTokenNonBinary() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_EMBEDDED_OBJECT, "nonBinaryData"); [EOL] String result = parser.getText(); [EOL] assertEquals("nonBinaryData", result); [EOL] }
public void testGetTextWithNullToken() { [EOL] JsonParser parser = createParserWithNullToken(); [EOL] String result = parser.getText(); [EOL] assertNull(result); [EOL] }
public void testGetTextWithUnrecognizedToken() { [EOL] JsonParser parser = createParserWithUnrecognizedToken(); [EOL] String result = parser.getText(); [EOL] assertEquals("unrecognizedTokenAsString", result); [EOL] }
public void testGetNumberTypeWithCurrentNumericNodeNull() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.currentNumericNode()).thenReturn(null); [EOL] NumberType result = parser.getNumberType(); [EOL] assertNull(result); [EOL] }
public void testGetNumberTypeWithCurrentNumericNodeNotNull() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] JsonNode mockNode = mock(JsonNode.class); [EOL] NumberType expectedNumberType = NumberType.INT; [EOL] when(mockNode.numberType()).thenReturn(expectedNumberType); [EOL] when(parser.currentNumericNode()).thenReturn(mockNode); [EOL] NumberType result = parser.getNumberType(); [EOL] assertEquals(expectedNumberType, result); [EOL] }
public void testGetDoubleValueWithIntNode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] double expectedValue = 42.0; [EOL] NumericNode numericNode = factory.numberNode((int) expectedValue); [EOL] JsonParser parser = new TreeTraversingParser(numericNode); [EOL] assertEquals(expectedValue, parser.getDoubleValue(), 0.0); [EOL] }
public void testGetDoubleValueWithDoubleNode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] double expectedValue = 42.0; [EOL] NumericNode numericNode = factory.numberNode(expectedValue); [EOL] JsonParser parser = new TreeTraversingParser(numericNode); [EOL] assertEquals(expectedValue, parser.getDoubleValue(), 0.0); [EOL] }
public void testGetDoubleValueWithFloatNode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] float floatValue = 42.0f; [EOL] double expectedValue = (double) floatValue; [EOL] NumericNode numericNode = factory.numberNode(floatValue); [EOL] JsonParser parser = new TreeTraversingParser(numericNode); [EOL] assertEquals(expectedValue, parser.getDoubleValue(), 0.0); [EOL] }
public void testGetDoubleValueWithLongNode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] long longValue = 42L; [EOL] double expectedValue = (double) longValue; [EOL] NumericNode numericNode = factory.numberNode(longValue); [EOL] JsonParser parser = new TreeTraversingParser(numericNode); [EOL] assertEquals(expectedValue, parser.getDoubleValue(), 0.0); [EOL] }
public void testGetDoubleValueWithBigIntegerNode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] BigInteger bigIntegerValue = new BigInteger("42"); [EOL] double expectedValue = bigIntegerValue.doubleValue(); [EOL] NumericNode numericNode = factory.numberNode(bigIntegerValue); [EOL] JsonParser parser = new TreeTraversingParser(numericNode); [EOL] assertEquals(expectedValue, parser.getDoubleValue(), 0.0); [EOL] }
public void testGetDoubleValueWithBigDecimalNode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] BigDecimal bigDecimalValue = new BigDecimal("42.0"); [EOL] double expectedValue = bigDecimalValue.doubleValue(); [EOL] NumericNode numericNode = factory.numberNode(bigDecimalValue); [EOL] JsonParser parser = new TreeTraversingParser(numericNode); [EOL] assertEquals(expectedValue, parser.getDoubleValue(), 0.0); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsPojo() { [EOL] JsonNode mockNode = mock(POJONode.class); [EOL] when(mockNode.isPojo()).thenReturn(true); [EOL] when(mockNode.isBinary()).thenReturn(false); [EOL] when(((POJONode) mockNode).getPojo()).thenReturn(new Object()); [EOL] Object result = getEmbeddedObject(); [EOL] assertNotNull(result); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsBinary() { [EOL] JsonNode mockNode = mock(BinaryNode.class); [EOL] when(mockNode.isPojo()).thenReturn(false); [EOL] when(mockNode.isBinary()).thenReturn(true); [EOL] when(((BinaryNode) mockNode).binaryValue()).thenReturn(new byte[0]); [EOL] Object result = getEmbeddedObject(); [EOL] assertTrue(result instanceof byte[]); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsNull() { [EOL] JsonNode mockNode = null; [EOL] Object result = getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testGetEmbeddedObjectWhenClosed() { [EOL] _closed = true; [EOL] Object result = getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] Collection<String> handlerResult = new ArrayList<>(); [EOL] when(handleNonArray(jp, ctxt, result)).thenReturn(handlerResult); [EOL] Collection<String> deserialized = deserialize(jp, ctxt, result); [EOL] assertSame(handlerResult, deserialized); [EOL] }
public void testDeserializeUsingCustomDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] JsonDeserializer<String> valueDeserializer = mock(JsonDeserializer.class); [EOL] _valueDeserializer = valueDeserializer; [EOL] Collection<String> customDeserialized = new ArrayList<>(); [EOL] when(deserializeUsingCustom(jp, ctxt, result, valueDeserializer)).thenReturn(customDeserialized); [EOL] Collection<String> deserialized = deserialize(jp, ctxt, result); [EOL] assertSame(customDeserialized, deserialized); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<String> deserialized = deserialize(jp, ctxt, result); [EOL] assertTrue(deserialized.isEmpty()); [EOL] }
public void testDeserializeWithNonNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(_parseString(jp, ctxt)).thenReturn("test"); [EOL] Collection<String> deserialized = deserialize(jp, ctxt, result); [EOL] assertEquals(1, deserialized.size()); [EOL] assertTrue(deserialized.contains("test")); [EOL] }
public void testDeserializeWithNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<String> deserialized = deserialize(jp, ctxt, result); [EOL] assertEquals(1, deserialized.size()); [EOL] assertTrue(deserialized.contains(null)); [EOL] }
public void testHandleNonArrayWithFeatureDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] try { [EOL] handleNonArray(jp, ctxt, result); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Collection<String> updatedResult = handleNonArray(jp, ctxt, result); [EOL] assertTrue(updatedResult.contains(null)); [EOL] }
public void testHandleNonArrayWithNonNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] JsonDeserializer<String> valueDes = mock(JsonDeserializer.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("testValue"); [EOL] Collection<String> updatedResult = handleNonArray(jp, ctxt, result); [EOL] assertTrue(updatedResult.contains("testValue")); [EOL] }
public void testFailingSerializerWithNullMessage() { [EOL] FailingSerializer serializer = new FailingSerializer(null); [EOL] assertNull("Message should be null", serializer.getMessage()); [EOL] }
public void testFailingSerializerWithEmptyMessage() { [EOL] FailingSerializer serializer = new FailingSerializer(""); [EOL] assertEquals("Message should be empty", "", serializer.getMessage()); [EOL] }
public void testFailingSerializerWithNonEmptyMessage() { [EOL] String testMessage = "Test Message"; [EOL] FailingSerializer serializer = new FailingSerializer(testMessage); [EOL] assertEquals("Message should match the provided message", testMessage, serializer.getMessage()); [EOL] }
public void testAsWrapperTypeDeserializerWithVisibleTypeId() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idResolver = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = Object.class; [EOL] AsWrapperTypeDeserializer deserializer = new AsWrapperTypeDeserializer(baseType, idResolver, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNotNull(deserializer); [EOL] assertEquals(typePropertyName, deserializer._typePropertyName); [EOL] assertTrue(deserializer._typeIdVisible); [EOL] assertEquals(defaultImpl, deserializer._defaultImpl); [EOL] }
public void testAsWrapperTypeDeserializerWithInvisibleTypeId() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idResolver = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = false; [EOL] Class<?> defaultImpl = Object.class; [EOL] AsWrapperTypeDeserializer deserializer = new AsWrapperTypeDeserializer(baseType, idResolver, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNotNull(deserializer); [EOL] assertEquals(typePropertyName, deserializer._typePropertyName); [EOL] assertFalse(deserializer._typeIdVisible); [EOL] assertEquals(defaultImpl, deserializer._defaultImpl); [EOL] }
public void testForPropertySameProperty() { [EOL] BeanProperty prop = createMockedBeanProperty(); [EOL] AsWrapperTypeDeserializer deserializer = new AsWrapperTypeDeserializer(null, prop); [EOL] TypeDeserializer result = deserializer.forProperty(prop); [EOL] assertSame(deserializer, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] BeanProperty prop1 = createMockedBeanProperty(); [EOL] BeanProperty prop2 = createMockedBeanProperty(); [EOL] AsWrapperTypeDeserializer deserializer = new AsWrapperTypeDeserializer(null, prop1); [EOL] TypeDeserializer result = deserializer.forProperty(prop2); [EOL] assertNotNull(result); [EOL] assertNotSame(deserializer, result); [EOL] assertTrue(result instanceof AsWrapperTypeDeserializer); [EOL] }
public void testDeserializeTypedFromObject() throws IOException, JsonProcessingException { [EOL] MyConcreteClass instance = new MyConcreteClass(); [EOL] JsonParser mockJsonParser = mock(JsonParser.class); [EOL] DeserializationContext mockDeserializationContext = mock(DeserializationContext.class); [EOL] Object expectedObject = new Object(); [EOL] when(instance._deserialize(mockJsonParser, mockDeserializationContext)).thenReturn(expectedObject); [EOL] Object result = instance.deserializeTypedFromObject(mockJsonParser, mockDeserializationContext); [EOL] assertEquals(expectedObject, result); [EOL] }
public void testDeserializeWithNonStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] try { [EOL] _deserialize(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithNonFieldNameTokenAfterStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] try { [EOL] _deserialize(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithCorrectStartObjectAndFieldNameTokens() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(ctxt.wrongTokenException(any(JsonParser.class), any(JsonToken.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] when(_findDeserializer(ctxt, "typeId")).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeVisibilityAndCorrectTokens() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] TokenBuffer tb = new TokenBuffer(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(ctxt.wrongTokenException(any(JsonParser.class), any(JsonToken.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] when(_findDeserializer(ctxt, "typeId")).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] _typeIdVisible = true; [EOL] _typePropertyName = "type"; [EOL] Object result = _deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithMissingEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(ctxt.wrongTokenException(any(JsonParser.class), any(JsonToken.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] when(_findDeserializer(ctxt, "typeId")).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] try { [EOL] _deserialize(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testRootNameLookupConstructor() { [EOL] RootNameLookup rootNameLookup = new RootNameLookup(); [EOL] assertNotNull(rootNameLookup); [EOL] }
public void testFindRootNameWithNullRootNames() { [EOL] Class<?> rootType = Object.class; [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] PropertyName pname = mock(PropertyName.class); [EOL] when(config.introspectClassAnnotations(rootType)).thenReturn(beanDesc); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(intr.findRootName(ac)).thenReturn(pname); [EOL] when(pname.hasSimpleName()).thenReturn(false); [EOL] SerializedString result = findRootName(rootType, config); [EOL] assertNotNull(result); [EOL] assertEquals(rootType.getSimpleName(), result.getValue()); [EOL] }
public void testFindRootNameWithExistingRootName() { [EOL] Class<?> rootType = Object.class; [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] PropertyName pname = mock(PropertyName.class); [EOL] SerializedString existingName = new SerializedString("existingName"); [EOL] when(config.introspectClassAnnotations(rootType)).thenReturn(beanDesc); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(intr.findRootName(ac)).thenReturn(pname); [EOL] when(pname.hasSimpleName()).thenReturn(true); [EOL] when(pname.getSimpleName()).thenReturn("existingName"); [EOL] LRUMap<ClassKey, SerializedString> _rootNames = new LRUMap<>(20, 200); [EOL] ClassKey key = new ClassKey(rootType); [EOL] _rootNames.put(key, existingName); [EOL] setPrivateField("_rootNames", _rootNames); [EOL] SerializedString result = findRootName(rootType, config); [EOL] assertNotNull(result); [EOL] assertEquals("existingName", result.getValue()); [EOL] }
public void testFindRootNameWithNonExistingRootNameAndSimpleName() { [EOL] Class<?> rootType = Object.class; [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] PropertyName pname = mock(PropertyName.class); [EOL] when(config.introspectClassAnnotations(rootType)).thenReturn(beanDesc); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(intr.findRootName(ac)).thenReturn(pname); [EOL] when(pname.hasSimpleName()).thenReturn(true); [EOL] when(pname.getSimpleName()).thenReturn("SimpleName"); [EOL] LRUMap<ClassKey, SerializedString> _rootNames = new LRUMap<>(20, 200); [EOL] setPrivateField("_rootNames", _rootNames); [EOL] SerializedString result = findRootName(rootType, config); [EOL] assertNotNull(result); [EOL] assertEquals("SimpleName", result.getValue()); [EOL] }
public void testTypeBindingsWithNonNullType() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] JavaType type = typeFactory.constructType(String.class); [EOL] TypeBindings typeBindings = new TypeBindings(typeFactory, type); [EOL] assertNotNull(typeBindings); [EOL] assertEquals(String.class, typeBindings.getRawClass()); [EOL] }
public void testTypeBindingsWithNullType() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] try { [EOL] TypeBindings typeBindings = new TypeBindings(typeFactory, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public JavaType resolveType(Type type) { [EOL] return _typeFactory._constructType(type, this); [EOL] }
public void testFindTypeWithNullBindingsAndNoPlaceholdersOrParentBindings() { [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, null, null, null); [EOL] String name = "T"; [EOL] try { [EOL] resolver.findType(name); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindTypeWithNonNullBindings() { [EOL] Map<String, JavaType> bindings = new HashMap<>(); [EOL] JavaType expectedType = new JavaType(); // Assuming JavaType is a valid type for this context [EOL] bindings.put("T", expectedType); [EOL] MyTypeResolver resolver = new MyTypeResolver(bindings, null, null, null, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be the one from the bindings map", expectedType, actualType); [EOL] }
public void testFindTypeWithPlaceholders() { [EOL] Set<String> placeholders = new HashSet<>(); [EOL] placeholders.add("T"); [EOL] MyTypeResolver resolver = new MyTypeResolver(null, placeholders, null, null, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be UNBOUND when name is in placeholders", UNBOUND, actualType); [EOL] }
public void testFindTypeWithParentBindings() { [EOL] MyTypeResolver parentResolver = new MyTypeResolver(null, null, null, null, null) { [EOL] @Override [EOL] public JavaType findType(String name) { [EOL] return new JavaType(); // Return a new JavaType instance for the parent binding [EOL] } [EOL] }; [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, parentResolver, null, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertNotNull("The type should be resolved by the parent bindings", actualType); [EOL] }
public void testFindTypeWithContextClassNotStatic() { [EOL] Class<?> contextClass = new Object() { }.getClass(); // Anonymous inner class, not static [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, null, contextClass, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be UNBOUND when context class is not static", UNBOUND, actualType); [EOL] }
public void testFindTypeWithStaticContextClass() { [EOL] Class<?> contextClass = MyStaticClass.class; // Assuming MyStaticClass is a static inner class [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, null, contextClass, null); [EOL] String name = "T"; [EOL] try { [EOL] resolver.findType(name); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testHandledTypeReturnsCorrectClass() { [EOL] TypeReference<SomeClass> typeRef = new TypeReference<SomeClass>() {}; [EOL] Class<SomeClass> expectedType = SomeClass.class; [EOL] assertEquals(expectedType, typeRef.handledType()); [EOL] }
public void testWithAdditionalDeserializers_Null() { [EOL] DeserializerFactory factory = new MyDeserializerFactory(); // Replace with actual factory implementation [EOL] DeserializerFactory result = factory.withAdditionalDeserializers(null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testWithAdditionalDeserializers_NonNull() { [EOL] DeserializerFactory factory = new MyDeserializerFactory(); // Replace with actual factory implementation [EOL] Deserializers deserializers = new MyDeserializers(); // Replace with actual Deserializers implementation [EOL] DeserializerFactory result = factory.withAdditionalDeserializers(deserializers); [EOL] assertNotNull(result); [EOL] assertNotSame(factory, result); [EOL] }
public void testWithDeserializerModifier_NullModifier() { [EOL] DeserializerFactory factory = new BasicDeserializerFactory(); [EOL] try { [EOL] factory.withDeserializerModifier(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDeserializerModifier_NonNullModifier() { [EOL] DeserializerFactory factory = new BasicDeserializerFactory(); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { [EOL] }; [EOL] DeserializerFactory resultFactory = factory.withDeserializerModifier(modifier); [EOL] assertNotNull(resultFactory); [EOL] assertNotSame(factory, resultFactory); [EOL] }
public void testFindValueInstantiatorWithAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(new Object()); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullFromAnnotationAndStdInstantiator() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(null); [EOL] when(_findStdValueInstantiator(ctxt.getConfig(), beanDesc)).thenReturn(new StdValueInstantiator(ctxt.getConfig(), beanDesc.getType())); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullFromAnnotationAndConstructDefault() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(null); [EOL] when(_findStdValueInstantiator(ctxt.getConfig(), beanDesc)).thenReturn(null); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithCustomValueInstantiators() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] ValueInstantiators customInstantiators = mock(ValueInstantiators.class); [EOL] when(_factoryConfig.hasValueInstantiators()).thenReturn(true); [EOL] when(_factoryConfig.valueInstantiators()).thenReturn(Collections.singletonList(customInstantiators)); [EOL] when(customInstantiators.findValueInstantiator(any(DeserializationConfig.class), any(BeanDescription.class), any(ValueInstantiator.class))).thenReturn(new StdValueInstantiator(ctxt.getConfig(), beanDesc.getType())); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithCustomValueInstantiatorsReturningNull() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] ValueInstantiators customInstantiators = mock(ValueInstantiators.class); [EOL] when(_factoryConfig.hasValueInstantiators()).thenReturn(true); [EOL] when(_factoryConfig.valueInstantiators()).thenReturn(Collections.singletonList(customInstantiators)); [EOL] when(customInstantiators.findValueInstantiator(any(DeserializationConfig.class), any(BeanDescription.class), any(ValueInstantiator.class))).thenReturn(null); [EOL] assertThrows(JsonMappingException.class, () -> findValueInstantiator(ctxt, beanDesc)); [EOL] }
public void testFindValueInstantiatorWithIncompleteParameter() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] ValueInstantiator instantiator = mock(ValueInstantiator.class); [EOL] AnnotatedParameter nonAnnotatedParam = mock(AnnotatedParameter.class); [EOL] AnnotatedWithParams ctor = mock(AnnotatedWithParams.class); [EOL] when(instantiator.getIncompleteParameter()).thenReturn(nonAnnotatedParam); [EOL] when(nonAnnotatedParam.getOwner()).thenReturn(ctor); [EOL] when(nonAnnotatedParam.getIndex()).thenReturn(0); [EOL] assertThrows(IllegalArgumentException.class, () -> findValueInstantiator(ctxt, beanDesc)); [EOL] }
public void testFindStdValueInstantiatorWithValidConfigAndBeanDescription() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] ValueInstantiator result = _findStdValueInstantiator(config, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindStdValueInstantiatorWithNullConfig() { [EOL] DeserializationConfig config = null; [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] try { [EOL] _findStdValueInstantiator(config, beanDesc); [EOL] fail("Expected JsonMappingException due to null config"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testFindStdValueInstantiatorWithNullBeanDescription() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = null; [EOL] try { [EOL] _findStdValueInstantiator(config, beanDesc); [EOL] fail("Expected JsonMappingException due to null beanDesc"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testConstructDefaultValueInstantiatorWithConcreteType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(ctxt.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] when(javaType.isConcrete()).thenReturn(true); [EOL] ValueInstantiator result = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructDefaultValueInstantiatorWithAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(ctxt.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] when(javaType.isConcrete()).thenReturn(false); [EOL] ValueInstantiator result = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testAddDeserializerConstructorsWithDefaultConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor defaultCtor = mock(AnnotatedConstructor.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(defaultCtor); [EOL] when(creators.hasDefaultCreator()).thenReturn(false); [EOL] when(intr.hasCreatorAnnotation(defaultCtor)).thenReturn(false); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators).setDefaultCreator(defaultCtor); [EOL] }
public void testAddDeserializerConstructorsWithPropertyConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor propertyCtor = mock(AnnotatedConstructor.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(null); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.singletonList(propDef)); [EOL] when(propDef.getConstructorParameter()).thenReturn(param); [EOL] when(param.getOwner()).thenReturn(propertyCtor); [EOL] when(propertyCtor.getParameterCount()).thenReturn(1); [EOL] when(param.getIndex()).thenReturn(0); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] }
public void testAddDeserializerConstructorsWithAnnotatedConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(null); [EOL] when(beanDesc.getConstructors()).thenReturn(Collections.singletonList(ctor)); [EOL] when(ctor.getParameterCount()).thenReturn(1); [EOL] when(intr.hasCreatorAnnotation(ctor)).thenReturn(true); [EOL] when(vchecker.isCreatorVisible(ctor)).thenReturn(true); [EOL] when(ctor.getParameter(0)).thenReturn(param); [EOL] when(intr.findNameForDeserialization(param)).thenReturn(new PropertyName("paramName")); [EOL] when(intr.findInjectableValueId(param)).thenReturn(null); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] verify(creators).addPropertyCreator(eq(ctor), any(CreatorProperty[].class)); [EOL] }
public void testHandleSingleArgumentConstructorWithNameAndInjectId() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(ctor.getParameter(0)).thenReturn(param); [EOL] when(intr.findNameForDeserialization(param)).thenReturn(new PropertyName("testName")); [EOL] when(intr.findInjectableValueId(param)).thenReturn("injectId"); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addPropertyCreator(eq(ctor), any(CreatorProperty[].class)); [EOL] }
public void testHandleSingleArgumentConstructorWithNullNameAndParam() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getParameter(0)).thenReturn(null); [EOL] when(intr.findNameForDeserialization(null)).thenReturn(null); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertFalse(result); [EOL] }
public void testHandleSingleArgumentConstructorWithStringType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(String.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, true, null); [EOL] assertTrue(result); [EOL] verify(creators).addStringCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithIntType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(int.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addIntCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithLongType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(long.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, true, null); [EOL] assertTrue(result); [EOL] verify(creators).addLongCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithDoubleType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(double.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addDoubleCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithIsCreator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addDelegatingCreator(ctor, null); [EOL] }
public void testAddDeserializerFactoryMethodsWithNoArgFactory() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithNoArgFactoryMethod(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospector(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithSingleArgFactoryWithoutInjectableOrName() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithSingleArgFactoryMethod(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithoutInjectableValueIdOrName(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithMultiArgFactoryAnnotatedAsCreator() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithMultiArgFactoryMethod(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithCreatorAnnotation(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithMultiArgFactoryWithoutCreatorAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithMultiArgFactoryMethod(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithoutCreatorAnnotation(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithInvalidConfiguration() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithInvalidConfigurationFactoryMethod(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidConfiguration(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] try { [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testHandleSingleArgumentFactoryWithString() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(String.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] verify(creators).addStringCreator(factory); [EOL] assertTrue(result); [EOL] }
public void testHandleSingleArgumentFactoryWithInt() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(int.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] verify(creators).addIntCreator(factory); [EOL] assertTrue(result); [EOL] }
public void testHandleSingleArgumentFactoryWithLong() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(long.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] verify(creators).addLongCreator(factory); [EOL] assertTrue(result); [EOL] }
public void testHandleSingleArgumentFactoryWithDouble() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(double.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] verify(creators).addDoubleCreator(factory); [EOL] assertTrue(result); [EOL] }
public void testHandleSingleArgumentFactoryWithBoolean() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(boolean.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] verify(creators).addBooleanCreator(factory); [EOL] assertTrue(result); [EOL] }
public void testHandleSingleArgumentFactoryWithCreatorAnnotation() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(Object.class); [EOL] when(intr.hasCreatorAnnotation(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] verify(creators).addDelegatingCreator(factory, null); [EOL] assertTrue(result); [EOL] }
public void testHandleSingleArgumentFactoryWithNoMatch() { [EOL] DeserializationConfig config = null; // Mock or create instance [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(Object.class); [EOL] when(intr.hasCreatorAnnotation(factory)).thenReturn(false); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertFalse(result); [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL] boolean req = (b == null) ? false : b.booleanValue(); [EOL] JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL] BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL] JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL] if (type != t0) { [EOL] property = property.withType(type); [EOL] } [EOL] JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL] type = modifyTypeByAnnotation(ctxt, param, type); [EOL] TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL] if (typeDeser == null) { [EOL] typeDeser = findTypeDeserializer(config, type); [EOL] } [EOL] CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL] if (deser != null) { [EOL] prop = prop.withValueDeserializer(deser); [EOL] } [EOL] return prop; [EOL] }
public void testCreateCollectionDeserializerWithEnumSet() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(EnumSet.class, MyEnum.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof EnumSetDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithAbstractType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(AbstractCollection.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] try { [EOL] createCollectionDeserializer(ctxt, type, beanDesc); [EOL] fail("Expected IllegalArgumentException for abstract collection type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateCollectionDeserializerWithArrayBlockingQueue() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(ArrayBlockingQueue.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ArrayBlockingQueueDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithStringCollection() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(ArrayList.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StringCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(MyCustomCollection.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof MyCustomCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithDeserializerModifiers() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(ArrayList.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] setupDeserializerModifier(); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ModifierCollectionDeserializer); [EOL] }
public void testFindCustomMapDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] MapType type = mock(MapType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_factoryConfig.deserializers()).thenReturn(Collections.singletonList(deserializers)); [EOL] when(deserializers.findMapDeserializer(any(MapType.class), any(DeserializationConfig.class), any(BeanDescription.class), any(KeyDeserializer.class), any(TypeDeserializer.class), any(JsonDeserializer.class))).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = _findCustomMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomMapDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] MapType type = mock(MapType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(_factoryConfig.deserializers()).thenReturn(Collections.singletonList(deserializers)); [EOL] when(deserializers.findMapDeserializer(any(MapType.class), any(DeserializationConfig.class), any(BeanDescription.class), any(KeyDeserializer.class), any(TypeDeserializer.class), any(JsonDeserializer.class))).thenReturn(null); [EOL] JsonDeserializer<?> result = _findCustomMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testCreateEnumDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] JsonDeserializer<?> customDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(_findCustomEnumDeserializer(enumClass, config, beanDesc)).thenReturn(customDeserializer); [EOL] JsonDeserializer<?> result = createEnumDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(customDeserializer, result); [EOL] }
public void testCreateEnumDeserializerWithFactoryMethod() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] AnnotatedMethod factoryMethod = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factoryMethod); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factoryMethod)).thenReturn(true); [EOL] when(factoryMethod.getParameterCount()).thenReturn(1); [EOL] when(factoryMethod.getRawReturnType()).thenReturn(enumClass); [EOL] JsonDeserializer<?> result = createEnumDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof EnumDeserializer); [EOL] }
public void testCreateEnumDeserializerWithInvalidFactoryMethod() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] AnnotatedMethod factoryMethod = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factoryMethod); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factoryMethod)).thenReturn(true); [EOL] when(factoryMethod.getParameterCount()).thenReturn(2); // Invalid parameter count [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] createEnumDeserializer(ctxt, type, beanDesc); [EOL] }); [EOL] assertNotNull(exception); [EOL] assertEquals("Unsuitable method (" + factoryMethod + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")", exception.getMessage()); [EOL] }
public void testCreateEnumDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] JsonDeserializer<?> baseDeserializer = mock(JsonDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] JsonDeserializer<?> modifiedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(_findCustomEnumDeserializer(enumClass, config, beanDesc)).thenReturn(null); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(Collections.emptyList()); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] when(modifier.modifyEnumDeserializer(config, type, beanDesc, baseDeserializer)).thenReturn(modifiedDeserializer); [EOL] JsonDeserializer<?> result = createEnumDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(modifiedDeserializer, result); [EOL] }
public void testFindCustomEnumDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializers.findEnumDeserializer(any(Class.class), any(DeserializationConfig.class), any(BeanDescription.class))) [EOL] .thenReturn(expectedDeserializer); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(_factoryConfig.withAdditionalDeserializers(deserializers)); [EOL] JsonDeserializer<?> result = factory._findCustomEnumDeserializer(Enum.class, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomEnumDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(deserializers.findEnumDeserializer(any(Class.class), any(DeserializationConfig.class), any(BeanDescription.class))) [EOL] .thenReturn(null); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(_factoryConfig.withAdditionalDeserializers(deserializers)); [EOL] JsonDeserializer<?> result = factory._findCustomEnumDeserializer(Enum.class, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindTypeDeserializerWithNoTypeResolverAndNoDefaultTyper() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(mock(BeanDescription.class)); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.getDefaultTyper(any(JavaType.class))).thenReturn(null); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNull(result); [EOL] }
public void testFindTypeDeserializerWithTypeResolver() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] BeanDescription bean = mock(BeanDescription.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(bean.getClassInfo()).thenReturn(ac); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] when(ai.findTypeResolver(config, ac, baseType)).thenReturn(builder); [EOL] when(builder.buildTypeDeserializer(config, baseType, null)).thenReturn(mock(TypeDeserializer.class)); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindTypeDeserializerWithDefaultTyper() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(baseType.isAbstract()).thenReturn(false); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(mock(BeanDescription.class)); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] TypeResolverBuilder<?> defaultTyper = mock(TypeResolverBuilder.class); [EOL] when(config.getDefaultTyper(any(JavaType.class))).thenReturn(defaultTyper); [EOL] when(defaultTyper.buildTypeDeserializer(config, baseType, null)).thenReturn(mock(TypeDeserializer.class)); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindTypeDeserializerWithAbstractTypeAndDefaultImpl() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JavaType defaultType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(baseType.isAbstract()).thenReturn(true); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(mock(BeanDescription.class)); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] when(builder.getDefaultImpl()).thenReturn(null); [EOL] when(config.getDefaultTyper(baseType)).thenReturn(builder); [EOL] when(mapAbstractType(config, baseType)).thenReturn(defaultType); [EOL] when(defaultType.getRawClass()).thenReturn(String.class); [EOL] when(builder.defaultImpl(String.class)).thenReturn(builder); [EOL] when(builder.buildTypeDeserializer(config, baseType, null)).thenReturn(mock(TypeDeserializer.class)); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindPropertyTypeDeserializerWithNullBuilder() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] AnnotatedMember annotated = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findPropertyTypeResolver(config, annotated, baseType)).thenReturn(null); [EOL] TypeDeserializer typeDeserializer = findPropertyTypeDeserializer(config, baseType, annotated); [EOL] assertNotNull(typeDeserializer); [EOL] }
public void testFindPropertyTypeDeserializerWithNonNullBuilder() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] AnnotatedMember annotated = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] TypeDeserializer expectedTypeDeserializer = mock(TypeDeserializer.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findPropertyTypeResolver(config, annotated, baseType)).thenReturn(builder); [EOL] when(config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType)).thenReturn(subtypes); [EOL] when(builder.buildTypeDeserializer(config, baseType, subtypes)).thenReturn(expectedTypeDeserializer); [EOL] TypeDeserializer typeDeserializer = findPropertyTypeDeserializer(config, baseType, annotated); [EOL] assertSame(expectedTypeDeserializer, typeDeserializer); [EOL] }
public void testFindDefaultDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(int.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NumberDeserializers.IntDeserializer); [EOL] }
public void testFindDefaultDeserializerWithStringType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringDeserializer); [EOL] }
public void testFindDefaultDeserializerWithIterableType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeFactory tf = mock(TypeFactory.class); [EOL] when(ctxt.getTypeFactory()).thenReturn(tf); [EOL] when(type.getRawClass()).thenReturn(Iterable.class); [EOL] when(type.containedTypeCount()).thenReturn(1); [EOL] when(type.containedType(0)).thenReturn(TypeFactory.unknownType()); [EOL] when(tf.constructCollectionType(eq(Collection.class), any(JavaType.class))).thenReturn(mock(CollectionType.class)); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindDefaultDeserializerWithUnknownType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.unknown.Type"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindDefaultDeserializerWithJacksonType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.fasterxml.jackson.databind.JsonNode"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindDeserializerFromAnnotationWithNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(null); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerFromAnnotationWithNonNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] Object deserDef = new Object(); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(deserDef); [EOL] when(ctxt.deserializerInstance(ann, deserDef)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testModifyTypeByAnnotationWithSubclass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithDeserializationType(type.getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidSubclass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithKeyClass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(type.getKeyType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotNull(result.getKeyType()); [EOL] }
public void testModifyTypeByAnnotationWithInvalidKeyClass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidKeyDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithContentType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithContentDeserializationType(type.getContentType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotNull(result.getContentType()); [EOL] }
public void testModifyTypeByAnnotationWithInvalidContentType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidContentDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testResolveTypeWithContainerTypeAndKeyDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithKeyDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getKeyType()); [EOL] assertNotNull(resultType.getKeyValueHandler()); [EOL] }
public void testResolveTypeWithContainerTypeAndContentDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithContentDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getContentType()); [EOL] assertNotNull(resultType.getContentValueHandler()); [EOL] }
public void testResolveTypeWithContainerTypeAndContentTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithContentTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getContentType()); [EOL] assertNotNull(resultType.getContentTypeHandler()); [EOL] }
public void testResolveTypeWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType nonContainerType = createNonContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithValueTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, nonContainerType, member); [EOL] assertNotNull(resultType.getTypeHandler()); [EOL] }
public void testResolveTypeWithoutTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType nonContainerType = createNonContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithoutTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, nonContainerType, member); [EOL] assertNull(resultType.getTypeHandler()); [EOL] }
public void testConstructEnumResolverWithJsonValueMethodAndCanOverrideAccessModifiers() { [EOL] DeserializationConfig config = Mockito.mock(DeserializationConfig.class); [EOL] AnnotatedMethod jsonValueMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method accessor = Mockito.mock(Method.class); [EOL] Class<?> enumClass = MyEnum.class; [EOL] Mockito.when(jsonValueMethod.getAnnotated()).thenReturn(accessor); [EOL] Mockito.when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] EnumResolver<?> result = constructEnumResolver(enumClass, config, jsonValueMethod); [EOL] assertNotNull(result); [EOL] }
public void testConstructEnumResolverWithJsonValueMethodAndCannotOverrideAccessModifiers() { [EOL] DeserializationConfig config = Mockito.mock(DeserializationConfig.class); [EOL] AnnotatedMethod jsonValueMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method accessor = Mockito.mock(Method.class); [EOL] Class<?> enumClass = MyEnum.class; [EOL] Mockito.when(jsonValueMethod.getAnnotated()).thenReturn(accessor); [EOL] Mockito.when(config.canOverrideAccessModifiers()).thenReturn(false); [EOL] EnumResolver<?> result = constructEnumResolver(enumClass, config, jsonValueMethod); [EOL] assertNotNull(result); [EOL] }
public void testConstructEnumResolverWithReadEnumsUsingToString() { [EOL] DeserializationConfig config = Mockito.mock(DeserializationConfig.class); [EOL] AnnotatedMethod jsonValueMethod = null; [EOL] Class<?> enumClass = MyEnum.class; [EOL] Mockito.when(config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)).thenReturn(true); [EOL] EnumResolver<?> result = constructEnumResolver(enumClass, config, jsonValueMethod); [EOL] assertNotNull(result); [EOL] }
public void testConstructEnumResolverWithoutJsonValueMethodAndReadEnumsUsingToStringDisabled() { [EOL] DeserializationConfig config = Mockito.mock(DeserializationConfig.class); [EOL] AnnotatedMethod jsonValueMethod = null; [EOL] Class<?> enumClass = MyEnum.class; [EOL] Mockito.when(config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)).thenReturn(false); [EOL] Mockito.when(config.getAnnotationIntrospector()).thenReturn(Mockito.mock(AnnotationIntrospector.class)); [EOL] EnumResolver<?> result = constructEnumResolver(enumClass, config, jsonValueMethod); [EOL] assertNotNull(result); [EOL] }
protected DefaultSerializerProvider() { [EOL] super(); [EOL] }
public void testSerializeValueWithNullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] serializeValue(jgen, value); [EOL] verify(getDefaultNullValueSerializer()).serialize(eq(value), eq(jgen), any()); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueWithoutWrap() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] when(_config.getRootName()).thenReturn(""); [EOL] when(_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)).thenReturn(false); [EOL] serializeValue(jgen, value); [EOL] verify(findTypedValueSerializer(Object.class, true, null)).serialize(eq(value), eq(jgen), any()); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueWithWrap() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] when(_config.getRootName()).thenReturn(null); [EOL] when(_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)).thenReturn(true); [EOL] serializeValue(jgen, value); [EOL] verify(findTypedValueSerializer(Object.class, true, null)).serialize(eq(value), eq(jgen), any()); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueWithRootName() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] String rootName = "root"; [EOL] when(_config.getRootName()).thenReturn(rootName); [EOL] serializeValue(jgen, value); [EOL] verify(findTypedValueSerializer(Object.class, true, null)).serialize(eq(value), eq(jgen), any()); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName(rootName); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeValueWithIOException() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JsonSerializer<Object> ser = findTypedValueSerializer(Object.class, true, null); [EOL] doThrow(new IOException()).when(ser).serialize(eq(value), eq(jgen), any()); [EOL] assertThrows(IOException.class, () -> serializeValue(jgen, value)); [EOL] }
public void testSerializeValueWithGenericException() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JsonSerializer<Object> ser = findTypedValueSerializer(Object.class, true, null); [EOL] Exception exception = new Exception("Test exception"); [EOL] doThrow(exception).when(ser).serialize(eq(value), eq(jgen), any()); [EOL] Exception e = assertThrows(JsonMappingException.class, () -> serializeValue(jgen, value)); [EOL] assertEquals("Test exception", e.getMessage()); [EOL] }
public void testSerializeValueWithNullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] JavaType rootType = null; [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(ser).when(spyMapper).getDefaultNullValueSerializer(); [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] verify(ser).serialize(eq(value), eq(jgen), any(SerializerProvider.class)); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(any(String.class)); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueAndSerializer() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = null; [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(false).when(spyMapper).isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] verify(ser).serialize(eq(value), eq(jgen), any(SerializerProvider.class)); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(any(String.class)); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueAndWrapRoot() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = null; [EOL] PropertyName rootName = new PropertyName("root"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(true).when(spyMapper).isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL] doReturn(Object.class).when(rootType).getRawClass(); [EOL] doReturn(rootName).when(spyMapper).findRootName(any(JavaType.class), any(SerializationConfig.class)); [EOL] doReturn(mock(JsonSerializer.class)).when(spyMapper).findTypedValueSerializer(any(JavaType.class), eq(true), isNull()); [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName(eq("root")); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeValueWithIncompatibleRootType() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = null; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(String.class).when(rootType).getRawClass(); [EOL] doThrow(new IllegalArgumentException("Incompatible types")).when(spyMapper)._reportIncompatibleRootType(value, rootType); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] }); [EOL] assertEquals("Incompatible types", exception.getMessage()); [EOL] }
public void testSerializeValueWithIOException() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = null; [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] IOException ioException = new IOException("IO error"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doThrow(ioException).when(ser).serialize(eq(value), eq(jgen), any(SerializerProvider.class)); [EOL] Exception exception = assertThrows(IOException.class, () -> { [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] }); [EOL] assertEquals("IO error", exception.getMessage()); [EOL] }
public void testSerializeValueWithGenericException() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = null; [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] Exception genericException = new Exception("Generic error"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doThrow(genericException).when(ser).serialize(eq(value), eq(jgen), any(SerializerProvider.class)); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] }); [EOL] assertEquals("Generic error", exception.getMessage()); [EOL] }
public void testFindObjectIdWithNewPojoAndGenerator() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object forPojo = new Object(); [EOL] ObjectIdGenerator<?> generatorType = new ObjectIdGenerators.IntSequenceGenerator(); [EOL] WritableObjectId result = mapper.findObjectId(forPojo, generatorType); [EOL] assertNotNull(result); [EOL] assertSame(generatorType, result.generator); [EOL] }
public void testFindObjectIdWithExistingPojo() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object forPojo = new Object(); [EOL] ObjectIdGenerator<?> generatorType = new ObjectIdGenerators.IntSequenceGenerator(); [EOL] WritableObjectId firstResult = mapper.findObjectId(forPojo, generatorType); [EOL] WritableObjectId secondResult = mapper.findObjectId(forPojo, generatorType); [EOL] assertNotNull(firstResult); [EOL] assertNotNull(secondResult); [EOL] assertSame(firstResult, secondResult); [EOL] }
public void testFindObjectIdWithDifferentGenerators() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object forPojo = new Object(); [EOL] ObjectIdGenerator<?> generatorType1 = new ObjectIdGenerators.IntSequenceGenerator(); [EOL] ObjectIdGenerator<?> generatorType2 = new ObjectIdGenerators.UUIDGenerator(); [EOL] WritableObjectId result1 = mapper.findObjectId(forPojo, generatorType1); [EOL] WritableObjectId result2 = mapper.findObjectId(forPojo, generatorType2); [EOL] assertNotNull(result1); [EOL] assertNotNull(result2); [EOL] assertNotSame(result1.generator, result2.generator); [EOL] }
public void testImplConstructor() { [EOL] Impl instance = new Impl(); [EOL] assertNotNull(instance); [EOL] }
public void testDeserializeWithStartObjectAndVanillaProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] MyDeserializer deserializer = new MyDeserializer(true, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectAndObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] MyDeserializer deserializer = new MyDeserializer(false, objectIdReader); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectWithoutVanillaProcessingOrObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] MyDeserializer deserializer = new MyDeserializer(false, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOther() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] MyDeserializer deserializer = new MyDeserializer(false, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] Object result = _deserializeOther(jp, ctxt, null); [EOL] } [EOL] public void testDeserializeOtherWithValueString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_STRING); [EOL] }
public void testDeserializeOtherWithValueNumberInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_INT); [EOL] }
public void testDeserializeOtherWithValueNumberFloat() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_FLOAT); [EOL] }
public void testDeserializeOtherWithValueEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getEmbeddedObject()).thenReturn(new Object()); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] assertEquals(result, jp.getEmbeddedObject()); [EOL] }
public void testDeserializeOtherWithValueTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_TRUE); [EOL] }
public void testDeserializeOtherWithValueFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_FALSE); [EOL] }
public void testDeserializeOtherWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.START_ARRAY); [EOL] }
public void testDeserializeOtherWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.FIELD_NAME); [EOL] }
public void testDeserializeOtherWithEndObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.END_OBJECT); [EOL] }
public void testDeserializeOtherWithInvalidToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _deserializeOther(jp, ctxt, JsonToken.NOT_AVAILABLE); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testVanillaDeserializeWithEndObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] Object result = vanillaDeserialize(jp, ctxt, JsonToken.END_OBJECT); [EOL] assertSame(bean, result); [EOL] }
public void testVanillaDeserializeWithPropertyDeserialization() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] BeanPropertyMap beanProperties = mock(BeanPropertyMap.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] Object bean = new Object(); [EOL] String propName = "testProperty"; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(beanProperties.find(propName)).thenReturn(prop); [EOL] Object result = vanillaDeserialize(jp, ctxt, JsonToken.FIELD_NAME); [EOL] verify(prop).deserializeAndSet(jp, ctxt, bean); [EOL] assertSame(bean, result); [EOL] }
public void testVanillaDeserializeWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] BeanPropertyMap beanProperties = mock(BeanPropertyMap.class); [EOL] Object bean = new Object(); [EOL] String propName = "unknownProperty"; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(beanProperties.find(propName)).thenReturn(null); [EOL] Object result = vanillaDeserialize(jp, ctxt, JsonToken.FIELD_NAME); [EOL] verify(ctxt).handleUnknownProperty(jp, this, bean, propName); [EOL] assertSame(bean, result); [EOL] }
public void testVanillaDeserializeWithExceptionInPropertyDeserialization() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] BeanPropertyMap beanProperties = mock(BeanPropertyMap.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] Object bean = new Object(); [EOL] String propName = "testProperty"; [EOL] Exception exceptionToThrow = new Exception(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(beanProperties.find(propName)).thenReturn(prop); [EOL] doThrow(exceptionToThrow).when(prop).deserializeAndSet(jp, ctxt, bean); [EOL] try { [EOL] vanillaDeserialize(jp, ctxt, JsonToken.FIELD_NAME); [EOL] fail("Expected exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertSame(exceptionToThrow, e); [EOL] } [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithUnwrapped(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithUnwrapped(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithExternalTypeId(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithExternalTypeId(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationUsingNonDefault() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationUsingNonDefault(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyDeserializeFromObjectUsingNonDefault(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreation() throws IOException, JsonProcessingException { [EOL] setupStandardCreation(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyStandardCreation(result); [EOL] }
public void testDeserializeFromObjectWithViewProcessing() throws IOException, JsonProcessingException { [EOL] setupViewProcessing(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getActiveView()).thenReturn(View.class); [EOL] Object bean = new Object(); [EOL] Object result = deserializeWithView(jp, ctxt, bean, View.class); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithView(result); [EOL] }
public void testDeserializeFromObjectWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] setupIgnorableProps(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorableProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertEquals(bean, result); [EOL] verify(jp, times(1)).skipChildren(); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] setupAnySetter(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("dynamicProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyAnySetterCalled(); [EOL] }
public void testDeserializeFromObjectWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] setupUnknownProperty(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyHandleUnknownPropertyCalled(); [EOL] }
public void testDeserializeWithUnwrappedDelegateDeserializerNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object delegateDeserializedObject = new Object(); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateDeserializedObject); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateDeserializedObject)).thenReturn(new Object()); [EOL] _delegateDeserializer = delegateDeserializer; [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator).createUsingDelegate(ctxt, delegateDeserializedObject); [EOL] }
public void testDeserializeWithUnwrappedPropertyBasedCreatorNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(mock(PropertyBasedCreator.class)); [EOL] when(deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt)).thenReturn(new Object()); [EOL] _propertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(this).deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL] }
public void testDeserializeWithUnwrappedUsingDefault() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(bean, result); [EOL] verify(_valueInstantiator).createUsingDefault(ctxt); [EOL] }
public void testDeserializeWithUnwrappedInjectablesNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] _injectables = new InjectableValues.Std(); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(bean, result); [EOL] verify(this).injectValues(ctxt, bean); [EOL] }
public void testDeserializeWithUnwrappedActiveViewProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(ctxt.getActiveView()).thenReturn(activeView); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] _needViewProcesing = true; [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(_beanProperties.find("propName")).thenReturn(prop); [EOL] when(prop.visibleInView(activeView)).thenReturn(true); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(bean, result); [EOL] verify(prop).deserializeAndSet(jp, ctxt, bean); [EOL] }
public void testDeserializeWithUnwrappedIgnorablePropsContainsPropName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorablePropName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] _ignorableProps = new HashSet<>(Arrays.asList("ignorablePropName")); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(bean, result); [EOL] verify(jp, atLeastOnce()).skipChildren(); [EOL] }
public void testDeserializeWithUnwrappedAnySetterNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] _anySetter = mock(AnySetter.class); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(bean, result); [EOL] verify(_anySetter).deserializeAndSet(jp, ctxt, bean, "propName"); [EOL] }
public void testDeserializeWithUnwrappedUnwrappedPropertyHandlerNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCodec()).thenReturn(mock(ObjectCodec.class)); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] _unwrappedPropertyHandler = mock(UnwrappedPropertyHandler.class); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(bean, result); [EOL] verify(_unwrappedPropertyHandler).processUnwrapped(jp, ctxt, bean, tokens); [EOL] }
protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] tokens.writeStartObject(); [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] t = jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] continue; [EOL] } [EOL] while (t == JsonToken.FIELD_NAME) { [EOL] jp.nextToken(); [EOL] tokens.copyCurrentStructure(jp); [EOL] t = jp.nextToken(); [EOL] } [EOL] tokens.writeEndObject(); [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] tokens.close(); [EOL] throw ctxt.mappingException("Can not create polymorphic instances with unwrapped values"); [EOL] } [EOL] return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] tokens.writeFieldName(propName); [EOL] tokens.copyCurrentStructure(jp); [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] } [EOL] } [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] return null; [EOL] } [EOL] return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL] }
public void testSerializerCacheConstructor() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] assertNotNull(cache); [EOL] }
public void testTypedValueSerializerWithExistingType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(String.class); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProviderInstance().typedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testTypedValueSerializerWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getSerializerProviderInstance().typedValueSerializer(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void addTypedSerializerTest_TypeNotInMap_ShouldAddSerializer() { [EOL] TypeKey typeKey = new TypeKey(new JavaType() {}, true); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() {}; [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(); [EOL] serializerMap.addTypedSerializer(typeKey.getType(), serializer); [EOL] assertEquals(serializer, serializerMap.findTypedSerializer(typeKey.getType())); [EOL] }
public void addTypedSerializerTest_TypeAlreadyInMap_ShouldNotModifyMap() { [EOL] TypeKey typeKey = new TypeKey(new JavaType() {}, true); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() {}; [EOL] JsonSerializer<Object> existingSerializer = new JsonSerializer<Object>() {}; [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(); [EOL] serializerMap.addTypedSerializer(typeKey.getType(), existingSerializer); [EOL] serializerMap.addTypedSerializer(typeKey.getType(), serializer); [EOL] assertNotEquals(serializer, serializerMap.findTypedSerializer(typeKey.getType())); [EOL] assertEquals(existingSerializer, serializerMap.findTypedSerializer(typeKey.getType())); [EOL] }
public void testAddAndResolveNonTypedSerializerWithNonResolvableSerializer() throws JsonMappingException { [EOL] TypeKey typeKey = new TypeKey(type, false); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializerProvider customSerializerProvider = new CustomSerializerProvider(); [EOL] customSerializerProvider.addAndResolveNonTypedSerializer(type, ser, provider); [EOL] assertNull(customSerializerProvider._readOnlyMap); [EOL] verify(ser, never()).resolve(any(SerializerProvider.class)); [EOL] }
public void testAddAndResolveNonTypedSerializerWithResolvableSerializer() throws JsonMappingException { [EOL] TypeKey typeKey = new TypeKey(type, false); [EOL] JsonSerializer<Object> ser = mock(ResolvableSerializer.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializerProvider customSerializerProvider = new CustomSerializerProvider(); [EOL] customSerializerProvider.addAndResolveNonTypedSerializer(type, ser, provider); [EOL] assertNull(customSerializerProvider._readOnlyMap); [EOL] verify(ser).resolve(provider); [EOL] }
public void testHashWithTypedTrue() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] Mockito.when(mockType.hashCode()).thenReturn(123); [EOL] int result = hash(mockType, true); [EOL] assertEquals(121, result); [EOL] }
public void testHashWithTypedFalse() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] Mockito.when(mockType.hashCode()).thenReturn(123); [EOL] int result = hash(mockType, false); [EOL] assertEquals(122, result); [EOL] }
public void testEqualsWithNull() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] assertFalse(key.equals(null)); [EOL] }
public void testEqualsWithSameObject() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] assertTrue(key.equals(key)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] TypeKey key1 = new TypeKey(SomeClass.class, false); [EOL] Object key2 = new Object(); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEqualsWithDifferentTypeKeyClass() { [EOL] TypeKey key1 = new TypeKey(SomeClass.class, false); [EOL] TypeKey key2 = new TypeKey(AnotherClass.class, false) { [EOL] }; [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEqualsWithDifferentIsTyped() { [EOL] TypeKey key1 = new TypeKey(SomeClass.class, false); [EOL] TypeKey key2 = new TypeKey(SomeClass.class, true); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEqualsWithSameClassAndIsTyped() { [EOL] TypeKey key1 = new TypeKey(SomeClass.class, false); [EOL] TypeKey key2 = new TypeKey(SomeClass.class, false); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testEqualsWithSameType() { [EOL] TypeKey key1 = new TypeKey(SomeType.class, false); [EOL] TypeKey key2 = new TypeKey(SomeType.class, false); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testEqualsWithDifferentType() { [EOL] TypeKey key1 = new TypeKey(SomeType.class, false); [EOL] TypeKey key2 = new TypeKey(AnotherType.class, false); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testMemberKeyWithNullMethod() { [EOL] try { [EOL] new MemberKey(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMemberKeyWithValidMethod() throws NoSuchMethodException { [EOL] Method method = String.class.getMethod("substring", int.class, int.class); [EOL] MemberKey key = new MemberKey(method); [EOL] assertEquals("substring", key.getName()); [EOL] assertArrayEquals(new Class<?>[]{int.class, int.class}, key.getArgTypes()); [EOL] }
public void testMemberKeyWithNameAndNullArgTypes() { [EOL] String name = "testMethod"; [EOL] Class<?>[] argTypes = null; [EOL] MemberKey key = new MemberKey(name, argTypes); [EOL] assertEquals(name, key.getName()); [EOL] assertArrayEquals(MemberKey.NO_CLASSES, key.getArgTypes()); [EOL] }
public void testMemberKeyWithNameAndNonNullArgTypes() { [EOL] String name = "testMethod"; [EOL] Class<?>[] argTypes = new Class<?>[]{String.class, Integer.class}; [EOL] MemberKey key = new MemberKey(name, argTypes); [EOL] assertEquals(name, key.getName()); [EOL] assertArrayEquals(argTypes, key.getArgTypes()); [EOL] }
public void testHashCodeWithDifferentNames() { [EOL] MethodKey key1 = new MethodKey("methodOne", new Class<?>[0]); [EOL] MethodKey key2 = new MethodKey("methodTwo", new Class<?>[0]); [EOL] assertNotEquals(key1.hashCode(), key2.hashCode()); [EOL] }
public void testHashCodeWithDifferentArgTypesLengths() { [EOL] MethodKey key1 = new MethodKey("method", new Class<?>[0]); [EOL] MethodKey key2 = new MethodKey("method", new Class<?>[]{String.class}); [EOL] assertNotEquals(key1.hashCode(), key2.hashCode()); [EOL] }
public void testHashCodeWithSameNameAndArgTypes() { [EOL] MethodKey key1 = new MethodKey("method", new Class<?>[]{int.class, String.class}); [EOL] MethodKey key2 = new MethodKey("method", new Class<?>[]{int.class, String.class}); [EOL] assertEquals(key1.hashCode(), key2.hashCode()); [EOL] }
public void testEquals_Reflexive() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key.equals(key)); [EOL] }
public void testEquals_Null() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] Object other = new Object(); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEquals_DifferentName() { [EOL] MemberKey key1 = new MemberKey("method1", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method2", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_DifferentArgLength() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_DifferentArgTypes() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Number.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_SameFields() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testEquals_CompatibleArgTypes() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Number.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testBeanPropertyMapConstructorWithEmptyBuckets() { [EOL] BeanPropertyMap.Bucket[] buckets = new BeanPropertyMap.Bucket[0]; [EOL] int size = 0; [EOL] int index = 0; [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(buckets, size, index); [EOL] assertEquals(0, beanPropertyMap.size()); [EOL] assertEquals(-1, beanPropertyMap._hashMask); [EOL] assertEquals(0, beanPropertyMap._nextBucketIndex); [EOL] }
public void testBeanPropertyMapConstructorWithNonEmptyBuckets() { [EOL] BeanPropertyMap.Bucket[] buckets = new BeanPropertyMap.Bucket[2]; [EOL] int size = 1; [EOL] int index = 1; [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(buckets, size, index); [EOL] assertEquals(1, beanPropertyMap.size()); [EOL] assertEquals(1, beanPropertyMap._hashMask); [EOL] assertEquals(1, beanPropertyMap._nextBucketIndex); [EOL] }
public void testWithPropertyNewProperty() { [EOL] BeanPropertyMap originalMap = new BeanPropertyMap(new Bucket[4], 0, 0); [EOL] SettableBeanProperty newProperty = new MockSettableBeanProperty("newProp"); [EOL] BeanPropertyMap newMap = originalMap.withProperty(newProperty); [EOL] assertNotNull(newMap); [EOL] assertNotSame(originalMap, newMap); [EOL] assertEquals(1, newMap.size()); [EOL] assertNotNull(newMap.find("newProp")); [EOL] }
public void testWithPropertyExistingProperty() { [EOL] BeanPropertyMap originalMap = new BeanPropertyMap(new Bucket[4], 0, 0); [EOL] SettableBeanProperty existingProperty = new MockSettableBeanProperty("existingProp"); [EOL] originalMap = originalMap.withProperty(existingProperty); [EOL] SettableBeanProperty newProperty = new MockSettableBeanProperty("existingProp"); [EOL] BeanPropertyMap newMap = originalMap.withProperty(newProperty); [EOL] assertNotNull(newMap); [EOL] assertSame(originalMap, newMap); [EOL] assertEquals(1, newMap.size()); [EOL] assertSame(newProperty, newMap.find("existingProp")); [EOL] }
public void testForTypeWithIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Integer.TYPE); [EOL] assertTrue(deserializer instanceof IntDeser); [EOL] }
public void testForTypeWithLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Long.TYPE); [EOL] assertTrue(deserializer instanceof LongDeser); [EOL] }
public void testForTypeWithByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Byte.TYPE); [EOL] assertTrue(deserializer instanceof ByteDeser); [EOL] }
public void testForTypeWithShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Short.TYPE); [EOL] assertTrue(deserializer instanceof ShortDeser); [EOL] }
public void testForTypeWithFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Float.TYPE); [EOL] assertTrue(deserializer instanceof FloatDeser); [EOL] }
public void testForTypeWithDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Double.TYPE); [EOL] assertTrue(deserializer instanceof DoubleDeser); [EOL] }
public void testForTypeWithBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Boolean.TYPE); [EOL] assertTrue(deserializer instanceof BooleanDeser); [EOL] }
public void testForTypeWithCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Character.TYPE); [EOL] assertTrue(deserializer instanceof CharDeser); [EOL] }
public void testForTypeWithInvalidType() { [EOL] try { [EOL] YourClass.forType(String.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithEmptyStringAndFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] when(jp.getText()).thenReturn(""); [EOL] int[] result = handleNonArray(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testHandleNonArrayWithNonEmptyStringAndFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] when(jp.getText()).thenReturn("non-empty"); [EOL] int[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] }
public void testHandleNonArrayWithFeatureDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] handleNonArray(jp, ctxt); [EOL] }); [EOL] }
public void testHandleNonArrayWithSingleValueAsArrayFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(42); [EOL] int[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(42, result[0]); [EOL] }
public void testFloatDeserConstructor() { [EOL] FloatDeser deserializer = new FloatDeser(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] float[] expected = new float[]{}; [EOL] when(this.handleNonArray(jp, ctxt)).thenReturn(expected); [EOL] float[] result = this.deserialize(jp, ctxt); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL] when(builder.completeAndClearBuffer(any(float[].class), anyInt())).thenReturn(new float[]{}); [EOL] float[] result = this.deserialize(jp, ctxt); [EOL] assertArrayEquals(new float[]{}, result); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getFloatValue()).thenReturn(1.0f); [EOL] ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL] when(builder.completeAndClearBuffer(any(float[].class), anyInt())).thenReturn(new float[]{1.0f}); [EOL] float[] result = this.deserialize(jp, ctxt); [EOL] assertArrayEquals(new float[]{1.0f}, result); [EOL] }
public void testDeserializeWithFullChunk() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT).thenReturn(JsonToken.VALUE_NUMBER_FLOAT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getFloatValue()).thenReturn(1.0f); [EOL] ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL] float[] chunk = new float[1]; [EOL] when(builder.resetAndStart()).thenReturn(chunk); [EOL] when(builder.appendCompletedChunk(any(float[].class), anyInt())).thenReturn(new float[2]); [EOL] when(builder.completeAndClearBuffer(any(float[].class), anyInt())).thenReturn(new float[]{1.0f, 1.0f}); [EOL] float[] result = this.deserialize(jp, ctxt); [EOL] assertArrayEquals(new float[]{1.0f, 1.0f}, result); [EOL] }
public void testReadIdPropertyWithNonNullObjectIdReaderAndMatchingPropertyName() throws IOException { [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("matchingPropName"); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] when(deserializer.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] objectIdReader.deserializer = deserializer; [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(); [EOL] yourObjectUnderTest._objectIdReader = objectIdReader; [EOL] yourObjectUnderTest._parser = mock(JsonParser.class); [EOL] yourObjectUnderTest._context = mock(DeserializationContext.class); [EOL] boolean result = yourObjectUnderTest.readIdProperty("matchingPropName"); [EOL] assertTrue(result); [EOL] verify(deserializer).deserialize(any(JsonParser.class), any(DeserializationContext.class)); [EOL] }
public void testReadIdPropertyWithNonNullObjectIdReaderAndNonMatchingPropertyName() throws IOException { [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("nonMatchingPropName"); [EOL] objectIdReader.deserializer = mock(JsonDeserializer.class); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(); [EOL] yourObjectUnderTest._objectIdReader = objectIdReader; [EOL] yourObjectUnderTest._parser = mock(JsonParser.class); [EOL] yourObjectUnderTest._context = mock(DeserializationContext.class); [EOL] boolean result = yourObjectUnderTest.readIdProperty("someOtherPropName"); [EOL] assertFalse(result); [EOL] }
public void testReadIdPropertyWithNullObjectIdReader() throws IOException { [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(); [EOL] yourObjectUnderTest._objectIdReader = null; [EOL] yourObjectUnderTest._parser = mock(JsonParser.class); [EOL] yourObjectUnderTest._context = mock(DeserializationContext.class); [EOL] boolean result = yourObjectUnderTest.readIdProperty("anyPropName"); [EOL] assertFalse(result); [EOL] }
public void testBufferPropertyWithNonNullValues() { [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] Object value = new Object(); [EOL] PropertyValueBuffer buffer = new PropertyValueBuffer(null, null, 0); [EOL] buffer.bufferProperty(prop, value); [EOL] assertNotNull(buffer._buffered); [EOL] assertEquals(value, buffer._buffered.getValue()); [EOL] assertEquals(prop, buffer._buffered.getProperty()); [EOL] }
public void testBufferPropertyWithNullInitialBuffer() { [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] Object value = new Object(); [EOL] PropertyValueBuffer buffer = new PropertyValueBuffer(null, null, 0); [EOL] buffer.bufferProperty(null, value); [EOL] assertNull(buffer._buffered.getProperty()); [EOL] assertEquals(value, buffer._buffered.getValue()); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] List<?> value = new ArrayList<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] setElementSerializer(elementSerializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(elementSerializer).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithValueTypeSerializer() throws IOException { [EOL] List<?> value = new ArrayList<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer valueTypeSerializer = mock(TypeSerializer.class); [EOL] setValueTypeSerializer(valueTypeSerializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(valueTypeSerializer).writeTypePrefixForScalar(any(), eq(jgen), any(Class.class)); [EOL] }
public void testSerializeContentsEmptyList() throws IOException { [EOL] List<?> value = new ArrayList<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(provider); [EOL] }
public void testSerializeContentsDynamicSerializer() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add("testString"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] PropertySerializerMap serializers = PropertySerializerMap.emptyForProperties(); [EOL] setDynamicSerializers(serializers); [EOL] JavaType elementType = mock(JavaType.class); [EOL] when(elementType.hasGenericTypes()).thenReturn(false); [EOL] setElementType(elementType); [EOL] when(_findAndAddDynamic(serializers, String.class, provider)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer).serialize(eq("testString"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add("testString"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] PropertySerializerMap serializers = PropertySerializerMap.emptyForProperties(); [EOL] setDynamicSerializers(serializers); [EOL] JavaType elementType = mock(JavaType.class); [EOL] when(elementType.hasGenericTypes()).thenReturn(false); [EOL] setElementType(elementType); [EOL] when(_findAndAddDynamic(serializers, String.class, provider)).thenReturn(serializer); [EOL] doThrow(new IOException()).when(serializer).serialize(eq("testString"), eq(jgen), eq(provider)); [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(provider).handleSecondaryContextualization(serializer, elementType); [EOL] }
public void testSerializeContentsUsingEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(ser); [EOL] }
public void testSerializeContentsUsingNonNullElements() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(ser, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithNullElements() throws IOException { [EOL] List<Object> value = Arrays.asList(null, "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(ser).serialize(eq("elem2"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithTypeSerializer() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser, typeSer); [EOL] verify(ser, times(2)).serializeWithType(any(), eq(jgen), eq(provider), eq(typeSer)); [EOL] }
public void testSerializeContentsUsingWithException() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] doThrow(new IOException()).when(ser).serialize(eq("elem1"), eq(jgen), eq(provider)); [EOL] try { [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(ser).serialize(eq("elem1"), eq(jgen), eq(provider)); [EOL] }
public void testTextNodeWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TextNode result = mapper.textNode(null); [EOL] assertNull(result.asText()); [EOL] }
public void testTextNodeWithEmptyString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TextNode result = mapper.textNode(""); [EOL] assertEquals("", result.asText()); [EOL] }
public void testTextNodeWithRegularString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TextNode result = mapper.textNode("regularString"); [EOL] assertEquals("regularString", result.asText()); [EOL] }
public void testCreateContextualWithDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] CollectionType collectionType = mock(CollectionType.class); [EOL] JsonDeserializer<Object> delegateDeser = mock(JsonDeserializer.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(delegateType); [EOL] when(collectionType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(mock(JsonDeserializer.class)); [EOL] when(ctxt.findDeserializer(any(DeserializationContext.class), eq(delegateType), eq(property))).thenReturn(delegateDeser); [EOL] CollectionDeserializer collectionDeserializer = new CollectionDeserializer(collectionType, null, null, null, valueInstantiator); [EOL] CollectionDeserializer result = collectionDeserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(delegateDeser, result._delegateDeserializer); [EOL] }
public void testCreateContextualWithoutDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] CollectionType collectionType = mock(CollectionType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(collectionType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(valueDeser); [EOL] CollectionDeserializer collectionDeserializer = new CollectionDeserializer(collectionType, null, null, null, valueInstantiator); [EOL] CollectionDeserializer result = collectionDeserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(valueDeser, result._valueDeserializer); [EOL] }
public void testCreateContextualWithNullDelegateType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] CollectionType collectionType = mock(CollectionType.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(null); [EOL] when(collectionType.toString()).thenReturn("CollectionType"); [EOL] CollectionDeserializer collectionDeserializer = new CollectionDeserializer(collectionType, null, null, null, valueInstantiator); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] collectionDeserializer.createContextual(ctxt, property); [EOL] }); [EOL] String expectedMessage = "Invalid delegate-creator definition for CollectionType: value instantiator (" + valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testCreateContextualWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] TypeDeserializer forPropertyValueTypeDeser = mock(TypeDeserializer.class); [EOL] CollectionType collectionType = mock(CollectionType.class); [EOL] when(valueTypeDeser.forProperty(property)).thenReturn(forPropertyValueTypeDeser); [EOL] CollectionDeserializer collectionDeserializer = new CollectionDeserializer(collectionType, null, valueTypeDeser, null, null); [EOL] CollectionDeserializer result = collectionDeserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(forPropertyValueTypeDeser, result._valueTypeDeserializer); [EOL] }
public void testGetContentDeserializerWhenDeserializerIsNull() { [EOL] CustomDeserializer deserializer = new CustomDeserializer(null); [EOL] JsonDeserializer<Object> result = deserializer.getContentDeserializer(); [EOL] assertNull(result); [EOL] }
public void testGetContentDeserializerWhenDeserializerIsNotNull() { [EOL] CustomDeserializer deserializer = new CustomDeserializer(null); [EOL] JsonDeserializer<Object> valueDeserializer = new SomeConcreteJsonDeserializer(); [EOL] deserializer.setDeserializer(valueDeserializer); [EOL] JsonDeserializer<Object> result = deserializer.getContentDeserializer(); [EOL] assertNotNull(result); [EOL] assertSame(valueDeserializer, result); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt))).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(valueInstantiator.createFromString(ctxt, "")).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeUsingDefault() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] Collection<Object> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertNotNull(deserializedResult); [EOL] verify(jp).isExpectedStartArrayToken(); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<Object> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertEquals(result, deserializedResult); [EOL] verify(jp).nextToken(); [EOL] }
public void testDeserializeWithValueNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<Object> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertTrue(deserializedResult.contains(null)); [EOL] verify(jp, times(2)).nextToken(); [EOL] }
public void testDeserializeWithNoTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("testValue"); [EOL] Collection<Object> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertTrue(deserializedResult.contains("testValue")); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(valueDes).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("testValue"); [EOL] Collection<Object> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertTrue(deserializedResult.contains("testValue")); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(valueDes).deserializeWithType(jp, ctxt, typeDeser); [EOL] }
public void testHandleNonArrayWithFeatureDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] try { [EOL] handleNonArray(jp, ctxt, result); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Collection<Object> output = handleNonArray(jp, ctxt, result); [EOL] assertTrue(output.contains(null)); [EOL] }
public void testHandleNonArrayWithValueDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("test"); [EOL] Collection<Object> output = handleNonArray(jp, ctxt, result); [EOL] assertTrue(output.contains("test")); [EOL] }
public void testHandleNonArrayWithValueTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("testWithType"); [EOL] Collection<Object> output = handleNonArray(jp, ctxt, result); [EOL] assertTrue(output.contains("testWithType")); [EOL] }
public void testEnabledByDefaultWhenDefaultStateIsTrue() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(feature.enabledByDefault()); [EOL] }
public void testEnabledByDefaultWhenDefaultStateIsFalse() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return false; [EOL] } [EOL] }; [EOL] assertFalse(feature.enabledByDefault()); [EOL] }
public void testGetMask() { [EOL] for (JsonParser.NumberType type : JsonParser.NumberType.values()) { [EOL] int expectedMask = 1 << type.ordinal(); [EOL] assertEquals(expectedMask, type.getMask()); [EOL] } [EOL] }
public void testSerializeWithType_NullValue() throws IOException, JsonGenerationException { [EOL] JsonSerializable value = null; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] try { [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSerializeWithType_ValidValue() throws IOException, JsonGenerationException { [EOL] JsonSerializable value = mock(JsonSerializable.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(value).serializeWithType(jgen, provider, typeSer); [EOL] }
public void testIteratorSerializerWithStaticTyping() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] TypeSerializer vts = null; [EOL] BeanProperty property = null; [EOL] boolean staticTyping = true; [EOL] IteratorSerializer serializer = new IteratorSerializer(elemType, staticTyping, vts, property); [EOL] assertNotNull(serializer); [EOL] }
public void testIteratorSerializerWithoutStaticTyping() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] TypeSerializer vts = null; [EOL] BeanProperty property = null; [EOL] boolean staticTyping = false; [EOL] IteratorSerializer serializer = new IteratorSerializer(elemType, staticTyping, vts, property); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeContentsWithEmptyIterator() throws IOException { [EOL] Iterator<?> value = Collections.emptyIterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] verifyNoMoreInteractions(provider); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] Iterator<?> value = Arrays.asList((Object) null).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithNonNullElement() throws IOException { [EOL] Object elem = new Object(); [EOL] Iterator<?> value = Arrays.asList(elem).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer).serialize(elem, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithMultipleElementsOfSameType() throws IOException { [EOL] Object elem1 = new Object(); [EOL] Object elem2 = new Object(); [EOL] Iterator<?> value = Arrays.asList(elem1, elem2).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithMultipleDifferentTypes() throws IOException { [EOL] Object elem1 = new Object(); [EOL] String elem2 = "test"; [EOL] Iterator<?> value = Arrays.asList(elem1, elem2).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializerForObject = mock(JsonSerializer.class); [EOL] JsonSerializer<String> serializerForString = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializerForObject); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(serializerForString); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializerForObject).serialize(elem1, jgen, provider); [EOL] verify(serializerForString).serialize(elem2, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] Object elem = new Object(); [EOL] Iterator<?> value = Arrays.asList(elem).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider, typeSer); [EOL] verify(serializer).serializeWithType(elem, jgen, provider, typeSer); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testTypedValueSerializerWithNullCacheKey() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] JavaType type = new SimpleType(String.class); [EOL] JsonSerializer<Object> serializer = cache.typedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testTypedValueSerializerWithNonNullCacheKey() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] JavaType type = new SimpleType(String.class); [EOL] cache.typedValueSerializer(type); // This will set the _cacheKey [EOL] JsonSerializer<Object> serializer = cache.typedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL] JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL] if (ser != null) { [EOL] return ser; [EOL] } [EOL] final SerializationConfig config = prov.getConfig(); [EOL] if (type.isContainerType()) { [EOL] if (!staticTyping) { [EOL] staticTyping = usesStaticTyping(config, beanDesc, null); [EOL] } [EOL] ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL] if (ser != null) { [EOL] return ser; [EOL] } [EOL] } else { [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findSerializer(config, type, beanDesc); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL] if (ser == null) { [EOL] ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] if (ser == null) { [EOL] ser = findBeanSerializer(prov, type, beanDesc); [EOL] if (ser == null) { [EOL] ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (ser != null) { [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifySerializer(config, beanDesc, ser); [EOL] } [EOL] } [EOL] } [EOL] return ser; [EOL] }
public void testConstructBeanSerializerWithObjectClass() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(Object.class); [EOL] when(prov.getUnknownTypeSerializer(Object.class)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(mock(BeanSerializerModifier.class))); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithoutModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(false); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithAnyGetter() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] AnnotatedMember anyGetter = mock(AnnotatedMember.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(anyGetter); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(false); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithNullSerializer() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(false); [EOL] when(builder.build()).thenReturn(null); [EOL] when(beanDesc.hasKnownClassAnnotations()).thenReturn(true); [EOL] when(builder.createDummy()).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL] ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL] if (objectIdInfo == null) { [EOL] return null; [EOL] } [EOL] ObjectIdGenerator<?> gen; [EOL] Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL] if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL] String propName = objectIdInfo.getPropertyName(); [EOL] BeanPropertyWriter idProp = null; [EOL] for (int i = 0, len = props.size(); ; ++i) { [EOL] if (i == len) { [EOL] throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL] } [EOL] BeanPropertyWriter prop = props.get(i); [EOL] if (propName.equals(prop.getName())) { [EOL] idProp = prop; [EOL] if (i > 0) { [EOL] props.remove(i); [EOL] props.add(0, idProp); [EOL] } [EOL] break; [EOL] } [EOL] } [EOL] JavaType idType = idProp.getType(); [EOL] gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL] return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL] } [EOL] JavaType type = prov.constructType(implClass); [EOL] JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL] gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL] return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
public void testFindBeanPropertiesWithEmptyProperties() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.emptyList()); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNull(result); [EOL] }
public void testFindBeanPropertiesWithIgnorableTypes() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(mock(BeanPropertyDefinition.class)); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithSetterlessGetters() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(true); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithTypeId() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.isTypeId()).thenReturn(true); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithBackReference() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] AnnotationIntrospector.ReferenceProperty refType = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(property.findReferenceType()).thenReturn(refType); [EOL] when(refType.isBackReference()).thenReturn(true); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithAccessorMethod() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMethod accessor = mock(AnnotatedMethod.class); [EOL] when(property.getAccessor()).thenReturn(accessor); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithAccessorField() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] AnnotatedField accessor = mock(AnnotatedField.class); [EOL] when(property.getAccessor()).thenReturn(accessor); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testRemoveIgnorableTypesWithNoProperties() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testRemoveIgnorableTypesWithIgnorableProperty() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition ignorableProperty = new BeanPropertyDefinition(...); // Provide necessary initialization [EOL] properties.add(ignorableProperty); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.isIgnorableType(any(AnnotatedClass.class))).thenReturn(Boolean.TRUE); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testRemoveIgnorableTypesWithNonIgnorableProperty() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition nonIgnorableProperty = new BeanPropertyDefinition(...); // Provide necessary initialization [EOL] properties.add(nonIgnorableProperty); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.isIgnorableType(any(AnnotatedClass.class))).thenReturn(Boolean.FALSE); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertFalse(properties.isEmpty()); [EOL] assertEquals(1, properties.size()); [EOL] assertSame(nonIgnorableProperty, properties.get(0)); [EOL] }
public void testRemoveIgnorableTypesWithNullAccessor() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyWithNullAccessor = new BeanPropertyDefinition(...); // Provide necessary initialization [EOL] when(propertyWithNullAccessor.getAccessor()).thenReturn(null); [EOL] properties.add(propertyWithNullAccessor); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testRemoveSetterlessGetters_AllPropertiesCouldDeserialize() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(new BeanPropertyDefinition(...)); // Provide necessary initialization [EOL] properties.add(new BeanPropertyDefinition(...)); // Provide necessary initialization [EOL] removeSetterlessGetters(config, beanDesc, properties); [EOL] assertEquals("Expected no properties to be removed", 2, properties.size()); [EOL] }
public void testRemoveSetterlessGetters_SomePropertiesCouldNotDeserialize() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(new BeanPropertyDefinition(...)); // Property that could deserialize [EOL] properties.add(new BeanPropertyDefinition(...)); // Property that could not deserialize [EOL] properties.add(new BeanPropertyDefinition(...)); // Property that is explicitly included [EOL] removeSetterlessGetters(config, beanDesc, properties); [EOL] assertEquals("Expected one property to be removed", 2, properties.size()); [EOL] }
public void testRemoveSetterlessGetters_NoPropertiesCouldDeserialize() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(new BeanPropertyDefinition(...)); // Provide necessary initialization [EOL] properties.add(new BeanPropertyDefinition(...)); // Provide necessary initialization [EOL] removeSetterlessGetters(config, beanDesc, properties); [EOL] assertEquals("Expected all properties to be removed", 0, properties.size()); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true); [EOL] assertTrue(mapper.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, false); [EOL] assertFalse(mapper.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testCanOverrideAccessModifiersTrue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertTrue(mapper.canOverrideAccessModifiers()); [EOL] }
public void testCanOverrideAccessModifiersFalse() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] assertFalse(mapper.canOverrideAccessModifiers()); [EOL] }
public void testEnumMapDeserializerWithNonNullValues() { [EOL] JavaType mapType = TypeFactory.defaultInstance().constructMapType(EnumMap.class, MyEnum.class, String.class); [EOL] JsonDeserializer<?> keyDeserializer = new MyEnumDeserializer(); [EOL] JsonDeserializer<?> valueDeserializer = new StdDeserializer.StringDeserializer(); [EOL] TypeDeserializer valueTypeDeserializer = new MyTypeDeserializer(); [EOL] EnumMapDeserializer deserializer = new EnumMapDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer); [EOL] assertNotNull(deserializer); [EOL] assertEquals(EnumMap.class, deserializer.handledType()); [EOL] assertEquals(MyEnum.class, deserializer._enumClass); [EOL] assertNotNull(deserializer._keyDeserializer); [EOL] assertNotNull(deserializer._valueDeserializer); [EOL] assertNotNull(deserializer._valueTypeDeserializer); [EOL] }
public void testEnumMapDeserializerWithNullValues() { [EOL] JavaType mapType = TypeFactory.defaultInstance().constructMapType(EnumMap.class, MyEnum.class, String.class); [EOL] EnumMapDeserializer deserializer = new EnumMapDeserializer(mapType, null, null, null); [EOL] assertNotNull(deserializer); [EOL] assertEquals(EnumMap.class, deserializer.handledType()); [EOL] assertEquals(MyEnum.class, deserializer._enumClass); [EOL] assertNull(deserializer._keyDeserializer); [EOL] assertNull(deserializer._valueDeserializer); [EOL] assertNull(deserializer._valueTypeDeserializer); [EOL] }
public void testWithResolvedSameDeserializers() { [EOL] JsonDeserializer<?> keyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] EnumMapDeserializer original = new EnumMapDeserializer(null, keyDeserializer, valueDeserializer, valueTypeDeser); [EOL] EnumMapDeserializer result = original.withResolved(keyDeserializer, valueDeserializer, valueTypeDeser); [EOL] assertSame(original, result); [EOL] }
public void testWithResolvedDifferentKeyDeserializer() { [EOL] JsonDeserializer<?> keyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newKeyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] EnumMapDeserializer original = new EnumMapDeserializer(null, keyDeserializer, valueDeserializer, valueTypeDeser); [EOL] EnumMapDeserializer result = original.withResolved(newKeyDeserializer, valueDeserializer, valueTypeDeser); [EOL] assertNotSame(original, result); [EOL] assertNotNull(result); [EOL] }
public void testWithResolvedDifferentValueDeserializer() { [EOL] JsonDeserializer<?> keyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newValueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] EnumMapDeserializer original = new EnumMapDeserializer(null, keyDeserializer, valueDeserializer, valueTypeDeser); [EOL] EnumMapDeserializer result = original.withResolved(keyDeserializer, newValueDeserializer, valueTypeDeser); [EOL] assertNotSame(original, result); [EOL] assertNotNull(result); [EOL] }
public void testWithResolvedDifferentValueTypeDeserializer() { [EOL] JsonDeserializer<?> keyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] TypeDeserializer newValueTypeDeser = mock(TypeDeserializer.class); [EOL] EnumMapDeserializer original = new EnumMapDeserializer(null, keyDeserializer, valueDeserializer, valueTypeDeser); [EOL] EnumMapDeserializer result = original.withResolved(keyDeserializer, valueDeserializer, newValueTypeDeser); [EOL] assertNotSame(original, result); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNullKeyAndValueDeserializers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(mapType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.findContextualValueDeserializer(keyType, property)).thenReturn(mock(JsonDeserializer.class)); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(mock(JsonDeserializer.class)); [EOL] TestDeserializer deserializer = new TestDeserializer(mapType, null, null, null); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullValueDeserializerNotContextual() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TestDeserializer deserializer = new TestDeserializer(mapType, null, valueDeserializer, null); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertSame(valueDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullValueDeserializerContextual() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] ContextualDeserializer valueDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<?> contextualValueDeserializer = mock(JsonDeserializer.class); [EOL] when(valueDeserializer.createContextual(ctxt, property)).thenReturn(contextualValueDeserializer); [EOL] TestDeserializer deserializer = new TestDeserializer(mapType, null, valueDeserializer, null); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertSame(contextualValueDeserializer, result); [EOL] }
public void testCreateContextualWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] TypeDeserializer propertyTypeDeserializer = mock(TypeDeserializer.class); [EOL] when(valueTypeDeserializer.forProperty(property)).thenReturn(propertyTypeDeserializer); [EOL] TestDeserializer deserializer = new TestDeserializer(null, null, null, valueTypeDeserializer); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testIsCachable() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] boolean result = mapper.getSerializationConfig().isCachable(); [EOL] assertTrue(result); [EOL] }
public void testDeserializeWithNonStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] try { [EOL] new TestDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("KEY"); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] TestDeserializer deserializer = new TestDeserializer(); [EOL] deserializer._keyDeserializer = mock(JsonDeserializer.class); [EOL] deserializer._valueDeserializer = mock(JsonDeserializer.class); [EOL] EnumMap<?, ?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithUnknownEnumValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM_VALUE"); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] TestDeserializer deserializer = new TestDeserializer(); [EOL] deserializer._keyDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializer._keyDeserializer.deserialize(jp, ctxt)).thenReturn(null); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("KEY"); [EOL] TestDeserializer deserializer = new TestDeserializer(); [EOL] deserializer._keyDeserializer = mock(JsonDeserializer.class); [EOL] deserializer._valueDeserializer = mock(JsonDeserializer.class); [EOL] EnumMap<?, ?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsValue(null)); [EOL] }
public void testDeserializeWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("KEY"); [EOL] TestDeserializer deserializer = new TestDeserializer(); [EOL] deserializer._keyDeserializer = mock(JsonDeserializer.class); [EOL] deserializer._valueDeserializer = mock(JsonDeserializer.class); [EOL] deserializer._valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] EnumMap<?, ?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(deserializer._valueDeserializer, never()).deserialize(jp, ctxt); [EOL] verify(deserializer._valueDeserializer).deserializeWithType(jp, ctxt, deserializer._valueTypeDeserializer); [EOL] }
private EnumMap<?, ?> constructMap() { [EOL] return new EnumMap(_enumClass); [EOL] }
public void testFindWithPrimitiveIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Integer.TYPE, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertEquals(IntegerDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Boolean.TYPE, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertEquals(BooleanDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Long.TYPE, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertEquals(LongDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Double.TYPE, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertEquals(DoubleDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Character.TYPE, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertEquals(CharacterDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Byte.TYPE, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertEquals(ByteDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Short.TYPE, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertEquals(ShortDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Float.TYPE, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertEquals(FloatDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithWrapperIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Integer.class, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertEquals(IntegerDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Boolean.class, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertEquals(BooleanDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Long.class, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertEquals(LongDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Double.class, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertEquals(DoubleDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Character.class, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertEquals(CharacterDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Byte.class, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertEquals(ByteDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Short.class, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertEquals(ShortDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Float.class, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertEquals(FloatDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithNumberType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Number.class, "java.lang.Number"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof NumberDeserializer); [EOL] assertEquals(NumberDeserializer.instance, deserializer); [EOL] }
public void testFindWithBigDecimalType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(BigDecimal.class, "java.math.BigDecimal"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigDecimalDeserializer); [EOL] assertEquals(BigDecimalDeserializer.instance, deserializer); [EOL] }
public void testFindWithBigIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(BigInteger.class, "java.math.BigInteger"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigIntegerDeserializer); [EOL] assertEquals(BigIntegerDeserializer.instance, deserializer); [EOL] }
public void testFindWithUnrecognizedType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Object.class, "java.lang.Object"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithNullType() { [EOL] try { [EOL] YourClass.find(null, "java.lang.Integer"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetNullValueWhenNullValueIsSet() { [EOL] Object expectedNullValue = new Object(); [EOL] ValueInstantiator instantiator = new ValueInstantiator(expectedNullValue); [EOL] Object actualNullValue = instantiator.getNullValue(); [EOL] assertEquals(expectedNullValue, actualNullValue); [EOL] }
public void testGetNullValueWhenNullValueIsNotSet() { [EOL] ValueInstantiator instantiator = new ValueInstantiator(null); [EOL] Object actualNullValue = instantiator.getNullValue(); [EOL] assertNull(actualNullValue); [EOL] }
public void testDeserializeKeyWithNull() throws IOException { [EOL] Object result = deserializer.deserializeKey(null, deserializationContext); [EOL] assertNull(result); [EOL] }
public void testDeserializeKeyWithValidKey() throws IOException { [EOL] String validKey = "validKey"; [EOL] when(deserializer._parse(validKey, deserializationContext)).thenReturn(new Object()); [EOL] Object result = deserializer.deserializeKey(validKey, deserializationContext); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeKeyWithInvalidKeyAndException() throws IOException { [EOL] String invalidKey = "invalidKey"; [EOL] when(deserializer._parse(invalidKey, deserializationContext)).thenThrow(new Exception("invalid")); [EOL] try { [EOL] deserializer.deserializeKey(invalidKey, deserializationContext); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertTrue(e instanceof deserializationContext.weirdKeyException.class); [EOL] assertTrue(e.getMessage().contains("not a valid representation: invalid")); [EOL] } [EOL] }
public void testDeserializeKeyWithInvalidKeyAndEnumClass() throws IOException { [EOL] String invalidKey = "invalidKey"; [EOL] when(_keyClass.isEnum()).thenReturn(true); [EOL] when(deserializationContext.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] when(deserializer._parse(invalidKey, deserializationContext)).thenReturn(null); [EOL] Object result = deserializer.deserializeKey(invalidKey, deserializationContext); [EOL] assertNull(result); [EOL] }
public void testDeserializeKeyWithInvalidKeyAndNonEnumClass() throws IOException { [EOL] String invalidKey = "invalidKey"; [EOL] when(_keyClass.isEnum()).thenReturn(false); [EOL] when(deserializer._parse(invalidKey, deserializationContext)).thenReturn(null); [EOL] try { [EOL] deserializer.deserializeKey(invalidKey, deserializationContext); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertTrue(e instanceof deserializationContext.weirdKeyException.class); [EOL] assertTrue(e.getMessage().contains("not a valid representation")); [EOL] } [EOL] }
public void testLocaleKDNotNull() { [EOL] LocaleKD localeKD = new LocaleKD(); [EOL] assertNotNull(localeKD); [EOL] }
protected Locale _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL] try { [EOL] return _localeDeserializer._deserialize(key, ctxt); [EOL] } catch (IOException e) { [EOL] throw ctxt.weirdKeyException(_keyClass, key, "unable to parse key as locale"); [EOL] } [EOL] }
public void testParseWithFactory() throws JsonMappingException { [EOL] MyFactory factory = mock(MyFactory.class); [EOL] MyEnum expected = MyEnum.VALUE_ONE; [EOL] when(factory.call1("VALUE_ONE")).thenReturn(expected); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(factory, null, MyEnum.class); [EOL] Object result = deserializer._parse("VALUE_ONE", null); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithResolver() throws JsonMappingException { [EOL] MyEnumResolver resolver = mock(MyEnumResolver.class); [EOL] MyEnum expected = MyEnum.VALUE_TWO; [EOL] when(resolver.findEnum("VALUE_TWO")).thenReturn(expected); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(null, resolver, MyEnum.class); [EOL] Object result = deserializer._parse("VALUE_TWO", null); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithFactoryException() { [EOL] MyFactory factory = mock(MyFactory.class); [EOL] when(factory.call1("INVALID")).thenThrow(new IllegalArgumentException()); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(factory, null, MyEnum.class); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] deserializer._parse("INVALID", null); [EOL] }); [EOL] }
public void testParseWithResolverReturningNullAndFeatureDisabled() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] MyEnumResolver resolver = mock(MyEnumResolver.class); [EOL] when(resolver.findEnum("UNKNOWN")).thenReturn(null); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(null, resolver, MyEnum.class); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializer._parse("UNKNOWN", ctxt); [EOL] }); [EOL] }
public void testParseWithResolverReturningNullAndFeatureEnabled() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] MyEnumResolver resolver = mock(MyEnumResolver.class); [EOL] when(resolver.findEnum("UNKNOWN")).thenReturn(null); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(null, resolver, MyEnum.class); [EOL] Object result = deserializer._parse("UNKNOWN", ctxt); [EOL] assertNull(result); [EOL] }
public void testObjectConstructorWithObjectNode() { [EOL] JsonNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] NodeCursor parentCursor = new NodeCursor.RootCursor(null); [EOL] TokenBufferReadContext objectContext = new TokenBufferReadContext(objectNode, parentCursor); [EOL] assertNotNull(objectContext); [EOL] assertTrue(objectContext.inObject()); [EOL] }
public void testObjectConstructorWithNonObjectNode() { [EOL] JsonNode nonObjectNode = new TextNode("text"); [EOL] NodeCursor parentCursor = new NodeCursor.RootCursor(null); [EOL] try { [EOL] TokenBufferReadContext objectContext = new TokenBufferReadContext(nonObjectNode, parentCursor); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testNextTokenWithEmptyContents() { [EOL] MyIteratorWrapper contents = new MyIteratorWrapper(Collections.emptyIterator()); [EOL] JsonTokenReader reader = new JsonTokenReader(contents); [EOL] JsonToken token = reader.nextToken(); [EOL] assertNull(token); [EOL] }
public void testNextTokenWithNonEmptyContents() { [EOL] Map.Entry<String, JsonToken> entry = new AbstractMap.SimpleEntry<>("key", JsonToken.VALUE_STRING); [EOL] MyIteratorWrapper contents = new MyIteratorWrapper(Collections.singleton(entry).iterator()); [EOL] JsonTokenReader reader = new JsonTokenReader(contents); [EOL] JsonToken token1 = reader.nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, token1); [EOL] JsonToken token2 = reader.nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, token2); [EOL] }
public void testNextTokenWithNullCurrent() { [EOL] Map.Entry<String, JsonToken> entry = new AbstractMap.SimpleEntry<>(null, null); [EOL] MyIteratorWrapper contents = new MyIteratorWrapper(Collections.singleton(entry).iterator()); [EOL] JsonTokenReader reader = new JsonTokenReader(contents); [EOL] JsonToken token1 = reader.nextToken(); [EOL] assertNull(token1); [EOL] JsonToken token2 = reader.nextToken(); [EOL] assertNull(token2); [EOL] }
public void testEndToken() { [EOL] JsonToken result = endToken(); [EOL] assertEquals(JsonToken.END_OBJECT, result); [EOL] }
public void testCurrentNodeWhenCurrentIsNull() { [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] assertNull(tb.currentNode()); [EOL] }
public void testCurrentNodeWhenCurrentIsNotNull() { [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] tb.writeStartObject(); [EOL] assertNotNull(tb.currentNode()); [EOL] }
public void testCurrentHasChildrenWithEmptyContainerNode() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ContainerNode<?> emptyNode = nodeFactory.objectNode(); // Assuming currentNode() would return this node [EOL] TokenBuffer buffer = new TokenBuffer(null, false); // Assuming this is the class that contains currentHasChildren() [EOL] buffer.writeStartObject(); // Set up the current node [EOL] assertFalse(buffer.currentHasChildren()); [EOL] }
public void testCurrentHasChildrenWithNonEmptyContainerNode() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ContainerNode<?> nonEmptyNode = nodeFactory.objectNode(); [EOL] nonEmptyNode.put("key", "value"); // Add an element to make it non-empty [EOL] TokenBuffer buffer = new TokenBuffer(null, false); // Assuming this is the class that contains currentHasChildren() [EOL] buffer.writeStartObject(); // Set up the current node [EOL] assertTrue(buffer.currentHasChildren()); [EOL] }
public void testTypeAndSerializerConstructor() { [EOL] Class<?> expectedType = String.class; [EOL] JsonSerializer<Object> expectedSerializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] TypeAndSerializer typeAndSerializer = new TypeAndSerializer(expectedType, expectedSerializer); [EOL] assertEquals(expectedType, typeAndSerializer.type); [EOL] assertEquals(expectedSerializer, typeAndSerializer.serializer); [EOL] }
public void testSerializerForSameType() { [EOL] Class<?> expectedType = _type; // Replace with actual type [EOL] JsonSerializer<Object> expectedSerializer = _serializer; // Replace with actual serializer [EOL] JsonSerializer<Object> result = serializerFor(expectedType); [EOL] assertSame("Serializer should be the same for the same type", expectedSerializer, result); [EOL] }
public void testSerializerForDifferentType() { [EOL] Class<?> differentType = DifferentType.class; // Replace with actual different type [EOL] JsonSerializer<Object> result = serializerFor(differentType); [EOL] assertNull("Serializer should be null for a different type", result); [EOL] }
public void testNewWithDifferentTypeAndSerializer() { [EOL] Class<?> initialType = String.class; [EOL] JsonSerializer<Object> initialSerializer = new StdSerializer<Object>(Object.class) {}; [EOL] PropertySerializerMap.Single single = new PropertySerializerMap.Single(initialType, initialSerializer); [EOL] Class<?> newType = Integer.class; [EOL] JsonSerializer<Object> newSerializer = new StdSerializer<Object>(Object.class) {}; [EOL] PropertySerializerMap result = single.newWith(newType, newSerializer); [EOL] assertTrue(result instanceof PropertySerializerMap.Double); [EOL] PropertySerializerMap.Double doubleMap = (PropertySerializerMap.Double) result; [EOL] assertEquals(newType, doubleMap._type2); [EOL] assertEquals(newSerializer, doubleMap._serializer2); [EOL] }
public void testNewWithSameTypeAndDifferentSerializer() { [EOL] Class<?> initialType = String.class; [EOL] JsonSerializer<Object> initialSerializer = new StdSerializer<Object>(Object.class) {}; [EOL] PropertySerializerMap.Single single = new PropertySerializerMap.Single(initialType, initialSerializer); [EOL] JsonSerializer<Object> newSerializer = new StdSerializer<Object>(Object.class) {}; [EOL] PropertySerializerMap result = single.newWith(initialType, newSerializer); [EOL] assertTrue(result instanceof PropertySerializerMap.Double); [EOL] PropertySerializerMap.Double doubleMap = (PropertySerializerMap.Double) result; [EOL] assertEquals(initialType, doubleMap._type2); [EOL] assertNotSame(initialSerializer, doubleMap._serializer2); [EOL] assertEquals(newSerializer, doubleMap._serializer2); [EOL] }
public void testDoubleConstructorWithNonNullValues() { [EOL] Class<?> type1 = String.class; [EOL] JsonSerializer<Object> serializer1 = mock(JsonSerializer.class); [EOL] Class<?> type2 = Integer.class; [EOL] JsonSerializer<Object> serializer2 = mock(JsonSerializer.class); [EOL] Double doubleInstance = new Double(type1, serializer1, type2, serializer2); [EOL] assertNotNull(doubleInstance); [EOL] assertEquals(type1, doubleInstance._type1); [EOL] assertEquals(serializer1, doubleInstance._serializer1); [EOL] assertEquals(type2, doubleInstance._type2); [EOL] assertEquals(serializer2, doubleInstance._serializer2); [EOL] }
public void testSerializerFor_Type1() { [EOL] Class<?> type = _type1; // Replace with actual type [EOL] JsonSerializer<Object> result = serializerFor(type); [EOL] assertEquals(_serializer1, result); [EOL] }
public void testSerializerFor_Type2() { [EOL] Class<?> type = _type2; // Replace with actual type [EOL] JsonSerializer<Object> result = serializerFor(type); [EOL] assertEquals(_serializer2, result); [EOL] }
public void testSerializerFor_UnknownType() { [EOL] Class<?> type = UnknownType.class; // Replace with actual unknown type [EOL] JsonSerializer<Object> result = serializerFor(type); [EOL] assertNull(result); [EOL] }
public void testNewWithDifferentTypes() { [EOL] Class<?> type1 = String.class; [EOL] JsonSerializer<Object> serializer1 = new StdSerializer<Object>(Object.class) {}; [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty().newWith(type1, serializer1); [EOL] assertTrue(map instanceof PropertySerializerMap.Multi); [EOL] PropertySerializerMap.Multi multiMap = (PropertySerializerMap.Multi) map; [EOL] assertEquals(2, multiMap._entries.length); [EOL] assertEquals(type1, multiMap._entries[0].type); [EOL] assertEquals(serializer1, multiMap._entries[0].serializer); [EOL] }
public void testNewWithSameType() { [EOL] Class<?> type1 = String.class; [EOL] JsonSerializer<Object> serializer1 = new StdSerializer<Object>(Object.class) {}; [EOL] JsonSerializer<Object> serializer2 = new StdSerializer<Object>(Object.class) {}; [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty().newWith(type1, serializer1).newWith(type1, serializer2); [EOL] assertTrue(map instanceof PropertySerializerMap.Multi); [EOL] PropertySerializerMap.Multi multiMap = (PropertySerializerMap.Multi) map; [EOL] assertEquals(2, multiMap._entries.length); [EOL] assertEquals(type1, multiMap._entries[1].type); [EOL] assertEquals(serializer2, multiMap._entries[1].serializer); [EOL] }
public void testMultiConstructorWithNull() { [EOL] TypeAndSerializer[] entries = null; [EOL] Multi multi = new Multi(entries); [EOL] assertNull(multi._entries); [EOL] }
public void testMultiConstructorWithEmptyArray() { [EOL] TypeAndSerializer[] entries = new TypeAndSerializer[0]; [EOL] Multi multi = new Multi(entries); [EOL] assertEquals(0, multi._entries.length); [EOL] }
public void testMultiConstructorWithNonEmptyArray() { [EOL] TypeAndSerializer[] entries = new TypeAndSerializer[1]; [EOL] entries[0] = new TypeAndSerializer(SomeType.class, new SomeSerializer()); [EOL] Multi multi = new Multi(entries); [EOL] assertEquals(1, multi._entries.length); [EOL] assertNotNull(multi._entries[0]); [EOL] }
public void testSerializerFor_WithMatchingType_ShouldReturnSerializer() { [EOL] TypeAndSerializer matchingEntry = new TypeAndSerializer(MyType.class, mySerializer); [EOL] _entries = new TypeAndSerializer[] { matchingEntry }; [EOL] JsonSerializer<Object> result = serializerFor(MyType.class); [EOL] assertSame("Expected the same serializer that was in the entry", mySerializer, result); [EOL] }
public void testSerializerFor_WithNoMatchingType_ShouldReturnNull() { [EOL] TypeAndSerializer nonMatchingEntry = new TypeAndSerializer(OtherType.class, otherSerializer); [EOL] _entries = new TypeAndSerializer[] { nonMatchingEntry }; [EOL] JsonSerializer<Object> result = serializerFor(MyType.class); [EOL] assertNull("Expected null when no matching type is found", result); [EOL] }
public void testNewWithLessThanMaxEntries() { [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] Class<?> type = String.class; [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] PropertySerializerMap newMap = map.newWith(type, serializer); [EOL] assertTrue(newMap instanceof PropertySerializerMap.Multi); [EOL] }
public void testNewWithMaxEntries() { [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] for (int i = 0; i < PropertySerializerMap.MAX_ENTRIES; i++) { [EOL] map = map.newWith(String.class, new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }); [EOL] } [EOL] PropertySerializerMap sameMap = map.newWith(String.class, new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }); [EOL] assertSame(map, sameMap); [EOL] }
public void testDeserializeWithNonStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] try { [EOL] new EnumSetDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected mappingException for non-start array token"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] try { [EOL] new EnumSetDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected mappingException for null value"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithValidEnum() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] EnumSetDeserializer deserializer = new EnumSetDeserializer(); [EOL] deserializer._enumClass = TestEnum.class; [EOL] deserializer._enumDeserializer = new TestEnumDeserializer(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("VALUE1"); [EOL] EnumSet<?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(TestEnum.VALUE1)); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] EnumSet<?> result = new EnumSetDeserializer().deserialize(jp, ctxt); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindKeyDeserializerWithStringClass() { [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithObjectClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithUUIDClass() { [EOL] JavaType type = SimpleType.constructUnsafe(UUID.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.UuidKD); [EOL] }
public void testFindKeyDeserializerWithPrimitiveType() { [EOL] JavaType type = SimpleType.constructUnsafe(int.class); // int is a primitive type [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithIntegerClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Integer.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithLongClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Long.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.LongKD); [EOL] }
public void testFindKeyDeserializerWithDateClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Date.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.DateKD); [EOL] }
public void testFindKeyDeserializerWithCalendarClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.CalendarKD); [EOL] }
public void testFindKeyDeserializerWithBooleanClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Boolean.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.BoolKD); [EOL] }
public void testFindKeyDeserializerWithByteClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Byte.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.ByteKD); [EOL] }
public void testFindKeyDeserializerWithCharacterClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Character.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.CharKD); [EOL] }
public void testFindKeyDeserializerWithShortClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Short.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.ShortKD); [EOL] }
public void testFindKeyDeserializerWithFloatClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Float.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.FloatKD); [EOL] }
public void testFindKeyDeserializerWithDoubleClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Double.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.DoubleKD); [EOL] }
public void testFindKeyDeserializerWithLocaleClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Locale.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.LocaleKD); [EOL] }
public void testFindKeyDeserializerWithUnmappedClass() { [EOL] JavaType type = SimpleType.constructUnsafe(SomeUnmappedClass.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testSerializeContentsWithNonNullElementSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] JsonSerializer<Object> elementSerializer = ...; // Mock element serializer [EOL] _elementSerializer = elementSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithEmptyCollection() throws IOException { [EOL] Collection<?> value = Collections.emptySet(); // Empty collection [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNonNullValues() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a non-empty collection [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] _elementSerializer = null; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection that will cause an exception when serialized [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] _elementSerializer = null; [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testSerializeContentsUsingWithEmptyCollection() throws IOException { [EOL] Collection<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(ser); [EOL] }
public void testSerializeContentsUsingWithNonNullElements() throws IOException { [EOL] Collection<?> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(ser, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithNullElements() throws IOException { [EOL] Collection<?> value = Arrays.asList(null, null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(provider, times(2)).defaultSerializeNull(jgen); [EOL] }
public void testSerializeContentsUsingWithTypeSerializer() throws IOException { [EOL] Collection<?> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser, typeSer); [EOL] verify(ser, times(2)).serializeWithType(any(), eq(jgen), eq(provider), eq(typeSer)); [EOL] }
public void testSerializeContentsUsingWithException() throws IOException { [EOL] Collection<?> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] doThrow(new IOException()).when(ser).serialize(any(), eq(jgen), eq(provider)); [EOL] try { [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testResetWithNonNullClass() { [EOL] SomeClass instance = new SomeClass(); [EOL] Class<?> clz = String.class; [EOL] instance.reset(clz); [EOL] assertEquals(String.class, instance._class); [EOL] assertEquals("java.lang.String", instance._className); [EOL] assertEquals("java.lang.String".hashCode(), instance._hashCode); [EOL] }
public void testResetWithNullClass() { [EOL] SomeClass instance = new SomeClass(); [EOL] Class<?> clz = null; [EOL] try { [EOL] instance.reset(clz); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerializerDefinition() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinition() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(expectedSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testCreateContextualWithDefaultSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> defaultSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(defaultSerializer); [EOL] when(isDefaultSerializer(defaultSerializer)).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonDefaultSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> nonDefaultSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(nonDefaultSerializer); [EOL] when(isDefaultSerializer(nonDefaultSerializer)).thenReturn(false); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testCreateContextualWithNonDefaultContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<?> expectedContextualSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(contextualSerializer); [EOL] when(isDefaultSerializer(contextualSerializer)).thenReturn(false); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(expectedContextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testCreateContextualReturnsThisWhenSerializerIsSameAsDefault() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> defaultSerializer = _serializer; [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(defaultSerializer); [EOL] when(isDefaultSerializer(defaultSerializer)).thenReturn(false); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testSerializeWithSingleElementUnwrapped() throws IOException { [EOL] List<String> value = Collections.singletonList("singleElement"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithMultipleElements() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider, never()).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithCustomSerializer() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(new CustomItemSerializer()); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(customSerializer).someMethod(any(), any(), any(), anyInt()); [EOL] }
public void testSerializeUsingCustomWithNonNullValues() throws IOException { [EOL] List<String> value = Arrays.asList("string1", "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<String> ser = mock(JsonSerializer.class); [EOL] int len = value.size(); [EOL] serializeUsingCustom(value, jgen, provider, len); [EOL] verify(ser, times(len)).serialize(anyString(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeUsingCustomWithNullValues() throws IOException { [EOL] List<String> value = Arrays.asList(null, null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] int len = value.size(); [EOL] serializeUsingCustom(value, jgen, provider, len); [EOL] verify(provider, times(len)).defaultSerializeNull(jgen); [EOL] }
public void testSerializeUsingCustomWithException() throws IOException { [EOL] List<String> value = Arrays.asList("string1", "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<String> ser = mock(JsonSerializer.class); [EOL] int len = value.size(); [EOL] doThrow(new IOException()).when(ser).serialize(anyString(), eq(jgen), eq(provider)); [EOL] try { [EOL] serializeUsingCustom(value, jgen, provider, len); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(ser).serialize(anyString(), eq(jgen), eq(provider)); [EOL] verify(provider, never()).defaultSerializeNull(jgen); [EOL] }
public void testAllMethod() { [EOL] Collection<Map.Entry<Class<?>, Object>> entries = YourClass.all(); [EOL] assertNotNull(entries); [EOL] int expectedSize = 13; // Since Locale.class is put twice, it should still result in 13 unique entries [EOL] assertEquals(expectedSize, entries.size()); [EOL] boolean hasURLSerializer = false; [EOL] boolean hasURISerializer = false; [EOL] boolean hasCurrencySerializer = false; [EOL] boolean hasUUIDSerializer = false; [EOL] boolean hasPatternSerializer = false; [EOL] boolean hasLocaleSerializer = false; [EOL] boolean hasAtomicReferenceSerializer = false; [EOL] boolean hasAtomicBooleanSerializer = false; [EOL] boolean hasAtomicIntegerSerializer = false; [EOL] boolean hasAtomicLongSerializer = false; [EOL] boolean hasFileSerializer = false; [EOL] boolean hasClassSerializer = false; [EOL] boolean hasNullSerializer = false; [EOL] for (Map.Entry<Class<?>, Object> entry : entries) { [EOL] if (entry.getKey().equals(java.net.URL.class) && entry.getValue() instanceof ToStringSerializer) { [EOL] hasURLSerializer = true; [EOL] } else if (entry.getKey().equals(java.net.URI.class) && entry.getValue() instanceof ToStringSerializer) { [EOL] hasURISerializer = true; [EOL] } else if (entry.getKey().equals(Currency.class) && entry.getValue() instanceof ToStringSerializer) { [EOL] hasCurrencySerializer = true; [EOL] } else if (entry.getKey().equals(UUID.class) && entry.getValue() instanceof ToStringSerializer) { [EOL] hasUUIDSerializer = true; [EOL] } else if (entry.getKey().equals(java.util.regex.Pattern.class) && entry.getValue() instanceof ToStringSerializer) { [EOL] hasPatternSerializer = true; [EOL] } else if (entry.getKey().equals(Locale.class) && entry.getValue() instanceof ToStringSerializer) { [EOL] hasLocaleSerializer = true; [EOL] } else if (entry.getKey().equals(AtomicReference.class) && entry.getValue().equals(AtomicReferenceSerializer.class)) { [EOL] hasAtomicReferenceSerializer = true; [EOL] } else if (entry.getKey().equals(AtomicBoolean.class) && entry.getValue().equals(AtomicBooleanSerializer.class)) { [EOL] hasAtomicBooleanSerializer = true; [EOL] } else if (entry.getKey().equals(AtomicInteger.class) && entry.getValue().equals(AtomicIntegerSerializer.class)) { [EOL] hasAtomicIntegerSerializer = true; [EOL] } else if (entry.getKey().equals(AtomicLong.class) && entry.getValue().equals(AtomicLongSerializer.class)) { [EOL] hasAtomicLongSerializer = true; [EOL] } else if (entry.getKey().equals(File.class) && entry.getValue().equals(FileSerializer.class)) { [EOL] hasFileSerializer = true; [EOL] } else if (entry.getKey().equals(Class.class) && entry.getValue().equals(ClassSerializer.class)) { [EOL] hasClassSerializer = true; [EOL] } else if (entry.getKey().equals(Void.TYPE) && entry.getValue().equals(NullSerializer.class)) { [EOL] hasNullSerializer = true; [EOL] } [EOL] } [EOL] assertTrue(hasURLSerializer); [EOL] assertTrue(hasURISerializer); [EOL] assertTrue(hasCurrencySerializer); [EOL] assertTrue(hasUUIDSerializer); [EOL] assertTrue(hasPatternSerializer); [EOL] assertTrue(hasLocaleSerializer); [EOL] assertTrue(hasAtomicReferenceSerializer); [EOL] assertTrue(hasAtomicBooleanSerializer); [EOL] assertTrue(hasAtomicIntegerSerializer); [EOL] assertTrue(hasAtomicLongSerializer); [EOL] assertTrue(hasFileSerializer); [EOL] assertTrue(hasClassSerializer); [EOL] assertTrue(hasNullSerializer); [EOL] }
public void testObjectNodeCreationWithNonNullFactory() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(true); [EOL] ObjectNode node = new ObjectNode(factory); [EOL] assertNotNull(node); [EOL] assertSame(factory, node.getNodeFactory()); [EOL] }
public void testObjectNodeCreationWithNullFactory() { [EOL] try { [EOL] new ObjectNode(null); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetWithExistingField() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "field"; [EOL] JsonNode childNode = TextNode.valueOf("value"); [EOL] node.set(fieldName, childNode); [EOL] JsonNode result = node.get(fieldName); [EOL] assertSame("The get method should return the correct child node.", childNode, result); [EOL] }
public void testGetWithNonExistingField() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "nonExistingField"; [EOL] JsonNode result = node.get(fieldName); [EOL] assertNull("The get method should return null for non-existing field.", result); [EOL] }
public void testWithExistingObjectNode() { [EOL] ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); [EOL] String propertyName = "existing"; [EOL] ObjectNode child = new ObjectNode(JsonNodeFactory.instance); [EOL] parent.set(propertyName, child); [EOL] ObjectNode result = parent.with(propertyName); [EOL] assertSame("The method should return the existing ObjectNode", child, result); [EOL] }
public void testWithNonObjectNode() { [EOL] ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); [EOL] String propertyName = "nonObject"; [EOL] parent.set(propertyName, TextNode.valueOf("text")); [EOL] try { [EOL] parent.with(propertyName); [EOL] fail("The method should throw an UnsupportedOperationException if the property is not an ObjectNode"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Property 'nonObject' has value that is not of type ObjectNode (but " + TextNode.class.getName() + ")", e.getMessage()); [EOL] } [EOL] }
public void testWithNewProperty() { [EOL] ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); [EOL] String propertyName = "newProperty"; [EOL] ObjectNode result = parent.with(propertyName); [EOL] assertNotNull("The method should create a new ObjectNode if the property does not exist", result); [EOL] assertTrue("The new property should be an instance of ObjectNode", result instanceof ObjectNode); [EOL] assertSame("The new ObjectNode should be added to the parent", result, parent.get(propertyName)); [EOL] }
public void testFindValuesWhenFieldNameExistsAndFoundSoFarIsNull() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testField"; [EOL] JsonNode fieldValue = JsonNodeFactory.instance.textNode("value"); [EOL] root.set(fieldName, fieldValue); [EOL] List<JsonNode> result = root.findValues(fieldName, null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals(fieldValue, result.get(0)); [EOL] }
public void testFindValuesWhenFieldNameExistsAndFoundSoFarIsNotNull() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testField"; [EOL] JsonNode fieldValue = JsonNodeFactory.instance.textNode("value"); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] root.set(fieldName, fieldValue); [EOL] List<JsonNode> result = root.findValues(fieldName, foundSoFar); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(fieldValue)); [EOL] }
public void testFindValuesWhenFieldNameDoesNotExist() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testField"; [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = root.findValues(fieldName, foundSoFar); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindValuesWhenFieldNameExistsInNestedNode() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testField"; [EOL] JsonNode fieldValue = JsonNodeFactory.instance.textNode("value"); [EOL] child.set(fieldName, fieldValue); [EOL] root.set("child", child); [EOL] List<JsonNode> result = root.findValues(fieldName, null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals(fieldValue, result.get(0)); [EOL] }
public void testFindValuesAsTextWithNullFoundSoFar() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("key1", "value1"); [EOL] root.put("key2", "value2"); [EOL] List<String> result = root.findValuesAsText("key1", null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("value1", result.get(0)); [EOL] }
public void testFindValuesAsTextWithNonNullFoundSoFar() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("key1", "value1"); [EOL] root.put("key2", "value2"); [EOL] List<String> initialList = new ArrayList<>(); [EOL] initialList.add("existingValue"); [EOL] List<String> result = root.findValuesAsText("key1", initialList); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains("existingValue")); [EOL] assertTrue(result.contains("value1")); [EOL] }
public void testFindValuesAsTextWithNoMatchingKey() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("key1", "value1"); [EOL] root.put("key2", "value2"); [EOL] List<String> result = root.findValuesAsText("key3", null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindValuesAsTextWithNestedObject() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child = JsonNodeFactory.instance.objectNode(); [EOL] child.put("nestedKey", "nestedValue"); [EOL] root.set("key1", child); [EOL] List<String> result = root.findValuesAsText("nestedKey", null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("nestedValue", result.get(0)); [EOL] }
public void testFindParentsWhenFieldNameExistsAndFoundSoFarIsNull() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.set("testField", new TextNode("testValue")); [EOL] List<JsonNode> result = node.findParents("testField", null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(node)); [EOL] } [EOL] public void testFindParentsWhenFieldNameExistsAndFoundSoFarIsNotNull() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode childNode = new ObjectNode(JsonNodeFactory.instance); [EOL] node.set("child", childNode); [EOL] childNode.set("testField", new TextNode("testValue")); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = node.findParents("testField", foundSoFar); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(childNode)); [EOL] assertTrue(foundSoFar.isEmpty()); [EOL] } [EOL] public void testFindParentsWhenFieldNameDoesNotExist() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.set("otherField", new TextNode("testValue")); [EOL] List<JsonNode> result = node.findParents("testField", null); [EOL] assertNull(result); [EOL] }
public void testFindParentsWhenFieldNameExistsInNestedChild() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode childNode = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode nestedChildNode = new ObjectNode(JsonNodeFactory.instance); [EOL] node.set("child", childNode); [EOL] childNode.set("nestedChild", nestedChildNode); [EOL] nestedChildNode.set("testField", new TextNode("testValue")); [EOL] List<JsonNode> result = node.findParents("testField", null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(nestedChildNode)); [EOL] }
public void testSerializeEmptyObject() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ObjectNode objectNode = new ObjectNode(nodeFactory); [EOL] JsonGenerator jg = new JsonFactory().createGenerator(new StringWriter()); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl().createInstance(new SerializationConfig(), new JsonFactory()); [EOL] objectNode.serialize(jg, provider); [EOL] jg.flush(); [EOL] String jsonOutput = jg.getOutputTarget().toString(); [EOL] assertEquals("{}", jsonOutput); [EOL] }
public void testSerializeNonEmptyObject() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ObjectNode objectNode = new ObjectNode(nodeFactory); [EOL] objectNode.put("key1", "value1"); [EOL] objectNode.put("key2", "value2"); [EOL] JsonGenerator jg = new JsonFactory().createGenerator(new StringWriter()); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl().createInstance(new SerializationConfig(), new JsonFactory()); [EOL] objectNode.serialize(jg, provider); [EOL] jg.flush(); [EOL] String jsonOutput = jg.getOutputTarget().toString(); [EOL] assertTrue(jsonOutput.contains("\"key1\":\"value1\"")); [EOL] assertTrue(jsonOutput.contains("\"key2\":\"value2\"")); [EOL] }
public void testSerializeWithType_EmptyObject() throws IOException { [EOL] JsonGenerator jg = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.serializeWithType(jg, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(objectNode, jg); [EOL] verify(typeSer).writeTypeSuffixForObject(objectNode, jg); [EOL] verifyNoMoreInteractions(jg); [EOL] }
public void testSerializeWithType_NonEmptyObject() throws IOException { [EOL] JsonGenerator jg = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.put("key", "value"); [EOL] objectNode.serializeWithType(jg, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(objectNode, jg); [EOL] verify(jg).writeFieldName("key"); [EOL] verify(typeSer).writeTypeSuffixForObject(objectNode, jg); [EOL] verify(jg).writeString("value"); [EOL] }
public void testSetWithNullValue() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode nullNode = null; [EOL] JsonNode result = node.set("fieldName", nullNode); [EOL] assertNotNull(result); [EOL] assertTrue(node.get("fieldName").isNull()); [EOL] }
public void testSetWithNonNullValue() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode nonNullNode = new TextNode("value"); [EOL] JsonNode result = node.set("fieldName", nonNullNode); [EOL] assertNotNull(result); [EOL] assertEquals("value", node.get("fieldName").asText()); [EOL] }
public void testRetainWithEmptyCollection() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] Collection<String> fieldNames = Collections.emptyList(); [EOL] ObjectNode result = node.retain(fieldNames); [EOL] assertTrue(result.size() == 0); [EOL] } [EOL] public void testRetainWithNonEmptyCollection() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] Collection<String> fieldNames = Arrays.asList("a"); [EOL] ObjectNode result = node.retain(fieldNames); [EOL] assertTrue(result.size() == 1 && result.has("a")); [EOL] } [EOL] public void testRetainWithAllFields() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] Collection<String> fieldNames = Arrays.asList("a", "b"); [EOL] ObjectNode result = node.retain(fieldNames); [EOL] assertTrue(result.size() == 2 && result.has("a") && result.has("b")); [EOL] } [EOL] public void testRetainWithNonExistentField() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] Collection<String> fieldNames = Arrays.asList("c"); [EOL] ObjectNode result = node.retain(fieldNames); [EOL] assertTrue(result.size() == 0); [EOL] }

public void testRetainWithEmptyArray() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] ObjectNode result = node.retain(new String[]{}); [EOL] assertTrue(result.size() == 2); [EOL] }
public void testRetainWithOneFieldName() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] ObjectNode result = node.retain(new String[]{"a"}); [EOL] assertTrue(result.size() == 1 && result.has("a")); [EOL] }
public void testRetainWithMultipleFieldNames() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] node.put("c", 3); [EOL] ObjectNode result = node.retain(new String[]{"a", "b"}); [EOL] assertTrue(result.size() == 2 && result.has("a") && result.has("b")); [EOL] }
public void testRetainWithNonExistingField() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("a", 1); [EOL] node.put("b", 2); [EOL] ObjectNode result = node.retain(new String[]{"c"}); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testPutNullWithValidFieldName() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] ObjectNode result = objectNode.putNull(fieldName); [EOL] assertTrue(result.has(fieldName)); [EOL] assertTrue(result.get(fieldName).isNull()); [EOL] }
public void testPutNullWithNullFieldName() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = null; [EOL] try { [EOL] objectNode.putNull(fieldName); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPutWithNullBigDecimal() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] BigDecimal value = null; [EOL] ObjectNode result = node.put(fieldName, value); [EOL] assertTrue(result.has(fieldName)); [EOL] assertTrue(result.get(fieldName).isNull()); [EOL] }
public void testPutWithNonNullBigDecimal() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] BigDecimal value = new BigDecimal("123.456"); [EOL] ObjectNode result = node.put(fieldName, value); [EOL] assertTrue(result.has(fieldName)); [EOL] assertFalse(result.get(fieldName).isNull()); [EOL] assertEquals(new BigDecimal(result.get(fieldName).asText()), value); [EOL] }
public void testPutWithNullValue() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] String value = null; [EOL] node.put(fieldName, value); [EOL] assertTrue(node.get(fieldName).isNull()); [EOL] }
public void testPutWithNonNullValue() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] String value = "testValue"; [EOL] node.put(fieldName, value); [EOL] assertEquals("testValue", node.get(fieldName).textValue()); [EOL] }
public void testOkNameForRegularGetterWithGetPrefixAndNotSpecial() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getRegularProperty"); [EOL] String name = "getRegularProperty"; [EOL] String result = okNameForRegularGetter(am, name); [EOL] assertEquals("regularProperty", result); [EOL] } [EOL] public void testOkNameForRegularGetterWithGetCallbacks() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getCallbacks"); [EOL] when(am.isCglibGetCallbacks()).thenReturn(false); [EOL] String name = "getCallbacks"; [EOL] String result = okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithGetMetaClass() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getMetaClass"); [EOL] when(am.isGroovyMetaClassGetter()).thenReturn(false); [EOL] String name = "getMetaClass"; [EOL] String result = okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithCglibGetCallbacks() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getCallbacks"); [EOL] when(am.isCglibGetCallbacks()).thenReturn(true); [EOL] String name = "getCallbacks"; [EOL] String result = okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithGroovyMetaClassGetter() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getMetaClass"); [EOL] when(am.isGroovyMetaClassGetter()).thenReturn(true); [EOL] String name = "getMetaClass"; [EOL] String result = okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithoutGetPrefix() { [EOL] AnnotatedMethod am = createAnnotatedMethod("someMethod"); [EOL] String name = "someMethod"; [EOL] String result = okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] }
private AnnotatedMethod createAnnotatedMethod(String methodName) { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getName()).thenReturn(methodName); [EOL] return am; [EOL] }
public void testOkNameForIsGetterWithIsPrefixAndBooleanReturnType() { [EOL] AnnotatedMethod am = createAnnotatedMethod("isSomething", Boolean.class); [EOL] String name = "isSomething"; [EOL] String result = okNameForIsGetter(am, name); [EOL] assertNotNull(result); [EOL] assertEquals("Something", result); [EOL] } [EOL] public void testOkNameForIsGetterWithIsPrefixAndNonBooleanReturnType() { [EOL] AnnotatedMethod am = createAnnotatedMethod("isSomething", String.class); [EOL] String name = "isSomething"; [EOL] String result = okNameForIsGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForIsGetterWithoutIsPrefix() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getSomething", Boolean.class); [EOL] String name = "getSomething"; [EOL] String result = okNameForIsGetter(am, name); [EOL] assertNull(result); [EOL] }
private AnnotatedMethod createAnnotatedMethod(String methodName, Class<?> returnType) { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getRawType()).thenReturn(returnType); [EOL] return am; [EOL] }
public void testOkNameForMutatorWithProperPrefix() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithGivenName("setValidName"); [EOL] String result = okNameForMutator(am, "set"); [EOL] assertEquals("ValidName", result); [EOL] }
public void testOkNameForMutatorWithImproperPrefix() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithGivenName("getInvalidName"); [EOL] String result = okNameForMutator(am, "set"); [EOL] assertNull(result); [EOL] }
public void testManglePropertyNameEmpty() { [EOL] String result = manglePropertyName(""); [EOL] assertNull(result); [EOL] } [EOL] public void testManglePropertyNameAlreadyLowercase() { [EOL] String input = "lowercase"; [EOL] String result = manglePropertyName(input); [EOL] assertSame("Should return the same string if no change is made", input, result); [EOL] } [EOL] public void testManglePropertyNameMixedCase() { [EOL] String result = manglePropertyName("MixedCASE"); [EOL] assertEquals("mixedcase", result); [EOL] } [EOL] public void testManglePropertyNameAllUppercase() { [EOL] String result = manglePropertyName("UPPERCASE"); [EOL] assertEquals("uppercase", result); [EOL] }
public void testMappingJsonFactoryWithNonNullMapper() { [EOL] ObjectMapper nonNullMapper = new ObjectMapper(); [EOL] MappingJsonFactory factory = new MappingJsonFactory(nonNullMapper); [EOL] assertSame("Expected the provided ObjectMapper to be set", nonNullMapper, factory.getCodec()); [EOL] }
public void testMappingJsonFactoryWithNullMapper() { [EOL] MappingJsonFactory factory = new MappingJsonFactory(null); [EOL] assertNotNull("Expected a new ObjectMapper to be created", factory.getCodec()); [EOL] assertTrue("Expected the codec to be an instance of ObjectMapper", factory.getCodec() instanceof ObjectMapper); [EOL] }
public void testHasFormatWithMappingJsonFactory() throws IOException { [EOL] MappingJsonFactory factory = new MappingJsonFactory(); [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] MatchStrength result = factory.hasFormat(acc); [EOL] assertNotNull(result); [EOL] } [EOL] public void testHasFormatWithNonMappingJsonFactory() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] }; [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] MatchStrength result = factory.hasFormat(acc); [EOL] assertNull(result); [EOL] }
public void testNumberValueReturnsCorrectInteger() { [EOL] IntNode node = new IntNode(5); [EOL] Number result = node.numberValue(); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(5, result.intValue()); [EOL] }
public void testNumberValueReturnsCorrectIntegerForNegativeValue() { [EOL] IntNode node = new IntNode(-5); [EOL] Number result = node.numberValue(); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(-5, result.intValue()); [EOL] }
public void testCreatorCollectorWithCanFixAccessTrue() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] CreatorCollector collector = new CreatorCollector(beanDesc, true); [EOL] assertNotNull(collector); [EOL] }
public void testCreatorCollectorWithCanFixAccessFalse() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] CreatorCollector collector = new CreatorCollector(beanDesc, false); [EOL] assertNotNull(collector); [EOL] }
public void testConstructValueInstantiatorWithNullDelegateCreator() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] MyClass instance = new MyClass(config, beanDesc); [EOL] instance.setDelegateCreator(null); // Assuming there's a setter for _delegateCreator [EOL] ValueInstantiator result = instance.constructValueInstantiator(config); [EOL] assertNull(result.getDelegateType()); // Assuming there's a getter for delegateType [EOL] }
public void testConstructValueInstantiatorWithNonNullDelegateCreatorAndNullArgs() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] MyClass instance = new MyClass(config, beanDesc); [EOL] instance.setDelegateCreator(...); // Provide actual initialization [EOL] instance.setDelegateArgs(null); // Assuming there's a setter for _delegateArgs [EOL] ValueInstantiator result = instance.constructValueInstantiator(config); [EOL] assertNotNull(result.getDelegateType()); // Assuming there's a getter for delegateType [EOL] }
public void testConstructValueInstantiatorWithNonNullDelegateCreatorAndNonNullArgs() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] MyClass instance = new MyClass(config, beanDesc); [EOL] instance.setDelegateCreator(...); // Provide actual initialization [EOL] Object[] delegateArgs = new Object[] { ... }; // Provide actual initialization with at least one null element [EOL] instance.setDelegateArgs(delegateArgs); // Assuming there's a setter for _delegateArgs [EOL] ValueInstantiator result = instance.constructValueInstantiator(config); [EOL] assertNotNull(result.getDelegateType()); // Assuming there's a getter for delegateType [EOL] }
public void testSetDefaultConstructorWithNull() { [EOL] BeanDescription beanDesc = new BasicBeanDescription(null, null, null); [EOL] beanDesc.setDefaultConstructor(null); [EOL] assertNull(beanDesc.getDefaultConstructor()); [EOL] }
public void testSetDefaultConstructorWithNonNull() { [EOL] AnnotatedConstructor ctor = new AnnotatedConstructor(null, null, null, null, null); [EOL] BeanDescription beanDesc = new BasicBeanDescription(null, null, null); [EOL] beanDesc.setDefaultConstructor(ctor); [EOL] assertNotNull(beanDesc.getDefaultConstructor()); [EOL] }
public void testSetDefaultCreatorWithAnnotatedConstructor() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = new AnnotatedConstructor(null, null, null, null); [EOL] mapper.setDefaultCreator(creator); [EOL] assertNotNull(mapper.getDefaultConstructor()); [EOL] }
public void testSetDefaultCreatorWithNonAnnotatedConstructor() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = new AnnotatedMethod(null, null, null, null); [EOL] mapper.setDefaultCreator(creator); [EOL] assertNull(mapper.getDefaultConstructor()); [EOL] }
public void testAddDoubleCreatorWithNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = null; [EOL] collector.addDoubleCreator(creator); [EOL] assertNull(collector.getDoubleCreator()); [EOL] }
public void testAddDoubleCreatorWithNonNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] collector.addDoubleCreator(creator); [EOL] assertEquals(creator, collector.getDoubleCreator()); [EOL] }
public void testAddDoubleCreatorWithDuplication() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams firstCreator = mock(AnnotatedWithParams.class); [EOL] AnnotatedWithParams secondCreator = mock(AnnotatedWithParams.class); [EOL] collector.addDoubleCreator(firstCreator); [EOL] try { [EOL] collector.addDoubleCreator(secondCreator); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Conflicting double creators", e.getMessage()); [EOL] } [EOL] }
public void testAddBooleanCreatorWithNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = null; [EOL] collector.addBooleanCreator(creator); [EOL] assertNull(collector.getBooleanCreator()); [EOL] }
public void testAddBooleanCreatorWithNonNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] collector.addBooleanCreator(creator); [EOL] assertEquals(creator, collector.getBooleanCreator()); [EOL] }
public void testAddBooleanCreatorWithDuplication() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams firstCreator = mock(AnnotatedWithParams.class); [EOL] AnnotatedWithParams secondCreator = mock(AnnotatedWithParams.class); [EOL] collector.addBooleanCreator(firstCreator); [EOL] try { [EOL] collector.addBooleanCreator(secondCreator); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Duplicate boolean creator", e.getMessage()); [EOL] } [EOL] }
public void testHasDefaultCreator_WithNonNullDefaultConstructor() { [EOL] SomeClass instance = new SomeClass(); // Replace SomeClass with the actual class name [EOL] instance._defaultConstructor = new Object(); // Replace Object with the actual constructor type [EOL] boolean result = instance.hasDefaultCreator(); [EOL] assertTrue(result); [EOL] }
public void testHasDefaultCreator_WithNullDefaultConstructor() { [EOL] SomeClass instance = new SomeClass(); // Replace SomeClass with the actual class name [EOL] instance._defaultConstructor = null; [EOL] boolean result = instance.hasDefaultCreator(); [EOL] assertFalse(result); [EOL] }
public void testFixAccessWithNonNullMemberAndCanFixAccessTrue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember member = new AnnotatedField(null, null, null, null); [EOL] boolean originalCanFixAccess = mapper.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] mapper.enable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] AnnotatedMember result = mapper._fixAccess(member); [EOL] assertNotNull(result); [EOL] mapper.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, originalCanFixAccess); [EOL] }
public void testFixAccessWithNonNullMemberAndCanFixAccessFalse() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember member = new AnnotatedField(null, null, null, null); [EOL] boolean originalCanFixAccess = mapper.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] mapper.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] AnnotatedMember result = mapper._fixAccess(member); [EOL] assertNotNull(result); [EOL] mapper.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, originalCanFixAccess); [EOL] }
public void testFixAccessWithNullMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember result = mapper._fixAccess(null); [EOL] assertNull(result); [EOL] }
public void testVerifyNonDupWithNullOldOne() { [EOL] AnnotatedWithParams newOne = createNewAnnotatedWithParams(); [EOL] AnnotatedWithParams oldOne = null; [EOL] String type = "testType"; [EOL] AnnotatedWithParams result = verifyNonDup(newOne, oldOne, type); [EOL] assertNotNull(result); [EOL] }
public void testVerifyNonDupWithDifferentClass() { [EOL] AnnotatedWithParams newOne = createNewAnnotatedWithParams(); [EOL] AnnotatedWithParams oldOne = createOldAnnotatedWithParamsWithDifferentClass(); [EOL] String type = "testType"; [EOL] AnnotatedWithParams result = verifyNonDup(newOne, oldOne, type); [EOL] assertNotNull(result); [EOL] }
public void testVerifyNonDupWithSameClass() { [EOL] AnnotatedWithParams newOne = createNewAnnotatedWithParams(); [EOL] AnnotatedWithParams oldOne = createOldAnnotatedWithParamsWithSameClass(); [EOL] String type = "testType"; [EOL] try { [EOL] verifyNonDup(newOne, oldOne, type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne, e.getMessage()); [EOL] } [EOL] }
public void testRenameAllWithNonNullTransformerAndNonNullDeserializer() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, new ArrayList<SettableBeanProperty>()); [EOL] SettableBeanProperty prop1 = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty prop2 = mock(SettableBeanProperty.class); [EOL] when(prop1.getName()).thenReturn("oldName1"); [EOL] when(prop2.getName()).thenReturn("oldName2"); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<Object> unwrappingDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializer.unwrappingDeserializer(any(NameTransformer.class))).thenReturn(unwrappingDeserializer); [EOL] when(prop1.getValueDeserializer()).thenReturn(deserializer); [EOL] when(prop2.getValueDeserializer()).thenReturn(null); [EOL] beanPropertyMap.assignIndexes(); [EOL] beanPropertyMap.addProperty(prop1); [EOL] beanPropertyMap.addProperty(prop2); [EOL] NameTransformer transformer = mock(NameTransformer.class); [EOL] when(transformer.transform("oldName1")).thenReturn("newName1"); [EOL] when(transformer.transform("oldName2")).thenReturn("newName2"); [EOL] beanPropertyMap.renameAll(transformer); [EOL] assertEquals(2, beanPropertyMap.size()); [EOL] assertNotNull(beanPropertyMap.find("newName1")); [EOL] assertNotNull(beanPropertyMap.find("newName2")); [EOL] }
public void testRenameAllWithNullDeserializer() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, new ArrayList<SettableBeanProperty>()); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.getValueDeserializer()).thenReturn(null); [EOL] beanPropertyMap.assignIndexes(); [EOL] beanPropertyMap.addProperty(prop); [EOL] NameTransformer transformer = mock(NameTransformer.class); [EOL] when(transformer.transform("oldName")).thenReturn("newName"); [EOL] beanPropertyMap.renameAll(transformer); [EOL] assertEquals(1, beanPropertyMap.size()); [EOL] assertNotNull(beanPropertyMap.find("newName")); [EOL] }
public void testRenameAllWithNoProperties() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, new ArrayList<SettableBeanProperty>()); [EOL] NameTransformer transformer = mock(NameTransformer.class); [EOL] beanPropertyMap.renameAll(transformer); [EOL] assertEquals(0, beanPropertyMap.size()); [EOL] }
public void testFindMapDeserializerWithNullClassMappings() throws JsonMappingException { [EOL] MapType type = mock(MapType.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] CustomDeserializerFactory factory = new CustomDeserializerFactory(); [EOL] factory._classMappings = null; [EOL] JsonDeserializer<?> result = factory.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindMapDeserializerWithNonNullClassMappings() throws JsonMappingException { [EOL] MapType type = mock(MapType.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] CustomDeserializerFactory factory = new CustomDeserializerFactory(); [EOL] factory._classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL] ClassKey classKey = new ClassKey(Object.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] factory._classMappings.put(classKey, expectedDeserializer); [EOL] JsonDeserializer<?> result = factory.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindFormatWithNoReaders() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] DataFormatReaders readers = new DataFormatReaders(); [EOL] Match match = readers._findFormat(acc); [EOL] assertNull(match.getReader()); [EOL] assertNull(match.getMatchStrength()); [EOL] }
public void testFindFormatWithNonMatchingReaders() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] ObjectReader reader = mock(ObjectReader.class); [EOL] DataFormatReaders readers = new DataFormatReaders(reader); [EOL] when(reader.getFactory().hasFormat(acc)).thenReturn(null); [EOL] Match match = readers._findFormat(acc); [EOL] assertNull(match.getReader()); [EOL] assertNull(match.getMatchStrength()); [EOL] }
public void testFindFormatWithOneMatchingReader() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] ObjectReader reader = mock(ObjectReader.class); [EOL] DataFormatReaders readers = new DataFormatReaders(reader); [EOL] MatchStrength matchStrength = MatchStrength.SOLID_MATCH; [EOL] when(reader.getFactory().hasFormat(acc)).thenReturn(matchStrength); [EOL] Match match = readers._findFormat(acc); [EOL] assertEquals(reader, match.getReader()); [EOL] assertEquals(matchStrength, match.getMatchStrength()); [EOL] }
public void testFindFormatWithMultipleReadersAndBestMatch() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] ObjectReader reader1 = mock(ObjectReader.class); [EOL] ObjectReader reader2 = mock(ObjectReader.class); [EOL] DataFormatReaders readers = new DataFormatReaders(reader1, reader2); [EOL] MatchStrength matchStrength1 = MatchStrength.WEAK_MATCH; [EOL] MatchStrength matchStrength2 = MatchStrength.SOLID_MATCH; [EOL] when(reader1.getFactory().hasFormat(acc)).thenReturn(matchStrength1); [EOL] when(reader2.getFactory().hasFormat(acc)).thenReturn(matchStrength2); [EOL] Match match = readers._findFormat(acc); [EOL] assertEquals(reader2, match.getReader()); [EOL] assertEquals(matchStrength2, match.getMatchStrength()); [EOL] }
public void testFindFormatWithMultipleReadersAndOptimalMatch() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] ObjectReader reader1 = mock(ObjectReader.class); [EOL] ObjectReader reader2 = mock(ObjectReader.class); [EOL] DataFormatReaders readers = new DataFormatReaders(reader1, reader2); [EOL] MatchStrength matchStrength1 = MatchStrength.FULL_MATCH; [EOL] MatchStrength matchStrength2 = MatchStrength.INCONCLUSIVE; [EOL] when(reader1.getFactory().hasFormat(acc)).thenReturn(matchStrength1); [EOL] when(reader2.getFactory().hasFormat(acc)).thenReturn(matchStrength2); [EOL] Match match = readers._findFormat(acc); [EOL] assertEquals(reader1, match.getReader()); [EOL] assertEquals(matchStrength1, match.getMatchStrength()); [EOL] }
public ObjectReader getReader() { [EOL] return _match; [EOL] }
public void testCreateParserWithMatchWhenMatchIsNull() throws IOException { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._match = null; [EOL] JsonParser result = instance.createParserWithMatch(); [EOL] assertNull(result); [EOL] }
public void testCreateParserWithMatchWhenOriginalStreamIsNull() throws IOException { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._match = mock(MatchClass.class); // Assuming MatchClass is the class of _match [EOL] instance._originalStream = null; [EOL] instance._bufferedData = new byte[0]; [EOL] instance._bufferedStart = 0; [EOL] instance._bufferedLength = 0; [EOL] JsonFactory mockFactory = mock(JsonFactory.class); [EOL] when(instance._match.getFactory()).thenReturn(mockFactory); [EOL] when(mockFactory.createParser(any(byte[].class), anyInt(), anyInt())).thenReturn(mock(JsonParser.class)); [EOL] JsonParser result = instance.createParserWithMatch(); [EOL] assertNotNull(result); [EOL] verify(mockFactory).createParser(any(byte[].class), anyInt(), anyInt()); [EOL] }
public void testCreateParserWithMatchWhenOriginalStreamIsNotNull() throws IOException { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._match = mock(MatchClass.class); // Assuming MatchClass is the class of _match [EOL] instance._originalStream = new ByteArrayInputStream(new byte[0]); [EOL] JsonFactory mockFactory = mock(JsonFactory.class); [EOL] when(instance._match.getFactory()).thenReturn(mockFactory); [EOL] when(mockFactory.createParser(any(InputStream.class))).thenReturn(mock(JsonParser.class)); [EOL] JsonParser result = instance.createParserWithMatch(); [EOL] assertNotNull(result); [EOL] verify(mockFactory).createParser(any(InputStream.class)); [EOL] }
public void testGetTypeWithNullTypeParams() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] JavaType result = getType(bindings, null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetTypeWithEmptyTypeParams() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] JavaType result = getType(bindings, new TypeVariable<?>[0]); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetTypeWithNonEmptyTypeParams() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] TypeVariable<?>[] typeParams = new TypeVariable<?>[1]; [EOL] TypeVariable<?> typeVar = mock(TypeVariable.class); [EOL] when(typeVar.getName()).thenReturn("T"); [EOL] when(typeVar.getBounds()).thenReturn(new Type[]{null}); [EOL] typeParams[0] = typeVar; [EOL] JavaType result = getType(bindings, typeParams); [EOL] assertNotNull(result); [EOL] }
public void testGetTypeWithNonEmptyTypeParamsAndNonNullBounds() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] TypeVariable<?>[] typeParams = new TypeVariable<?>[1]; [EOL] TypeVariable<?> typeVar = mock(TypeVariable.class); [EOL] when(typeVar.getName()).thenReturn("T"); [EOL] Type lowerBound = String.class; [EOL] when(typeVar.getBounds()).thenReturn(new Type[]{lowerBound}); [EOL] typeParams[0] = typeVar; [EOL] JavaType result = getType(bindings, typeParams); [EOL] assertNotNull(result); [EOL] }
public void testGetFactoryMethodsWithEmptyCandidates() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] Mockito.when(mockClassInfo.getStaticMethods()).thenReturn(Collections.emptyList()); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo); [EOL] List<AnnotatedMethod> result = myClassUnderTest.getFactoryMethods(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetFactoryMethodsWithNonEmptyCandidatesNoFactoryMethods() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] List<AnnotatedMethod> mockMethods = Arrays.asList( [EOL] Mockito.mock(AnnotatedMethod.class), [EOL] Mockito.mock(AnnotatedMethod.class) [EOL] ); [EOL] Mockito.when(mockClassInfo.getStaticMethods()).thenReturn(mockMethods); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo) { [EOL] @Override [EOL] protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL] return false; [EOL] } [EOL] }; [EOL] List<AnnotatedMethod> result = myClassUnderTest.getFactoryMethods(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetFactoryMethodsWithNonEmptyCandidatesWithFactoryMethods() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] AnnotatedMethod mockMethod1 = Mockito.mock(AnnotatedMethod.class); [EOL] AnnotatedMethod mockMethod2 = Mockito.mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> mockMethods = Arrays.asList(mockMethod1, mockMethod2); [EOL] Mockito.when(mockClassInfo.getStaticMethods()).thenReturn(mockMethods); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo) { [EOL] @Override [EOL] protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL] return am.equals(mockMethod1); // Let's assume only mockMethod1 is a factory method [EOL] } [EOL] }; [EOL] List<AnnotatedMethod> result = myClassUnderTest.getFactoryMethods(); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(mockMethod1)); [EOL] assertFalse(result.contains(mockMethod2)); [EOL] }
public void testIsFactoryMethodWithNonAssignableReturnType() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithReturnType(String.class); [EOL] boolean result = isFactoryMethod(am); [EOL] assertFalse(result); [EOL] }
public void testIsFactoryMethodWithAssignableReturnTypeAndCreatorAnnotation() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithReturnTypeAndAnnotation(getBeanClass(), true); [EOL] boolean result = isFactoryMethod(am); [EOL] assertTrue(result); [EOL] }
public void testIsFactoryMethodWithAssignableReturnTypeAndValueOfName() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithName("valueOf"); [EOL] boolean result = isFactoryMethod(am); [EOL] assertTrue(result); [EOL] }
public void testIsFactoryMethodWithAssignableReturnTypeWithoutCreatorAnnotationAndDifferentName() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithReturnTypeAndAnnotation(getBeanClass(), false); [EOL] am = renameAnnotatedMethod(am, "notValueOf"); [EOL] boolean result = isFactoryMethod(am); [EOL] assertFalse(result); [EOL] }
public void testFindPOJOBuilderConfigWithNullIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(SomeClass.class, mapper.getSerializationConfig()); [EOL] BeanDescription beanDesc = new BasicBeanDescription(mapper.getSerializationConfig(), ac, SimpleType.constructUnsafe(SomeClass.class)); [EOL] assertNull(beanDesc.findPOJOBuilderConfig()); [EOL] }
public void testFindPOJOBuilderConfigWithNonNullIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = new JacksonAnnotationIntrospector(); [EOL] mapper.setAnnotationIntrospector(introspector); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(SomeClass.class, mapper.getSerializationConfig()); [EOL] BeanDescription beanDesc = new BasicBeanDescription(mapper.getSerializationConfig(), ac, SimpleType.constructUnsafe(SomeClass.class)); [EOL] assertNotNull(beanDesc.findPOJOBuilderConfig()); [EOL] }
public void testStdValueInstantiatorWithNonNullConfigAndValueType() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] JavaType valueType = new JavaType(...); // Provide necessary arguments [EOL] StdValueInstantiator instantiator = new StdValueInstantiator(config, valueType); [EOL] assertFalse(instantiator._cfgEmptyStringsAsObjects); [EOL] assertEquals(valueType.toString(), instantiator._valueTypeDesc); [EOL] }
public void testStdValueInstantiatorWithNullConfigAndNonNullValueType() { [EOL] JavaType valueType = new JavaType(...); // Provide necessary arguments [EOL] StdValueInstantiator instantiator = new StdValueInstantiator(null, valueType); [EOL] assertFalse(instantiator._cfgEmptyStringsAsObjects); [EOL] assertEquals(valueType.toString(), instantiator._valueTypeDesc); [EOL] }
public void testStdValueInstantiatorWithNonNullConfigAndNullValueType() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] StdValueInstantiator instantiator = new StdValueInstantiator(config, null); [EOL] assertTrue(config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)); [EOL] assertEquals("UNKNOWN TYPE", instantiator._valueTypeDesc); [EOL] }
public void testStdValueInstantiatorWithNullConfigAndNullValueType() { [EOL] StdValueInstantiator instantiator = new StdValueInstantiator(null, null); [EOL] assertFalse(instantiator._cfgEmptyStringsAsObjects); [EOL] assertEquals("UNKNOWN TYPE", instantiator._valueTypeDesc); [EOL] }
public void testConfigureFromObjectSettings_AllNull() { [EOL] ObjectSettingsConfigurator configurator = new ObjectSettingsConfigurator(); [EOL] configurator.configureFromObjectSettings(null, null, null, null, null, null); [EOL] assertNull(configurator.getDefaultCreator()); [EOL] assertNull(configurator.getDelegateCreator()); [EOL] assertNull(configurator.getDelegateType()); [EOL] assertNull(configurator.getDelegateArguments()); [EOL] assertNull(configurator.getWithArgsCreator()); [EOL] assertNull(configurator.getConstructorArguments()); [EOL] }
public void testConfigureFromObjectSettings_AllNonNull() { [EOL] ObjectSettingsConfigurator configurator = new ObjectSettingsConfigurator(); [EOL] AnnotatedWithParams defaultCreator = mock(AnnotatedWithParams.class); [EOL] AnnotatedWithParams delegateCreator = mock(AnnotatedWithParams.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] CreatorProperty[] delegateArgs = new CreatorProperty[] { mock(CreatorProperty.class) }; [EOL] AnnotatedWithParams withArgsCreator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] constructorArgs = new CreatorProperty[] { mock(CreatorProperty.class) }; [EOL] configurator.configureFromObjectSettings(defaultCreator, delegateCreator, delegateType, delegateArgs, withArgsCreator, constructorArgs); [EOL] assertEquals(defaultCreator, configurator.getDefaultCreator()); [EOL] assertEquals(delegateCreator, configurator.getDelegateCreator()); [EOL] assertEquals(delegateType, configurator.getDelegateType()); [EOL] assertArrayEquals(delegateArgs, configurator.getDelegateArguments()); [EOL] assertEquals(withArgsCreator, configurator.getWithArgsCreator()); [EOL] assertArrayEquals(constructorArgs, configurator.getConstructorArguments()); [EOL] }
public void testConfigureFromStringCreator() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = null; // Assuming AnnotatedWithParams is a mockable class/interface [EOL] mapper.configureFromStringCreator(creator); [EOL] }
public void testConfigureFromStringCreatorWithNonNullCreator() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); // Assuming we can mock AnnotatedWithParams [EOL] mapper.configureFromStringCreator(creator); [EOL] }
public void testConfigureFromIntCreatorWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() {}; [EOL] modifier.configureFromIntCreator(creator); [EOL] assertNotNull(modifier._fromIntCreator); [EOL] assertEquals(creator, modifier._fromIntCreator); [EOL] }
public void testConfigureFromIntCreatorWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() {}; [EOL] modifier.configureFromIntCreator(null); [EOL] assertNull(modifier._fromIntCreator); [EOL] }
public void testConfigureFromLongCreatorWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] mapper.configureFromLongCreator(creator); [EOL] AnnotatedWithParams result = mapper.getFromLongCreator(); [EOL] assertSame("The creator should be the same as the one set", creator, result); [EOL] }
public void testConfigureFromLongCreatorWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configureFromLongCreator(null); [EOL] AnnotatedWithParams result = mapper.getFromLongCreator(); [EOL] assertNull("The creator should be null", result); [EOL] }
public void testConfigureFromDoubleCreatorWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { [EOL] @Override [EOL] public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, [EOL] BeanDescription beanDesc, [EOL] JsonDeserializer<?> deserializer) { [EOL] if (deserializer instanceof BeanDeserializerBase) { [EOL] ((BeanDeserializerBase) deserializer).configureFromDoubleCreator(creator); [EOL] } [EOL] return deserializer; [EOL] } [EOL] }; [EOL] mapper.registerModule(new SimpleModule().setDeserializerModifier(modifier)); [EOL] mapper.readValue("{}", Object.class); [EOL] verify(creator).withSomething(); // Replace with actual verification [EOL] }
public void testConfigureFromDoubleCreatorWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { [EOL] @Override [EOL] public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, [EOL] BeanDescription beanDesc, [EOL] JsonDeserializer<?> deserializer) { [EOL] if (deserializer instanceof BeanDeserializerBase) { [EOL] ((BeanDeserializerBase) deserializer).configureFromDoubleCreator(null); [EOL] } [EOL] return deserializer; [EOL] } [EOL] }; [EOL] mapper.registerModule(new SimpleModule().setDeserializerModifier(modifier)); [EOL] mapper.readValue("{}", Object.class); [EOL] }
public void testConfigureFromBooleanCreator() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedWithParams mockCreator = Mockito.mock(AnnotatedWithParams.class); [EOL] mapper.configureFromBooleanCreator(mockCreator); [EOL] AnnotatedWithParams actualCreator = mapper.getFromBooleanCreator(); [EOL] assertSame("The creator should be the same as the one set", mockCreator, actualCreator); [EOL] }
public void testConfigureIncompleteParameterWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedParameter parameter = new AnnotatedParameter(null, null, null); [EOL] mapper.configureIncompleteParameter(parameter); [EOL] assertNotNull(mapper.getIncompleteParameter()); [EOL] }
public void testConfigureIncompleteParameterWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configureIncompleteParameter(null); [EOL] assertNull(mapper.getIncompleteParameter()); [EOL] }
public void testCanCreateUsingDefault_WithNonNullDefaultCreator() { [EOL] MyClass instance = new MyClass(); [EOL] instance._defaultCreator = new Object(); // Set a non-null default creator [EOL] boolean result = instance.canCreateUsingDefault(); [EOL] assertTrue(result); // Assert that the result is true when _defaultCreator is not null [EOL] }
public void testCanCreateUsingDefault_WithNullDefaultCreator() { [EOL] MyClass instance = new MyClass(); [EOL] instance._defaultCreator = null; // Set the default creator to null [EOL] boolean result = instance.canCreateUsingDefault(); [EOL] assertFalse(result); // Assert that the result is false when _defaultCreator is null [EOL] }
public void testCanCreateUsingDelegate_WithNonNullDelegateType() { [EOL] MyBeanDeserializerModifier modifier = new MyBeanDeserializerModifier(); [EOL] modifier._delegateType = new TypeReference<Object>() { }; [EOL] boolean result = modifier.canCreateUsingDelegate(); [EOL] assertTrue(result); [EOL] }
public void testCanCreateUsingDelegate_WithNullDelegateType() { [EOL] MyBeanDeserializerModifier modifier = new MyBeanDeserializerModifier(); [EOL] modifier._delegateType = null; [EOL] boolean result = modifier.canCreateUsingDelegate(); [EOL] assertFalse(result); [EOL] }
public void testCanCreateFromObjectWith_WithArgsCreatorNotNull() { [EOL] instance.setWithArgsCreator(someNonNullValue); // Replace 'someNonNullValue' with an actual non-null value [EOL] boolean result = instance.canCreateFromObjectWith(); [EOL] assertTrue(result); [EOL] }
public void testCanCreateFromObjectWith_WithArgsCreatorNull() { [EOL] instance.setWithArgsCreator(null); [EOL] boolean result = instance.canCreateFromObjectWith(); [EOL] assertFalse(result); [EOL] }
public void testGetFromObjectArgumentsNonNull() { [EOL] SettableBeanProperty[] properties = new SettableBeanProperty[] {/* initialize with some properties */}; [EOL] SomeClass instance = new SomeClass(properties); [EOL] SettableBeanProperty[] result = instance.getFromObjectArguments(null); [EOL] assertNotNull(result); [EOL] assertArrayEquals(properties, result); [EOL] }
public void testGetFromObjectArgumentsEmpty() { [EOL] SettableBeanProperty[] properties = new SettableBeanProperty[0]; [EOL] SomeClass instance = new SomeClass(properties); [EOL] SettableBeanProperty[] result = instance.getFromObjectArguments(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testCreateUsingDefaultWithNullDefaultCreator() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(null); [EOL] try { [EOL] obj.createUsingDefault(null); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No default constructor for " + obj.getValueTypeDesc(), e.getMessage()); [EOL] } [EOL] }
public void testCreateUsingDefaultWithValidDefaultCreator() { [EOL] DefaultCreator mockCreator = mock(DefaultCreator.class); [EOL] when(mockCreator.call()).thenReturn(new Object()); [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(mockCreator); [EOL] try { [EOL] Object result = obj.createUsingDefault(null); [EOL] assertNotNull(result); [EOL] } catch (Exception e) { [EOL] fail("No exception should be thrown when default creator is valid"); [EOL] } [EOL] }
public void testCreateUsingDefaultWithExceptionInInitializerError() { [EOL] DefaultCreator mockCreator = mock(DefaultCreator.class); [EOL] when(mockCreator.call()).thenThrow(new ExceptionInInitializerError()); [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(mockCreator); [EOL] try { [EOL] obj.createUsingDefault(null); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] assertTrue(e.getCause() instanceof ExceptionInInitializerError); [EOL] } [EOL] }
public void testCreateUsingDefaultWithGenericException() { [EOL] DefaultCreator mockCreator = mock(DefaultCreator.class); [EOL] when(mockCreator.call()).thenThrow(new IOException()); [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(mockCreator); [EOL] try { [EOL] obj.createUsingDefault(null); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] assertTrue(e.getCause() instanceof IOException); [EOL] } [EOL] }
public void testCreateFromStringWithFromStringCreator() throws IOException { [EOL] String testValue = "testValue"; [EOL] Object expectedResult = new Object(); [EOL] when(_fromStringCreator.call1(testValue)).thenReturn(expectedResult); [EOL] Object result = createFromString(null, testValue); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testCreateFromStringWithException() throws IOException { [EOL] String testValue = "testValue"; [EOL] Exception toBeThrown = new Exception(); [EOL] when(_fromStringCreator.call1(testValue)).thenThrow(toBeThrown); [EOL] try { [EOL] createFromString(null, testValue); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals(wrapException(toBeThrown), e); [EOL] } [EOL] }
public void testCreateFromStringWithExceptionInInitializerError() throws IOException { [EOL] String testValue = "testValue"; [EOL] ExceptionInInitializerError toBeThrown = new ExceptionInInitializerError(); [EOL] when(_fromStringCreator.call1(testValue)).thenThrow(toBeThrown); [EOL] try { [EOL] createFromString(null, testValue); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals(wrapException(toBeThrown), e); [EOL] } [EOL] }
public void testCreateFromStringFallback() throws IOException { [EOL] String testValue = "testValue"; [EOL] Object expectedResult = new Object(); [EOL] when(_createFromStringFallbacks(null, testValue)).thenReturn(expectedResult); [EOL] _fromStringCreator = null; [EOL] Object result = createFromString(null, testValue); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testCreateFromLongWithFromLongCreator() throws Exception { [EOL] long testValue = 123L; [EOL] Object expected = new Object(); [EOL] when(_fromLongCreator.call1(Long.valueOf(testValue))).thenReturn(expected); [EOL] Object result = createFromLong(ctxt, testValue); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateFromLongWithoutFromLongCreator() { [EOL] long testValue = 123L; [EOL] try { [EOL] createFromLong(ctxt, testValue); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected JsonMappingException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testCreateFromLongWithFromLongCreatorThrowsException() throws Exception { [EOL] long testValue = 123L; [EOL] when(_fromLongCreator.call1(Long.valueOf(testValue))).thenThrow(new Exception("test exception")); [EOL] try { [EOL] createFromLong(ctxt, testValue); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testCreateFromLongWithFromLongCreatorThrowsError() throws Exception { [EOL] long testValue = 123L; [EOL] when(_fromLongCreator.call1(Long.valueOf(testValue))).thenThrow(new ExceptionInInitializerError()); [EOL] try { [EOL] createFromLong(ctxt, testValue); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testCreateFromDoubleWithFromDoubleCreator() throws IOException { [EOL] DoubleCreator mockDoubleCreator = Mockito.mock(DoubleCreator.class); [EOL] double testValue = 10.0; [EOL] Object expectedObject = new Object(); [EOL] Mockito.when(mockDoubleCreator.call1(Double.valueOf(testValue))).thenReturn(expectedObject); [EOL] YourClass instance = new YourClass(); [EOL] instance.setFromDoubleCreator(mockDoubleCreator); [EOL] DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); [EOL] Object result = instance.createFromDouble(ctxt, testValue); [EOL] assertEquals(expectedObject, result); [EOL] }
public void testCreateFromDoubleWithoutFromDoubleCreatorThrowsException() { [EOL] double testValue = 10.0; [EOL] YourClass instance = new YourClass(); [EOL] DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); [EOL] try { [EOL] instance.createFromDouble(ctxt, testValue); [EOL] fail("Expected JsonMappingException was not thrown"); [EOL] } catch (JsonMappingException e) { [EOL] String expectedMessage = "Can not instantiate value of type " + instance.getValueTypeDesc() + " from Floating-point number; no one-double/Double-arg constructor/factory method"; [EOL] assertEquals(expectedMessage, e.getMessage()); [EOL] } [EOL] }
public void testCreateFromDoubleWithFromDoubleCreatorThrowsWrappedException() throws Exception { [EOL] DoubleCreator mockDoubleCreator = Mockito.mock(DoubleCreator.class); [EOL] double testValue = 10.0; [EOL] Exception toBeThrown = new Exception("Inner exception"); [EOL] Mockito.when(mockDoubleCreator.call1(Double.valueOf(testValue))).thenThrow(toBeThrown); [EOL] YourClass instance = new YourClass(); [EOL] instance.setFromDoubleCreator(mockDoubleCreator); [EOL] DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); [EOL] try { [EOL] instance.createFromDouble(ctxt, testValue); [EOL] fail("Expected exception was not thrown"); [EOL] } catch (Exception e) { [EOL] Exception expectedWrappedException = instance.wrapException(toBeThrown); [EOL] assertEquals(expectedWrappedException.getClass(), e.getClass()); [EOL] assertEquals(expectedWrappedException.getMessage(), e.getMessage()); [EOL] } [EOL] }
public void testCreateFromDoubleWithFromDoubleCreatorThrowsExceptionInInitializerError() throws Exception { [EOL] DoubleCreator mockDoubleCreator = Mockito.mock(DoubleCreator.class); [EOL] double testValue = 10.0; [EOL] ExceptionInInitializerError toBeThrown = new ExceptionInInitializerError("Inner error"); [EOL] Mockito.when(mockDoubleCreator.call1(Double.valueOf(testValue))).thenThrow(toBeThrown); [EOL] YourClass instance = new YourClass(); [EOL] instance.setFromDoubleCreator(mockDoubleCreator); [EOL] DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); [EOL] try { [EOL] instance.createFromDouble(ctxt, testValue); [EOL] fail("Expected ExceptionInInitializerError was not thrown"); [EOL] } catch (ExceptionInInitializerError e) { [EOL] Exception expectedWrappedException = instance.wrapException(toBeThrown); [EOL] assertEquals(expectedWrappedException.getClass(), e.getClass()); [EOL] assertEquals(expectedWrappedException.getMessage(), e.getMessage()); [EOL] } [EOL] }
public void testCreateFromBooleanWithTrueValue() throws IOException { [EOL] YourDeserializationClass instance = new YourDeserializationClass(true); [EOL] Object result = instance.createFromBoolean(new DeserializationContext(), true); [EOL] assertNotNull(result); [EOL] assertTrue((Boolean) result.getValue()); [EOL] }
public void testCreateFromBooleanWithFalseValue() throws IOException { [EOL] YourDeserializationClass instance = new YourDeserializationClass(false); [EOL] Object result = instance.createFromBoolean(new DeserializationContext(), false); [EOL] assertNotNull(result); [EOL] assertFalse((Boolean) result.getValue()); [EOL] }
public void testCreateFromBooleanWithException() { [EOL] YourDeserializationClass instance = new YourDeserializationClass(); [EOL] instance.setFromBooleanCreator(creatorThatThrowsException()); [EOL] try { [EOL] instance.createFromBoolean(new DeserializationContext(), true); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not instantiate value of type " + instance.getValueTypeDesc() + " from Boolean value; no single-boolean/Boolean-arg constructor/factory method", e.getMessage()); [EOL] } [EOL] }
public void testCreateFromBooleanWithNoBooleanCreator() { [EOL] YourDeserializationClass instance = new YourDeserializationClass(); [EOL] instance.setFromBooleanCreator(null); [EOL] try { [EOL] instance.createFromBoolean(new DeserializationContext(), true); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not instantiate value of type " + instance.getValueTypeDesc() + " from Boolean value; no single-boolean/Boolean-arg constructor/factory method", e.getMessage()); [EOL] } [EOL] }
public void testGetIncompleteParameterWhenParameterIsSet() { [EOL] AnnotatedParameter expectedParameter = new AnnotatedParameter(null, null, null); [EOL] TestClass testClass = new TestClass(expectedParameter); [EOL] AnnotatedParameter result = testClass.getIncompleteParameter(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedParameter, result); [EOL] }
public void testGetIncompleteParameterWhenParameterIsNull() { [EOL] TestClass testClass = new TestClass(null); [EOL] AnnotatedParameter result = testClass.getIncompleteParameter(); [EOL] assertNull(result); [EOL] }
public void testCreateFromStringFallbacksWithTrue() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = " true "; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNotNull(result); [EOL] assertTrue((Boolean) result); [EOL] }
public void testCreateFromStringFallbacksWithFalse() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = " false "; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNotNull(result); [EOL] assertFalse((Boolean) result); [EOL] }
public void testCreateFromStringFallbacksWithEmptyString() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = ""; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNull(result); [EOL] }
public void testCreateFromStringFallbacksWithNonEmptyString() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = "nonEmptyString"; [EOL] try { [EOL] _createFromStringFallbacks(ctxt, value); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonMappingException, but got IOException"); [EOL] } [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] double[] emptyArray = new double[0]; [EOL] new TestSerializer().serializeContents(emptyArray, mockGenerator, mockProvider); [EOL] verify(mockGenerator, never()).writeNumber(anyDouble()); [EOL] }
public void testSerializeContentsNonEmptyArray() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] double[] nonEmptyArray = new double[] {1.0, 2.0, 3.0}; [EOL] new TestSerializer().serializeContents(nonEmptyArray, mockGenerator, mockProvider); [EOL] verify(mockGenerator, times(3)).writeNumber(anyDouble()); [EOL] }
public void testWithTypeHandlerNonNull() { [EOL] MapType originalMapType = new MapType(SomeClass.class, keyType, valueType, valueHandler, typeHandler, asStatic); [EOL] Object newTypeHandler = new Object(); [EOL] MapType newMapType = originalMapType.withTypeHandler(newTypeHandler); [EOL] assertNotNull(newMapType); [EOL] assertSame(SomeClass.class, newMapType.getRawClass()); [EOL] assertSame(keyType, newMapType.getKeyType()); [EOL] assertSame(valueType, newMapType.getContentType()); [EOL] assertSame(valueHandler, newMapType.getValueHandler()); [EOL] assertSame(newTypeHandler, newMapType.getTypeHandler()); [EOL] assertEquals(asStatic, newMapType.isStatic()); [EOL] }
public void testWithTypeHandlerNull() { [EOL] MapType originalMapType = new MapType(SomeClass.class, keyType, valueType, valueHandler, typeHandler, asStatic); [EOL] MapType newMapType = originalMapType.withTypeHandler(null); [EOL] assertNotNull(newMapType); [EOL] assertSame(SomeClass.class, newMapType.getRawClass()); [EOL] assertSame(keyType, newMapType.getKeyType()); [EOL] assertSame(valueType, newMapType.getContentType()); [EOL] assertSame(valueHandler, newMapType.getValueHandler()); [EOL] assertNull(newMapType.getTypeHandler()); [EOL] assertEquals(asStatic, newMapType.isStatic()); [EOL] }
public void testWithStaticTyping_AlreadyStatic() { [EOL] MapType original = new MapType(SomeClass.class, keyType, valueType, null, null, true); [EOL] MapType result = original.withStaticTyping(); [EOL] assertSame("Should return the same object if already static", original, result); [EOL] }
public void testWithStaticTyping_NotStatic() { [EOL] MapType original = new MapType(SomeClass.class, keyType, valueType, null, null, false); [EOL] MapType result = original.withStaticTyping(); [EOL] assertNotSame("Should not return the same object if not static", original, result); [EOL] assertTrue("Resulting MapType should have static typing enabled", result.isStaticTyping()); [EOL] }
public void testFindBeanDeserializerWithQName() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(QName.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = config.introspect(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof QNameDeserializer); [EOL] }
public void testFindBeanDeserializerWithXMLGregorianCalendar() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(XMLGregorianCalendar.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = config.introspect(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof GregorianCalendarDeserializer); [EOL] }
public void testFindBeanDeserializerWithDuration() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Duration.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = config.introspect(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DurationDeserializer); [EOL] }
public void testFindBeanDeserializerWithUnrecognizedType() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = config.introspect(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testDeserializeValidDuration() { [EOL] String validDurationString = "PT20.345S"; [EOL] DurationDeserializer deserializer = new DurationDeserializer(); [EOL] Duration result = deserializer._deserialize(validDurationString, new DeserializationContext()); [EOL] assertNotNull(result); [EOL] assertEquals(DatatypeFactory.newInstance().newDuration(validDurationString), result); [EOL] }
public void testDeserializeInvalidDuration() { [EOL] String invalidDurationString = "INVALID"; [EOL] DurationDeserializer deserializer = new DurationDeserializer(); [EOL] try { [EOL] deserializer._deserialize(invalidDurationString, new DeserializationContext()); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAnnotationWithValidClass() { [EOL] Member memberMock = Mockito.mock(Member.class); [EOL] Mockito.when(memberMock.getAnnotation(SomeAnnotation.class)).thenReturn(new SomeAnnotationImpl()); [EOL] JacksonAnnotationIntrospector introspector = new JacksonAnnotationIntrospector(memberMock); [EOL] SomeAnnotation annotation = introspector.getAnnotation(SomeAnnotation.class); [EOL] assertNotNull(annotation); [EOL] }
public void testGetAnnotationWithInvalidClass() { [EOL] Member memberMock = Mockito.mock(Member.class); [EOL] Mockito.when(memberMock.getAnnotation(OtherAnnotation.class)).thenReturn(null); [EOL] JacksonAnnotationIntrospector introspector = new JacksonAnnotationIntrospector(memberMock); [EOL] OtherAnnotation annotation = introspector.getAnnotation(OtherAnnotation.class); [EOL] assertNull(annotation); [EOL] }
public void testSerializeAsFieldWithNullValueAndNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> nullSerializer = mock(JsonSerializer.class); [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw._nullSerializer = nullSerializer; [EOL] bpw._name = "fieldName"; [EOL] bpw.serializeAsField(null, jgen, prov); [EOL] verify(jgen).writeFieldName("fieldName"); [EOL] verify(nullSerializer).serialize(null, jgen, prov); [EOL] }
public void testSerializeAsFieldWithValueAndNoSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] PropertySerializerMap map = mock(PropertySerializerMap.class); [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw._serializer = null; [EOL] bpw._dynamicSerializers = map; [EOL] when(map.serializerFor(any(Class.class))).thenReturn(null); [EOL] when(bpw._findAndAddDynamic(map, value.getClass(), prov)).thenReturn(mock(JsonSerializer.class)); [EOL] bpw.serializeAsField(bean, jgen, prov); [EOL] verify(map).serializerFor(value.getClass()); [EOL] }
public void testSerializeAsFieldWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw._serializer = ser; [EOL] bpw._suppressableValue = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL] when(ser.isEmpty(value)).thenReturn(true); [EOL] bpw.serializeAsField(bean, jgen, prov); [EOL] verify(ser, never()).serialize(any(), any(), any()); [EOL] }
public void testSerializeAsFieldWithSelfReference() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw._serializer = ser; [EOL] bpw._name = "fieldName"; [EOL] bpw.serializeAsField(bean, jgen, prov); [EOL] }
public void testSerializeAsFieldWithTypeSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw._serializer = ser; [EOL] bpw._typeSerializer = typeSer; [EOL] bpw._name = "fieldName"; [EOL] bpw.serializeAsField(value, jgen, prov); [EOL] verify(ser).serializeWithType(value, jgen, prov, typeSer); [EOL] }
public void testHandleNonArrayWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] Object[] result = handleNonArray(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testHandleNonArrayWithException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> handleNonArray(jp, ctxt)); [EOL] }
public void testHandleNonArrayWithSingleValueAsArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> elementDeserializer = mock(JsonDeserializer.class); [EOL] Object mockValue = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(elementDeserializer.deserialize(jp, ctxt)).thenReturn(mockValue); [EOL] _elementDeserializer = elementDeserializer; [EOL] _untyped = true; [EOL] Object[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(mockValue, result[0]); [EOL] }
public void testHandleNonArrayWithSingleValueAndTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> elementDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] Object mockValue = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(elementDeserializer.deserializeWithType(jp, ctxt, elementTypeDeserializer)).thenReturn(mockValue); [EOL] _elementDeserializer = elementDeserializer; [EOL] _elementTypeDeserializer = elementTypeDeserializer; [EOL] _untyped = false; [EOL] _elementClass = Object.class; [EOL] Object[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(mockValue, result[0]); [EOL] }
public void testFindObjectIdInfoWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated ann = null; [EOL] ObjectIdInfo result = mapper.getSerializationConfig().introspect(null).findObjectIdInfo(ann); [EOL] assertNull(result); [EOL] }
public void testFindPropertyContentTypeResolver_ReturnsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember annotatedMember = null; // Assuming AnnotatedMember is an interface or abstract class [EOL] JavaType containerType = null; // Assuming JavaType is a class or interface [EOL] TypeResolverBuilder<?> result = mapper.getDeserializationConfig().findPropertyContentTypeResolver(null, annotatedMember, containerType); [EOL] assertNull(result); [EOL] }
public void testFindFormatWithNullMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonFormat.Value result = mapper.getSerializationConfig().findFormat(null); [EOL] assertNull(result); [EOL] }

public void testFindFormatWithAnnotatedMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] Object result = mapper.getSerializationConfig().findFormat(annotatedMember); [EOL] assertNotNull(result); [EOL] }
public void testFindFormatWithNonAnnotatedMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated memberOrClass = mock(Annotated.class); [EOL] Object result = mapper.getSerializationConfig().findFormat(memberOrClass); [EOL] assertNull(result); [EOL] }
public Object findContentSerializer(Annotated am) { [EOL] return null; [EOL] }
public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL] return null; [EOL] }
public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL] return null; [EOL] }
public Object findSerializationContentConverter(AnnotatedMember a) { [EOL] return null; [EOL] }
public void testMapSerializerCopyConstructor() { [EOL] HashSet<String> ignoredSet = new HashSet<>(); [EOL] ignoredSet.add("ignoredKey"); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] MapSerializer original = new MapSerializer(null, null, null, null, null); [EOL] MapSerializer copy = new MapSerializer(original, property, keySerializer, valueSerializer, ignoredSet); [EOL] assertNotNull(copy); [EOL] assertEquals(ignoredSet, copy._ignoredEntries); [EOL] assertEquals(original._keyType, copy._keyType); [EOL] assertEquals(original._valueType, copy._valueType); [EOL] assertEquals(original._valueTypeIsStatic, copy._valueTypeIsStatic); [EOL] assertEquals(original._valueTypeSerializer, copy._valueTypeSerializer); [EOL] assertSame(keySerializer, copy._keySerializer); [EOL] assertSame(valueSerializer, copy._valueSerializer); [EOL] assertEquals(original._dynamicValueSerializers, copy._dynamicValueSerializers); [EOL] assertSame(property, copy._property); [EOL] }
public void testMapSerializerCopyWithTypeSerializer() { [EOL] TypeSerializer vts = new MockTypeSerializer(); [EOL] MapSerializer src = new MapSerializer(null, null, null, false, vts, null, null); [EOL] MapSerializer copy = new MapSerializer(src, vts); [EOL] assertNotNull(copy); [EOL] assertEquals(src._ignoredEntries, copy._ignoredEntries); [EOL] assertEquals(src._keyType, copy._keyType); [EOL] assertEquals(src._valueType, copy._valueType); [EOL] assertEquals(src._valueTypeIsStatic, copy._valueTypeIsStatic); [EOL] assertSame(vts, copy._valueTypeSerializer); [EOL] assertEquals(src._keySerializer, copy._keySerializer); [EOL] assertEquals(src._valueSerializer, copy._valueSerializer); [EOL] assertEquals(src._dynamicValueSerializers, copy._dynamicValueSerializers); [EOL] assertEquals(src._property, copy._property); [EOL] }
public void testWithValueTypeSerializerNonNull() { [EOL] TypeSerializer typeSerializer = new StdTypeSerializer(); [EOL] MapSerializer originalMapSerializer = new MapSerializer(); [EOL] MapSerializer newMapSerializer = originalMapSerializer._withValueTypeSerializer(typeSerializer); [EOL] assertNotNull(newMapSerializer); [EOL] }
public void testWithValueTypeSerializerNull() { [EOL] MapSerializer originalMapSerializer = new MapSerializer(); [EOL] MapSerializer newMapSerializer = originalMapSerializer._withValueTypeSerializer(null); [EOL] assertNotNull(newMapSerializer); [EOL] }
public void testWithResolved() { [EOL] JsonSerializer<?> keySerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] HashSet<String> ignored = new HashSet<>(); [EOL] ignored.add("key1"); [EOL] MapSerializer original = new MapSerializer(null, null, null, null, null); [EOL] MapSerializer result = original.withResolved(property, keySerializer, valueSerializer, ignored); [EOL] assertNotSame(original, result); [EOL] assertSame(property, result.getProperty()); [EOL] assertSame(keySerializer, result.getKeySerializer()); [EOL] assertSame(valueSerializer, result.getValueSerializer()); [EOL] assertEquals(ignored, result.getIgnoredEntries()); [EOL] }
public void testWithResolvedNullParameters() { [EOL] MapSerializer original = new MapSerializer(null, null, null, null, null); [EOL] MapSerializer result = original.withResolved(null, null, null, null); [EOL] assertNotSame(original, result); [EOL] assertNull(result.getProperty()); [EOL] assertNull(result.getKeySerializer()); [EOL] assertNull(result.getValueSerializer()); [EOL] assertNull(result.getIgnoredEntries()); [EOL] }
public JsonSerializer<?> testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public JsonSerializer<?> testCreateContextualWithNonNullPropertyAndMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findKeySerializer(member)).thenReturn(null); [EOL] when(introspector.findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public JsonSerializer<?> testCreateContextualWithNonNullPropertyAndMemberWithKeySerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] Object keySerDef = new Object(); [EOL] when(introspector.findKeySerializer(member)).thenReturn(keySerDef); [EOL] JsonSerializer<?> keySerializer = mock(JsonSerializer.class); [EOL] when(provider.serializerInstance(member, keySerDef)).thenReturn(keySerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public JsonSerializer<?> testCreateContextualWithNonNullPropertyAndMemberWithContentSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] Object contentSerDef = new Object(); [EOL] when(introspector.findContentSerializer(member)).thenReturn(contentSerDef); [EOL] JsonSerializer<?> contentSerializer = mock(JsonSerializer.class); [EOL] when(provider.serializerInstance(member, contentSerDef)).thenReturn(contentSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public JsonSerializer<?> testCreateContextualWithNonNullPropertyAndIgnoredEntries() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] String[] toIgnore = new String[]{"propToIgnore"}; [EOL] when(introspector.findPropertiesToIgnore(member)).thenReturn(toIgnore); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testSerializeEmptyMap() throws IOException { [EOL] Map<?, ?> emptyMap = Collections.emptyMap(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] MapSerializer serializer = new MapSerializer(null, null, false, null, null, null); [EOL] serializer.serialize(emptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testSerializeNonEmptyMapWithoutOrdering() throws IOException { [EOL] Map<String, String> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("key", "value"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(false); [EOL] MapSerializer serializer = new MapSerializer(null, null, false, null, null, null); [EOL] serializer.serialize(nonEmptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeFieldName("key"); [EOL] verify(mockJsonGenerator).writeString("value"); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testSerializeNonEmptyMapWithOrdering() throws IOException { [EOL] Map<String, String> nonEmptyMap = new TreeMap<>(); [EOL] nonEmptyMap.put("b", "value2"); [EOL] nonEmptyMap.put("a", "value1"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(true); [EOL] MapSerializer serializer = new MapSerializer(null, null, false, null, null, null); [EOL] serializer.serialize(nonEmptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeFieldName("a"); [EOL] verify(mockJsonGenerator).writeString("value1"); [EOL] verify(mockJsonGenerator).writeFieldName("b"); [EOL] verify(mockJsonGenerator).writeString("value2"); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testSerializeNonEmptyMapUsingValueSerializer() throws IOException { [EOL] Map<String, String> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("key", "value"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> mockValueSerializer = mock(JsonSerializer.class); [EOL] MapSerializer serializer = new MapSerializer(null, null, false, null, mockValueSerializer, null); [EOL] serializer.serialize(nonEmptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockValueSerializer).serialize("value", mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testSerializeWithTypeEmptyMap() throws IOException { [EOL] Map<?, ?> value = new HashMap<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(value, jgen); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] }
public void testSerializeWithTypeNonEmptyMapWithoutOrdering() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(false); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(value, jgen); [EOL] verify(jgen).writeFieldName("key"); [EOL] }
public void testSerializeWithTypeNonEmptyMapWithOrdering() throws IOException { [EOL] Map<Object, Object> value = new LinkedHashMap<>(); [EOL] value.put("b", "value2"); [EOL] value.put("a", "value1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(true); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(value, jgen); [EOL] InOrder inOrder = inOrder(jgen); [EOL] inOrder.verify(jgen).writeFieldName("a"); [EOL] inOrder.verify(jgen).writeFieldName("b"); [EOL] }
public void testSerializeWithTypeNonEmptyMapUsingValueSerializer() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] _valueSerializer = valueSerializer; // Assuming this is a field in the class [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(value, jgen); [EOL] verify(valueSerializer).serialize(eq("value"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsWithValueTypeSerializerNotNull() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._valueTypeSerializer = mock(TypeSerializer.class); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(instance._valueTypeSerializer).serializeTypedFields(value, jgen, provider); [EOL] }
public void testSerializeFieldsWithNullKey() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put(null, "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(provider).findNullKeySerializer(any(), any()); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeFieldsWithNonNullKeyAndValue() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance._dynamicValueSerializers = PropertySerializerMap.emptyForProperties(); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(instance._keySerializer).serialize("key", jgen, provider); [EOL] verify(provider, never()).defaultSerializeNull(jgen); [EOL] }
public void testSerializeFieldsWithIgnoredKey() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("ignoredKey", "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance._ignoredEntries = new HashSet<>(); [EOL] instance._ignoredEntries.add("ignoredKey"); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(instance._keySerializer, never()).serialize(any(), any(), any()); [EOL] }
public void testSerializeFieldsWithNullValueAndSerializationFeatureEnabled() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeFieldsWithNonNullValueAndSerializerNotFound() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", new Object()); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance._dynamicValueSerializers = PropertySerializerMap.emptyForProperties(); [EOL] instance._valueType = SimpleType.constructUnsafe(Object.class); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(provider, never()).defaultSerializeNull(jgen); [EOL] }
public void testSerializeFieldsWithExceptionDuringSerialization() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", new Object()); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance._dynamicValueSerializers = PropertySerializerMap.emptyForProperties(); [EOL] instance._valueType = SimpleType.constructUnsafe(Object.class); [EOL] doThrow(new IOException()).when(jgen).writeObject(any()); [EOL] assertThrows(IOException.class, () -> instance.serializeFields(value, jgen, provider)); [EOL] }
public void testSerializeFieldsUsingWithNonNullValues() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key1", "value1"); [EOL] value.put("key2", "value2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(false); [EOL] when(_keySerializer).thenReturn(keySerializer); [EOL] serializeFieldsUsing(value, jgen, provider, ser); [EOL] verify(keySerializer, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] verify(ser, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsUsingWithNullKey() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put(null, "value1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> nullKeySerializer = mock(JsonSerializer.class); [EOL] when(provider.findNullKeySerializer(any(), any())).thenReturn(nullKeySerializer); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(false); [EOL] serializeFieldsUsing(value, jgen, provider, ser); [EOL] verify(nullKeySerializer).serialize(eq(null), eq(jgen), eq(provider)); [EOL] verify(ser).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsUsingWithNullValue() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key1", null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); [EOL] when(_keySerializer).thenReturn(keySerializer); [EOL] serializeFieldsUsing(value, jgen, provider, ser); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(keySerializer).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsUsingWithIgnoredKey() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key1", "value1"); [EOL] value.put("ignoredKey", "value2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); [EOL] HashSet<String> ignored = new HashSet<>(); [EOL] ignored.add("ignoredKey"); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(false); [EOL] when(_keySerializer).thenReturn(keySerializer); [EOL] when(_ignoredEntries).thenReturn(ignored); [EOL] serializeFieldsUsing(value, jgen, provider, ser); [EOL] verify(keySerializer).serialize(eq("key1"), eq(jgen), eq(provider)); [EOL] verify(ser).serialize(eq("value1"), eq(jgen), eq(provider)); [EOL] verify(keySerializer, never()).serialize(eq("ignoredKey"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsUsingWithTypeSerializer() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key1", "value1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(false); [EOL] when(_keySerializer).thenReturn(keySerializer); [EOL] when(_valueTypeSerializer).thenReturn(typeSer); [EOL] serializeFieldsUsing(value, jgen, provider, ser); [EOL] verify(ser).serializeWithType(eq("value1"), eq(jgen), eq(provider), eq(typeSer)); [EOL] }
public void testSerializeFieldsUsingWithSerializationException() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key1", "value1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(false); [EOL] when(_keySerializer).thenReturn(keySerializer); [EOL] doThrow(new IOException()).when(ser).serialize(any(), eq(jgen), eq(provider)); [EOL] try { [EOL] serializeFieldsUsing(value, jgen, provider, ser); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(keySerializer).serialize(eq("key1"), eq(jgen), eq(provider)); [EOL] }
public void testFindAndAddDynamicNewMap() throws JsonMappingException { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyForProperties(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] JsonSerializer<Object> serializer = _findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertNotSame(map, _dynamicValueSerializers); [EOL] }
public void testFindAndAddDynamicExistingMap() throws JsonMappingException { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyForProperties(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] map = map.newWith(type, new StdSerializer<Object>(type) {}); [EOL] int initialSize = map.size(); [EOL] JsonSerializer<Object> serializer = _findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertEquals(initialSize, _dynamicValueSerializers.size()); [EOL] assertSame(map, _dynamicValueSerializers); [EOL] }
public void testDeserializeWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] Object expectedObject = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromObject(jp, ctxt)).thenReturn(expectedObject); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expectedObject, result); [EOL] }
public void testReadAndBindWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] when(valueDes.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn("value1"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertEquals("value1", result.get("key1")); [EOL] }
public void testReadAndBindWithIgnorableProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key1"); [EOL] _ignorableProperties = ignorableProperties; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1", "key2"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1", "key2"); [EOL] when(valueDes.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn("value2"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key2")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testReadAndBindWithValueDeserializerWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] when(valueDes.deserializeWithType(any(JsonParser.class), any(DeserializationContext.class), any(TypeDeserializer.class))).thenReturn("value1"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertEquals("value1", result.get("key1")); [EOL] }
public void testReadAndBindWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_NULL, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertNull(result.get("key1")); [EOL] }
public void testReadAndBindStringMapWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("value"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadAndBindStringMapWithIgnorableProperty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] this._ignorableProperties = ignorableProperties; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testReadAndBindStringMapWithValueDeserializerWithType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("value"); [EOL] this._valueDeserializer = valueDes; [EOL] this._valueTypeDeserializer = typeDeser; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadAndBindStringMapWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_NULL, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertNull(result.get("key")); [EOL] }
public void testIsCachable() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertFalse(mapper.getDeserializationConfig().isCachable()); [EOL] }
public void testFindDeserializerWithJavaxXml() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) JavaxXmlType.class); [EOL] when(JavaxXmlType.class.getName()).thenReturn("javax.xml.Type"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JavaxXmlDeserializer); [EOL] }
public void testFindDeserializerWithDomDocument() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) DomDocumentType.class); [EOL] when(DomDocumentType.class.getName()).thenReturn("org.w3c.dom.Document"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DomDocumentDeserializer); [EOL] }
public void testFindDeserializerWithDomNode() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) DomNodeType.class); [EOL] when(DomNodeType.class.getName()).thenReturn("org.w3c.dom.Node"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DomNodeDeserializer); [EOL] }
public void testFindDeserializerReturnsNull() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) OtherType.class); [EOL] when(OtherType.class.getName()).thenReturn("com.example.OtherType"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testDoesImplementWithExactClassMatch() { [EOL] boolean result = doesImplement(String.class, "java.lang.String"); [EOL] assertTrue(result); [EOL] }
public void testDoesImplementWithSuperclassMatch() { [EOL] boolean result = doesImplement(Integer.class, "java.lang.Number"); [EOL] assertTrue(result); [EOL] }
public void testDoesImplementWithInterfaceMatch() { [EOL] boolean result = doesImplement(ArrayList.class, "java.util.List"); [EOL] assertTrue(result); [EOL] }
public void testDoesImplementWithNoMatch() { [EOL] boolean result = doesImplement(Object.class, "java.util.List"); [EOL] assertFalse(result); [EOL] }
public void testDoesImplementWithNullClass() { [EOL] boolean result = doesImplement(null, "java.util.List"); [EOL] assertFalse(result); [EOL] }
public void testHasInterfaceWithDirectInterface() { [EOL] boolean result = hasInterface(SomeClassWithDesiredInterface.class, "com.example.DesiredInterface"); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasInterfaceWithoutInterface() { [EOL] boolean result = hasInterface(SomeClassWithoutDesiredInterface.class, "com.example.DesiredInterface"); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasInterfaceWithInheritedInterface() { [EOL] boolean result = hasInterface(SomeClassWithInheritedInterface.class, "com.example.DesiredInterface"); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasInterfaceWithNoInterfaces() { [EOL] boolean result = hasInterface(Object.class, "com.example.DesiredInterface"); [EOL] assertFalse(result); [EOL] }
public void testHasSupertypeStartingWith_SuperclassMatch() { [EOL] class SuperclassWithPrefix {} [EOL] class Subclass extends SuperclassWithPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "SuperclassWithPrefix"); [EOL] assert result; [EOL] }
public void testHasSupertypeStartingWith_NoSuperclassMatch() { [EOL] class SuperclassWithoutPrefix {} [EOL] class Subclass extends SuperclassWithoutPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "NonExistentPrefix"); [EOL] assert !result; [EOL] }
public void testHasSupertypeStartingWith_InterfaceMatch() { [EOL] class Superclass {} [EOL] class Subclass extends Superclass implements InterfaceWithPrefix {} [EOL] interface InterfaceWithPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "InterfaceWithPrefix"); [EOL] assert result; [EOL] }
public void testHasSupertypeStartingWith_NoMatchAtAll() { [EOL] class Superclass {} [EOL] class Subclass extends Superclass {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "NonExistentPrefix"); [EOL] assert !result; [EOL] }
public void testHasInterfaceStartingWith_InterfaceMatchesPrefix_ReturnsTrue() { [EOL] class TestClass implements MyPrefixedInterface {} [EOL] boolean result = hasInterfaceStartingWith(TestClass.class, "MyPrefix"); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_InterfaceDoesNotMatchPrefix_ReturnsFalse() { [EOL] class TestClass implements MyOtherInterface {} [EOL] boolean result = hasInterfaceStartingWith(TestClass.class, "MyPrefix"); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_NoInterfaces_ReturnsFalse() { [EOL] class TestClass {} [EOL] boolean result = hasInterfaceStartingWith(TestClass.class, "MyPrefix"); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_IndirectInterfaceMatchesPrefix_ReturnsTrue() { [EOL] class ParentClass implements MyPrefixedInterface {} [EOL] class TestClass extends ParentClass {} [EOL] boolean result = hasInterfaceStartingWith(TestClass.class, "MyPrefix"); [EOL] assertTrue(result); [EOL] }
public void testHasInterfaceStartingWith_IndirectInterfaceDoesNotMatchPrefix_ReturnsFalse() { [EOL] class ParentClass implements MyOtherInterface {} [EOL] class TestClass extends ParentClass {} [EOL] boolean result = hasInterfaceStartingWith(TestClass.class, "MyPrefix"); [EOL] assertFalse(result); [EOL] }
public void testParseValidDateWithMilliseconds() { [EOL] String validDateWithMilliseconds = "2023-03-15T10:20:30.123Z"; [EOL] Date result = parse(validDateWithMilliseconds); [EOL] assertNotNull(result); [EOL] Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("GMT")); [EOL] calendar.set(2023, Calendar.MARCH, 15, 10, 20, 30); [EOL] calendar.set(Calendar.MILLISECOND, 123); [EOL] Date expected = calendar.getTime(); [EOL] assertEquals(expected, result); [EOL] }
public void testParseValidDateWithoutMilliseconds() { [EOL] String validDateWithoutMilliseconds = "2023-03-15T10:20:30Z"; [EOL] Date result = parse(validDateWithoutMilliseconds); [EOL] assertNotNull(result); [EOL] Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("GMT")); [EOL] calendar.set(2023, Calendar.MARCH, 15, 10, 20, 30); [EOL] calendar.set(Calendar.MILLISECOND, 0); [EOL] Date expected = calendar.getTime(); [EOL] assertEquals(expected, result); [EOL] }
public void testParseDateWithInvalidFormat() { [EOL] String invalidDateFormat = "2023-03-15"; [EOL] try { [EOL] parse(invalidDateFormat); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseDateWithInvalidTimeZone() { [EOL] String invalidTimeZone = "2023-03-15T10:20:30.123X"; [EOL] try { [EOL] parse(invalidTimeZone); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testParseDateWithInvalidMonth() { [EOL] String invalidMonth = "2023-13-15T10:20:30Z"; [EOL] try { [EOL] parse(invalidMonth); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCheckOffsetWithCorrectOffset() { [EOL] String testString = "hello"; [EOL] int offset = 1; [EOL] char expectedChar = 'e'; [EOL] checkOffset(testString, offset, expectedChar); [EOL] }
public void testCheckOffsetWithIncorrectOffset() { [EOL] String testString = "hello"; [EOL] int offset = 1; [EOL] char expectedChar = 'a'; [EOL] try { [EOL] checkOffset(testString, offset, expectedChar); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Expected 'a' character but found 'e'", e.getMessage()); [EOL] } [EOL] }
public void testCheckOffsetWithOutOfBoundsOffset() { [EOL] String testString = "hello"; [EOL] int offset = 5; [EOL] char expectedChar = 'a'; [EOL] try { [EOL] checkOffset(testString, offset, expectedChar); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: 5", e.getMessage()); [EOL] } [EOL] }
public void testParseIntValidInput() { [EOL] String value = "12345"; [EOL] int beginIndex = 0; [EOL] int endIndex = 5; [EOL] int result = parseInt(value, beginIndex, endIndex); [EOL] assertEquals(12345, result); [EOL] }
public void testParseIntInvalidInputNegativeBeginIndex() { [EOL] String value = "12345"; [EOL] int beginIndex = -1; [EOL] int endIndex = 5; [EOL] try { [EOL] parseInt(value, beginIndex, endIndex); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntInvalidInputEndIndexGreaterThanLength() { [EOL] String value = "12345"; [EOL] int beginIndex = 0; [EOL] int endIndex = 6; [EOL] try { [EOL] parseInt(value, beginIndex, endIndex); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntInvalidInputBeginIndexGreaterThanEndIndex() { [EOL] String value = "12345"; [EOL] int beginIndex = 3; [EOL] int endIndex = 2; [EOL] try { [EOL] parseInt(value, beginIndex, endIndex); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntInvalidCharacter() { [EOL] String value = "12a45"; [EOL] int beginIndex = 0; [EOL] int endIndex = 5; [EOL] try { [EOL] parseInt(value, beginIndex, endIndex); [EOL] fail("Should have thrown NumberFormatException for invalid character"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntSingleDigit() { [EOL] String value = "7"; [EOL] int beginIndex = 0; [EOL] int endIndex = 1; [EOL] int result = parseInt(value, beginIndex, endIndex); [EOL] assertEquals(7, result); [EOL] }
public void testParseIntLeadingZeros() { [EOL] String value = "007"; [EOL] int beginIndex = 0; [EOL] int endIndex = 3; [EOL] int result = parseInt(value, beginIndex, endIndex); [EOL] assertEquals(7, result); [EOL] }
public void testFindWithTokenBufferClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerCache.find(TokenBuffer.class); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TokenBufferDeserializer); [EOL] }
public void testFindWithJavaTypeClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerCache.find(JavaType.class); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof JavaTypeDeserializer); [EOL] }
public void testFindWithUnassignableClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerCache.find(String.class); [EOL] assertNull(deserializer); [EOL] }
public void testFindValueInstantiatorWithJsonLocationClass() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(JsonLocation.class); [EOL] ValueInstantiator result = ClassName.findValueInstantiator(config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonLocationInstantiator); [EOL] }
public void testFindValueInstantiatorWithNonJsonLocationClass() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(Object.class); [EOL] ValueInstantiator result = ClassName.findValueInstantiator(config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testJsonMappingExceptionWithMessageLocationAndCause() { [EOL] String expectedMessage = "Test message"; [EOL] JsonLocation expectedLocation = new JsonLocation(new Object(), 1L, 2, 3); [EOL] Throwable expectedCause = new Exception("Root cause"); [EOL] JsonMappingException exception = new JsonMappingException(expectedMessage, expectedLocation, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedLocation, exception.getLocation()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public void testFromWithNullJsonParser() { [EOL] JsonMappingException exception = JsonMappingException.from(null, "Error message"); [EOL] assertNull(exception.getLocation()); [EOL] assertEquals("Error message", exception.getMessage()); [EOL] } [EOL] public void testFromWithNonNullJsonParser() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getTokenLocation()).thenReturn(new JsonLocation(new Object(), -1L, -1, -1)); [EOL] JsonMappingException exception = JsonMappingException.from(jp, "Error message"); [EOL] assertNotNull(exception.getLocation()); [EOL] assertEquals("Error message", exception.getMessage()); [EOL] }
public void testGetMessage() { [EOL] MyClass instance = new MyClass(); [EOL] String expected = "expected message"; [EOL] instance.setExpectedMessage(expected); // This line is pseudo-code [EOL] String actual = instance.getMessage(); [EOL] assertEquals(expected, actual); [EOL] }
public void testBuildMessageWithNullPath() { [EOL] JsonMappingException exception = new JsonMappingException(null, "Test message"); [EOL] String result = exception._buildMessage(); [EOL] assertEquals("Test message", result); [EOL] }
public void testBuildMessageWithPath() { [EOL] JsonMappingException exception = new JsonMappingException(null, "Test message"); [EOL] exception.prependPath(new JsonMappingException.Reference(null, "fieldName")); [EOL] String result = exception._buildMessage(); [EOL] assertTrue(result.startsWith("Test message (through reference chain: ")); [EOL] assertTrue(result.endsWith("fieldName)")); [EOL] }
public void testFindValueSerializerWithKnownSerializer() { [EOL] SerializerProvider provider = createProviderWithKnownSerializers(); [EOL] Class<?> valueType = String.class; [EOL] BeanProperty property = createBeanProperty(); [EOL] JsonSerializer<Object> serializer = provider.findValueSerializer(valueType, property); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof KnownSerializer); [EOL] }
public void testFindValueSerializerWithCacheSerializer() { [EOL] SerializerProvider provider = createProviderWithCacheSerializers(); [EOL] Class<?> valueType = Integer.class; [EOL] BeanProperty property = createBeanProperty(); [EOL] JsonSerializer<Object> serializer = provider.findValueSerializer(valueType, property); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof CacheSerializer); [EOL] }
public void testFindValueSerializerWithCreatedSerializer() { [EOL] SerializerProvider provider = createProviderWithoutKnownOrCacheSerializers(); [EOL] Class<?> valueType = CustomType.class; [EOL] BeanProperty property = createBeanProperty(); [EOL] JsonSerializer<Object> serializer = provider.findValueSerializer(valueType, property); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof CreatedSerializer); [EOL] }
public void testFindValueSerializerWithUnknownTypeSerializer() { [EOL] SerializerProvider provider = createProviderWithoutAnySerializers(); [EOL] Class<?> valueType = UnknownType.class; [EOL] BeanProperty property = createBeanProperty(); [EOL] JsonSerializer<Object> serializer = provider.findValueSerializer(valueType, property); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof UnknownTypeSerializer); [EOL] }
public void testFindValueSerializerWithCacheUnknownMappings() { [EOL] SerializerProvider provider = createProviderWithCacheUnknownMappings(); [EOL] Class<?> valueType = UnknownType.class; [EOL] BeanProperty property = createBeanProperty(); [EOL] JsonSerializer<Object> serializer = provider.findValueSerializer(valueType, property); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof UnknownTypeSerializer); [EOL] assertTrue(provider.isSerializerCachedForUnknownType(valueType)); [EOL] }
public void testFindTypedValueSerializerWithKnownSerializer() { [EOL] JavaType valueType = ...; // Initialize with a specific JavaType [EOL] boolean cache = ...; // Set cache to true or false [EOL] BeanProperty property = ...; // Initialize with a specific BeanProperty or null [EOL] JsonSerializer<Object> expectedSerializer = ...; // Mock or create an expected serializer [EOL] _knownSerializers.typedValueSerializer(valueType).andReturn(expectedSerializer); // Expectation setup for known serializers [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertSame(expectedSerializer, result); // Assert that the expected serializer is returned [EOL] }
public void testFindTypedValueSerializerWithCacheSerializer() { [EOL] JavaType valueType = ...; // Initialize with a specific JavaType [EOL] boolean cache = true; // Set cache to true [EOL] BeanProperty property = ...; // Initialize with a specific BeanProperty or null [EOL] _knownSerializers.typedValueSerializer(valueType).andReturn(null); // Expectation setup for known serializers [EOL] JsonSerializer<Object> cachedSerializer = ...; // Mock or create a cached serializer [EOL] _serializerCache.typedValueSerializer(valueType).andReturn(cachedSerializer); // Expectation setup for cache [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertSame(cachedSerializer, result); // Assert that the cached serializer is returned [EOL] verify(_serializerCache).addTypedSerializer(eq(valueType), eq(cachedSerializer)); // Verify that the serializer is cached [EOL] }
public void testFindTypedValueSerializerWithTypeSerializer() { [EOL] JavaType valueType = ...; // Initialize with a specific JavaType [EOL] boolean cache = ...; // Set cache to true or false [EOL] BeanProperty property = ...; // Initialize with a specific BeanProperty or null [EOL] _knownSerializers.typedValueSerializer(valueType).andReturn(null); // Expectation setup for known serializers [EOL] _serializerCache.typedValueSerializer(valueType).andReturn(null); // Expectation setup for cache [EOL] JsonSerializer<Object> valueSerializer = ...; // Mock or create a value serializer [EOL] stub(findValueSerializer(valueType, property)).toReturn(valueSerializer); // Stubbing findValueSerializer [EOL] TypeSerializer typeSerializer = ...; // Mock or create a type serializer [EOL] _serializerFactory.createTypeSerializer(_config, valueType).andReturn(typeSerializer); // Expectation setup for serializer factory [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); // Assert that a serializer is returned [EOL] assertTrue(result instanceof TypeWrappedSerializer); // Assert that the result is a TypeWrappedSerializer [EOL] if (cache) { [EOL] verify(_serializerCache).addTypedSerializer(eq(valueType), eq(result)); // Verify that the serializer is cached [EOL] } [EOL] }
public void testFindTypedValueSerializerWithoutTypeSerializer() { [EOL] JavaType valueType = ...; // Initialize with a specific JavaType [EOL] boolean cache = ...; // Set cache to true or false [EOL] BeanProperty property = ...; // Initialize with a specific BeanProperty or null [EOL] _knownSerializers.typedValueSerializer(valueType).andReturn(null); // Expectation setup for known serializers [EOL] _serializerCache.typedValueSerializer(valueType).andReturn(null); // Expectation setup for cache [EOL] JsonSerializer<Object> valueSerializer = ...; // Mock or create a value serializer [EOL] stub(findValueSerializer(valueType, property)).toReturn(valueSerializer); // Stubbing findValueSerializer [EOL] _serializerFactory.createTypeSerializer(_config, valueType).andReturn(null); // Expectation setup for serializer factory [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertSame(valueSerializer, result); // Assert that the value serializer is returned [EOL] if (cache) { [EOL] verify(_serializerCache).addTypedSerializer(eq(valueType), eq(result)); // Verify that the serializer is cached [EOL] } [EOL] }
