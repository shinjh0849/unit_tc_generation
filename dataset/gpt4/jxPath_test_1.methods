public int getArgumentCount() { [EOL]     if (args == null) { [EOL]         return 0; [EOL]     } [EOL]     return args.length; [EOL] }
public int getArgumentCount() { [EOL]     if (args == null) { [EOL]         return 0; [EOL]     } [EOL]     return args.length; [EOL] }
public int getArgumentCount() { [EOL]     if (args == null) { [EOL]         return 0; [EOL]     } [EOL]     return args.length; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public Object compute(EvalContext context) { [EOL]     return computeValue(context); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
protected Object functionLast(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     int old = context.getCurrentPosition(); [EOL]     context.reset(); [EOL]     int count = 0; [EOL]     while (context.nextNode()) { [EOL]         count++; [EOL]     } [EOL]     if (old != 0) { [EOL]         context.setPosition(old); [EOL]     } [EOL]     return new Double(count); [EOL] }
protected Object functionPosition(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     return new Integer(context.getCurrentPosition()); [EOL] }
protected Object functionPosition(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     return new Integer(context.getCurrentPosition()); [EOL] }
protected Object functionLang(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String lang = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     NodePointer pointer = (NodePointer) context.getSingleNodePointer(); [EOL]     if (pointer == null) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionLang(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String lang = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     NodePointer pointer = (NodePointer) context.getSingleNodePointer(); [EOL]     if (pointer == null) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionLang(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String lang = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     NodePointer pointer = (NodePointer) context.getSingleNodePointer(); [EOL]     if (pointer == null) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionID(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String id = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     JXPathContext jxpathContext = context.getJXPathContext(); [EOL]     NodePointer pointer = (NodePointer) jxpathContext.getContextPointer(); [EOL]     return pointer.getPointerByID(jxpathContext, id); [EOL] }
protected Object functionID(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String id = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     JXPathContext jxpathContext = context.getJXPathContext(); [EOL]     NodePointer pointer = (NodePointer) jxpathContext.getContextPointer(); [EOL]     return pointer.getPointerByID(jxpathContext, id); [EOL] }
protected Object functionID(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String id = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     JXPathContext jxpathContext = context.getJXPathContext(); [EOL]     NodePointer pointer = (NodePointer) jxpathContext.getContextPointer(); [EOL]     return pointer.getPointerByID(jxpathContext, id); [EOL] }
protected Object functionStringLength(EvalContext context) { [EOL]     String s; [EOL]     if (getArgumentCount() == 0) { [EOL]         s = InfoSetUtil.stringValue(context.getCurrentNodePointer()); [EOL]     } else { [EOL]         assertArgCount(1); [EOL]         s = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     } [EOL]     return new Double(s.length()); [EOL] }
protected Object functionStringLength(EvalContext context) { [EOL]     String s; [EOL]     if (getArgumentCount() == 0) { [EOL]         s = InfoSetUtil.stringValue(context.getCurrentNodePointer()); [EOL]     } else { [EOL]         assertArgCount(1); [EOL]         s = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     } [EOL]     return new Double(s.length()); [EOL] }
protected Object functionBoolean(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionBoolean(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionFalse(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     return Boolean.FALSE; [EOL] }
protected Object functionFalse(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     return Boolean.FALSE; [EOL] }
protected Object functionSum(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     Object v = getArg1().compute(context); [EOL]     if (v == null) { [EOL]         return ZERO; [EOL]     } else if (v instanceof EvalContext) { [EOL]         double sum = 0.0; [EOL]         EvalContext ctx = (EvalContext) v; [EOL]         while (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             sum += InfoSetUtil.doubleValue(ptr); [EOL]         } [EOL]         return new Double(sum); [EOL]     } [EOL]     throw new JXPathException("Invalid argument type for 'sum': " + v.getClass().getName()); [EOL] }
protected Object functionSum(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     Object v = getArg1().compute(context); [EOL]     if (v == null) { [EOL]         return ZERO; [EOL]     } else if (v instanceof EvalContext) { [EOL]         double sum = 0.0; [EOL]         EvalContext ctx = (EvalContext) v; [EOL]         while (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             sum += InfoSetUtil.doubleValue(ptr); [EOL]         } [EOL]         return new Double(sum); [EOL]     } [EOL]     throw new JXPathException("Invalid argument type for 'sum': " + v.getClass().getName()); [EOL] }
protected Object functionSum(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     Object v = getArg1().compute(context); [EOL]     if (v == null) { [EOL]         return ZERO; [EOL]     } else if (v instanceof EvalContext) { [EOL]         double sum = 0.0; [EOL]         EvalContext ctx = (EvalContext) v; [EOL]         while (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             sum += InfoSetUtil.doubleValue(ptr); [EOL]         } [EOL]         return new Double(sum); [EOL]     } [EOL]     throw new JXPathException("Invalid argument type for 'sum': " + v.getClass().getName()); [EOL] }
private void assertArgCount(int count) { [EOL]     if (getArgumentCount() != count) { [EOL]         throw new JXPathInvalidSyntaxException("Incorrect number of argument: " + this); [EOL]     } [EOL] }
private void assertArgCount(int count) { [EOL]     if (getArgumentCount() != count) { [EOL]         throw new JXPathInvalidSyntaxException("Incorrect number of argument: " + this); [EOL]     } [EOL] }
public EvalContext getAbsoluteRootContext() { [EOL]     return jxpathContext.getAbsoluteRootContext(); [EOL] }
public EvalContext getConstantContext(Object constant) { [EOL]     if (constant instanceof NodeSet) { [EOL]         return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant); [EOL]     } [EOL]     NodePointer pointer; [EOL]     if (constant instanceof NodePointer) { [EOL]         pointer = (NodePointer) constant; [EOL]     } else { [EOL]         pointer = NodePointer.newNodePointer(new QName(null, ""), constant, null); [EOL]     } [EOL]     return new InitialContext(new RootContext(jxpathContext, pointer)); [EOL] }
public EvalContext getConstantContext(Object constant) { [EOL]     if (constant instanceof NodeSet) { [EOL]         return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant); [EOL]     } [EOL]     NodePointer pointer; [EOL]     if (constant instanceof NodePointer) { [EOL]         pointer = (NodePointer) constant; [EOL]     } else { [EOL]         pointer = NodePointer.newNodePointer(new QName(null, ""), constant, null); [EOL]     } [EOL]     return new InitialContext(new RootContext(jxpathContext, pointer)); [EOL] }
public EvalContext getConstantContext(Object constant) { [EOL]     if (constant instanceof NodeSet) { [EOL]         return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant); [EOL]     } [EOL]     NodePointer pointer; [EOL]     if (constant instanceof NodePointer) { [EOL]         pointer = (NodePointer) constant; [EOL]     } else { [EOL]         pointer = NodePointer.newNodePointer(new QName(null, ""), constant, null); [EOL]     } [EOL]     return new InitialContext(new RootContext(jxpathContext, pointer)); [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL]     Object node1 = pointer1.getBaseValue(); [EOL]     Object node2 = pointer2.getBaseValue(); [EOL]     if (node1 == node2) { [EOL]         return 0; [EOL]     } [EOL]     if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) { [EOL]         return -1; [EOL]     } else if (!(node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL]         return 1; [EOL]     } else if ((node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL]         List list = ((Element) getNode()).getAttributes(); [EOL]         int length = list.size(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             Object n = list.get(i); [EOL]             if (n == node1) { [EOL]                 return -1; [EOL]             } else if (n == node2) { [EOL]                 return 1; [EOL]             } [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (!(node instanceof Element)) { [EOL]         throw new RuntimeException("JXPath internal error: " + "compareChildNodes called for " + node); [EOL]     } [EOL]     List children = ((Element) node).getContent(); [EOL]     int length = children.size(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         Object n = children.get(i); [EOL]         if (n == node1) { [EOL]             return -1; [EOL]         } else if (n == node2) { [EOL]             return 1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLanguage(String lang) { [EOL]     String current = getLanguage(); [EOL]     if (current == null) { [EOL]         return super.isLanguage(lang); [EOL]     } [EOL]     return current.toUpperCase().startsWith(lang.toUpperCase()); [EOL] }
public boolean isLanguage(String lang) { [EOL]     String current = getLanguage(); [EOL]     if (current == null) { [EOL]         return super.isLanguage(lang); [EOL]     } [EOL]     return current.toUpperCase().startsWith(lang.toUpperCase()); [EOL] }
public boolean isLanguage(String lang) { [EOL]     String current = getLanguage(); [EOL]     if (current == null) { [EOL]         return super.isLanguage(lang); [EOL]     } [EOL]     return current.toUpperCase().startsWith(lang.toUpperCase()); [EOL] }
protected String getLanguage() { [EOL]     Object n = node; [EOL]     while (n != null) { [EOL]         if (n instanceof Element) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = nodeParent(n); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Object n = node; [EOL]     while (n != null) { [EOL]         if (n instanceof Element) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = nodeParent(n); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Object n = node; [EOL]     while (n != null) { [EOL]         if (n instanceof Element) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = nodeParent(n); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Object n = node; [EOL]     while (n != null) { [EOL]         if (n instanceof Element) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = nodeParent(n); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Object n = node; [EOL]     while (n != null) { [EOL]         if (n instanceof Element) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = nodeParent(n); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
private Element nodeParent(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (parent instanceof Element) { [EOL]             return (Element) parent; [EOL]         } [EOL]     } else if (node instanceof Text) { [EOL]         return (Element) ((Text) node).getParent(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return (Element) ((CDATA) node).getParent(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         return (Element) ((ProcessingInstruction) node).getParent(); [EOL]     } else if (node instanceof Comment) { [EOL]         return (Element) ((Comment) node).getParent(); [EOL]     } [EOL]     return null; [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private int getRelativePositionOfElement() { [EOL]     Object parent = ((Element) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children; [EOL]     if (parent instanceof Element) { [EOL]         children = ((Element) parent).getContent(); [EOL]     } else { [EOL]         children = ((Document) parent).getContent(); [EOL]     } [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Element) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfElement() { [EOL]     Object parent = ((Element) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children; [EOL]     if (parent instanceof Element) { [EOL]         children = ((Element) parent).getContent(); [EOL]     } else { [EOL]         children = ((Document) parent).getContent(); [EOL]     } [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Element) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfElement() { [EOL]     Object parent = ((Element) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children; [EOL]     if (parent instanceof Element) { [EOL]         children = ((Element) parent).getContent(); [EOL]     } else { [EOL]         children = ((Document) parent).getContent(); [EOL]     } [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Element) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfElement() { [EOL]     Object parent = ((Element) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children; [EOL]     if (parent instanceof Element) { [EOL]         children = ((Element) parent).getContent(); [EOL]     } else { [EOL]         children = ((Document) parent).getContent(); [EOL]     } [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof Element) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     Element parent = (Element) ((ProcessingInstruction) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof ProcessingInstruction && (target == null || target.equals(((ProcessingInstruction) child).getTarget()))) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     Element parent = (Element) ((ProcessingInstruction) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof ProcessingInstruction && (target == null || target.equals(((ProcessingInstruction) child).getTarget()))) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     Element parent = (Element) ((ProcessingInstruction) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof ProcessingInstruction && (target == null || target.equals(((ProcessingInstruction) child).getTarget()))) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     Element parent = (Element) ((ProcessingInstruction) node).getParent(); [EOL]     if (parent == null) { [EOL]         return 1; [EOL]     } [EOL]     List children = parent.getContent(); [EOL]     int count = 0; [EOL]     for (int i = 0; i < children.size(); i++) { [EOL]         Object child = children.get(i); [EOL]         if (child instanceof ProcessingInstruction && (target == null || target.equals(((ProcessingInstruction) child).getTarget()))) { [EOL]             count++; [EOL]         } [EOL]         if (child == node) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public int hashCode() { [EOL]     return System.identityHashCode(node); [EOL] }
public QName getName() { [EOL]     return name; [EOL] }
public int getLength() { [EOL]     return 1; [EOL] }
public boolean isLeaf() { [EOL]     return false; [EOL] }
public int hashCode() { [EOL]     return name == null ? 0 : name.hashCode(); [EOL] }
public int hashCode() { [EOL]     return name == null ? 0 : name.hashCode(); [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AbsoluteLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     if (jj_2_2(2147483647)) { [EOL]         LocationStep(steps); [EOL]         label_1: while (true) { [EOL]             switch(jj_nt.kind) { [EOL]                 case SLASH: [EOL]                 case SLASHSLASH: [EOL]                     ; [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[6] = jj_gen; [EOL]                     break label_1; [EOL]             } [EOL]             LocationStep(steps); [EOL]         } [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]                 jj_consume_token(SLASH); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[7] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(true, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AbsoluteLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     if (jj_2_2(2147483647)) { [EOL]         LocationStep(steps); [EOL]         label_1: while (true) { [EOL]             switch(jj_nt.kind) { [EOL]                 case SLASH: [EOL]                 case SLASHSLASH: [EOL]                     ; [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[6] = jj_gen; [EOL]                     break label_1; [EOL]             } [EOL]             LocationStep(steps); [EOL]         } [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]                 jj_consume_token(SLASH); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[7] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(true, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AbsoluteLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     if (jj_2_2(2147483647)) { [EOL]         LocationStep(steps); [EOL]         label_1: while (true) { [EOL]             switch(jj_nt.kind) { [EOL]                 case SLASH: [EOL]                 case SLASHSLASH: [EOL]                     ; [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[6] = jj_gen; [EOL]                     break label_1; [EOL]             } [EOL]             LocationStep(steps); [EOL]         } [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]                 jj_consume_token(SLASH); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[7] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(true, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public void NodeTest(ArrayList steps) throws ParseException { [EOL]     int axis; [EOL]     int type = -1; [EOL]     String instruction = null; [EOL]     Object name = null; [EOL]     Object s; [EOL]     Object p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 86: [EOL]         case 88: [EOL]             axis = AxisSpecifier(); [EOL]             if (jj_2_3(2147483647)) { [EOL]                 type = NodeType(); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(81); [EOL]             } else if (jj_2_4(2147483647)) { [EOL]                 jj_consume_token(PI); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(Literal); [EOL]                 instruction = unescape(token.image.substring(1, token.image.length() - 1)); [EOL]                 jj_consume_token(81); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                     case 88: [EOL]                         name = WildcardName(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[10] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case 82: [EOL]             jj_consume_token(82); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case 83: [EOL]             jj_consume_token(83); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[11] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     label_3: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[12] = jj_gen; [EOL]                 break label_3; [EOL]         } [EOL]         p = Predicate(); [EOL]         ps.add(p); [EOL]     } [EOL]     if (name != null) { [EOL]         s = compiler.nodeNameTest(name); [EOL]     } else if (instruction != null) { [EOL]         s = compiler.processingInstructionTest(instruction); [EOL]     } else { [EOL]         s = compiler.nodeTypeTest(type); [EOL]     } [EOL]     steps.add(compiler.step(axis, s, ps.toArray())); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AbbreviatedAxisSpecifier() throws ParseException { [EOL]     int axis = Compiler.AXIS_CHILD; [EOL]     switch(jj_nt.kind) { [EOL]         case 86: [EOL]             jj_consume_token(86); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[15] = jj_gen; [EOL]             ; [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AbbreviatedAxisSpecifier() throws ParseException { [EOL]     int axis = Compiler.AXIS_CHILD; [EOL]     switch(jj_nt.kind) { [EOL]         case 86: [EOL]             jj_consume_token(86); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[15] = jj_gen; [EOL]             ; [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object CoreFunctionCall() throws ParseException { [EOL]     int code = 0; [EOL]     ArrayList args; [EOL]     code = CoreFunctionName(); [EOL]     args = ArgumentList(); [EOL]     if (args == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, null); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, args.toArray()); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object CoreFunctionCall() throws ParseException { [EOL]     int code = 0; [EOL]     ArrayList args; [EOL]     code = CoreFunctionName(); [EOL]     args = ArgumentList(); [EOL]     if (args == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, null); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, args.toArray()); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object Argument() throws ParseException { [EOL]     Object ex; [EOL]     ex = Expression(); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnionExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = PathExpr(); [EOL]     label_5: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case UNION: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[20] = jj_gen; [EOL]                 break label_5; [EOL]         } [EOL]         jj_consume_token(UNION); [EOL]         r = PathExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.union(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnionExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = PathExpr(); [EOL]     label_5: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case UNION: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[20] = jj_gen; [EOL]                 break label_5; [EOL]         } [EOL]         jj_consume_token(UNION); [EOL]         r = PathExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.union(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object MultiplicativeExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = UnaryExpr(); [EOL]     label_14: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MOD: [EOL]             case DIV: [EOL]             case 88: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[32] = jj_gen; [EOL]                 break label_14; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case 88: [EOL]                 jj_consume_token(88); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.multiply(ex, r); [EOL]                 break; [EOL]             case DIV: [EOL]                 jj_consume_token(DIV); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.divide(ex, r); [EOL]                 break; [EOL]             case MOD: [EOL]                 jj_consume_token(MOD); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.mod(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[33] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int NodeType() throws ParseException { [EOL]     int type; [EOL]     switch(jj_nt.kind) { [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             type = Compiler.NODE_TYPE_TEXT; [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             type = Compiler.NODE_TYPE_COMMENT; [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             type = Compiler.NODE_TYPE_PI; [EOL]             break; [EOL]         default: [EOL]             jj_la1[38] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return type; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int NodeType() throws ParseException { [EOL]     int type; [EOL]     switch(jj_nt.kind) { [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             type = Compiler.NODE_TYPE_TEXT; [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             type = Compiler.NODE_TYPE_COMMENT; [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             type = Compiler.NODE_TYPE_PI; [EOL]             break; [EOL]         default: [EOL]             jj_la1[38] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return type; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int NodeType() throws ParseException { [EOL]     int type; [EOL]     switch(jj_nt.kind) { [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             type = Compiler.NODE_TYPE_TEXT; [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             type = Compiler.NODE_TYPE_COMMENT; [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             type = Compiler.NODE_TYPE_PI; [EOL]             break; [EOL]         default: [EOL]             jj_la1[38] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return type; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int NodeType() throws ParseException { [EOL]     int type; [EOL]     switch(jj_nt.kind) { [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             type = Compiler.NODE_TYPE_TEXT; [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             type = Compiler.NODE_TYPE_COMMENT; [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             type = Compiler.NODE_TYPE_PI; [EOL]             break; [EOL]         default: [EOL]             jj_la1[38] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return type; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int NodeType() throws ParseException { [EOL]     int type; [EOL]     switch(jj_nt.kind) { [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             type = Compiler.NODE_TYPE_TEXT; [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             type = Compiler.NODE_TYPE_COMMENT; [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             type = Compiler.NODE_TYPE_PI; [EOL]             break; [EOL]         default: [EOL]             jj_la1[38] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return type; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final private boolean jj_2_2(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_2(); [EOL]     jj_save(1, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_2(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_2(); [EOL]     jj_save(1, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_5(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_5(); [EOL]     jj_save(4, xla); [EOL]     return retval; [EOL] }
final private boolean jj_3R_65() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_65() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_104() { [EOL]     if (jj_3R_118()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_104() { [EOL]     if (jj_3R_118()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_104() { [EOL]     if (jj_3R_118()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_64() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_64() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_64() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_63() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_63() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_63() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_62() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_62() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_62() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_18() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_62()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_63()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_64()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_65()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_66()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_67()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_68()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_69()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_70()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_71()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_72()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_73()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_74()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_75()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_76()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_77()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_78()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_79()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_80()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_81()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_82()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_83()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_84()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_85()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_86()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_87()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_88()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_89()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_90()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_91()) [EOL]                                                                                                                             return true; [EOL]                                                                                                                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_111() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_111() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_111() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_110() { [EOL]     if (jj_scan_token(MOD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_110() { [EOL]     if (jj_scan_token(MOD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_110() { [EOL]     if (jj_scan_token(MOD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_109() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_109() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_108() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_108() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_108() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_172() { [EOL]     if (jj_3R_177()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_172() { [EOL]     if (jj_3R_177()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_172() { [EOL]     if (jj_3R_177()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_153() { [EOL]     if (jj_scan_token(86)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_153() { [EOL]     if (jj_scan_token(86)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_153() { [EOL]     if (jj_scan_token(86)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_130() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_153()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_54() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_54() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_54() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_53() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_53() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_53() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_52() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_52() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_52() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_51() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_51() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_51() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_50() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_50() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_50() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_49() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_49() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_49() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_48() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_48() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_48() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_176() { [EOL]     if (jj_scan_token(MOD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_47() { [EOL]     if (jj_scan_token(FUNCTION_LANG)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_47() { [EOL]     if (jj_scan_token(FUNCTION_LANG)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_46() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_46() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_46() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_174() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_174() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_174() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_174() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_45() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_45() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_45() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_44() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_44() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_44() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_43() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_43() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_43() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_42() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_42() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_42() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_41() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_41() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_41() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_116() { [EOL]     if (jj_scan_token(84)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(85)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_40() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_40() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_40() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_39() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_39() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_39() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_38() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_38() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_38() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_37() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_37() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_37() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_36() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_36() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_36() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_168() { [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_171()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_35() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_35() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_35() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_34() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_34() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_33() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_33() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_33() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_32() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_32() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_32() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_31() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_31() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_31() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_30() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_30() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_30() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_29() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_29() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_29() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_28() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_28() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_28() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_27() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_27() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_27() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_152() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_152() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_152() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_26() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_26() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_26() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_25() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_25() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_25() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_151() { [EOL]     if (jj_scan_token(AXIS_PRECEDING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_151() { [EOL]     if (jj_scan_token(AXIS_PRECEDING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_151() { [EOL]     if (jj_scan_token(AXIS_PRECEDING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_24() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_24() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_24() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_150() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_150() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_150() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_23() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_23() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_23() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_149() { [EOL]     if (jj_scan_token(AXIS_ANCESTOR_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_149() { [EOL]     if (jj_scan_token(AXIS_ANCESTOR_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_163() { [EOL]     if (jj_scan_token(PLUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_163() { [EOL]     if (jj_scan_token(PLUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_163() { [EOL]     if (jj_scan_token(PLUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_163() { [EOL]     if (jj_scan_token(PLUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_22() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_22() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_22() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_148() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_148() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_148() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_21() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_147() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_147() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_147() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_146() { [EOL]     if (jj_scan_token(AXIS_PRECEDING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_146() { [EOL]     if (jj_scan_token(AXIS_PRECEDING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_146() { [EOL]     if (jj_scan_token(AXIS_PRECEDING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_145() { [EOL]     if (jj_scan_token(AXIS_NAMESPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_145() { [EOL]     if (jj_scan_token(AXIS_NAMESPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_145() { [EOL]     if (jj_scan_token(AXIS_NAMESPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_144() { [EOL]     if (jj_scan_token(AXIS_ATTRIBUTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_144() { [EOL]     if (jj_scan_token(AXIS_ATTRIBUTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_144() { [EOL]     if (jj_scan_token(AXIS_ATTRIBUTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_143() { [EOL]     if (jj_scan_token(AXIS_ANCESTOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_143() { [EOL]     if (jj_scan_token(AXIS_ANCESTOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_142() { [EOL]     if (jj_scan_token(AXIS_PARENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_142() { [EOL]     if (jj_scan_token(AXIS_PARENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_142() { [EOL]     if (jj_scan_token(AXIS_PARENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_141() { [EOL]     if (jj_scan_token(AXIS_CHILD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_141() { [EOL]     if (jj_scan_token(AXIS_CHILD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_141() { [EOL]     if (jj_scan_token(AXIS_CHILD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_140() { [EOL]     if (jj_scan_token(AXIS_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_140() { [EOL]     if (jj_scan_token(AXIS_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_140() { [EOL]     if (jj_scan_token(AXIS_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_158() { [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_163()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_158() { [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_163()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_158() { [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_163()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_158() { [EOL]     if (jj_3R_162()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_163()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_122() { [EOL]     if (jj_3R_130()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_122() { [EOL]     if (jj_3R_130()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_122() { [EOL]     if (jj_3R_130()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_121() { [EOL]     if (jj_3R_129()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_121() { [EOL]     if (jj_3R_129()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_121() { [EOL]     if (jj_3R_129()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_112() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_121()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_122()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_112() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_121()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_122()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_112() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_121()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_122()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_166() { [EOL]     if (jj_scan_token(LTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_165() { [EOL]     if (jj_scan_token(GT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_165() { [EOL]     if (jj_scan_token(GT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_165() { [EOL]     if (jj_scan_token(GT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_165() { [EOL]     if (jj_scan_token(GT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_157() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_160()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_161()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_164() { [EOL]     if (jj_scan_token(LT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_164() { [EOL]     if (jj_scan_token(LT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_164() { [EOL]     if (jj_scan_token(LT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_164() { [EOL]     if (jj_scan_token(LT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_156() { [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_159()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_156() { [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_159()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_156() { [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_159()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_156() { [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_159()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_161() { [EOL]     if (jj_scan_token(NEQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_161() { [EOL]     if (jj_scan_token(NEQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_161() { [EOL]     if (jj_scan_token(NEQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_161() { [EOL]     if (jj_scan_token(NEQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_160() { [EOL]     if (jj_scan_token(EQ)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_102() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_102() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_102() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_4() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_4() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_4() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_115() { [EOL]     if (jj_3R_123()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_115() { [EOL]     if (jj_3R_123()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_115() { [EOL]     if (jj_3R_123()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_134() { [EOL]     if (jj_3R_156()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_157()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_114() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_114() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_114() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_114() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_114() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_114() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_135() { [EOL]     if (jj_scan_token(AND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_125() { [EOL]     if (jj_3R_134()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_135()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_56() { [EOL]     if (jj_scan_token(SLASHSLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_56() { [EOL]     if (jj_scan_token(SLASHSLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_56() { [EOL]     if (jj_scan_token(SLASHSLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_55() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_55() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_55() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_126() { [EOL]     if (jj_scan_token(OR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_16() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_55()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_56()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_118() { [EOL]     if (jj_3R_125()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_126()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3_2() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_2() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_185() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_185() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_185() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_184() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_184() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_184() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_182() { [EOL]     if (jj_3R_19()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_184()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_185()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_180() { [EOL]     if (jj_3R_182()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_180() { [EOL]     if (jj_3R_182()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_180() { [EOL]     if (jj_3R_182()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_178() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_180()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_181()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_178() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_180()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_181()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_178() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_180()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_181()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_136() { [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_119() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_127()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_119() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_127()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_119() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_127()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_119() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_127()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_61() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_61() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_61() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_60() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_60() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_60() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_59() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_59() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_59() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_58() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_58() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_58() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_139() { [EOL]     if (jj_3R_98()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_132() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_105() { [EOL]     if (jj_3R_18()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_105() { [EOL]     if (jj_3R_18()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_105() { [EOL]     if (jj_3R_18()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_105() { [EOL]     if (jj_3R_18()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_128() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_138()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_139()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_131() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_131() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_131() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_5() { [EOL]     if (jj_3R_18()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_91() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_91() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_91() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_90() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_90() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_90() { [EOL]     if (jj_scan_token(FUNCTION_KEY)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_89() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_89() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_89() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_88() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_88() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_88() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_97() { [EOL]     if (jj_3R_106()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_97() { [EOL]     if (jj_3R_106()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_97() { [EOL]     if (jj_3R_106()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_87() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_87() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_87() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_96() { [EOL]     if (jj_3R_105()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_96() { [EOL]     if (jj_3R_105()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_96() { [EOL]     if (jj_3R_105()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_86() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_86() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_86() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_85() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_85() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_85() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_94() { [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_94() { [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_94() { [EOL]     if (jj_scan_token(Literal)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_84() { [EOL]     if (jj_scan_token(FUNCTION_LANG)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_84() { [EOL]     if (jj_scan_token(FUNCTION_LANG)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_84() { [EOL]     if (jj_scan_token(FUNCTION_LANG)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_93() { [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_104()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_83() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_83() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_83() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_82() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_82() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_82() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_81() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_81() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_81() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_120() { [EOL]     if (jj_3R_128()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_120() { [EOL]     if (jj_3R_128()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_120() { [EOL]     if (jj_3R_128()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_80() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_79() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_79() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_78() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_78() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_78() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_77() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_77() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_77() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_76() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_76() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_76() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_75() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_75() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_75() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_74() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_74() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_74() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_73() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_73() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_73() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_72() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_72() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_72() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_71() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_71() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_71() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_70() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_70() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_70() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_69() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_69() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_69() { [EOL]     if (jj_scan_token(FUNCTION_STRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_68() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_68() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_68() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_67() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_67() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_67() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_66() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_66() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_66() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private void jj_save(int index, int xla) { [EOL]     JJCalls p = jj_2_rtns[index]; [EOL]     while (p.gen > jj_gen) { [EOL]         if (p.next == null) { [EOL]             p = p.next = new JJCalls(); [EOL]             break; [EOL]         } [EOL]         p = p.next; [EOL]     } [EOL]     p.gen = jj_gen + xla - jj_la; [EOL]     p.first = token; [EOL]     p.arg = xla; [EOL] }
final private void jj_save(int index, int xla) { [EOL]     JJCalls p = jj_2_rtns[index]; [EOL]     while (p.gen > jj_gen) { [EOL]         if (p.next == null) { [EOL]             p = p.next = new JJCalls(); [EOL]             break; [EOL]         } [EOL]         p = p.next; [EOL]     } [EOL]     p.gen = jj_gen + xla - jj_la; [EOL]     p.first = token; [EOL]     p.arg = xla; [EOL] }
public String toString() { [EOL]     if (args.length == 1) { [EOL]         return getSymbol() + parenthesize(args[0], false); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(' '); [EOL]                 buffer.append(getSymbol()); [EOL]                 buffer.append(' '); [EOL]             } [EOL]             buffer.append(parenthesize(args[i], i == 0)); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String toString() { [EOL]     if (args.length == 1) { [EOL]         return getSymbol() + parenthesize(args[0], false); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(' '); [EOL]                 buffer.append(getSymbol()); [EOL]                 buffer.append(' '); [EOL]             } [EOL]             buffer.append(parenthesize(args[i], i == 0)); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
public String[] getPropertyNames(Object object) { [EOL]     Map map = (Map) object; [EOL]     Set set = map.keySet(); [EOL]     String[] names = new String[set.size()]; [EOL]     Iterator it = set.iterator(); [EOL]     for (int i = 0; i < names.length; i++) { [EOL]         names[i] = String.valueOf(it.next()); [EOL]     } [EOL]     return names; [EOL] }
public String[] getPropertyNames(Object object) { [EOL]     Map map = (Map) object; [EOL]     Set set = map.keySet(); [EOL]     String[] names = new String[set.size()]; [EOL]     Iterator it = set.iterator(); [EOL]     for (int i = 0; i < names.length; i++) { [EOL]         names[i] = String.valueOf(it.next()); [EOL]     } [EOL]     return names; [EOL] }
private static boolean isLangAttribute(QName name) { [EOL]     return name.getPrefix() != null && name.getPrefix().equals("xml") && name.getName().equals("lang"); [EOL] }
public boolean isCollection() { [EOL]     return getIndex() != WHOLE_COLLECTION; [EOL] }
public boolean isCollection() { [EOL]     return getIndex() != WHOLE_COLLECTION; [EOL] }
public NullPointer(QName name, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL] }
public NullPointer(QName name, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL] }
public NullPointer(QName name, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL] }
public NullPointer(QName name, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL] }
public NullPointer(Locale locale, String id) { [EOL]     super(null, locale); [EOL]     this.id = id; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     return createPath(context).createChild(context, name, index, value); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     return createPath(context).createChild(context, name, index, value); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     return createPath(context).createChild(context, name, index, value); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id(" + id + ")"; [EOL]     } [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "null()"; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof BeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     BeanPointer other = (BeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) { [EOL]         return bean.equals(other.bean); [EOL]     } [EOL]     return bean == other.bean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof BeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     BeanPointer other = (BeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) { [EOL]         return bean.equals(other.bean); [EOL]     } [EOL]     return bean == other.bean; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public void setValue(Object value) { [EOL]     throw new UnsupportedOperationException("Collection element does not exist: " + this); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (parent != null && parent.getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } else if (parent != null && parent.getImmediateParentPointer() != null && parent.getImmediateParentPointer().getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } [EOL]         buffer.append("[").append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (parent != null && parent.getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } else if (parent != null && parent.getImmediateParentPointer() != null && parent.getImmediateParentPointer().getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } [EOL]         buffer.append("[").append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (parent != null && parent.getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } else if (parent != null && parent.getImmediateParentPointer() != null && parent.getImmediateParentPointer().getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } [EOL]         buffer.append("[").append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (parent != null && parent.getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } else if (parent != null && parent.getImmediateParentPointer() != null && parent.getImmediateParentPointer().getIndex() != WHOLE_COLLECTION) { [EOL]             buffer.append("/."); [EOL]         } [EOL]         buffer.append("[").append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public void add(Pointer pointer) { [EOL]     pointers.add(pointer); [EOL]     readOnlyPointers = null; [EOL] }
public void add(Pointer pointer) { [EOL]     pointers.add(pointer); [EOL]     readOnlyPointers = null; [EOL] }
public List getPointers() { [EOL]     if (readOnlyPointers == null) { [EOL]         readOnlyPointers = Collections.unmodifiableList(pointers); [EOL]     } [EOL]     return readOnlyPointers; [EOL] }
public List getPointers() { [EOL]     if (readOnlyPointers == null) { [EOL]         readOnlyPointers = Collections.unmodifiableList(pointers); [EOL]     } [EOL]     return readOnlyPointers; [EOL] }
public List getValues() { [EOL]     if (values == null) { [EOL]         values = new ArrayList(); [EOL]         for (int i = 0; i < pointers.size(); i++) { [EOL]             Pointer pointer = (Pointer) pointers.get(i); [EOL]             values.add(pointer.getValue()); [EOL]         } [EOL]         values = Collections.unmodifiableList(values); [EOL]     } [EOL]     return values; [EOL] }
public List getValues() { [EOL]     if (values == null) { [EOL]         values = new ArrayList(); [EOL]         for (int i = 0; i < pointers.size(); i++) { [EOL]             Pointer pointer = (Pointer) pointers.get(i); [EOL]             values.add(pointer.getValue()); [EOL]         } [EOL]         values = Collections.unmodifiableList(values); [EOL]     } [EOL]     return values; [EOL] }
public int getPropertyCount() { [EOL]     return getPropertyNames().length; [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         String[] allNames = handler.getPropertyNames(getBean()); [EOL]         names = new String[allNames.length]; [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             names[i] = allNames[i]; [EOL]         } [EOL]         Arrays.sort(names); [EOL]         if (requiredPropertyName != null) { [EOL]             int inx = Arrays.binarySearch(names, requiredPropertyName); [EOL]             if (inx < 0) { [EOL]                 allNames = names; [EOL]                 names = new String[allNames.length + 1]; [EOL]                 names[0] = requiredPropertyName; [EOL]                 System.arraycopy(allNames, 0, names, 1, allNames.length); [EOL]                 Arrays.sort(names); [EOL]             } [EOL]         } [EOL]     } [EOL]     return names; [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         String[] allNames = handler.getPropertyNames(getBean()); [EOL]         names = new String[allNames.length]; [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             names[i] = allNames[i]; [EOL]         } [EOL]         Arrays.sort(names); [EOL]         if (requiredPropertyName != null) { [EOL]             int inx = Arrays.binarySearch(names, requiredPropertyName); [EOL]             if (inx < 0) { [EOL]                 allNames = names; [EOL]                 names = new String[allNames.length + 1]; [EOL]                 names[0] = requiredPropertyName; [EOL]                 System.arraycopy(allNames, 0, names, 1, allNames.length); [EOL]                 Arrays.sort(names); [EOL]             } [EOL]         } [EOL]     } [EOL]     return names; [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         String[] allNames = handler.getPropertyNames(getBean()); [EOL]         names = new String[allNames.length]; [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             names[i] = allNames[i]; [EOL]         } [EOL]         Arrays.sort(names); [EOL]         if (requiredPropertyName != null) { [EOL]             int inx = Arrays.binarySearch(names, requiredPropertyName); [EOL]             if (inx < 0) { [EOL]                 allNames = names; [EOL]                 names = new String[allNames.length + 1]; [EOL]                 names[0] = requiredPropertyName; [EOL]                 System.arraycopy(allNames, 0, names, 1, allNames.length); [EOL]                 Arrays.sort(names); [EOL]             } [EOL]         } [EOL]     } [EOL]     return names; [EOL] }
public String getPropertyName() { [EOL]     if (name == null) { [EOL]         String[] names = getPropertyNames(); [EOL]         if (propertyIndex >= 0 && propertyIndex < names.length) { [EOL]             name = names[propertyIndex]; [EOL]         } else { [EOL]             name = "*"; [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
public String getPropertyName() { [EOL]     if (name == null) { [EOL]         String[] names = getPropertyNames(); [EOL]         if (propertyIndex >= 0 && propertyIndex < names.length) { [EOL]             name = names[propertyIndex]; [EOL]         } else { [EOL]             name = "*"; [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
public String getPropertyName() { [EOL]     if (name == null) { [EOL]         String[] names = getPropertyNames(); [EOL]         if (propertyIndex >= 0 && propertyIndex < names.length) { [EOL]             name = names[propertyIndex]; [EOL]         } else { [EOL]             name = "*"; [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         name = null; [EOL]     } [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         name = null; [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName())); [EOL]     } else { [EOL]         value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index); [EOL]     } [EOL]     return value; [EOL] }
public Pointer getSingleNodePointer() { [EOL]     reset(); [EOL]     while (nextSet()) { [EOL]         if (nextNode()) { [EOL]             return getCurrentNodePointer(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean nextSet() { [EOL]     reset(); [EOL]     if (!startedSetIteration) { [EOL]         startedSetIteration = true; [EOL]         while (parentContext.nextSet()) { [EOL]             if (parentContext.nextNode()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (parentContext.nextNode()) { [EOL]         return true; [EOL]     } [EOL]     while (parentContext.nextSet()) { [EOL]         if (parentContext.nextNode()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Set getUsedNamespaces() { [EOL]     return Collections.singleton(namespace); [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if ((namespace == null && this.namespace != null) || (namespace != null && !namespace.equals(this.namespace))) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (parameters.length >= 1) { [EOL]         Object target = TypeUtils.convert(parameters[0], Object.class); [EOL]         if (target != null) { [EOL]             Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL]             if (method != null) { [EOL]                 return new MethodFunction(method); [EOL]             } [EOL]             if (target instanceof NodeSet) { [EOL]                 target = ((NodeSet) target).getPointers(); [EOL]             } [EOL]             method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL]             if (method != null) { [EOL]                 return new MethodFunction(method); [EOL]             } [EOL]             if (target instanceof Collection) { [EOL]                 Iterator iter = ((Collection) target).iterator(); [EOL]                 if (iter.hasNext()) { [EOL]                     target = iter.next(); [EOL]                     if (target instanceof Pointer) { [EOL]                         target = ((Pointer) target).getValue(); [EOL]                     } [EOL]                 } else { [EOL]                     target = null; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (target != null) { [EOL]             Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL]             if (method != null) { [EOL]                 return new MethodFunction(method); [EOL]             } [EOL]         } [EOL]     } [EOL]     String fullName = classPrefix + name; [EOL]     int inx = fullName.lastIndexOf('.'); [EOL]     if (inx == -1) { [EOL]         return null; [EOL]     } [EOL]     String className = fullName.substring(0, inx); [EOL]     String methodName = fullName.substring(inx + 1); [EOL]     Class functionClass; [EOL]     try { [EOL]         functionClass = Class.forName(className); [EOL]     } catch (ClassNotFoundException ex) { [EOL]         throw new JXPathException("Cannot invoke extension function " + (namespace != null ? namespace + ":" + name : name), ex); [EOL]     } [EOL]     if (methodName.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, methodName, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l > r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l > r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l > r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (dynamicPropertyPointer != null) { [EOL]         return dynamicPropertyPointer.getValuePointer(); [EOL]     } else { [EOL]         return parentContext.getCurrentNodePointer(); [EOL]     } [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         return true; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         return true; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType.isAssignableFrom(fromType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType == String.class) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof Boolean) { [EOL]         if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Number) { [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         if (toType.isPrimitive()) { [EOL]             return true; [EOL]         } [EOL]         if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (fromType.isArray()) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             int length = Array.getLength(object); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (Array.getLength(object) > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             while (it.hasNext()) { [EOL]                 Object value = it.next(); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (((Collection) object).size() > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return canConvert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return canConvert(((Pointer) object).getValue(), toType); [EOL]     } [EOL]     return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         if (toType.isPrimitive()) { [EOL]             return convertNullToPrimitive(toType); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         if (object instanceof NodeSet) { [EOL]             return convert(((NodeSet) object).getValues(), toType); [EOL]         } else if (object instanceof Pointer) { [EOL]             return convert(((Pointer) object).getValue(), toType); [EOL]         } [EOL]         return object; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL]         return object; [EOL]     } [EOL]     if (fromType.isArray()) { [EOL]         int length = Array.getLength(object); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 collection.add(Array.get(object, i)); [EOL]             } [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         int length = ((Collection) object).size(); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = it.next(); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             collection.addAll((Collection) object); [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return convert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return convert(((Pointer) object).getValue(), toType); [EOL]     } else if (toType == String.class) { [EOL]         return object.toString(); [EOL]     } else if (object instanceof Boolean) { [EOL]         if (toType == boolean.class) { [EOL]             return object; [EOL]         } [EOL]         boolean value = ((Boolean) object).booleanValue(); [EOL]         return allocateNumber(toType, value ? 1 : 0); [EOL]     } else if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         if (toType == boolean.class || toType == Boolean.class) { [EOL]             return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return allocateNumber(toType, value); [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return object; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         Object value = convertStringToPrimitive(object, toType); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     Converter converter = ConvertUtils.lookup(toType); [EOL]     if (converter != null) { [EOL]         return converter.convert(toType, object); [EOL]     } [EOL]     throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
public DynamicPointer(QName name, Object bean, DynamicPropertyHandler handler, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL]     this.bean = bean; [EOL]     this.handler = handler; [EOL] }
public NodeIterator createNodeIterator(String property, boolean reverse, NodePointer startWith) { [EOL]     return new PropertyIterator(this, property, reverse, startWith); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public int hashCode() { [EOL]     return System.identityHashCode(bean) + name.hashCode(); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public int getPosition() { [EOL]     return position; [EOL] }
public boolean setPosition(int position) { [EOL]     if (name != null) { [EOL]         return setPositionIndividualProperty(position); [EOL]     } else { [EOL]         return setPositionAllProperties(position); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     if (name != null) { [EOL]         return setPositionIndividualProperty(position); [EOL]     } else { [EOL]         return setPositionAllProperties(position); [EOL]     } [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public VariableReference(QName varName) { [EOL]     this.varName = varName; [EOL] }
public VariableReference(QName varName) { [EOL]     this.varName = varName; [EOL] }
public String toString() { [EOL]     return "$" + varName; [EOL] }
public AncestorContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.includeSelf = includeSelf; [EOL]     this.nodeTest = nodeTest; [EOL] }
public AncestorContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.includeSelf = includeSelf; [EOL]     this.nodeTest = nodeTest; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     return currentNodePointer; [EOL] }
public int getDocumentOrder() { [EOL]     return -1; [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     setStarted = false; [EOL] }
public boolean setPosition(int position) { [EOL]     if (position < getCurrentPosition()) { [EOL]         reset(); [EOL]     } [EOL]     while (getCurrentPosition() < position) { [EOL]         if (!nextNode()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     if (position < getCurrentPosition()) { [EOL]         reset(); [EOL]     } [EOL]     while (getCurrentPosition() < position) { [EOL]         if (!nextNode()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     if (position < getCurrentPosition()) { [EOL]         reset(); [EOL]     } [EOL]     while (getCurrentPosition() < position) { [EOL]         if (!nextNode()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     if (position < getCurrentPosition()) { [EOL]         reset(); [EOL]     } [EOL]     while (getCurrentPosition() < position) { [EOL]         if (!nextNode()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (includeSelf) { [EOL]             if (currentNodePointer.testNode(nodeTest)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]         if (currentNodePointer == null) { [EOL]             return false; [EOL]         } [EOL]         if (currentNodePointer.testNode(nodeTest)) { [EOL]             position++; [EOL]             return true; [EOL]         } [EOL]     } [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (includeSelf) { [EOL]             if (currentNodePointer.testNode(nodeTest)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]         if (currentNodePointer == null) { [EOL]             return false; [EOL]         } [EOL]         if (currentNodePointer.testNode(nodeTest)) { [EOL]             position++; [EOL]             return true; [EOL]         } [EOL]     } [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (includeSelf) { [EOL]             if (currentNodePointer.testNode(nodeTest)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]         if (currentNodePointer == null) { [EOL]             return false; [EOL]         } [EOL]         if (currentNodePointer.testNode(nodeTest)) { [EOL]             position++; [EOL]             return true; [EOL]         } [EOL]     } [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (includeSelf) { [EOL]             if (currentNodePointer.testNode(nodeTest)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]         if (currentNodePointer == null) { [EOL]             return false; [EOL]         } [EOL]         if (currentNodePointer.testNode(nodeTest)) { [EOL]             position++; [EOL]             return true; [EOL]         } [EOL]     } [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         currentRootLocation = parentContext.getCurrentNodePointer(); [EOL]         NodePointer parent = currentRootLocation.getParent(); [EOL]         if (parent != null) { [EOL]             stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         if (stack.isEmpty()) { [EOL]             currentRootLocation = currentRootLocation.getParent(); [EOL]             if (currentRootLocation == null || currentRootLocation.isRoot()) { [EOL]                 break; [EOL]             } [EOL]             NodePointer parent = currentRootLocation.getParent(); [EOL]             if (parent != null) { [EOL]                 stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL]             } [EOL]         } [EOL]         while (!stack.isEmpty()) { [EOL]             if (!reverse) { [EOL]                 NodeIterator it = (NodeIterator) stack.peek(); [EOL]                 if (it.setPosition(it.getPosition() + 1)) { [EOL]                     currentNodePointer = it.getNodePointer(); [EOL]                     if (!currentNodePointer.isLeaf()) { [EOL]                         stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL]                     } [EOL]                     if (currentNodePointer.testNode(nodeTest)) { [EOL]                         super.setPosition(getCurrentPosition() + 1); [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     stack.pop(); [EOL]                 } [EOL]             } else { [EOL]                 NodeIterator it = (NodeIterator) stack.peek(); [EOL]                 if (it.setPosition(it.getPosition() + 1)) { [EOL]                     currentNodePointer = it.getNodePointer(); [EOL]                     if (!currentNodePointer.isLeaf()) { [EOL]                         stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL]                     } else if (currentNodePointer.testNode(nodeTest)) { [EOL]                         super.setPosition(getCurrentPosition() + 1); [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     stack.pop(); [EOL]                     if (!stack.isEmpty()) { [EOL]                         it = (PropertyIterator) stack.peek(); [EOL]                         currentNodePointer = it.getNodePointer(); [EOL]                         if (currentNodePointer.testNode(nodeTest)) { [EOL]                             super.setPosition(getCurrentPosition() + 1); [EOL]                             return true; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public LocationPath(boolean absolute, Step[] steps) { [EOL]     super(steps); [EOL]     this.absolute = absolute; [EOL] }
public LocationPath(boolean absolute, Step[] steps) { [EOL]     super(steps); [EOL]     this.absolute = absolute; [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     Step[] steps = getSteps(); [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (i > 0 || absolute) { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             buffer.append(steps[i]); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext rootContext; [EOL]     if (isAbsolute()) { [EOL]         rootContext = context.getRootContext().getAbsoluteRootContext(); [EOL]     } else { [EOL]         rootContext = new InitialContext(context); [EOL]     } [EOL]     return getSingleNodePointerForSteps(rootContext); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext rootContext; [EOL]     if (isAbsolute()) { [EOL]         rootContext = context.getRootContext().getAbsoluteRootContext(); [EOL]     } else { [EOL]         rootContext = new InitialContext(context); [EOL]     } [EOL]     return getSingleNodePointerForSteps(rootContext); [EOL] }
public Object literal(String value) { [EOL]     return new Constant(value); [EOL] }
public Object literal(String value) { [EOL]     return new Constant(value); [EOL] }
public Object multiply(Object left, Object right) { [EOL]     return new CoreOperationMultiply((Expression) left, (Expression) right); [EOL] }
public Object minus(Object argument) { [EOL]     return new CoreOperationNegate((Expression) argument); [EOL] }
public Object minus(Object argument) { [EOL]     return new CoreOperationNegate((Expression) argument); [EOL] }
public Object function(int code, Object[] args) { [EOL]     return new CoreFunction(code, toExpressionArray(args)); [EOL] }
public Object function(int code, Object[] args) { [EOL]     return new CoreFunction(code, toExpressionArray(args)); [EOL] }
public Object function(int code, Object[] args) { [EOL]     return new CoreFunction(code, toExpressionArray(args)); [EOL] }
public Object union(Object[] arguments) { [EOL]     return new CoreOperationUnion(toExpressionArray(arguments)); [EOL] }
public Object locationPath(boolean absolute, Object[] steps) { [EOL]     return new LocationPath(absolute, toStepArray(steps)); [EOL] }
public Object locationPath(boolean absolute, Object[] steps) { [EOL]     return new LocationPath(absolute, toStepArray(steps)); [EOL] }
public Object processingInstructionTest(String instruction) { [EOL]     return new ProcessingInstructionTest(instruction); [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public ExpressionPath(Expression expression, Expression[] predicates, Step[] steps) { [EOL]     super(steps); [EOL]     this.expression = expression; [EOL]     this.predicates = predicates; [EOL] }
public ExpressionPath(Expression expression, Expression[] predicates, Step[] steps) { [EOL]     super(steps); [EOL]     this.expression = expression; [EOL]     this.predicates = predicates; [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (expression instanceof CoreOperation || expression instanceof ExpressionPath || expression instanceof LocationPath) { [EOL]         buffer.append('('); [EOL]         buffer.append(expression); [EOL]         buffer.append(')'); [EOL]     } else { [EOL]         buffer.append(expression); [EOL]     } [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     Step[] steps = getSteps(); [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             buffer.append("/"); [EOL]             buffer.append(steps[i]); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         DynaClass dynaClass = dynaBean.getDynaClass(); [EOL]         DynaProperty[] properties = dynaClass.getDynaProperties(); [EOL]         int count = properties.length; [EOL]         boolean hasClass = dynaClass.getDynaProperty("class") != null; [EOL]         if (hasClass) { [EOL]             count--; [EOL]         } [EOL]         names = new String[count]; [EOL]         for (int i = 0, j = 0; i < properties.length; i++) { [EOL]             String name = properties[i].getName(); [EOL]             if (!hasClass || !name.equals("class")) { [EOL]                 names[j++] = name; [EOL]             } [EOL]         } [EOL]         Arrays.sort(names); [EOL]     } [EOL]     return names; [EOL] }
public String[] getPropertyNames() { [EOL]     if (names == null) { [EOL]         DynaClass dynaClass = dynaBean.getDynaClass(); [EOL]         DynaProperty[] properties = dynaClass.getDynaProperties(); [EOL]         int count = properties.length; [EOL]         boolean hasClass = dynaClass.getDynaProperty("class") != null; [EOL]         if (hasClass) { [EOL]             count--; [EOL]         } [EOL]         names = new String[count]; [EOL]         for (int i = 0, j = 0; i < properties.length; i++) { [EOL]             String name = properties[i].getName(); [EOL]             if (!hasClass || !name.equals("class")) { [EOL]                 names[j++] = name; [EOL]             } [EOL]         } [EOL]         Arrays.sort(names); [EOL]     } [EOL]     return names; [EOL] }
public int getPropertyIndex() { [EOL]     if (propertyIndex == UNSPECIFIED_PROPERTY) { [EOL]         String[] names = getPropertyNames(); [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             if (names[i].equals(name)) { [EOL]                 propertyIndex = i; [EOL]                 name = null; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.getPropertyIndex(); [EOL] }
public int getPropertyIndex() { [EOL]     if (propertyIndex == UNSPECIFIED_PROPERTY) { [EOL]         String[] names = getPropertyNames(); [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             if (names[i].equals(name)) { [EOL]                 propertyIndex = i; [EOL]                 name = null; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.getPropertyIndex(); [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l < r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l < r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String axisToString(int axis) { [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_SELF: [EOL]             return "self"; [EOL]         case Compiler.AXIS_CHILD: [EOL]             return "child"; [EOL]         case Compiler.AXIS_PARENT: [EOL]             return "parent"; [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return "ancestor"; [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return "attribute"; [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return "namespace"; [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return "preceding"; [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return "following"; [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return "descendant"; [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return "ancestor-or-self"; [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return "following-sibling"; [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return "preceding-sibling"; [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return "descendant-or-self"; [EOL]     } [EOL]     return "UNKNOWN"; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public void setIdentityManager(IdentityManager idManager) { [EOL]     this.idManager = idManager; [EOL] }
public void setIdentityManager(IdentityManager idManager) { [EOL]     this.idManager = idManager; [EOL] }
public IdentityManager getIdentityManager() { [EOL]     if (idManager == null && parentContext != null) { [EOL]         return parentContext.getIdentityManager(); [EOL]     } [EOL]     return idManager; [EOL] }
public IdentityManager getIdentityManager() { [EOL]     if (idManager == null && parentContext != null) { [EOL]         return parentContext.getIdentityManager(); [EOL]     } [EOL]     return idManager; [EOL] }
public IdentityManager getIdentityManager() { [EOL]     if (idManager == null && parentContext != null) { [EOL]         return parentContext.getIdentityManager(); [EOL]     } [EOL]     return idManager; [EOL] }
public Pointer getPointerByID(String id) { [EOL]     IdentityManager manager = getIdentityManager(); [EOL]     if (manager != null) { [EOL]         return manager.getPointerByID(this, id); [EOL]     } else { [EOL]         throw new JXPathException("Cannot find an element by ID - " + "no IdentityManager has been specified"); [EOL]     } [EOL] }
public Pointer getPointerByID(String id) { [EOL]     IdentityManager manager = getIdentityManager(); [EOL]     if (manager != null) { [EOL]         return manager.getPointerByID(this, id); [EOL]     } else { [EOL]         throw new JXPathException("Cannot find an element by ID - " + "no IdentityManager has been specified"); [EOL]     } [EOL] }
public MethodFunction(Method method) { [EOL]     this.method = ValueUtils.getAccessibleMethod(method); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object target; [EOL]         Object[] args; [EOL]         if (Modifier.isStatic(method.getModifiers())) { [EOL]             target = null; [EOL]             if (parameters == null) { [EOL]                 parameters = EMPTY_ARRAY; [EOL]             } [EOL]             int pi = 0; [EOL]             Class[] types = method.getParameterTypes(); [EOL]             if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]                 pi = 1; [EOL]             } [EOL]             args = new Object[parameters.length + pi]; [EOL]             if (pi == 1) { [EOL]                 args[0] = context; [EOL]             } [EOL]             for (int i = 0; i < parameters.length; i++) { [EOL]                 args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]             } [EOL]         } else { [EOL]             int pi = 0; [EOL]             Class[] types = method.getParameterTypes(); [EOL]             if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]                 pi = 1; [EOL]             } [EOL]             target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); [EOL]             args = new Object[parameters.length - 1 + pi]; [EOL]             if (pi == 1) { [EOL]                 args[0] = context; [EOL]             } [EOL]             for (int i = 1; i < parameters.length; i++) { [EOL]                 args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); [EOL]             } [EOL]         } [EOL]         return method.invoke(target, args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke " + method, ex); [EOL]     } [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) { [EOL]     super(parent, (name.getPrefix() == null && (name.getName() == null || name.getName().equals("*"))) ? null : name.toString(), false, null); [EOL]     this.parent = parent; [EOL]     includeXmlLang = (name.getPrefix() != null && name.getPrefix().equals("xml")) && (name.getName().equals("lang") || name.getName().equals("*")); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (includeXmlLang && position == 1) { [EOL]         return new LangAttributePointer(parent); [EOL]     } else { [EOL]         return super.getNodePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (includeXmlLang && position == 1) { [EOL]         return new LangAttributePointer(parent); [EOL]     } else { [EOL]         return super.getNodePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (includeXmlLang && position == 1) { [EOL]         return new LangAttributePointer(parent); [EOL]     } else { [EOL]         return super.getNodePointer(); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (includeXmlLang) { [EOL]         if (position == 1) { [EOL]             return true; [EOL]         } else { [EOL]             return super.setPosition(position - 1); [EOL]         } [EOL]     } else { [EOL]         this.position = position; [EOL]         return super.setPosition(position); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (includeXmlLang) { [EOL]         if (position == 1) { [EOL]             return true; [EOL]         } else { [EOL]             return super.setPosition(position - 1); [EOL]         } [EOL]     } else { [EOL]         this.position = position; [EOL]         return super.setPosition(position); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (includeXmlLang) { [EOL]         if (position == 1) { [EOL]             return true; [EOL]         } else { [EOL]             return super.setPosition(position - 1); [EOL]         } [EOL]     } else { [EOL]         this.position = position; [EOL]         return super.setPosition(position); [EOL]     } [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private EvalContext buildContextChain(EvalContext context, int stepCount, boolean createInitialContext) { [EOL]     if (createInitialContext) { [EOL]         context = new InitialContext(context); [EOL]     } [EOL]     if (steps.length == 0) { [EOL]         return context; [EOL]     } [EOL]     for (int i = 0; i < stepCount; i++) { [EOL]         context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest()); [EOL]         Expression[] predicates = steps[i].getPredicates(); [EOL]         if (predicates != null) { [EOL]             for (int j = 0; j < predicates.length; j++) { [EOL]                 if (j != 0) { [EOL]                     context = new UnionContext(context, new EvalContext[] { context }); [EOL]                 } [EOL]                 context = new PredicateContext(context, predicates[j]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return context; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
public VariablePointer(QName name) { [EOL]     super(null); [EOL]     this.name = name; [EOL]     actual = false; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (!actual) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         if (!factory.declareVariable(context, name.toString())) { [EOL]             throw new JXPathAbstractFactoryException("Factory cannot define variable '" + name + "' for path: " + asPath()); [EOL]         } [EOL]         findVariables(context); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (!actual) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         if (!factory.declareVariable(context, name.toString())) { [EOL]             throw new JXPathAbstractFactoryException("Factory cannot define variable '" + name + "' for path: " + asPath()); [EOL]         } [EOL]         findVariables(context); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (!actual) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         if (!factory.declareVariable(context, name.toString())) { [EOL]             throw new JXPathAbstractFactoryException("Factory cannot define variable '" + name + "' for path: " + asPath()); [EOL]         } [EOL]         findVariables(context); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     Object collection = createCollection(context, index); [EOL]     if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, collection, getName().toString(), index); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create object path: " + asPath()); [EOL]         } [EOL]         NodePointer cln = (NodePointer) clone(); [EOL]         cln.setIndex(index); [EOL]         return cln; [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     Object collection = createCollection(context, index); [EOL]     if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, collection, getName().toString(), index); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create object path: " + asPath()); [EOL]         } [EOL]         NodePointer cln = (NodePointer) clone(); [EOL]         cln.setIndex(index); [EOL]         return cln; [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     Object collection = createCollection(context, index); [EOL]     if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, collection, getName().toString(), index); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create object path: " + asPath()); [EOL]         } [EOL]         NodePointer cln = (NodePointer) clone(); [EOL]         cln.setIndex(index); [EOL]         return cln; [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     Object collection = createCollection(context, index); [EOL]     if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, collection, getName().toString(), index); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create object path: " + asPath()); [EOL]         } [EOL]         NodePointer cln = (NodePointer) clone(); [EOL]         cln.setIndex(index); [EOL]         return cln; [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     Object collection = createCollection(context, index); [EOL]     ValueUtils.setValue(collection, index, value); [EOL]     NodePointer cl = (NodePointer) clone(); [EOL]     cl.setIndex(index); [EOL]     return cl; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     Object collection = createCollection(context, index); [EOL]     ValueUtils.setValue(collection, index, value); [EOL]     NodePointer cl = (NodePointer) clone(); [EOL]     cl.setIndex(index); [EOL]     return cl; [EOL] }
private Object createCollection(JXPathContext context, int index) { [EOL]     createPath(context); [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         throw new JXPathAbstractFactoryException("Factory did not assign a collection to variable '" + name + "' for path: " + asPath()); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } else if (index < 0) { [EOL]         throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]     } [EOL]     if (index >= getLength()) { [EOL]         collection = ValueUtils.expandCollection(collection, index + 1); [EOL]         variables.declareVariable(name.toString(), collection); [EOL]     } [EOL]     return collection; [EOL] }
private Object createCollection(JXPathContext context, int index) { [EOL]     createPath(context); [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         throw new JXPathAbstractFactoryException("Factory did not assign a collection to variable '" + name + "' for path: " + asPath()); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } else if (index < 0) { [EOL]         throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]     } [EOL]     if (index >= getLength()) { [EOL]         collection = ValueUtils.expandCollection(collection, index + 1); [EOL]         variables.declareVariable(name.toString(), collection); [EOL]     } [EOL]     return collection; [EOL] }
private Object createCollection(JXPathContext context, int index) { [EOL]     createPath(context); [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         throw new JXPathAbstractFactoryException("Factory did not assign a collection to variable '" + name + "' for path: " + asPath()); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } else if (index < 0) { [EOL]         throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]     } [EOL]     if (index >= getLength()) { [EOL]         collection = ValueUtils.expandCollection(collection, index + 1); [EOL]         variables.declareVariable(name.toString(), collection); [EOL]     } [EOL]     return collection; [EOL] }
private Object createCollection(JXPathContext context, int index) { [EOL]     createPath(context); [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         throw new JXPathAbstractFactoryException("Factory did not assign a collection to variable '" + name + "' for path: " + asPath()); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         index = 0; [EOL]     } else if (index < 0) { [EOL]         throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]     } [EOL]     if (index >= getLength()) { [EOL]         collection = ValueUtils.expandCollection(collection, index + 1); [EOL]         variables.declareVariable(name.toString(), collection); [EOL]     } [EOL]     return collection; [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parent != null) { [EOL]             locale = parent.getLocale(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parent != null) { [EOL]             locale = parent.getLocale(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parent != null) { [EOL]             locale = parent.getLocale(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public boolean isLanguage(String lang) { [EOL]     Locale loc = getLocale(); [EOL]     String name = loc.toString().replace('_', '-'); [EOL]     return name.toUpperCase().startsWith(lang.toUpperCase()); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != null && valuePointer != this) { [EOL]         return valuePointer.childIterator(test, reverse, startWith); [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != null && valuePointer != this) { [EOL]         return valuePointer.childIterator(test, reverse, startWith); [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != null && valuePointer != this) { [EOL]         return valuePointer.childIterator(test, reverse, startWith); [EOL]     } [EOL]     return null; [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     return context.getPointerByID(id); [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     return context.getPointerByID(id); [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     return context.getPointerByID(id); [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     return context.getPointerByID(id); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
protected CollectionNodeIterator(CollectionPointer pointer, boolean reverse, NodePointer startWith) { [EOL]     this.pointer = pointer; [EOL]     this.reverse = reverse; [EOL]     this.startWith = startWith; [EOL] }
protected CollectionNodeIterator(CollectionPointer pointer, boolean reverse, NodePointer startWith) { [EOL]     this.pointer = pointer; [EOL]     this.reverse = reverse; [EOL]     this.startWith = startWith; [EOL] }
protected CollectionNodeIterator(CollectionPointer pointer, boolean reverse, NodePointer startWith) { [EOL]     this.pointer = pointer; [EOL]     this.reverse = reverse; [EOL]     this.startWith = startWith; [EOL] }
public boolean setPosition(int position) { [EOL]     if (collection == null) { [EOL]         prepare(); [EOL]     } [EOL]     if (position < 1 || position > collection.size()) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     if (collection == null) { [EOL]         prepare(); [EOL]     } [EOL]     if (position < 1 || position > collection.size()) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return true; [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         return null; [EOL]     } [EOL]     return (NodePointer) collection.get(position - 1); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         return null; [EOL]     } [EOL]     return (NodePointer) collection.get(position - 1); [EOL] }
private void prepare() { [EOL]     collection = new ArrayList(); [EOL]     NodePointer ptr = (NodePointer) pointer.clone(); [EOL]     int length = ptr.getLength(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         ptr.setIndex(i); [EOL]         NodePointer elementPointer = ptr.getValuePointer(); [EOL]         NodeIterator iter = getElementNodeIterator(elementPointer); [EOL]         for (int j = 1; iter.setPosition(j); j++) { [EOL]             NodePointer childPointer = iter.getNodePointer(); [EOL]             if (reverse) { [EOL]                 collection.add(0, childPointer); [EOL]             } else { [EOL]                 collection.add(childPointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (startWith != null) { [EOL]         int index = collection.indexOf(startWith); [EOL]         if (index == -1) { [EOL]             throw new JXPathException("Invalid starting pointer for iterator: " + startWith); [EOL]         } [EOL]         while (collection.size() > index) { [EOL]             if (!reverse) { [EOL]                 collection.remove(collection.size() - 1); [EOL]             } else { [EOL]                 collection.remove(0); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepare() { [EOL]     collection = new ArrayList(); [EOL]     NodePointer ptr = (NodePointer) pointer.clone(); [EOL]     int length = ptr.getLength(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         ptr.setIndex(i); [EOL]         NodePointer elementPointer = ptr.getValuePointer(); [EOL]         NodeIterator iter = getElementNodeIterator(elementPointer); [EOL]         for (int j = 1; iter.setPosition(j); j++) { [EOL]             NodePointer childPointer = iter.getNodePointer(); [EOL]             if (reverse) { [EOL]                 collection.add(0, childPointer); [EOL]             } else { [EOL]                 collection.add(childPointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (startWith != null) { [EOL]         int index = collection.indexOf(startWith); [EOL]         if (index == -1) { [EOL]             throw new JXPathException("Invalid starting pointer for iterator: " + startWith); [EOL]         } [EOL]         while (collection.size() > index) { [EOL]             if (!reverse) { [EOL]                 collection.remove(collection.size() - 1); [EOL]             } else { [EOL]                 collection.remove(0); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepare() { [EOL]     collection = new ArrayList(); [EOL]     NodePointer ptr = (NodePointer) pointer.clone(); [EOL]     int length = ptr.getLength(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         ptr.setIndex(i); [EOL]         NodePointer elementPointer = ptr.getValuePointer(); [EOL]         NodeIterator iter = getElementNodeIterator(elementPointer); [EOL]         for (int j = 1; iter.setPosition(j); j++) { [EOL]             NodePointer childPointer = iter.getNodePointer(); [EOL]             if (reverse) { [EOL]                 collection.add(0, childPointer); [EOL]             } else { [EOL]                 collection.add(childPointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (startWith != null) { [EOL]         int index = collection.indexOf(startWith); [EOL]         if (index == -1) { [EOL]             throw new JXPathException("Invalid starting pointer for iterator: " + startWith); [EOL]         } [EOL]         while (collection.size() > index) { [EOL]             if (!reverse) { [EOL]                 collection.remove(collection.size() - 1); [EOL]             } else { [EOL]                 collection.remove(0); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepare() { [EOL]     collection = new ArrayList(); [EOL]     NodePointer ptr = (NodePointer) pointer.clone(); [EOL]     int length = ptr.getLength(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         ptr.setIndex(i); [EOL]         NodePointer elementPointer = ptr.getValuePointer(); [EOL]         NodeIterator iter = getElementNodeIterator(elementPointer); [EOL]         for (int j = 1; iter.setPosition(j); j++) { [EOL]             NodePointer childPointer = iter.getNodePointer(); [EOL]             if (reverse) { [EOL]                 collection.add(0, childPointer); [EOL]             } else { [EOL]                 collection.add(childPointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (startWith != null) { [EOL]         int index = collection.indexOf(startWith); [EOL]         if (index == -1) { [EOL]             throw new JXPathException("Invalid starting pointer for iterator: " + startWith); [EOL]         } [EOL]         while (collection.size() > index) { [EOL]             if (!reverse) { [EOL]                 collection.remove(collection.size() - 1); [EOL]             } else { [EOL]                 collection.remove(0); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepare() { [EOL]     collection = new ArrayList(); [EOL]     NodePointer ptr = (NodePointer) pointer.clone(); [EOL]     int length = ptr.getLength(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         ptr.setIndex(i); [EOL]         NodePointer elementPointer = ptr.getValuePointer(); [EOL]         NodeIterator iter = getElementNodeIterator(elementPointer); [EOL]         for (int j = 1; iter.setPosition(j); j++) { [EOL]             NodePointer childPointer = iter.getNodePointer(); [EOL]             if (reverse) { [EOL]                 collection.add(0, childPointer); [EOL]             } else { [EOL]                 collection.add(childPointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (startWith != null) { [EOL]         int index = collection.indexOf(startWith); [EOL]         if (index == -1) { [EOL]             throw new JXPathException("Invalid starting pointer for iterator: " + startWith); [EOL]         } [EOL]         while (collection.size() > index) { [EOL]             if (!reverse) { [EOL]                 collection.remove(collection.size() - 1); [EOL]             } else { [EOL]                 collection.remove(0); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static Object expandCollection(Object collection, int size) { [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         Object bigger = Array.newInstance(collection.getClass().getComponentType(), size); [EOL]         System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection)); [EOL]         return bigger; [EOL]     } else if (collection instanceof Collection) { [EOL]         while (((Collection) collection).size() < size) { [EOL]             ((Collection) collection).add(null); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot turn " + collection.getClass().getName() + " into a collection of size " + size); [EOL]     } [EOL] }
public static Object expandCollection(Object collection, int size) { [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         Object bigger = Array.newInstance(collection.getClass().getComponentType(), size); [EOL]         System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection)); [EOL]         return bigger; [EOL]     } else if (collection instanceof Collection) { [EOL]         while (((Collection) collection).size() < size) { [EOL]             ((Collection) collection).add(null); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot turn " + collection.getClass().getName() + " into a collection of size " + size); [EOL]     } [EOL] }
public static Object expandCollection(Object collection, int size) { [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         Object bigger = Array.newInstance(collection.getClass().getComponentType(), size); [EOL]         System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection)); [EOL]         return bigger; [EOL]     } else if (collection instanceof Collection) { [EOL]         while (((Collection) collection).size() < size) { [EOL]             ((Collection) collection).add(null); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot turn " + collection.getClass().getName() + " into a collection of size " + size); [EOL]     } [EOL] }
public static Object expandCollection(Object collection, int size) { [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         Object bigger = Array.newInstance(collection.getClass().getComponentType(), size); [EOL]         System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection)); [EOL]         return bigger; [EOL]     } else if (collection instanceof Collection) { [EOL]         while (((Collection) collection).size() < size) { [EOL]             ((Collection) collection).add(null); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot turn " + collection.getClass().getName() + " into a collection of size " + size); [EOL]     } [EOL] }
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public boolean isContainer() { [EOL]     return true; [EOL] }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL]     switch(pos) { [EOL]         case 0: [EOL]             if ((active1 & 0xc0000L) != 0L) [EOL]                 return 10; [EOL]             if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 1: [EOL]             if ((active0 & 0x8000008000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 1; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 2: [EOL]             if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 2; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 3: [EOL]             if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL]                 if (jjmatchedPos != 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 4: [EOL]             if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 4; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 5: [EOL]             if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL]                 if (jjmatchedPos != 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 6: [EOL]             if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 6; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 7: [EOL]             if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 7; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x802000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 8: [EOL]             if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 if (jjmatchedPos != 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 9: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 9; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 10: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 10; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 11: [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 11; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 12: [EOL]             if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 12; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 13: [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 13; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 14: [EOL]             if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x1000f00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 14; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 15: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xf00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 15; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 16: [EOL]             if ((active0 & 0xe00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 16; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 17: [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 17; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 18: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 18; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 19: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 19; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 20: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 20; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         default: [EOL]             return -1; [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjStartNfaWithStates_0(int pos, int kind, int state) { [EOL]     jjmatchedKind = kind; [EOL]     jjmatchedPos = pos; [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         return pos + 1; [EOL]     } [EOL]     return jjMoveNfa_0(state, pos + 1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(0, active0, active1); [EOL]         return 1; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 46: [EOL]             if ((active1 & 0x80000L) != 0L) [EOL]                 return jjStopAtPos(1, 83); [EOL]             break; [EOL]         case 47: [EOL]             if ((active0 & 0x80L) != 0L) [EOL]                 return jjStopAtPos(1, 7); [EOL]             break; [EOL]         case 61: [EOL]             if ((active0 & 0x1000L) != 0L) [EOL]                 return jjStopAtPos(1, 12); [EOL]             else if ((active0 & 0x4000L) != 0L) [EOL]                 return jjStopAtPos(1, 14); [EOL]             else if ((active0 & 0x10000L) != 0L) [EOL]                 return jjStopAtPos(1, 16); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL]         case 100: [EOL]             if ((active0 & 0x8000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 51, 12); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL]         case 104: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL]         case 114: [EOL]             if ((active0 & 0x8000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 27, 12); [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(0, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(0, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(1, active0, active1); [EOL]         return 2; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL]         case 100: [EOL]             if ((active0 & 0x10000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 28, 12); [EOL]             else if ((active0 & 0x20000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 29, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL]         case 109: [EOL]             if ((active1 & 0x200L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 73, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active1 & 0x8L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 67, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL]         case 118: [EOL]             if ((active0 & 0x40000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 30, 12); [EOL]             break; [EOL]         case 120: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL]         case 121: [EOL]             if ((active0 & 0x10000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 52, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(1, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(2, active0, active1); [EOL]         return 3; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x80000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 31, 12); [EOL]             else if ((active0 & 0x80000000000000L) != 0L) { [EOL]                 jjmatchedKind = 55; [EOL]                 jjmatchedPos = 3; [EOL]             } else if ((active1 & 0x10L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 68, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x80L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 71, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL]         case 108: [EOL]             if ((active1 & 0x40L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 70, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL]         case 116: [EOL]             if ((active0 & 0x100000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 32, 12); [EOL]             else if ((active0 & 0x1000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 48, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(2, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(3, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(4, active0, active1); [EOL]         return 5; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x800000000L) != 0L) [EOL]                 return jjStopAtPos(5, 35); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active0 & 0x100000000000000L) != 0L) { [EOL]                 jjmatchedKind = 56; [EOL]                 jjmatchedPos = 5; [EOL]             } [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x100L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 72, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 57, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(4, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(4, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(5, active0, active1); [EOL]         return 6; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL]         case 58: [EOL]             if ((active0 & 0x1000000000L) != 0L) [EOL]                 return jjStopAtPos(6, 36); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x800L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 75, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL]         case 110: [EOL]             if ((active1 & 0x4L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 66, 12); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 33, 12); [EOL]             break; [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(5, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(6, active0, active1); [EOL]         return 7; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x2000000000L) != 0L) [EOL]                 return jjStopAtPos(7, 37); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 110: [EOL]             if ((active0 & 0x2000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 49, 12); [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL]         case 115: [EOL]             if ((active0 & 0x800000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 59, 12); [EOL]             break; [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 122: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(6, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(7, active0, active1); [EOL]         return 8; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x2L) != 0L) [EOL]                 return jjStartNfaWithStates_0(8, 65, 12); [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL]         case 103: [EOL]             if ((active0 & 0x4000000000000000L) != 0L) { [EOL]                 jjmatchedKind = 62; [EOL]                 jjmatchedPos = 8; [EOL]             } [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(7, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(8, active0, active1); [EOL]         return 9; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL]         case 58: [EOL]             if ((active0 & 0x4000000000L) != 0L) [EOL]                 return jjStopAtPos(9, 38); [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(9, 53, 12); [EOL]             break; [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(8, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(9, active0, active1); [EOL]         return 10; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x8000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 39); [EOL]             else if ((active0 & 0x10000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 40); [EOL]             else if ((active0 & 0x20000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 41); [EOL]             else if ((active0 & 0x40000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 42); [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(10, 58, 12); [EOL]             break; [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(9, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(9, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(10, active0, active1); [EOL]         return 11; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x80000000000L) != 0L) [EOL]                 return jjStopAtPos(11, 43); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(10, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(10, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(11, active0, active1); [EOL]         return 12; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x8000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 63, 12); [EOL]             break; [EOL]         case 105: [EOL]             if ((active0 & 0x40000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 54, 12); [EOL]             break; [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x2000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 77, 12); [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(11, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(11, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(12, active0, active1); [EOL]         return 13; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(12, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(12, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(13, active0, active1); [EOL]         return 14; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active1 & 0x1L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 64, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active0 & 0x2000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 61, 12); [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(13, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(13, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(14, active0, 0L); [EOL]         return 15; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(15, 60, 12); [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(14, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(14, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(15, active0, 0L); [EOL]         return 16; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(15, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(15, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(16, active0, 0L); [EOL]         return 17; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x100000000000L) != 0L) [EOL]                 return jjStopAtPos(17, 44); [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(16, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(16, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(17, active0, 0L); [EOL]         return 18; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x200000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 45); [EOL]             else if ((active0 & 0x400000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 46); [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(17, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa19_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(17, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(18, active0, 0L); [EOL]         return 19; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x800000000000L) != 0L) [EOL]                 return jjStopAtPos(19, 47); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa20_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(18, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa20_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(18, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(19, active0, 0L); [EOL]         return 20; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa21_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(19, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa21_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(19, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(20, active0, 0L); [EOL]         return 21; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 110: [EOL]             if ((active0 & 0x400000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(21, 34, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(20, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final void jjAddStates(int start, int end) { [EOL]     do { [EOL]         jjstateSet[jjnewStateCnt++] = jjnextStates[start]; [EOL]     } while (start++ != end); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveNfa_0(int startState, int curPos) { [EOL]     int[] nextStates; [EOL]     int startsAt = 0; [EOL]     jjnewStateCnt = 13; [EOL]     int i = 1; [EOL]     jjstateSet[0] = startState; [EOL]     int j, kind = 0x7fffffff; [EOL]     for (; ; ) { [EOL]         if (++jjround == 0x7fffffff) [EOL]             ReInitRounds(); [EOL]         if (curChar < 64) { [EOL]             long l = 1L << curChar; [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if ((0x3ff000000000000L & l) != 0L) { [EOL]                             if (kind > 20) [EOL]                                 kind = 20; [EOL]                             jjCheckNAddTwoStates(6, 7); [EOL]                         } else if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         else if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         else if (curChar == 34) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 1: [EOL]                         if ((0xfffffffbffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 2: [EOL]                         if (curChar == 34 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 3: [EOL]                         if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 4: [EOL]                         if ((0xffffff7fffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 5: [EOL]                         if (curChar == 39 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 6: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAddTwoStates(6, 7); [EOL]                         break; [EOL]                     case 7: [EOL]                         if (curChar != 46) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 8: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 9: [EOL]                         if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 10: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 12: [EOL]                         if ((0x3ff600000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjstateSet[jjnewStateCnt++] = 12; [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else if (curChar < 128) { [EOL]             long l = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                     case 12: [EOL]                         if ((0x7fffffe87fffffeL & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         jjAddStates(2, 3); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else { [EOL]             int hiByte = (int) (curChar >> 8); [EOL]             int i1 = hiByte >> 6; [EOL]             long l1 = 1L << (hiByte & 077); [EOL]             int i2 = (curChar & 0xff) >> 6; [EOL]             long l2 = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(2, 3); [EOL]                         break; [EOL]                     case 12: [EOL]                         if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } [EOL]         if (kind != 0x7fffffff) { [EOL]             jjmatchedKind = kind; [EOL]             jjmatchedPos = curPos; [EOL]             kind = 0x7fffffff; [EOL]         } [EOL]         ++curPos; [EOL]         if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL]             return curPos; [EOL]         try { [EOL]             curChar = input_stream.readChar(); [EOL]         } catch (java.io.IOException e) { [EOL]             return curPos; [EOL]         } [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public DOMNodePointer(Node node, Locale locale, String id) { [EOL]     super(null, locale); [EOL]     this.node = node; [EOL]     this.id = id; [EOL] }
public DOMNodePointer(Node node, Locale locale, String id) { [EOL]     super(null, locale); [EOL]     this.node = node; [EOL]     this.id = id; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public QName getName() { [EOL]     String ln = null; [EOL]     String ns = null; [EOL]     int type = node.getNodeType(); [EOL]     if (type == Node.ELEMENT_NODE) { [EOL]         ns = DOMNodePointer.getPrefix(node); [EOL]         ln = DOMNodePointer.getLocalName(node); [EOL]     } else if (type == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ln = null; [EOL]     String ns = null; [EOL]     int type = node.getNodeType(); [EOL]     if (type == Node.ELEMENT_NODE) { [EOL]         ns = DOMNodePointer.getPrefix(node); [EOL]         ln = DOMNodePointer.getLocalName(node); [EOL]     } else if (type == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ln = null; [EOL]     String ns = null; [EOL]     int type = node.getNodeType(); [EOL]     if (type == Node.ELEMENT_NODE) { [EOL]         ns = DOMNodePointer.getPrefix(node); [EOL]         ln = DOMNodePointer.getLocalName(node); [EOL]     } else if (type == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
protected String getLanguage() { [EOL]     Node n = node; [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttribute("xml:lang"); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = n.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Node n = node; [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttribute("xml:lang"); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = n.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Node n = node; [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttribute("xml:lang"); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = n.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
protected String getLanguage() { [EOL]     Node n = node; [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Element e = (Element) n; [EOL]             String attr = e.getAttribute("xml:lang"); [EOL]             if (attr != null && !attr.equals("")) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         n = n.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private int getRelativePositionOfElement() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfElement() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE && ((ProcessingInstruction) n).getTarget().equals(target)) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE && ((ProcessingInstruction) n).getTarget().equals(target)) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE && ((ProcessingInstruction) n).getTarget().equals(target)) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionOfPI(String target) { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE && ((ProcessingInstruction) n).getTarget().equals(target)) { [EOL]             count++; [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     Document document; [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         document = (Document) node; [EOL]     } else { [EOL]         document = node.getOwnerDocument(); [EOL]     } [EOL]     Element element = document.getElementById(id); [EOL]     if (element != null) { [EOL]         return new DOMNodePointer(element, getLocale(), id); [EOL]     } else { [EOL]         return new NullPointer(getLocale(), id); [EOL]     } [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     Document document; [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         document = (Document) node; [EOL]     } else { [EOL]         document = node.getOwnerDocument(); [EOL]     } [EOL]     Element element = document.getElementById(id); [EOL]     if (element != null) { [EOL]         return new DOMNodePointer(element, getLocale(), id); [EOL]     } else { [EOL]         return new NullPointer(getLocale(), id); [EOL]     } [EOL] }
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     Document document; [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         document = (Document) node; [EOL]     } else { [EOL]         document = node.getOwnerDocument(); [EOL]     } [EOL]     Element element = document.getElementById(id); [EOL]     if (element != null) { [EOL]         return new DOMNodePointer(element, getLocale(), id); [EOL]     } else { [EOL]         return new NullPointer(getLocale(), id); [EOL]     } [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public ExtensionFunction(QName functionName, Expression[] args) { [EOL]     super(args); [EOL]     this.functionName = functionName; [EOL] }
public ExtensionFunction(QName functionName, Expression[] args) { [EOL]     super(args); [EOL]     this.functionName = functionName; [EOL] }
public ExtensionFunction(QName functionName, Expression[] args) { [EOL]     super(args); [EOL]     this.functionName = functionName; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     Object[] parameters = null; [EOL]     if (args != null) { [EOL]         parameters = new Object[args.length]; [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             parameters[i] = convert(args[i].compute(context)); [EOL]         } [EOL]     } [EOL]     Function function = context.getRootContext().getFunction(functionName, parameters); [EOL]     if (function == null) { [EOL]         throw new JXPathFunctionNotFoundException("No such function: " + functionName + Arrays.asList(parameters)); [EOL]     } [EOL]     return function.invoke(context, parameters); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     Object[] parameters = null; [EOL]     if (args != null) { [EOL]         parameters = new Object[args.length]; [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             parameters[i] = convert(args[i].compute(context)); [EOL]         } [EOL]     } [EOL]     Function function = context.getRootContext().getFunction(functionName, parameters); [EOL]     if (function == null) { [EOL]         throw new JXPathFunctionNotFoundException("No such function: " + functionName + Arrays.asList(parameters)); [EOL]     } [EOL]     return function.invoke(context, parameters); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     Object[] parameters = null; [EOL]     if (args != null) { [EOL]         parameters = new Object[args.length]; [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             parameters[i] = convert(args[i].compute(context)); [EOL]         } [EOL]     } [EOL]     Function function = context.getRootContext().getFunction(functionName, parameters); [EOL]     if (function == null) { [EOL]         throw new JXPathFunctionNotFoundException("No such function: " + functionName + Arrays.asList(parameters)); [EOL]     } [EOL]     return function.invoke(context, parameters); [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer(parent, (Node) bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer(parent, (Node) bean); [EOL]     } [EOL]     return null; [EOL] }
public CollectionPointer(Object collection, Locale locale) { [EOL]     super(null, locale); [EOL]     this.collection = collection; [EOL] }
public CollectionPointer(Object collection, Locale locale) { [EOL]     super(null, locale); [EOL]     this.collection = collection; [EOL] }
public CollectionPointer(NodePointer parent, Object collection) { [EOL]     super(parent); [EOL]     this.collection = collection; [EOL] }
public CollectionPointer(NodePointer parent, Object collection) { [EOL]     super(parent); [EOL]     this.collection = collection; [EOL] }
public CollectionPointer(NodePointer parent, Object collection) { [EOL]     super(parent); [EOL]     this.collection = collection; [EOL] }
public QName getName() { [EOL]     return null; [EOL] }
public Object getBaseValue() { [EOL]     return collection; [EOL] }
public int getLength() { [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public int getLength() { [EOL]     return ValueUtils.getLength(getBaseValue()); [EOL] }
public Object getImmediateNode() { [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(collection, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(collection); [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(collection, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(collection); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         parent.setValue(value); [EOL]     } else { [EOL]         ValueUtils.setValue(collection, index, value); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         parent.setValue(value); [EOL]     } else { [EOL]         ValueUtils.setValue(collection, index, value); [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     super.setIndex(index); [EOL]     valuePointer = null; [EOL] }
public NodePointer getValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             valuePointer = this; [EOL]         } else { [EOL]             Object value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, getName(), value); [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer getValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             valuePointer = this; [EOL]         } else { [EOL]             Object value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, getName(), value); [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer getValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             valuePointer = this; [EOL]         } else { [EOL]             Object value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, getName(), value); [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (ValueUtils.getLength(collection) <= index) { [EOL]         collection = ValueUtils.expandCollection(getNode(), index + 1); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (ValueUtils.getLength(collection) <= index) { [EOL]         collection = ValueUtils.expandCollection(getNode(), index + 1); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (ValueUtils.getLength(collection) <= index) { [EOL]         collection = ValueUtils.expandCollection(getNode(), index + 1); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer ptr = createPath(context); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer ptr = createPath(context); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer ptr = createPath(context); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     NodePointer ptr = (NodePointer) clone(); [EOL]     ptr.setIndex(index); [EOL]     return ptr.createPath(context, value); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     NodePointer ptr = (NodePointer) clone(); [EOL]     ptr.setIndex(index); [EOL]     return ptr.createPath(context, value); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return new CollectionChildNodeIterator(this, test, reverse, startWith); [EOL]     } else { [EOL]         return getValuePointer().childIterator(test, reverse, startWith); [EOL]     } [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return new CollectionChildNodeIterator(this, test, reverse, startWith); [EOL]     } else { [EOL]         return getValuePointer().childIterator(test, reverse, startWith); [EOL]     } [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         if (test == null) { [EOL]             return true; [EOL]         } else if (test instanceof NodeNameTest) { [EOL]             return false; [EOL]         } else if (test instanceof NodeTypeTest) { [EOL]             if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return getValuePointer().testNode(test); [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         if (test == null) { [EOL]             return true; [EOL]         } else if (test instanceof NodeNameTest) { [EOL]             return false; [EOL]         } else if (test instanceof NodeTypeTest) { [EOL]             if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return getValuePointer().testNode(test); [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         if (test == null) { [EOL]             return true; [EOL]         } else if (test instanceof NodeNameTest) { [EOL]             return false; [EOL]         } else if (test instanceof NodeTypeTest) { [EOL]             if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return getValuePointer().testNode(test); [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         if (test == null) { [EOL]             return true; [EOL]         } else if (test instanceof NodeNameTest) { [EOL]             return false; [EOL]         } else if (test instanceof NodeTypeTest) { [EOL]             if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return getValuePointer().testNode(test); [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         if (test == null) { [EOL]             return true; [EOL]         } else if (test instanceof NodeNameTest) { [EOL]             return false; [EOL]         } else if (test instanceof NodeTypeTest) { [EOL]             if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return getValuePointer().testNode(test); [EOL] }
public CollectionChildNodeIterator(CollectionPointer pointer, NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     super(pointer, reverse, startWith); [EOL]     this.test = test; [EOL] }
public CollectionChildNodeIterator(CollectionPointer pointer, NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     super(pointer, reverse, startWith); [EOL]     this.test = test; [EOL] }
public CollectionChildNodeIterator(CollectionPointer pointer, NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     super(pointer, reverse, startWith); [EOL]     this.test = test; [EOL] }
protected NodeIterator getElementNodeIterator(NodePointer elementPointer) { [EOL]     return elementPointer.childIterator(test, false, null); [EOL] }
protected boolean isSymmetric() { [EOL]     return true; [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
private NodePointer getAbsoluteRootPointer() { [EOL]     return (NodePointer) rootPointer; [EOL] }
public EvalContext getAbsoluteRootContext() { [EOL]     return new InitialContext(new RootContext(this, getAbsoluteRootPointer())); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return namespaceResolver.getNamespaceURI(prefix); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return namespaceResolver.getNamespaceURI(prefix); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return namespaceResolver.getNamespaceURI(prefix); [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public void registerDefaultNamespace(String uri) { [EOL]     defaultNamespaceURI = uri; [EOL] }
public NodeSetContext(EvalContext parentContext, NodeSet nodeSet) { [EOL]     super(parentContext); [EOL]     this.nodeSet = nodeSet; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return (NodePointer) nodeSet.getPointers().get(position - 1); [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return (NodePointer) nodeSet.getPointers().get(position - 1); [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return (NodePointer) nodeSet.getPointers().get(position - 1); [EOL] }
public boolean setPosition(int position) { [EOL]     super.setPosition(position); [EOL]     return position >= 1 && position <= nodeSet.getPointers().size(); [EOL] }
public boolean setPosition(int position) { [EOL]     super.setPosition(position); [EOL]     return position >= 1 && position <= nodeSet.getPointers().size(); [EOL] }
public boolean setPosition(int position) { [EOL]     super.setPosition(position); [EOL]     return position >= 1 && position <= nodeSet.getPointers().size(); [EOL] }
public boolean nextSet() { [EOL]     if (startedSet) { [EOL]         return false; [EOL]     } [EOL]     startedSet = true; [EOL]     return true; [EOL] }
public boolean nextSet() { [EOL]     if (startedSet) { [EOL]         return false; [EOL]     } [EOL]     startedSet = true; [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     return setPosition(position + 1); [EOL] }
public CoreOperationUnion(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperationUnion(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperationUnion(Expression[] args) { [EOL]     super(args); [EOL] }
public String getSymbol() { [EOL]     return "|"; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
