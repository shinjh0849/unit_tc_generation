public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Integer toIntegerObject(final boolean bool, final Integer trueValue, final Integer falseValue) { [EOL]     return bool ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static String toStringOnOff(final Boolean bool) { [EOL]     return toString(bool, "on", "off", null); [EOL] }
public static String toStringOnOff(final Boolean bool) { [EOL]     return toString(bool, "on", "off", null); [EOL] }
public static String toStringOnOff(final Boolean bool) { [EOL]     return toString(bool, "on", "off", null); [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public NumericEntityUnescaper(final OPTION... options) { [EOL]     if (options.length > 0) { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(options)); [EOL]     } else { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired })); [EOL]     } [EOL] }
public NumericEntityUnescaper(final OPTION... options) { [EOL]     if (options.length > 0) { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(options)); [EOL]     } else { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired })); [EOL]     } [EOL] }
public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] }
public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] }
public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] }
public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] }
private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] }
private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] }
private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] }
private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] }
public static double toDouble(final String str) { [EOL]     return toDouble(str, 0.0d); [EOL] }
public static double toDouble(final String str) { [EOL]     return toDouble(str, 0.0d); [EOL] }
public static double toDouble(final String str) { [EOL]     return toDouble(str, 0.0d); [EOL] }
public static double toDouble(final String str) { [EOL]     return toDouble(str, 0.0d); [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
public static Float createFloat(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Float.valueOf(str); [EOL] }
public static Double createDouble(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Double.valueOf(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static byte min(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static byte min(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static byte min(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static byte min(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(long a, final long b, final long c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static long max(long a, final long b, final long c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static long max(long a, final long b, final long c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static long max(long a, final long b, final long c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public short setShortBoolean(final short holder, final boolean flag) { [EOL]     return flag ? setShort(holder) : clearShort(holder); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
public final ThreadFactory getWrappedFactory() { [EOL]     return wrappedFactory; [EOL] }
public final String getNamingPattern() { [EOL]     return namingPattern; [EOL] }
public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] }
public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] }
public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [EOL]     return uncaughtExceptionHandler; [EOL] }
@Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] }
@Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] }
public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] }
public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] }
public void reset() { [EOL]     wrappedFactory = null; [EOL]     exceptionHandler = null; [EOL]     namingPattern = null; [EOL]     priority = null; [EOL]     daemonFlag = null; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public ContextedRuntimeException(final String message, final Throwable cause, ExceptionContext context) { [EOL]     super(message, cause); [EOL]     if (context == null) { [EOL]         context = new DefaultExceptionContext(); [EOL]     } [EOL]     exceptionContext = context; [EOL] }
public ContextedRuntimeException(final String message, final Throwable cause, ExceptionContext context) { [EOL]     super(message, cause); [EOL]     if (context == null) { [EOL]         context = new DefaultExceptionContext(); [EOL]     } [EOL]     exceptionContext = context; [EOL] }
@Override [EOL] public ContextedRuntimeException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public ContextedRuntimeException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] }
private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException { [EOL]     final ArrayList<L> serializableListeners = new ArrayList<L>(); [EOL]     ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]     for (final L listener : listeners) { [EOL]         try { [EOL]             testObjectOutputStream.writeObject(listener); [EOL]             serializableListeners.add(listener); [EOL]         } catch (final IOException exception) { [EOL]             testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream()); [EOL]         } [EOL]     } [EOL]     objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray)); [EOL] }
private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] }
private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { [EOL]     @SuppressWarnings("unchecked") [EOL]     final L[] listeners = (L[]) objectInputStream.readObject(); [EOL]     this.listeners = new CopyOnWriteArrayList<L>(listeners); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType(); [EOL]     initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader()); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public MutableFloat(final Number value) { [EOL]     super(); [EOL]     this.value = value.floatValue(); [EOL] }
public void add(final float operand) { [EOL]     this.value += operand; [EOL] }
public void add(final float operand) { [EOL]     this.value += operand; [EOL] }
public void add(final float operand) { [EOL]     this.value += operand; [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
public static String getSimpleName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return cls.getSimpleName(); [EOL] }
public static String getSimpleName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return cls.getSimpleName(); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getPackageName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getPackageName(object.getClass()); [EOL] }
public static String getPackageName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getPackageName(object.getClass()); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] }
public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException { [EOL]     final Method declaredMethod = cls.getMethod(methodName, parameterTypes); [EOL]     if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { [EOL]         return declaredMethod; [EOL]     } [EOL]     final List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); [EOL]     candidateClasses.addAll(getAllInterfaces(cls)); [EOL]     candidateClasses.addAll(getAllSuperclasses(cls)); [EOL]     for (final Class<?> candidateClass : candidateClasses) { [EOL]         if (!Modifier.isPublic(candidateClass.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         Method candidateMethod; [EOL]         try { [EOL]             candidateMethod = candidateClass.getMethod(methodName, parameterTypes); [EOL]         } catch (final NoSuchMethodException ex) { [EOL]             continue; [EOL]         } [EOL]         if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { [EOL]             return candidateMethod; [EOL]         } [EOL]     } [EOL]     throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes)); [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
public static String getPackageCanonicalName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return getPackageCanonicalName(cls.getName()); [EOL] }
public static String getPackageCanonicalName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return getPackageCanonicalName(cls.getName()); [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
private NumericEntityEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] }
private NumericEntityEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] }
public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] }
public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] }
public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final V result = map.putIfAbsent(key, value); [EOL]     return result != null ? result : value; [EOL] }
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final V result = map.putIfAbsent(key, value); [EOL]     return result != null ? result : value; [EOL] }
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final V result = map.putIfAbsent(key, value); [EOL]     return result != null ? result : value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) { [EOL]     try { [EOL]         return createIfAbsent(map, key, init); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
public static <T> Future<T> constantFuture(final T value) { [EOL]     return new ConstantFuture<T>(value); [EOL] }
public static <T> Future<T> constantFuture(final T value) { [EOL]     return new ConstantFuture<T>(value); [EOL] }
ConstantFuture(final T value) { [EOL]     this.value = value; [EOL] }
ConstantFuture(final T value) { [EOL]     this.value = value; [EOL] }
@Override [EOL] public boolean isDone() { [EOL]     return true; [EOL] }
@Override [EOL] public T get() { [EOL]     return value; [EOL] }
@Override [EOL] public T get(final long timeout, final TimeUnit unit) { [EOL]     return value; [EOL] }
@Override [EOL] public boolean isCancelled() { [EOL]     return false; [EOL] }
@Override [EOL] public boolean cancel(final boolean mayInterruptIfRunning) { [EOL]     return false; [EOL] }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parse(source, pos); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static ConcurrentMap<Locale, Strategy> getCache(final int field) { [EOL]     synchronized (caches) { [EOL]         if (caches[field] == null) { [EOL]             caches[field] = new ConcurrentHashMap<Locale, Strategy>(3); [EOL]         } [EOL]         return caches[field]; [EOL]     } [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static ConcurrentMap<Locale, Strategy> getCache(final int field) { [EOL]     synchronized (caches) { [EOL]         if (caches[field] == null) { [EOL]             caches[field] = new ConcurrentHashMap<Locale, Strategy>(3); [EOL]         } [EOL]         return caches[field]; [EOL]     } [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
NumberStrategy(final int field) { [EOL]     this.field = field; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
NumberStrategy(final int field) { [EOL]     this.field = field; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
NumberStrategy(final int field) { [EOL]     this.field = field; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
NumberStrategy(final int field) { [EOL]     this.field = field; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
NumberStrategy(final int field) { [EOL]     this.field = field; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape) { [EOL]     this(StrLookup.mapLookup(valueMap), prefix, suffix, escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, offset, length); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, offset, length); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public static Fraction getFraction(final int whole, final int numerator, final int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         throw new ArithmeticException("The denominator must not be negative"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         throw new ArithmeticException("The numerator must not be negative"); [EOL]     } [EOL]     long numeratorValue; [EOL]     if (whole < 0) { [EOL]         numeratorValue = whole * (long) denominator - numerator; [EOL]     } else { [EOL]         numeratorValue = whole * (long) denominator + numerator; [EOL]     } [EOL]     if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Numerator too large to represent as an Integer."); [EOL]     } [EOL]     return new Fraction((int) numeratorValue, denominator); [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public int getProperNumerator() { [EOL]     return Math.abs(numerator % denominator); [EOL] }
public int getProperNumerator() { [EOL]     return Math.abs(numerator % denominator); [EOL] }
public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }
public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }
public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }
public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }
static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int lastIndexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).lastIndexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             return -1; [EOL]         } [EOL]         if (start >= sz) { [EOL]             start = sz - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; --i) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
private static StrTokenizer getCSVClone() { [EOL]     return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone(); [EOL] }
public static StrTokenizer getCSVInstance() { [EOL]     return getCSVClone(); [EOL] }
public static StrTokenizer getCSVInstance(final String input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static StrTokenizer getCSVInstance(final String input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static StrTokenizer getCSVInstance(final String input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
private static StrTokenizer getTSVClone() { [EOL]     return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone(); [EOL] }
public static StrTokenizer getTSVInstance() { [EOL]     return getTSVClone(); [EOL] }
public StrTokenizer(final char[] input) { [EOL]     super(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL] }
public StrTokenizer(final char[] input) { [EOL]     super(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL] }
public StrTokenizer(final char[] input) { [EOL]     super(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL] }
public StrTokenizer(final char[] input, final char delim) { [EOL]     this(input); [EOL]     setDelimiterChar(delim); [EOL] }
public StrTokenizer(final char[] input, final char delim) { [EOL]     this(input); [EOL]     setDelimiterChar(delim); [EOL] }
public StrTokenizer(final char[] input, final char delim, final char quote) { [EOL]     this(input, delim); [EOL]     setQuoteChar(quote); [EOL] }
public StrTokenizer(final char[] input, final char delim, final char quote) { [EOL]     this(input, delim); [EOL]     setQuoteChar(quote); [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
public String nextToken() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     return null; [EOL] }
public String nextToken() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     return null; [EOL] }
public String[] getTokenArray() { [EOL]     checkTokenized(); [EOL]     return tokens.clone(); [EOL] }
public String[] getTokenArray() { [EOL]     checkTokenized(); [EOL]     return tokens.clone(); [EOL] }
public String[] getTokenArray() { [EOL]     checkTokenized(); [EOL]     return tokens.clone(); [EOL] }
public StrTokenizer reset() { [EOL]     tokenPos = 0; [EOL]     tokens = null; [EOL]     return this; [EOL] }
public StrTokenizer reset(final String input) { [EOL]     reset(); [EOL]     if (input != null) { [EOL]         this.chars = input.toCharArray(); [EOL]     } else { [EOL]         this.chars = null; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer reset(final String input) { [EOL]     reset(); [EOL]     if (input != null) { [EOL]         this.chars = input.toCharArray(); [EOL]     } else { [EOL]         this.chars = null; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer reset(final char[] input) { [EOL]     reset(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL]     return this; [EOL] }
public StrTokenizer reset(final char[] input) { [EOL]     reset(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL]     return this; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public boolean hasPrevious() { [EOL]     checkTokenized(); [EOL]     return tokenPos > 0; [EOL] }
private void addToken(final List<String> list, String tok) { [EOL]     if (StringUtils.isEmpty(tok)) { [EOL]         if (isIgnoreEmptyTokens()) { [EOL]             return; [EOL]         } [EOL]         if (isEmptyTokenAsNull()) { [EOL]             tok = null; [EOL]         } [EOL]     } [EOL]     list.add(tok); [EOL] }
private void addToken(final List<String> list, String tok) { [EOL]     if (StringUtils.isEmpty(tok)) { [EOL]         if (isIgnoreEmptyTokens()) { [EOL]             return; [EOL]         } [EOL]         if (isEmptyTokenAsNull()) { [EOL]             tok = null; [EOL]         } [EOL]     } [EOL]     list.add(tok); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
Object cloneReset() throws CloneNotSupportedException { [EOL]     final StrTokenizer cloned = (StrTokenizer) super.clone(); [EOL]     if (cloned.chars != null) { [EOL]         cloned.chars = cloned.chars.clone(); [EOL]     } [EOL]     cloned.reset(); [EOL]     return cloned; [EOL] }
@Override [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL]     Class<? extends Annotation> annotationType = null; [EOL]     for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL]         if (Annotation.class.isAssignableFrom(iface)) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL]             annotationType = found; [EOL]             break; [EOL]         } [EOL]     } [EOL]     return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
@Override [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL]     if (value instanceof Annotation) { [EOL]         value = AnnotationUtils.toString((Annotation) value); [EOL]     } [EOL]     super.appendDetail(buffer, fieldName, value); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static int hashCode(final Annotation a) { [EOL]     int result = 0; [EOL]     final Class<? extends Annotation> type = a.annotationType(); [EOL]     for (final Method m : type.getDeclaredMethods()) { [EOL]         try { [EOL]             final Object value = m.invoke(a); [EOL]             if (value == null) { [EOL]                 throw new IllegalStateException(String.format("Annotation method %s returned null", m)); [EOL]             } [EOL]             result += hashMember(m.getName(), value); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static String toString(final Annotation a) { [EOL]     final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE); [EOL]     for (final Method m : a.annotationType().getDeclaredMethods()) { [EOL]         if (m.getParameterTypes().length > 0) { [EOL]             continue; [EOL]         } [EOL]         try { [EOL]             builder.append(m.getName(), m.invoke(a)); [EOL]         } catch (final RuntimeException ex) { [EOL]             throw ex; [EOL]         } catch (final Exception ex) { [EOL]             throw new RuntimeException(ex); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static int hashMember(final String name, final Object value) { [EOL]     final int part1 = name.hashCode() * 127; [EOL]     if (value.getClass().isArray()) { [EOL]         return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value); [EOL]     } [EOL]     if (value instanceof Annotation) { [EOL]         return part1 ^ hashCode((Annotation) value); [EOL]     } [EOL]     return part1 ^ value.hashCode(); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.hashCode((byte[]) o); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.hashCode((short[]) o); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.hashCode((int[]) o); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.hashCode((char[]) o); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.hashCode((long[]) o); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.hashCode((float[]) o); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.hashCode((double[]) o); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.hashCode((boolean[]) o); [EOL]     } [EOL]     return Arrays.hashCode((Object[]) o); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static String formatUTC(final long millis, final String pattern) { [EOL]     return format(new Date(millis), pattern, UTC_TIME_ZONE, null); [EOL] }
public static String formatUTC(final long millis, final String pattern) { [EOL]     return format(new Date(millis), pattern, UTC_TIME_ZONE, null); [EOL] }
public static String formatUTC(final Date date, final String pattern) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, null); [EOL] }
public static String formatUTC(final Date date, final String pattern) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, null); [EOL] }
public static String formatUTC(final Date date, final String pattern) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, null); [EOL] }
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String format(final Date date, final String pattern) { [EOL]     return format(date, pattern, null, null); [EOL] }
public static String format(final Date date, final String pattern) { [EOL]     return format(date, pattern, null, null); [EOL] }
public static String format(final Date date, final String pattern) { [EOL]     return format(date, pattern, null, null); [EOL] }
public static String format(final Date date, final String pattern) { [EOL]     return format(date, pattern, null, null); [EOL] }
public static String format(final Calendar calendar, final String pattern) { [EOL]     return format(calendar, pattern, null, null); [EOL] }
public static String format(final Calendar calendar, final String pattern) { [EOL]     return format(calendar, pattern, null, null); [EOL] }
public static String format(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, null, locale); [EOL] }
public static String format(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, null, locale); [EOL] }
public static String format(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, null, locale); [EOL] }
public static String format(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, null, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final Locale locale) { [EOL]     return format(calendar, pattern, null, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final Locale locale) { [EOL]     return format(calendar, pattern, null, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final Locale locale) { [EOL]     return format(calendar, pattern, null, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final Locale locale) { [EOL]     return format(calendar, pattern, null, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] }
@Override [EOL] public StringBuffer format(final Date date, final StringBuffer buf) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRules(c, buf); [EOL] }
@Override [EOL] public StringBuffer format(final Date date, final StringBuffer buf) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRules(c, buf); [EOL] }
@Override [EOL] public String getPattern() { [EOL]     return mPattern; [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDatePrinter[" + mPattern + "," + mLocale + "," + mTimeZone.getID() + "]"; [EOL] }
TwoDigitMonthField() { [EOL]     super(); [EOL] }
TimeZoneNumberRule(final boolean colon) { [EOL]     mColon = colon; [EOL] }
TimeZoneNumberRule(final boolean colon) { [EOL]     mColon = colon; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public static StrMatcher splitMatcher() { [EOL]     return SPLIT_MATCHER; [EOL] }
public static StrMatcher trimMatcher() { [EOL]     return TRIM_MATCHER; [EOL] }
public static StrMatcher doubleQuoteMatcher() { [EOL]     return DOUBLE_QUOTE_MATCHER; [EOL] }
public static StrMatcher quoteMatcher() { [EOL]     return QUOTE_MATCHER; [EOL] }
public static StrMatcher noneMatcher() { [EOL]     return NONE_MATCHER; [EOL] }
public static StrMatcher charMatcher(final char ch) { [EOL]     return new CharMatcher(ch); [EOL] }
public static StrMatcher charSetMatcher(final char... chars) { [EOL]     if (chars == null || chars.length == 0) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length == 1) { [EOL]         return new CharMatcher(chars[0]); [EOL]     } [EOL]     return new CharSetMatcher(chars); [EOL] }
public static StrMatcher charSetMatcher(final char... chars) { [EOL]     if (chars == null || chars.length == 0) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length == 1) { [EOL]         return new CharMatcher(chars[0]); [EOL]     } [EOL]     return new CharSetMatcher(chars); [EOL] }
public static StrMatcher charSetMatcher(final char... chars) { [EOL]     if (chars == null || chars.length == 0) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length == 1) { [EOL]         return new CharMatcher(chars[0]); [EOL]     } [EOL]     return new CharSetMatcher(chars); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher stringMatcher(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     return new StringMatcher(str); [EOL] }
protected StrMatcher() { [EOL]     super(); [EOL] }
public int isMatch(final char[] buffer, final int pos) { [EOL]     return isMatch(buffer, pos, 0, buffer.length); [EOL] }
CharSetMatcher(final char[] chars) { [EOL]     super(); [EOL]     this.chars = chars.clone(); [EOL]     Arrays.sort(this.chars); [EOL] }
CharSetMatcher(final char[] chars) { [EOL]     super(); [EOL]     this.chars = chars.clone(); [EOL]     Arrays.sort(this.chars); [EOL] }
CharSetMatcher(final char[] chars) { [EOL]     super(); [EOL]     this.chars = chars.clone(); [EOL]     Arrays.sort(this.chars); [EOL] }
CharSetMatcher(final char[] chars) { [EOL]     super(); [EOL]     this.chars = chars.clone(); [EOL]     Arrays.sort(this.chars); [EOL] }
CharSetMatcher(final char[] chars) { [EOL]     super(); [EOL]     this.chars = chars.clone(); [EOL]     Arrays.sort(this.chars); [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0; [EOL] }
CharMatcher(final char ch) { [EOL]     super(); [EOL]     this.ch = ch; [EOL] }
CharMatcher(final char ch) { [EOL]     super(); [EOL]     this.ch = ch; [EOL] }
CharMatcher(final char ch) { [EOL]     super(); [EOL]     this.ch = ch; [EOL] }
StringMatcher(final String str) { [EOL]     super(); [EOL]     chars = str.toCharArray(); [EOL] }
StringMatcher(final String str) { [EOL]     super(); [EOL]     chars = str.toCharArray(); [EOL] }
StringMatcher(final String str) { [EOL]     super(); [EOL]     chars = str.toCharArray(); [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { [EOL]     final int len = chars.length; [EOL]     if (pos + len > bufferEnd) { [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < chars.length; i++, pos++) { [EOL]         if (chars[i] != buffer[pos]) { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     return len; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { [EOL]     final int len = chars.length; [EOL]     if (pos + len > bufferEnd) { [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < chars.length; i++, pos++) { [EOL]         if (chars[i] != buffer[pos]) { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     return len; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { [EOL]     final int len = chars.length; [EOL]     if (pos + len > bufferEnd) { [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < chars.length; i++, pos++) { [EOL]         if (chars[i] != buffer[pos]) { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     return len; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { [EOL]     final int len = chars.length; [EOL]     if (pos + len > bufferEnd) { [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < chars.length; i++, pos++) { [EOL]         if (chars[i] != buffer[pos]) { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     return len; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { [EOL]     final int len = chars.length; [EOL]     if (pos + len > bufferEnd) { [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < chars.length; i++, pos++) { [EOL]         if (chars[i] != buffer[pos]) { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     return len; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public RandomStringUtils() { [EOL]     super(); [EOL] }
public static String random(final int count) { [EOL]     return random(count, false, false); [EOL] }
public static String random(final int count) { [EOL]     return random(count, false, false); [EOL] }
public static String random(final int count, final boolean letters, final boolean numbers) { [EOL]     return random(count, 0, 0, letters, numbers); [EOL] }
public static String random(final int count, final boolean letters, final boolean numbers) { [EOL]     return random(count, 0, 0, letters, numbers); [EOL] }
public static String random(final int count, final boolean letters, final boolean numbers) { [EOL]     return random(count, 0, 0, letters, numbers); [EOL] }
public static String random(final int count, final boolean letters, final boolean numbers) { [EOL]     return random(count, 0, 0, letters, numbers); [EOL] }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) { [EOL]     return random(count, start, end, letters, numbers, null, RANDOM); [EOL] }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) { [EOL]     return random(count, start, end, letters, numbers, null, RANDOM); [EOL] }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) { [EOL]     return random(count, start, end, letters, numbers, null, RANDOM); [EOL] }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) { [EOL]     return random(count, start, end, letters, numbers, null, RANDOM); [EOL] }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) { [EOL]     return random(count, start, end, letters, numbers, null, RANDOM); [EOL] }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) { [EOL]     return random(count, start, end, letters, numbers, null, RANDOM); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public MutableByte(final byte value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) { [EOL]     final Map<String, E> map = new LinkedHashMap<String, E>(); [EOL]     for (final E e : enumClass.getEnumConstants()) { [EOL]         map.put(e.name(), e); [EOL]     } [EOL]     return map; [EOL] }
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getMiddle(), getRight()); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getMiddle(), getRight()); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getMiddle(), getRight()); [EOL] }
public static String reflectionToString(final Object object) { [EOL]     return ReflectionToStringBuilder.toString(object); [EOL] }
public static String reflectionToString(final Object object) { [EOL]     return ReflectionToStringBuilder.toString(object); [EOL] }
public ToStringBuilder append(final char value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final char value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final char[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final char[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final char[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final float value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final char value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final char value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final float value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final float value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder appendSuper(final String superToString) { [EOL]     if (superToString != null) { [EOL]         style.appendSuper(buffer, superToString); [EOL]     } [EOL]     return this; [EOL] }
public ToStringBuilder appendSuper(final String superToString) { [EOL]     if (superToString != null) { [EOL]         style.appendSuper(buffer, superToString); [EOL]     } [EOL]     return this; [EOL] }
public ToStringStyle getStyle() { [EOL]     return style; [EOL] }
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addMonths(final Date date, final int amount) { [EOL]     return add(date, Calendar.MONTH, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addDays(final Date date, final int amount) { [EOL]     return add(date, Calendar.DAY_OF_MONTH, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setMonths(final Date date, final int amount) { [EOL]     return set(date, Calendar.MONTH, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setMonths(final Date date, final int amount) { [EOL]     return set(date, Calendar.MONTH, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setDays(final Date date, final int amount) { [EOL]     return set(date, Calendar.DAY_OF_MONTH, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setSeconds(final Date date, final int amount) { [EOL]     return set(date, Calendar.SECOND, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date truncate(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_TRUNCATE); [EOL]     return gval.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date truncate(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_TRUNCATE); [EOL]     return gval.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Calendar truncate(final Calendar date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar truncated = (Calendar) date.clone(); [EOL]     modify(truncated, field, MODIFY_TRUNCATE); [EOL]     return truncated; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(focus); [EOL]     return iterator(gval, rangeStyle); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(focus); [EOL]     return iterator(gval, rangeStyle); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInMilliseconds(final Date date, final int fragment) { [EOL]     return getFragment(date, fragment, Calendar.MILLISECOND); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInMinutes(final Date date, final int fragment) { [EOL]     return getFragment(date, fragment, Calendar.MINUTE); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInHours(final Date date, final int fragment) { [EOL]     return getFragment(date, fragment, Calendar.HOUR_OF_DAY); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInHours(final Date date, final int fragment) { [EOL]     return getFragment(date, fragment, Calendar.HOUR_OF_DAY); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInDays(final Date date, final int fragment) { [EOL]     return getFragment(date, fragment, Calendar.DAY_OF_YEAR); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getMillisPerUnit(final int unit) { [EOL]     long result = Long.MAX_VALUE; [EOL]     switch(unit) { [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result = MILLIS_PER_DAY; [EOL]             break; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result = MILLIS_PER_HOUR; [EOL]             break; [EOL]         case Calendar.MINUTE: [EOL]             result = MILLIS_PER_MINUTE; [EOL]             break; [EOL]         case Calendar.SECOND: [EOL]             result = MILLIS_PER_SECOND; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             result = 1; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The unit " + unit + " cannot be represented is milleseconds"); [EOL]     } [EOL]     return result; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
DateIterator(final Calendar startFinal, final Calendar endFinal) { [EOL]     super(); [EOL]     this.endFinal = endFinal; [EOL]     spot = startFinal; [EOL]     spot.add(Calendar.DATE, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
DateIterator(final Calendar startFinal, final Calendar endFinal) { [EOL]     super(); [EOL]     this.endFinal = endFinal; [EOL]     spot = startFinal; [EOL]     spot.add(Calendar.DATE, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
DateIterator(final Calendar startFinal, final Calendar endFinal) { [EOL]     super(); [EOL]     this.endFinal = endFinal; [EOL]     spot = startFinal; [EOL]     spot.add(Calendar.DATE, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
@Override [EOL] public boolean hasNext() { [EOL]     return spot.before(endFinal); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
@Override [EOL] public Calendar next() { [EOL]     if (spot.equals(endFinal)) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     spot.add(Calendar.DATE, 1); [EOL]     return (Calendar) spot.clone(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
@Override [EOL] public final int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int codepoint = Character.codePointAt(input, index); [EOL]     final boolean consumed = translate(codepoint, out); [EOL]     if (consumed) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalizeFully(final String str) { [EOL]     return capitalizeFully(str, null); [EOL] }
public static String capitalizeFully(final String str) { [EOL]     return capitalizeFully(str, null); [EOL] }
public static String capitalizeFully(final String str) { [EOL]     return capitalizeFully(str, null); [EOL] }
public static String capitalizeFully(final String str) { [EOL]     return capitalizeFully(str, null); [EOL] }
public static String capitalizeFully(final String str) { [EOL]     return capitalizeFully(str, null); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public MultiBackgroundInitializer() { [EOL]     super(); [EOL] }
@Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] }
@Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] }
@Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] }
public boolean isSuccessful() { [EOL]     return exceptions.isEmpty(); [EOL] }
public boolean isSuccessful() { [EOL]     return exceptions.isEmpty(); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] }
public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] }
public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] }
public static int hashCode(final Object array) { [EOL]     return new HashCodeBuilder().append(array).toHashCode(); [EOL] }
public static long[] clone(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static long[] clone(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static long[] clone(final long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static byte[] clone(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static byte[] clone(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static byte[] clone(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static double[] clone(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static double[] clone(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static double[] clone(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static Object[] nullToEmpty(final Object[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Object[] nullToEmpty(final Object[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Object[] nullToEmpty(final Object[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static float[] nullToEmpty(final float[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_FLOAT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Character[] nullToEmpty(final Character[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Character[] nullToEmpty(final Character[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Character[] nullToEmpty(final Character[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Double[] nullToEmpty(final Double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Double[] nullToEmpty(final Double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Double[] nullToEmpty(final Double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] subarray = new byte[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] subarray = new double[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static void reverse(final float[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     float tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final float[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     float tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final float[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     float tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final char[] array, final char valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int[] toPrimitive(final Integer[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].intValue(); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].intValue(); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].intValue(); [EOL]     } [EOL]     return result; [EOL] }
public static short[] toPrimitive(final Short[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].shortValue(); [EOL]     } [EOL]     return result; [EOL] }
public static short[] toPrimitive(final Short[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].shortValue(); [EOL]     } [EOL]     return result; [EOL] }
public static short[] toPrimitive(final Short[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     final short[] result = new short[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].shortValue(); [EOL]     } [EOL]     return result; [EOL] }
public static Byte[] toObject(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     final Byte[] result = new Byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Byte.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Byte[] toObject(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     final Byte[] result = new Byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Byte.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Byte[] toObject(final byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_OBJECT_ARRAY; [EOL]     } [EOL]     final Byte[] result = new Byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Byte.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static boolean isEmpty(final Object[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final Object[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final Object[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final double[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final double[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final double[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static <T> boolean isNotEmpty(final T[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static <T> boolean isNotEmpty(final T[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static <T> boolean isNotEmpty(final T[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] remove(final T[] array, final int index) { [EOL]     return (T[]) remove((Object) array, index); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] remove(final T[] array, final int index) { [EOL]     return (T[]) remove((Object) array, index); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] remove(final T[] array, final int index) { [EOL]     return (T[]) remove((Object) array, index); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] remove(final T[] array, final int index) { [EOL]     return (T[]) remove((Object) array, index); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] remove(final T[] array, final int index) { [EOL]     return (T[]) remove((Object) array, index); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] remove(final T[] array, final int index) { [EOL]     return (T[]) remove((Object) array, index); [EOL] }
public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] }
public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] }
public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] }
public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] }
public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] }
public static byte[] remove(final byte[] array, final int index) { [EOL]     return (byte[]) remove((Object) array, index); [EOL] }
public static byte[] removeElement(final byte[] array, final byte element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static byte[] removeElement(final byte[] array, final byte element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static byte[] removeElement(final byte[] array, final byte element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static byte[] removeElement(final byte[] array, final byte element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static double[] removeElement(final double[] array, final double element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static double[] removeElement(final double[] array, final double element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static double[] removeElement(final double[] array, final double element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static double[] removeElement(final double[] array, final double element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static long[] remove(final long[] array, final int index) { [EOL]     return (long[]) remove((Object) array, index); [EOL] }
public static long[] remove(final long[] array, final int index) { [EOL]     return (long[]) remove((Object) array, index); [EOL] }
public static long[] remove(final long[] array, final int index) { [EOL]     return (long[]) remove((Object) array, index); [EOL] }
public static long[] remove(final long[] array, final int index) { [EOL]     return (long[]) remove((Object) array, index); [EOL] }
public static long[] remove(final long[] array, final int index) { [EOL]     return (long[]) remove((Object) array, index); [EOL] }
public static long[] removeElement(final long[] array, final long element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static long[] removeElement(final long[] array, final long element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static long[] removeElement(final long[] array, final long element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static long[] removeElement(final long[] array, final long element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static short[] removeAll(final short[] array, final int... indices) { [EOL]     return (short[]) removeAll((Object) array, clone(indices)); [EOL] }
public static short[] removeAll(final short[] array, final int... indices) { [EOL]     return (short[]) removeAll((Object) array, clone(indices)); [EOL] }
public static short[] removeAll(final short[] array, final int... indices) { [EOL]     return (short[]) removeAll((Object) array, clone(indices)); [EOL] }
public static short[] removeAll(final short[] array, final int... indices) { [EOL]     return (short[]) removeAll((Object) array, clone(indices)); [EOL] }
public static short[] removeAll(final short[] array, final int... indices) { [EOL]     return (short[]) removeAll((Object) array, clone(indices)); [EOL] }
public static short[] removeAll(final short[] array, final int... indices) { [EOL]     return (short[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeAll(final int[] array, final int... indices) { [EOL]     return (int[]) removeAll((Object) array, clone(indices)); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static int[] removeElements(final int[] array, final int... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length); [EOL]     for (final int v : values) { [EOL]         final Integer boxed = Integer.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) { [EOL]         final Integer v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.intValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (int[]) removeAll(array, toRemove); [EOL] }
public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] }
public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] }
public static double[] removeElements(final double[] array, final double... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length); [EOL]     for (final double v : values) { [EOL]         final Double boxed = Double.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) { [EOL]         final Double v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.doubleValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (double[]) removeAll(array, toRemove); [EOL] }
static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
static boolean isAccessible(final Member m) { [EOL]     return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) { [EOL]     final float leftCost = getTotalTransformationCost(actual, left); [EOL]     final float rightCost = getTotalTransformationCost(actual, right); [EOL]     return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0; [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) { [EOL]     float totalCost = 0.0f; [EOL]     for (int i = 0; i < srcArgs.length; i++) { [EOL]         Class<?> srcClass, destClass; [EOL]         srcClass = srcArgs[i]; [EOL]         destClass = destArgs[i]; [EOL]         totalCost += getObjectTransformationCost(srcClass, destClass); [EOL]     } [EOL]     return totalCost; [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
public static boolean isAssignable(final Type type, final Type toType) { [EOL]     return isAssignable(type, toType, null); [EOL] }
public static boolean isAssignable(final Type type, final Type toType) { [EOL]     return isAssignable(type, toType, null); [EOL] }
public static boolean isAssignable(final Type type, final Type toType) { [EOL]     return isAssignable(type, toType, null); [EOL] }
public static boolean isAssignable(final Type type, final Type toType) { [EOL]     return isAssignable(type, toType, null); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] }
private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] }
private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] }
private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] }
private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] }
private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] }
private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] }
private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] }
public static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass) { [EOL]     return getTypeArguments(type, toClass, null); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] }
private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] }
private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] }
private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] }
public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] }
public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] }
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] }
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] }
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getLowerBounds(); [EOL]     return bounds.length == 0 ? new Type[] { null } : bounds; [EOL] }
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getLowerBounds(); [EOL]     return bounds.length == 0 ? new Type[] { null } : bounds; [EOL] }
private static Class<?> getRawType(final ParameterizedType parameterizedType) { [EOL]     final Type rawType = parameterizedType.getRawType(); [EOL]     if (!(rawType instanceof Class<?>)) { [EOL]         throw new IllegalStateException("Wait... What!? Type of rawType: " + rawType); [EOL]     } [EOL]     return (Class<?>) rawType; [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     final Set<String> labels = new HashSet<String>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         labels.add(pair.getKey()); [EOL]     } [EOL]     return labels; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     final Set<String> labels = new HashSet<String>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         labels.add(pair.getKey()); [EOL]     } [EOL]     return labels; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     final Set<String> labels = new HashSet<String>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         labels.add(pair.getKey()); [EOL]     } [EOL]     return labels; [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return contextValues; [EOL] }
public String getNullText() { [EOL]     return nullText; [EOL] }
public StrBuilder appendNewLine() { [EOL]     if (newLine == null) { [EOL]         append(SystemUtils.LINE_SEPARATOR); [EOL]         return this; [EOL]     } [EOL]     return append(newLine); [EOL] }
public StrBuilder append(final String str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final String format, final Object... objs) { [EOL]     return append(String.format(format, objs)); [EOL] }
public StrBuilder append(final String format, final Object... objs) { [EOL]     return append(String.format(format, objs)); [EOL] }
public StrBuilder append(final String format, final Object... objs) { [EOL]     return append(String.format(format, objs)); [EOL] }
public StrBuilder append(final String format, final Object... objs) { [EOL]     return append(String.format(format, objs)); [EOL] }
public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final char[] chars, final int startIndex, final int length) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid startIndex: " + length); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         System.arraycopy(chars, startIndex, buffer, len, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final boolean value) { [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         buffer[size++] = 't'; [EOL]         buffer[size++] = 'r'; [EOL]         buffer[size++] = 'u'; [EOL]         buffer[size++] = 'e'; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         buffer[size++] = 'f'; [EOL]         buffer[size++] = 'a'; [EOL]         buffer[size++] = 'l'; [EOL]         buffer[size++] = 's'; [EOL]         buffer[size++] = 'e'; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final boolean value) { [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         buffer[size++] = 't'; [EOL]         buffer[size++] = 'r'; [EOL]         buffer[size++] = 'u'; [EOL]         buffer[size++] = 'e'; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         buffer[size++] = 'f'; [EOL]         buffer[size++] = 'a'; [EOL]         buffer[size++] = 'l'; [EOL]         buffer[size++] = 's'; [EOL]         buffer[size++] = 'e'; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public StrBuilder append(final char ch) { [EOL]     final int len = length(); [EOL]     ensureCapacity(len + 1); [EOL]     buffer[size++] = ch; [EOL]     return this; [EOL] }
@Override [EOL] public StrBuilder append(final char ch) { [EOL]     final int len = length(); [EOL]     ensureCapacity(len + 1); [EOL]     buffer[size++] = ch; [EOL]     return this; [EOL] }
public StrBuilder appendln(final String str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final String str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final String format, final Object... objs) { [EOL]     return append(format, objs).appendNewLine(); [EOL] }
public StrBuilder appendln(final String format, final Object... objs) { [EOL]     return append(format, objs).appendNewLine(); [EOL] }
public StrBuilder appendln(final String format, final Object... objs) { [EOL]     return append(format, objs).appendNewLine(); [EOL] }
public StrBuilder appendln(final String format, final Object... objs) { [EOL]     return append(format, objs).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendSeparator(final String separator, final int loopIndex) { [EOL]     if (separator != null && loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String separator, final int loopIndex) { [EOL]     if (separator != null && loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String separator, final int loopIndex) { [EOL]     if (separator != null && loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String separator, final int loopIndex) { [EOL]     if (separator != null && loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(0, width, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             str.getChars(0, strLen, buffer, size); [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + strLen + i] = padChar; [EOL]             } [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(0, width, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             str.getChars(0, strLen, buffer, size); [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + strLen + i] = padChar; [EOL]             } [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadRight(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadRight(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadRight(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadRight(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder deleteFirst(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             deleteImpl(i, i + 1, 1); [EOL]             break; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteFirst(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             deleteImpl(i, i + 1, 1); [EOL]             break; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteFirst(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             deleteImpl(i, i + 1, 1); [EOL]             break; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int index = indexOf(searchStr, 0); [EOL]         if (index >= 0) { [EOL]             final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, 1); [EOL] }
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount); [EOL] }
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount); [EOL] }
private StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount) { [EOL]     if (matcher == null || size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     final char[] buf = buffer; [EOL]     for (int i = from; i < to && replaceCount != 0; i++) { [EOL]         final int removeLen = matcher.isMatch(buf, i, from, to); [EOL]         if (removeLen > 0) { [EOL]             replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen); [EOL]             to = to - removeLen + replaceLen; [EOL]             i = i + replaceLen - 1; [EOL]             if (replaceCount > 0) { [EOL]                 replaceCount--; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
private StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount) { [EOL]     if (matcher == null || size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     final char[] buf = buffer; [EOL]     for (int i = from; i < to && replaceCount != 0; i++) { [EOL]         final int removeLen = matcher.isMatch(buf, i, from, to); [EOL]         if (removeLen > 0) { [EOL]             replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen); [EOL]             to = to - removeLen + replaceLen; [EOL]             i = i + replaceLen - 1; [EOL]             if (replaceCount > 0) { [EOL]                 replaceCount--; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder reverse() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int half = size / 2; [EOL]     final char[] buf = buffer; [EOL]     for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) { [EOL]         final char swap = buf[leftIdx]; [EOL]         buf[leftIdx] = buf[rightIdx]; [EOL]         buf[rightIdx] = swap; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder reverse() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int half = size / 2; [EOL]     final char[] buf = buffer; [EOL]     for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) { [EOL]         final char swap = buf[leftIdx]; [EOL]         buf[leftIdx] = buf[rightIdx]; [EOL]         buf[rightIdx] = swap; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public CharSequence subSequence(final int startIndex, final int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex - startIndex); [EOL]     } [EOL]     return substring(startIndex, endIndex); [EOL] }
@Override [EOL] public CharSequence subSequence(final int startIndex, final int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex - startIndex); [EOL]     } [EOL]     return substring(startIndex, endIndex); [EOL] }
@Override [EOL] public CharSequence subSequence(final int startIndex, final int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex - startIndex); [EOL]     } [EOL]     return substring(startIndex, endIndex); [EOL] }
@Override [EOL] public CharSequence subSequence(final int startIndex, final int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex - startIndex); [EOL]     } [EOL]     return substring(startIndex, endIndex); [EOL] }
public String rightString(final int length) { [EOL]     if (length <= 0) { [EOL]         return ""; [EOL]     } else if (length >= size) { [EOL]         return new String(buffer, 0, size); [EOL]     } else { [EOL]         return new String(buffer, size - length, length); [EOL]     } [EOL] }
public boolean contains(final String str) { [EOL]     return indexOf(str, 0) >= 0; [EOL] }
public boolean contains(final StrMatcher matcher) { [EOL]     return indexOf(matcher, 0) >= 0; [EOL] }
public boolean contains(final StrMatcher matcher) { [EOL]     return indexOf(matcher, 0) >= 0; [EOL] }
public boolean contains(final StrMatcher matcher) { [EOL]     return indexOf(matcher, 0) >= 0; [EOL] }
public int lastIndexOf(final String str) { [EOL]     return lastIndexOf(str, size - 1); [EOL] }
public int lastIndexOf(final String str) { [EOL]     return lastIndexOf(str, size - 1); [EOL] }
public int lastIndexOf(final String str) { [EOL]     return lastIndexOf(str, size - 1); [EOL] }
public int lastIndexOf(final String str) { [EOL]     return lastIndexOf(str, size - 1); [EOL] }
public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public StringBuffer toStringBuffer() { [EOL]     return new StringBuffer(size).append(buffer, 0, size); [EOL] }
public StringBuffer toStringBuffer() { [EOL]     return new StringBuffer(size).append(buffer, 0, size); [EOL] }
protected int validateRange(final int startIndex, int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         endIndex = size; [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     return endIndex; [EOL] }
protected int validateRange(final int startIndex, int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         endIndex = size; [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     return endIndex; [EOL] }
protected int validateRange(final int startIndex, int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         endIndex = size; [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     return endIndex; [EOL] }
protected int validateRange(final int startIndex, int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         endIndex = size; [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     return endIndex; [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return printer.format(obj, toAppendTo, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public MutableTriple() { [EOL]     super(); [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] }
public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] }
public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] }
public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] }
public static Object readField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readField(target, fieldName, false); [EOL] }
public static Object readField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readField(target, fieldName, false); [EOL] }
public static Object readField(final Object target, final String fieldName) throws IllegalAccessException { [EOL]     return readField(target, fieldName, false); [EOL] }
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] }
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] }
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     return readField(field, target); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredStaticField(cls, fieldName, value, false); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeField(target, fieldName, value, false); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] }
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
@Override [EOL] public String toString() { [EOL]     return set.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return set.toString(); [EOL] }
public ContextedException() { [EOL]     super(); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedException(final Throwable cause) { [EOL]     super(cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedException(final Throwable cause) { [EOL]     super(cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public static <L, R> MutablePair<L, R> of(final L left, final R right) { [EOL]     return new MutablePair<L, R>(left, right); [EOL] }
public static <L, R> MutablePair<L, R> of(final L left, final R right) { [EOL]     return new MutablePair<L, R>(left, right); [EOL] }
public MutablePair(final L left, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.right = right; [EOL] }
public MutablePair(final L left, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.right = right; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
public void setLeft(final L left) { [EOL]     this.left = left; [EOL] }
public void setLeft(final L left) { [EOL]     this.left = left; [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
public void setRight(final R right) { [EOL]     this.right = right; [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactConstructor(cls, args, parameterTypes); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleConstructor(cls.getConstructor(parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static boolean isSupported(final String name) { [EOL]     if (name == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         return Charset.isSupported(name); [EOL]     } catch (final IllegalCharsetNameException ex) { [EOL]         return false; [EOL]     } [EOL] }
private void checkCallable(final Callable<T> call) { [EOL]     if (call == null) { [EOL]         throw new IllegalArgumentException("Callable must not be null!"); [EOL]     } [EOL] }
private void checkCallable(final Callable<T> call) { [EOL]     if (call == null) { [EOL]         throw new IllegalArgumentException("Callable must not be null!"); [EOL]     } [EOL] }
static Set<IDKey> getRegistry() { [EOL]     return REGISTRY.get(); [EOL] }
static boolean isRegistered(final Object value) { [EOL]     final Set<IDKey> registry = getRegistry(); [EOL]     return registry != null && registry.contains(new IDKey(value)); [EOL] }
static boolean isRegistered(final Object value) { [EOL]     final Set<IDKey> registry = getRegistry(); [EOL]     return registry != null && registry.contains(new IDKey(value)); [EOL] }
static boolean isRegistered(final Object value) { [EOL]     final Set<IDKey> registry = getRegistry(); [EOL]     return registry != null && registry.contains(new IDKey(value)); [EOL] }
private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] }
private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] }
private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] }
private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] }
private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] }
private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(object)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(object); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (final Field field : fields) { [EOL]             if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { [EOL]                 try { [EOL]                     final Object fieldValue = field.get(object); [EOL]                     builder.append(fieldValue); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(object); [EOL]     } [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(17, 37, object, testTransients, null); [EOL] }
public static int reflectionHashCode(final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(17, 37, object, testTransients, null); [EOL] }
public static int reflectionHashCode(final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(17, 37, object, testTransients, null); [EOL] }
static void register(final Object value) { [EOL]     synchronized (HashCodeBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<IDKey>()); [EOL]         } [EOL]     } [EOL]     getRegistry().add(new IDKey(value)); [EOL] }
static void unregister(final Object value) { [EOL]     Set<IDKey> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         registry.remove(new IDKey(value)); [EOL]         synchronized (HashCodeBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
static void unregister(final Object value) { [EOL]     Set<IDKey> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         registry.remove(new IDKey(value)); [EOL]         synchronized (HashCodeBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
static void unregister(final Object value) { [EOL]     Set<IDKey> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         registry.remove(new IDKey(value)); [EOL]         synchronized (HashCodeBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public HashCodeBuilder() { [EOL]     iConstant = 37; [EOL]     iTotal = 17; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder append(final float[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final float element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final float element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final float element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static <T extends Comparable<T>> Range<T> between(final T fromInclusive, final T toInclusive) { [EOL]     return between(fromInclusive, toInclusive, null); [EOL] }
public static <T extends Comparable<T>> Range<T> between(final T fromInclusive, final T toInclusive) { [EOL]     return between(fromInclusive, toInclusive, null); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
public boolean isStartedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) == 0; [EOL] }
public boolean isEndedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) == 0; [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     String result = toString; [EOL]     if (result == null) { [EOL]         final StringBuilder buf = new StringBuilder(32); [EOL]         buf.append('['); [EOL]         buf.append(minimum); [EOL]         buf.append(".."); [EOL]         buf.append(maximum); [EOL]         buf.append(']'); [EOL]         result = buf.toString(); [EOL]         toString = result; [EOL]     } [EOL]     return result; [EOL] }
public static String toString(final Object object) { [EOL]     return toString(object, null, false, false, null); [EOL] }
public static String toString(final Object object) { [EOL]     return toString(object, null, false, false, null); [EOL] }
public static <T> String toString(final T object, final ToStringStyle style, final boolean outputTransients, final boolean outputStatics, final Class<? super T> reflectUpToClass) { [EOL]     return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString(); [EOL] }
public static <T> String toString(final T object, final ToStringStyle style, final boolean outputTransients, final boolean outputStatics, final Class<? super T> reflectUpToClass) { [EOL]     return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString(); [EOL] }
static String[] toNoNullStringArray(final Object[] array) { [EOL]     final List<String> list = new ArrayList<String>(array.length); [EOL]     for (final Object e : array) { [EOL]         if (e != null) { [EOL]             list.add(e.toString()); [EOL]         } [EOL]     } [EOL]     return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
public ReflectionToStringBuilder(final Object object) { [EOL]     super(object); [EOL] }
public ReflectionToStringBuilder(final Object object) { [EOL]     super(object); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
public <T> ReflectionToStringBuilder(final T object, final ToStringStyle style, final StringBuffer buffer, final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) { [EOL]     super(object, style, buffer); [EOL]     this.setUpToClass(reflectUpToClass); [EOL]     this.setAppendTransients(outputTransients); [EOL]     this.setAppendStatics(outputStatics); [EOL] }
protected boolean accept(final Field field) { [EOL]     if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) { [EOL]         return false; [EOL]     } [EOL]     if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) { [EOL]         return false; [EOL]     } [EOL]     if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public Class<?> getUpToClass() { [EOL]     return this.upToClass; [EOL] }
protected Object getValue(final Field field) throws IllegalArgumentException, IllegalAccessException { [EOL]     return field.get(this.getObject()); [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public void setAppendStatics(final boolean appendStatics) { [EOL]     this.appendStatics = appendStatics; [EOL] }
public void setAppendTransients(final boolean appendTransients) { [EOL]     this.appendTransients = appendTransients; [EOL] }
public void setAppendTransients(final boolean appendTransients) { [EOL]     this.appendTransients = appendTransients; [EOL] }
public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) { [EOL]     if (excludeFieldNamesParam == null) { [EOL]         this.excludeFieldNames = null; [EOL]     } else { [EOL]         this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam); [EOL]         Arrays.sort(this.excludeFieldNames); [EOL]     } [EOL]     return this; [EOL] }
public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) { [EOL]     if (excludeFieldNamesParam == null) { [EOL]         this.excludeFieldNames = null; [EOL]     } else { [EOL]         this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam); [EOL]         Arrays.sort(this.excludeFieldNames); [EOL]     } [EOL]     return this; [EOL] }
public void setUpToClass(final Class<?> clazz) { [EOL]     if (clazz != null) { [EOL]         final Object object = getObject(); [EOL]         if (object != null && clazz.isInstance(object) == false) { [EOL]             throw new IllegalArgumentException("Specified class is not a superclass of the object"); [EOL]         } [EOL]     } [EOL]     this.upToClass = clazz; [EOL] }
public void setUpToClass(final Class<?> clazz) { [EOL]     if (clazz != null) { [EOL]         final Object object = getObject(); [EOL]         if (object != null && clazz.isInstance(object) == false) { [EOL]             throw new IllegalArgumentException("Specified class is not a superclass of the object"); [EOL]         } [EOL]     } [EOL]     this.upToClass = clazz; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
public boolean atLeast(final JavaVersion requiredVersion) { [EOL]     return this.value >= requiredVersion.value; [EOL] }
public boolean atLeast(final JavaVersion requiredVersion) { [EOL]     return this.value >= requiredVersion.value; [EOL] }
public boolean atLeast(final JavaVersion requiredVersion) { [EOL]     return this.value >= requiredVersion.value; [EOL] }
public void increment() { [EOL]     value++; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.longValue(); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public static int hashCode(final Object obj) { [EOL]     return obj == null ? 0 : obj.hashCode(); [EOL] }
public static int hashCode(final Object obj) { [EOL]     return obj == null ? 0 : obj.hashCode(); [EOL] }
public static int hashCodeMulti(final Object... objects) { [EOL]     int hash = 1; [EOL]     if (objects != null) { [EOL]         for (final Object object : objects) { [EOL]             hash = hash * 31 + ObjectUtils.hashCode(object); [EOL]         } [EOL]     } [EOL]     return hash; [EOL] }
public static void identityToString(final StrBuilder builder, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static void identityToString(final StrBuilder builder, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
Null() { [EOL]     super(); [EOL] }
public IDKey(final Object _value) { [EOL]     id = System.identityHashCode(_value); [EOL]     value = _value; [EOL] }
public IDKey(final Object _value) { [EOL]     id = System.identityHashCode(_value); [EOL]     value = _value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return id; [EOL] }
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (!(other instanceof IDKey)) { [EOL]         return false; [EOL]     } [EOL]     final IDKey idKey = (IDKey) other; [EOL]     if (id != idKey.id) { [EOL]         return false; [EOL]     } [EOL]     return value == idKey.value; [EOL] }
public static void isTrue(final boolean expression, final String message, final Object... values) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isTrue(final boolean expression, final String message, final Object... values) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isTrue(final boolean expression, final String message, final Object... values) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isTrue(final boolean expression) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE); [EOL]     } [EOL] }
public static void isTrue(final boolean expression) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE); [EOL]     } [EOL] }
public static <T extends Collection<?>> T validIndex(final T collection, final int index) { [EOL]     return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends Collection<?>> T validIndex(final T collection, final int index) { [EOL]     return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern)); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), obj == null ? "null" : obj.getClass().getName())); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), obj == null ? "null" : obj.getClass().getName())); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), obj == null ? "null" : obj.getClass().getName())); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), obj == null ? "null" : obj.getClass().getName())); [EOL]     } [EOL] }
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
public ImmutableTriple(final L left, final M middle, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.middle = middle; [EOL]     this.right = right; [EOL] }
public ImmutableTriple(final L left, final M middle, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.middle = middle; [EOL]     this.right = right; [EOL] }
@Override [EOL] public M getMiddle() { [EOL]     return middle; [EOL] }
@Override [EOL] public int compareTo(final MutableBoolean other) { [EOL]     final boolean anotherVal = other.value; [EOL]     return value == anotherVal ? 0 : (value ? 1 : -1); [EOL] }
@Override [EOL] public int compareTo(final MutableBoolean other) { [EOL]     final boolean anotherVal = other.value; [EOL]     return value == anotherVal ? 0 : (value ? 1 : -1); [EOL] }
@Override [EOL] public int compareTo(final MutableBoolean other) { [EOL]     final boolean anotherVal = other.value; [EOL]     return value == anotherVal ? 0 : (value ? 1 : -1); [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
Token(final Object value, final int count) { [EOL]     this.value = value; [EOL]     this.count = count; [EOL] }
Token(final Object value, final int count) { [EOL]     this.value = value; [EOL]     this.count = count; [EOL] }
@Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public String toString() { [EOL]     return StringUtils.repeat(this.value.toString(), this.count); [EOL] }
@Override [EOL] public String toString() { [EOL]     return StringUtils.repeat(this.value.toString(), this.count); [EOL] }
@Override [EOL] public String toString() { [EOL]     return StringUtils.repeat(this.value.toString(), this.count); [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static boolean deepEmpty(final String[] strings) { [EOL]     if (strings != null) { [EOL]         for (final String s : strings) { [EOL]             if (StringUtils.isNotEmpty(s)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean deepEmpty(final String[] strings) { [EOL]     if (strings != null) { [EOL]         for (final String s : strings) { [EOL]             if (StringUtils.isNotEmpty(s)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean deepEmpty(final String[] strings) { [EOL]     if (strings != null) { [EOL]         for (final String s : strings) { [EOL]             if (StringUtils.isNotEmpty(s)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private static boolean deepEmpty(final String[] strings) { [EOL]     if (strings != null) { [EOL]         for (final String s : strings) { [EOL]             if (StringUtils.isNotEmpty(s)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable) { [EOL]     return getCause(throwable, CAUSE_METHOD_NAMES); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) { [EOL]     Method method = null; [EOL]     try { [EOL]         method = throwable.getClass().getMethod(methodName); [EOL]     } catch (final NoSuchMethodException ignored) { [EOL]     } catch (final SecurityException ignored) { [EOL]     } [EOL]     if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) { [EOL]         try { [EOL]             return (Throwable) method.invoke(throwable); [EOL]         } catch (final IllegalAccessException ignored) { [EOL]         } catch (final IllegalArgumentException ignored) { [EOL]         } catch (final InvocationTargetException ignored) { [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable[] getThrowables(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.toArray(new Throwable[list.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable[] getThrowables(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.toArray(new Throwable[list.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static Throwable[] getThrowables(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.toArray(new Throwable[list.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) { [EOL]     if (causeFrames == null || wrapperFrames == null) { [EOL]         throw new IllegalArgumentException("The List must not be null"); [EOL]     } [EOL]     int causeFrameIndex = causeFrames.size() - 1; [EOL]     int wrapperFrameIndex = wrapperFrames.size() - 1; [EOL]     while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) { [EOL]         final String causeFrame = causeFrames.get(causeFrameIndex); [EOL]         final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex); [EOL]         if (causeFrame.equals(wrapperFrame)) { [EOL]             causeFrames.remove(causeFrameIndex); [EOL]         } [EOL]         causeFrameIndex--; [EOL]         wrapperFrameIndex--; [EOL]     } [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) { [EOL]     if (causeFrames == null || wrapperFrames == null) { [EOL]         throw new IllegalArgumentException("The List must not be null"); [EOL]     } [EOL]     int causeFrameIndex = causeFrames.size() - 1; [EOL]     int wrapperFrameIndex = wrapperFrames.size() - 1; [EOL]     while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) { [EOL]         final String causeFrame = causeFrames.get(causeFrameIndex); [EOL]         final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex); [EOL]         if (causeFrame.equals(wrapperFrame)) { [EOL]             causeFrames.remove(causeFrameIndex); [EOL]         } [EOL]         causeFrameIndex--; [EOL]         wrapperFrameIndex--; [EOL]     } [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getStackTrace(final Throwable throwable) { [EOL]     final StringWriter sw = new StringWriter(); [EOL]     final PrintWriter pw = new PrintWriter(sw, true); [EOL]     throwable.printStackTrace(pw); [EOL]     return sw.getBuffer().toString(); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getStackTrace(final Throwable throwable) { [EOL]     final StringWriter sw = new StringWriter(); [EOL]     final PrintWriter pw = new PrintWriter(sw, true); [EOL]     throwable.printStackTrace(pw); [EOL]     return sw.getBuffer().toString(); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public void unsplit() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch has not been split. "); [EOL]     } [EOL]     this.splitState = STATE_UNSPLIT; [EOL] }
public void unsplit() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch has not been split. "); [EOL]     } [EOL]     this.splitState = STATE_UNSPLIT; [EOL] }
public void suspend() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch must be running to suspend. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.runningState = STATE_SUSPENDED; [EOL] }
public void suspend() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch must be running to suspend. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.runningState = STATE_SUSPENDED; [EOL] }
public void resume() { [EOL]     if (this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch must be suspended to resume. "); [EOL]     } [EOL]     this.startTime += System.nanoTime() - this.stopTime; [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void resume() { [EOL]     if (this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch must be suspended to resume. "); [EOL]     } [EOL]     this.startTime += System.nanoTime() - this.stopTime; [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getSplitNanoTime() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch must be split to get the split time. "); [EOL]     } [EOL]     return this.stopTime - this.startTime; [EOL] }
public long getSplitNanoTime() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch must be split to get the split time. "); [EOL]     } [EOL]     return this.stopTime - this.startTime; [EOL] }
@Override [EOL] public String toString() { [EOL]     return DurationFormatUtils.formatDurationHMS(getTime()); [EOL] }
public CompareToBuilder() { [EOL]     super(); [EOL]     comparison = 0; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final long lhs, final long rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final long lhs, final long rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final long lhs, final long rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final long lhs, final long rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     return append(lhs, rhs, null); [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     return append(lhs, rhs, null); [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     return append(lhs, rhs, null); [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     return append(lhs, rhs, null); [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     return append(lhs, rhs, null); [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs) { [EOL]     return append(lhs, rhs, null); [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i], comparator); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public StringUtils() { [EOL]     super(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static String trimToNull(final String str) { [EOL]     final String ts = trim(str); [EOL]     return isEmpty(ts) ? null : ts; [EOL] }
public static String trimToNull(final String str) { [EOL]     final String ts = trim(str); [EOL]     return isEmpty(ts) ? null : ts; [EOL] }
public static String trimToNull(final String str) { [EOL]     final String ts = trim(str); [EOL]     return isEmpty(ts) ? null : ts; [EOL] }
public static String trimToNull(final String str) { [EOL]     final String ts = trim(str); [EOL]     return isEmpty(ts) ? null : ts; [EOL] }
public static String stripStart(final String str, final String stripChars) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     int start = 0; [EOL]     if (stripChars == null) { [EOL]         while (start != strLen && Character.isWhitespace(str.charAt(start))) { [EOL]             start++; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [EOL]             start++; [EOL]         } [EOL]     } [EOL]     return str.substring(start); [EOL] }
public static String stripEnd(final String str, final String stripChars) { [EOL]     int end; [EOL]     if (str == null || (end = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     if (stripChars == null) { [EOL]         while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) { [EOL]             end--; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) { [EOL]             end--; [EOL]         } [EOL]     } [EOL]     return str.substring(0, end); [EOL] }
public static String[] stripAll(final String... strs) { [EOL]     return stripAll(strs, null); [EOL] }
public static String[] stripAll(final String... strs) { [EOL]     return stripAll(strs, null); [EOL] }
public static String[] stripAll(final String... strs) { [EOL]     return stripAll(strs, null); [EOL] }
public static String[] stripAll(final String... strs) { [EOL]     return stripAll(strs, null); [EOL] }
public static String[] stripAll(final String[] strs, final String stripChars) { [EOL]     int strsLen; [EOL]     if (strs == null || (strsLen = strs.length) == 0) { [EOL]         return strs; [EOL]     } [EOL]     final String[] newArr = new String[strsLen]; [EOL]     for (int i = 0; i < strsLen; i++) { [EOL]         newArr[i] = strip(strs[i], stripChars); [EOL]     } [EOL]     return newArr; [EOL] }
public static String[] stripAll(final String[] strs, final String stripChars) { [EOL]     int strsLen; [EOL]     if (strs == null || (strsLen = strs.length) == 0) { [EOL]         return strs; [EOL]     } [EOL]     final String[] newArr = new String[strsLen]; [EOL]     for (int i = 0; i < strsLen; i++) { [EOL]         newArr[i] = strip(strs[i], stripChars); [EOL]     } [EOL]     return newArr; [EOL] }
public static String[] stripAll(final String[] strs, final String stripChars) { [EOL]     int strsLen; [EOL]     if (strs == null || (strsLen = strs.length) == 0) { [EOL]         return strs; [EOL]     } [EOL]     final String[] newArr = new String[strsLen]; [EOL]     for (int i = 0; i < strsLen; i++) { [EOL]         newArr[i] = strip(strs[i], stripChars); [EOL]     } [EOL]     return newArr; [EOL] }
public static String[] stripAll(final String[] strs, final String stripChars) { [EOL]     int strsLen; [EOL]     if (strs == null || (strsLen = strs.length) == 0) { [EOL]         return strs; [EOL]     } [EOL]     final String[] newArr = new String[strsLen]; [EOL]     for (int i = 0; i < strsLen; i++) { [EOL]         newArr[i] = strip(strs[i], stripChars); [EOL]     } [EOL]     return newArr; [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length()); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return lastIndexOfIgnoreCase(str, searchStr, str.length()); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return lastIndexOfIgnoreCase(str, searchStr, str.length()); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return lastIndexOfIgnoreCase(str, searchStr, str.length()); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return lastIndexOfIgnoreCase(str, searchStr, str.length()); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0; [EOL] }
public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAny(final CharSequence cs, final String searchChars) { [EOL]     if (isEmpty(cs) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return indexOfAny(cs, searchChars.toCharArray()); [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] }
public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] }
public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] }
public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] }
public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] }
public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] }
public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] }
public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] }
public static String substringAfter(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (separator == null) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String open, final String close) { [EOL]     if (str == null || open == null || close == null) { [EOL]         return null; [EOL]     } [EOL]     final int start = str.indexOf(open); [EOL]     if (start != INDEX_NOT_FOUND) { [EOL]         final int end = str.indexOf(close, start + open.length()); [EOL]         if (end != INDEX_NOT_FOUND) { [EOL]             return str.substring(start + open.length(), end); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.isEmpty()) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String join(final int[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterable<?> iterable, final char separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] }
public static String removeEnd(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.endsWith(remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEnd(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.endsWith(remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEnd(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.endsWith(remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEnd(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.endsWith(remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEnd(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.endsWith(remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String remove(final String str, final char remove) { [EOL]     if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int pos = 0; [EOL]     for (int i = 0; i < chars.length; i++) { [EOL]         if (chars[i] != remove) { [EOL]             chars[pos++] = chars[i]; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, pos); [EOL] }
public static String replace(final String text, final String searchString, final String replacement, int max) { [EOL]     if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int end = text.indexOf(searchString, start); [EOL]     if (end == INDEX_NOT_FOUND) { [EOL]         return text; [EOL]     } [EOL]     final int replLength = searchString.length(); [EOL]     int increase = replacement.length() - replLength; [EOL]     increase = increase < 0 ? 0 : increase; [EOL]     increase *= max < 0 ? 16 : max > 64 ? 64 : max; [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (end != INDEX_NOT_FOUND) { [EOL]         buf.append(text.substring(start, end)).append(replacement); [EOL]         start = end + replLength; [EOL]         if (--max == 0) { [EOL]             break; [EOL]         } [EOL]         end = text.indexOf(searchString, start); [EOL]     } [EOL]     buf.append(text.substring(start)); [EOL]     return buf.toString(); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static int countMatches(final CharSequence str, final CharSequence sub) { [EOL]     if (isEmpty(str) || isEmpty(sub)) { [EOL]         return 0; [EOL]     } [EOL]     int count = 0; [EOL]     int idx = 0; [EOL]     while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) { [EOL]         count++; [EOL]         idx += sub.length(); [EOL]     } [EOL]     return count; [EOL] }
public static int countMatches(final CharSequence str, final CharSequence sub) { [EOL]     if (isEmpty(str) || isEmpty(sub)) { [EOL]         return 0; [EOL]     } [EOL]     int count = 0; [EOL]     int idx = 0; [EOL]     while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) { [EOL]         count++; [EOL]         idx += sub.length(); [EOL]     } [EOL]     return count; [EOL] }
public static int countMatches(final CharSequence str, final CharSequence sub) { [EOL]     if (isEmpty(str) || isEmpty(sub)) { [EOL]         return 0; [EOL]     } [EOL]     int count = 0; [EOL]     int idx = 0; [EOL]     while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) { [EOL]         count++; [EOL]         idx += sub.length(); [EOL]     } [EOL]     return count; [EOL] }
public static int countMatches(final CharSequence str, final CharSequence sub) { [EOL]     if (isEmpty(str) || isEmpty(sub)) { [EOL]         return 0; [EOL]     } [EOL]     int count = 0; [EOL]     int idx = 0; [EOL]     while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) { [EOL]         count++; [EOL]         idx += sub.length(); [EOL]     } [EOL]     return count; [EOL] }
public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static String abbreviate(final String str, final int maxWidth) { [EOL]     return abbreviate(str, 0, maxWidth); [EOL] }
public static String abbreviate(final String str, final int maxWidth) { [EOL]     return abbreviate(str, 0, maxWidth); [EOL] }
public static String abbreviate(final String str, final int maxWidth) { [EOL]     return abbreviate(str, 0, maxWidth); [EOL] }
public static String abbreviate(final String str, final int maxWidth) { [EOL]     return abbreviate(str, 0, maxWidth); [EOL] }
public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) { [EOL]     if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (suffixes != null && suffixes.length > 0) { [EOL]         for (final CharSequence s : suffixes) { [EOL]             if (endsWith(str, s, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return str + suffix.toString(); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
public void add(final double operand) { [EOL]     this.value += operand; [EOL] }
public void add(final double operand) { [EOL]     this.value += operand; [EOL] }
public void add(final double operand) { [EOL]     this.value += operand; [EOL] }
public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL]     appendToString(buffer, superToString); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL]     final int len = buffer.length(); [EOL]     final int sepLen = fieldSeparator.length(); [EOL]     if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL]         boolean match = true; [EOL]         for (int i = 0; i < sepLen; i++) { [EOL]             if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL]                 match = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (match) { [EOL]             buffer.setLength(len - sepLen); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL]     buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL]     buffer.append(arrayStart); [EOL]     final int length = Array.getLength(array); [EOL]     for (int i = 0; i < length; i++) { [EOL]         final Object item = Array.get(array, i); [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         if (item == null) { [EOL]             appendNullText(buffer, fieldName); [EOL]         } else { [EOL]             appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL]         } [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setArrayEnd(String arrayEnd) { [EOL]     if (arrayEnd == null) { [EOL]         arrayEnd = ""; [EOL]     } [EOL]     this.arrayEnd = arrayEnd; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getContentStart() { [EOL]     return contentStart; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setContentStart(String contentStart) { [EOL]     if (contentStart == null) { [EOL]         contentStart = ""; [EOL]     } [EOL]     this.contentStart = contentStart; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setContentStart(String contentStart) { [EOL]     if (contentStart == null) { [EOL]         contentStart = ""; [EOL]     } [EOL]     this.contentStart = contentStart; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setFieldSeparator(String fieldSeparator) { [EOL]     if (fieldSeparator == null) { [EOL]         fieldSeparator = ""; [EOL]     } [EOL]     this.fieldSeparator = fieldSeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected UnicodeEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] }
protected UnicodeEscaper(final int below, final int above, final boolean between) { [EOL]     this.below = below; [EOL]     this.above = above; [EOL]     this.between = between; [EOL] }
public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, false); [EOL] }
public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, false); [EOL] }
public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, false); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public StringEscapeUtils() { [EOL]     super(); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String unescapeXml(final String input) { [EOL]     return UNESCAPE_XML.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public CompositeFormat(final Format parser, final Format formatter) { [EOL]     this.parser = parser; [EOL]     this.formatter = formatter; [EOL] }
public CompositeFormat(final Format parser, final Format formatter) { [EOL]     this.parser = parser; [EOL]     this.formatter = formatter; [EOL] }
public CompositeFormat(final Format parser, final Format formatter) { [EOL]     this.parser = parser; [EOL]     this.formatter = formatter; [EOL] }
public CompositeFormat(final Format parser, final Format formatter) { [EOL]     this.parser = parser; [EOL]     this.formatter = formatter; [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return formatter.format(obj, toAppendTo, pos); [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return formatter.format(obj, toAppendTo, pos); [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return formatter.format(obj, toAppendTo, pos); [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return formatter.format(obj, toAppendTo, pos); [EOL] }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] }
public String reformat(final String input) throws ParseException { [EOL]     return format(parseObject(input)); [EOL] }
public String reformat(final String input) throws ParseException { [EOL]     return format(parseObject(input)); [EOL] }
