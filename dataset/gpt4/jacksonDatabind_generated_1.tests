public void testFindReferenceTypeWithManagedReference() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonManagedReference ref1 = mock(JsonManagedReference.class); [EOL] when(member.getAnnotation(JsonManagedReference.class)).thenReturn(ref1); [EOL] when(ref1.value()).thenReturn("managedRef"); [EOL] ReferenceProperty result = findReferenceType(member); [EOL] assertNotNull(result); [EOL] assertTrue(result.isManagedReference()); [EOL] assertEquals("managedRef", result.getName()); [EOL] }
public void testFindReferenceTypeWithBackReference() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonBackReference ref2 = mock(JsonBackReference.class); [EOL] when(member.getAnnotation(JsonBackReference.class)).thenReturn(ref2); [EOL] when(ref2.value()).thenReturn("backRef"); [EOL] ReferenceProperty result = findReferenceType(member); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBackReference()); [EOL] assertEquals("backRef", result.getName()); [EOL] }
public void testFindReferenceTypeWithNoReference() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JsonManagedReference.class)).thenReturn(null); [EOL] when(member.getAnnotation(JsonBackReference.class)).thenReturn(null); [EOL] ReferenceProperty result = findReferenceType(member); [EOL] assertNull(result); [EOL] }
public void testFindUnwrappingNameTransformerWithNoAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JsonUnwrapped.class)).thenReturn(null); [EOL] NameTransformer result = findUnwrappingNameTransformer(member); [EOL] assertNull(result); [EOL] }
public void testFindUnwrappingNameTransformerWithDisabledAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonUnwrapped ann = mock(JsonUnwrapped.class); [EOL] when(member.getAnnotation(JsonUnwrapped.class)).thenReturn(ann); [EOL] when(ann.enabled()).thenReturn(false); [EOL] NameTransformer result = findUnwrappingNameTransformer(member); [EOL] assertNull(result); [EOL] }
public void testFindUnwrappingNameTransformerWithEnabledAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonUnwrapped ann = mock(JsonUnwrapped.class); [EOL] when(member.getAnnotation(JsonUnwrapped.class)).thenReturn(ann); [EOL] when(ann.enabled()).thenReturn(true); [EOL] when(ann.prefix()).thenReturn("prefix_"); [EOL] when(ann.suffix()).thenReturn("_suffix"); [EOL] NameTransformer result = findUnwrappingNameTransformer(member); [EOL] assertNotNull(result); [EOL] assertEquals("prefix_", result.transform("name").substring(0, 7)); [EOL] assertTrue(result.transform("name").endsWith("_suffix")); [EOL] }
public void testFindInjectableValueIdWithNoAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(null); [EOL] Object result = findInjectableValueId(member); [EOL] assertNull(result); [EOL] }
public void testFindInjectableValueIdWithEmptyValue() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JacksonInject inject = mock(JacksonInject.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(inject); [EOL] when(inject.value()).thenReturn(""); [EOL] when(member instanceof AnnotatedMethod).thenReturn(false); [EOL] when(member.getRawType()).thenReturn((Class) String.class); [EOL] Object result = findInjectableValueId(member); [EOL] assertEquals(String.class.getName(), result); [EOL] }
public void testFindInjectableValueIdWithEmptyValueAndAnnotatedMethod() { [EOL] AnnotatedMethod member = mock(AnnotatedMethod.class); [EOL] JacksonInject inject = mock(JacksonInject.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(inject); [EOL] when(inject.value()).thenReturn(""); [EOL] when(member.getParameterCount()).thenReturn(1); [EOL] when(member.getRawParameterType(0)).thenReturn((Class) Integer.class); [EOL] Object result = findInjectableValueId(member); [EOL] assertEquals(Integer.class.getName(), result); [EOL] }
public void testFindInjectableValueIdWithNonEmptyValue() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JacksonInject inject = mock(JacksonInject.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(inject); [EOL] when(inject.value()).thenReturn("customId"); [EOL] Object result = findInjectableValueId(member); [EOL] assertEquals("customId", result); [EOL] }
public void testFindSubtypesWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSubTypes.class)).thenReturn(null); [EOL] List<NamedType> result = findSubtypes(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSubtypesWithEmptyTypes() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSubTypes jsonSubTypes = mock(JsonSubTypes.class); [EOL] when(annotated.getAnnotation(JsonSubTypes.class)).thenReturn(jsonSubTypes); [EOL] when(jsonSubTypes.value()).thenReturn(new JsonSubTypes.Type[0]); [EOL] List<NamedType> result = findSubtypes(annotated); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindSubtypesWithNonEmptyTypes() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSubTypes jsonSubTypes = mock(JsonSubTypes.class); [EOL] JsonSubTypes.Type typeMock = mock(JsonSubTypes.Type.class); [EOL] when(annotated.getAnnotation(JsonSubTypes.class)).thenReturn(jsonSubTypes); [EOL] when(jsonSubTypes.value()).thenReturn(new JsonSubTypes.Type[]{typeMock}); [EOL] when(typeMock.value()).thenReturn(SomeClass.class); [EOL] when(typeMock.name()).thenReturn("SomeName"); [EOL] List<NamedType> result = findSubtypes(annotated); [EOL] assertEquals(1, result.size()); [EOL] assertEquals(SomeClass.class, result.get(0).getType()); [EOL] assertEquals("SomeName", result.get(0).getName()); [EOL] }
public void testFindKeySerializerWithNonNullAnnotationAndKeyUsing() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyUsing()).thenReturn((Class)CustomKeySerializer.class); [EOL] Class<? extends JsonSerializer<?>> result = findKeySerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomKeySerializer.class, result); [EOL] }
public void testFindKeySerializerWithNonNullAnnotationAndKeyUsingNone() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyUsing()).thenReturn((Class)JsonSerializer.None.class); [EOL] Class<? extends JsonSerializer<?>> result = findKeySerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindKeySerializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Class<? extends JsonSerializer<?>> result = findKeySerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithAnnotationPresentAndSerializerSpecified() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentUsing()).thenReturn((Class)CustomSerializer.class); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomSerializer.class, result); [EOL] }
public void testFindContentSerializerWithAnnotationPresentAndNoSerializerSpecified() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentUsing()).thenReturn((Class)JsonSerializer.None.class); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithNoAnnotationPresent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationInclusionWithJsonInclude() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonInclude.Include defValue = JsonInclude.Include.USE_DEFAULTS; [EOL] JsonInclude inc = mock(JsonInclude.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(inc); [EOL] when(inc.value()).thenReturn(JsonInclude.Include.ALWAYS); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, defValue); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerialize() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonInclude.Include defValue = JsonInclude.Include.USE_DEFAULTS; [EOL] JsonSerialize ann = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(ann); [EOL] when(ann.include()).thenReturn(JsonSerialize.Inclusion.NON_EMPTY); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, defValue); [EOL] assertEquals(JsonInclude.Include.NON_EMPTY, result); [EOL] }
public void testFindSerializationInclusionWithDefault() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonInclude.Include defValue = JsonInclude.Include.USE_DEFAULTS; [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, defValue); [EOL] assertEquals(JsonInclude.Include.USE_DEFAULTS, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonNull() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonInclude.Include defValue = JsonInclude.Include.USE_DEFAULTS; [EOL] JsonSerialize ann = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(ann); [EOL] when(ann.include()).thenReturn(JsonSerialize.Inclusion.NON_NULL); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, defValue); [EOL] assertEquals(JsonInclude.Include.NON_NULL, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonDefault() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonInclude.Include defValue = JsonInclude.Include.USE_DEFAULTS; [EOL] JsonSerialize ann = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(ann); [EOL] when(ann.include()).thenReturn(JsonSerialize.Inclusion.NON_DEFAULT); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, defValue); [EOL] assertEquals(JsonInclude.Include.NON_DEFAULT, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeAlways() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonInclude.Include defValue = JsonInclude.Include.USE_DEFAULTS; [EOL] JsonSerialize ann = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(ann); [EOL] when(ann.include()).thenReturn(JsonSerialize.Inclusion.ALWAYS); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, defValue); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindObjectIdInfoWithNoAnnotation() { [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ann.getAnnotation(JsonIdentityInfo.class)).thenReturn(null); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] ObjectIdInfo result = resolver.findObjectIdInfo(ann); [EOL] assertNull(result); [EOL] }
public void testFindObjectIdInfoWithNoneGenerator() { [EOL] JsonIdentityInfo info = mock(JsonIdentityInfo.class); [EOL] when(info.generator()).thenReturn(ObjectIdGenerators.None.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ann.getAnnotation(JsonIdentityInfo.class)).thenReturn(info); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] ObjectIdInfo result = resolver.findObjectIdInfo(ann); [EOL] assertNull(result); [EOL] }
public void testFindObjectIdInfoWithValidAnnotation() { [EOL] JsonIdentityInfo info = mock(JsonIdentityInfo.class); [EOL] when(info.generator()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(info.property()).thenReturn("id"); [EOL] when(info.scope()).thenReturn(Object.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ann.getAnnotation(JsonIdentityInfo.class)).thenReturn(info); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] ObjectIdInfo result = resolver.findObjectIdInfo(ann); [EOL] assertNotNull(result); [EOL] assertEquals("id", result.getPropertyName()); [EOL] assertEquals(Object.class, result.getScope()); [EOL] assertEquals(ObjectIdGenerators.PropertyGenerator.class, result.getGeneratorType()); [EOL] }
public void testFindObjectReferenceInfoWithNonNullRef() { [EOL] Annotated ann = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(null, null, null, false, null); [EOL] JsonIdentityReference ref = mock(JsonIdentityReference.class); [EOL] when(ann.getAnnotation(JsonIdentityReference.class)).thenReturn(ref); [EOL] when(ref.alwaysAsId()).thenReturn(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectIdInfo result = mapper.findObjectReferenceInfo(ann, objectIdInfo); [EOL] assertNotNull(result); [EOL] assertTrue(result.getAlwaysAsId()); [EOL] }
public void testFindObjectReferenceInfoWithNullRef() { [EOL] Annotated ann = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(null, null, null, false, null); [EOL] when(ann.getAnnotation(JsonIdentityReference.class)).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectIdInfo result = mapper.findObjectReferenceInfo(ann, objectIdInfo); [EOL] assertNotNull(result); [EOL] assertFalse(result.getAlwaysAsId()); [EOL] }
public void testFindSerializationNameWithJsonProperty() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] JsonProperty pann = mock(JsonProperty.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(pann); [EOL] when(pann.value()).thenReturn("testName"); [EOL] String result = findSerializationName(af); [EOL] assertEquals("testName", result); [EOL] }
public void testFindSerializationNameWithJsonSerialize() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonSerialize.class)).thenReturn(true); [EOL] String result = findSerializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindSerializationNameWithJsonView() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonSerialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(true); [EOL] String result = findSerializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindSerializationNameWithNoAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonSerialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] String result = findSerializationName(af); [EOL] assertNull(result); [EOL] }
public void testFindContentDeserializerWithNonNullAnnotationAndNonDefaultDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentUsing()).thenReturn((Class)CustomJsonDeserializer.class); [EOL] Class<? extends JsonDeserializer<?>> result = findContentDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomJsonDeserializer.class, result); [EOL] }
public void testFindContentDeserializerWithNonNullAnnotationAndDefaultDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentUsing()).thenReturn(JsonDeserializer.None.class); [EOL] Class<? extends JsonDeserializer<?>> result = findContentDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends JsonDeserializer<?>> result = findContentDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationKeyTypeWithNonNullAnnotationAndKeyAsNotNoClass() { [EOL] Annotated am = createMockAnnotatedWithJsonDeserializeKeyAs(SomeClass.class); [EOL] JavaType baseKeyType = createMockJavaType(); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNotNull(result); [EOL] assertEquals(SomeClass.class, result); [EOL] } [EOL] public void testFindDeserializationKeyTypeWithNonNullAnnotationAndKeyAsNoClass() { [EOL] Annotated am = createMockAnnotatedWithJsonDeserializeKeyAs(NoClass.class); [EOL] JavaType baseKeyType = createMockJavaType(); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNull(result); [EOL] } [EOL] public void testFindDeserializationKeyTypeWithNullAnnotation() { [EOL] Annotated am = createMockAnnotatedWithNoJsonDeserialize(); [EOL] JavaType baseKeyType = createMockJavaType(); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNull(result); [EOL] }
private Annotated createMockAnnotatedWithJsonDeserializeKeyAs(Class<?> keyAs) { [EOL] Annotated am = mock(Annotated.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(ann.keyAs()).thenReturn(keyAs); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] return am; [EOL] } [EOL] private Annotated createMockAnnotatedWithNoJsonDeserialize() { [EOL] Annotated am = mock(Annotated.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] return am; [EOL] } [EOL] private JavaType createMockJavaType() { [EOL] return mock(JavaType.class); [EOL] }
public void testFindDeserializationContentTypeWithAnnotationPresentAndValidClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseContentType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.contentAs()).thenReturn(String.class); [EOL] Class<?> result = findDeserializationContentType(am, baseContentType); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindDeserializationContentTypeWithAnnotationPresentAndNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseContentType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.contentAs()).thenReturn(NoClass.class); [EOL] Class<?> result = findDeserializationContentType(am, baseContentType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentTypeWithNoAnnotation() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseContentType = mock(JavaType.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<?> result = findDeserializationContentType(am, baseContentType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentConverterWithNonNullAnnotationAndValidConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentConverter()).thenReturn((Class)SomeConverter.class); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNotNull(result); [EOL] assertEquals(SomeConverter.class, result); [EOL] }
public void testFindDeserializationContentConverterWithNonNullAnnotationAndNoneConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentConverter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentConverterWithNullAnnotation() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithJsonProperty() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] JsonProperty pann = mock(JsonProperty.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(pann); [EOL] when(pann.value()).thenReturn("testName"); [EOL] String result = findDeserializationName(af); [EOL] assertEquals("testName", result); [EOL] }
public void testFindDeserializationNameWithOtherAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonDeserialize.class)).thenReturn(true); [EOL] String result = findDeserializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindDeserializationNameWithNoAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonDeserialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonBackReference.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonManagedReference.class)).thenReturn(false); [EOL] String result = findDeserializationName(af); [EOL] assertNull(result); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL] TypeResolverBuilder<?> b; [EOL] JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL] JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL] if (resAnn != null) { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL] } else { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] if (info.use() == JsonTypeInfo.Id.NONE) { [EOL] return _constructNoTypeResolverBuilder(); [EOL] } [EOL] b = _constructStdTypeResolverBuilder(); [EOL] } [EOL] JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL] TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL] if (idRes != null) { [EOL] idRes.init(baseType); [EOL] } [EOL] b = b.init(info.use(), idRes); [EOL] JsonTypeInfo.As inclusion = info.include(); [EOL] if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL] inclusion = JsonTypeInfo.As.PROPERTY; [EOL] } [EOL] b = b.inclusion(inclusion); [EOL] b = b.typeProperty(info.property()); [EOL] Class<?> defaultImpl = info.defaultImpl(); [EOL] if (defaultImpl != JsonTypeInfo.None.class) { [EOL] b = b.defaultImpl(defaultImpl); [EOL] } [EOL] b = b.typeIdVisibility(info.visible()); [EOL] return b; [EOL] }
public void testGetActiveView_WithNonNullView() { [EOL] Class<?> expectedView = SomeViewClass.class; [EOL] ObjectMapper mapper = new ObjectMapper().setConfig(mapper.getSerializationConfig().withView(expectedView)); [EOL] Class<?> actualView = mapper.getSerializationConfig().getActiveView(); [EOL] assertEquals("The active view should be the one that was set", expectedView, actualView); [EOL] }
public void testGetActiveView_WithNullView() { [EOL] ObjectMapper mapper = new ObjectMapper(); // By default, the view is null [EOL] Class<?> actualView = mapper.getSerializationConfig().getActiveView(); [EOL] assertNull("The active view should be null when not set", actualView); [EOL] }
public void testGetTimeZone() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone expectedTimeZone = TimeZone.getDefault(); [EOL] TimeZone actualTimeZone = mapper.getTimeZone(); [EOL] assertEquals(expectedTimeZone, actualTimeZone); [EOL] }
public void testGetArrayBuilders_WhenArrayBuildersIsNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] ArrayBuilders initialArrayBuilders = objectMapper.getSerializationConfig().getArrayBuilders(); [EOL] ArrayBuilders result = objectMapper.getSerializationConfig().getArrayBuilders(); [EOL] assertNotNull(result); [EOL] assertSame(initialArrayBuilders, result); [EOL] }
public void testGetArrayBuilders_WhenArrayBuildersIsNotNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] ArrayBuilders initialArrayBuilders = objectMapper.getSerializationConfig().getArrayBuilders(); [EOL] objectMapper.getSerializationConfig().getArrayBuilders(); [EOL] ArrayBuilders result = objectMapper.getSerializationConfig().getArrayBuilders(); [EOL] assertNotNull(result); [EOL] assertSame(initialArrayBuilders, result); [EOL] }
public void testCloneMethod() { [EOL] YourClass instance = new YourClass(); [EOL] Object clonedInstance = instance.clone(); [EOL] assertSame(instance, clonedInstance); [EOL] }
public void testIsNaturalTypeWithStdHandling_PrimitiveInteger() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Integer.TYPE, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_PrimitiveBoolean() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Boolean.TYPE, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_PrimitiveDouble() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Double.TYPE, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_PrimitiveNonStandard() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Byte.TYPE, serializer); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_NonPrimitiveString() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(String.class, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_NonPrimitiveInteger() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Integer.class, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_NonPrimitiveBoolean() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Boolean.class, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_NonPrimitiveDouble() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Double.class, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_NonPrimitiveNonStandard() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Byte.class, serializer); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_DefaultSerializer() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(String.class, serializer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_NonDefaultSerializer() { [EOL] JsonSerializer<?> serializer = getNonDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(String.class, serializer); [EOL] assertFalse(result); [EOL] } [EOL] private JsonSerializer<?> getDefaultSerializer() { [EOL] return new DefaultSerializer(); [EOL] } [EOL] private JsonSerializer<?> getNonDefaultSerializer() { [EOL] return new NonDefaultSerializer(); [EOL] } [EOL] private boolean isDefaultSerializer(JsonSerializer<?> ser) { [EOL] return ser instanceof DefaultSerializer; [EOL] } [EOL] class DefaultSerializer extends JsonSerializer<Object> { [EOL] } [EOL] class NonDefaultSerializer extends JsonSerializer<Object> { [EOL] }
public void testGetFieldWhenFieldsIsNull() { [EOL] instance._fields = null; [EOL] AnnotatedField result = instance.getField(); [EOL] assertNull(result); [EOL] }
public void testGetFieldWhenFieldsIsNotNullButNoNext() { [EOL] instance._fields = new Linked<>(new AnnotatedField(), null); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(instance._fields.value, result); [EOL] }
public void testGetFieldWhenNextFieldIsSubclass() { [EOL] AnnotatedField field = new AnnotatedField(); [EOL] AnnotatedField nextField = new AnnotatedFieldSubclass(); // Assuming AnnotatedFieldSubclass is a subclass of AnnotatedField [EOL] instance._fields = new Linked<>(field, new Linked<>(nextField, null)); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(nextField, result); [EOL] }
public void testGetFieldWhenNextFieldIsSuperclass() { [EOL] AnnotatedField field = new AnnotatedFieldSubclass(); // Assuming AnnotatedFieldSubclass is a subclass of AnnotatedField [EOL] AnnotatedField nextField = new AnnotatedField(); [EOL] instance._fields = new Linked<>(field, new Linked<>(nextField, null)); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(field, result); [EOL] }
public void testGetFieldWhenMultipleIncompatibleFields() { [EOL] AnnotatedField field = new AnnotatedField(); [EOL] AnnotatedField nextField = new AnnotatedFieldOther(); // Assuming AnnotatedFieldOther is not compatible with AnnotatedField [EOL] instance._fields = new Linked<>(field, new Linked<>(nextField, null)); [EOL] try { [EOL] instance.getField(); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddAllWithNonNullFields() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with non-null _fields [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with non-null _fields [EOL] target.addAll(src); [EOL] assertNotNull(target._fields); [EOL] assertEquals(target._fields, src._fields); [EOL] }
public void testAddAllWithNullFields() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with null _fields [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with null _fields [EOL] target.addAll(src); [EOL] assertNull(target._fields); [EOL] }
public void testAddAllWithNonNullCtorParameters() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with non-null _ctorParameters [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with non-null _ctorParameters [EOL] target.addAll(src); [EOL] assertNotNull(target._ctorParameters); [EOL] assertEquals(target._ctorParameters, src._ctorParameters); [EOL] }
public void testAddAllWithNullCtorParameters() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with null _ctorParameters [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with null _ctorParameters [EOL] target.addAll(src); [EOL] assertNull(target._ctorParameters); [EOL] }
public void testAddAllWithNonNullGetters() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with non-null _getters [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with non-null _getters [EOL] target.addAll(src); [EOL] assertNotNull(target._getters); [EOL] assertEquals(target._getters, src._getters); [EOL] }
public void testAddAllWithNullGetters() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with null _getters [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with null _getters [EOL] target.addAll(src); [EOL] assertNull(target._getters); [EOL] }
public void testAddAllWithNonNullSetters() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with non-null _setters [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with non-null _setters [EOL] target.addAll(src); [EOL] assertNotNull(target._setters); [EOL] assertEquals(target._setters, src._setters); [EOL] }
public void testAddAllWithNullSetters() { [EOL] POJOPropertyBuilder src = new POJOPropertyBuilder(...); // Initialize with null _setters [EOL] POJOPropertyBuilder target = new POJOPropertyBuilder(...); // Initialize with null _setters [EOL] target.addAll(src); [EOL] assertNull(target._setters); [EOL] }
public void testMergeBothChainsNull() { [EOL] Linked<Object> chain1 = null; [EOL] Linked<Object> chain2 = null; [EOL] Linked<Object> result = merge(chain1, chain2); [EOL] assertNull(result); [EOL] }
public void testMergeFirstChainNull() { [EOL] Linked<Object> chain1 = null; [EOL] Linked<Object> chain2 = new Linked<Object>(); [EOL] Linked<Object> result = merge(chain1, chain2); [EOL] assertSame(chain2, result); [EOL] }
public void testMergeSecondChainNull() { [EOL] Linked<Object> chain1 = new Linked<Object>(); [EOL] Linked<Object> chain2 = null; [EOL] Linked<Object> result = merge(chain1, chain2); [EOL] assertSame(chain1, result); [EOL] }
public void testMergeNoChainNull() { [EOL] Linked<Object> chain1 = new Linked<Object>(); [EOL] Linked<Object> chain2 = new Linked<Object>(); [EOL] chain1.append(new Linked<Object>()); [EOL] chain2.append(new Linked<Object>()); [EOL] Linked<Object> result = merge(chain1, chain2); [EOL] assertNotNull(result); [EOL] assertSame(chain1.getTail(), result.getHead()); [EOL] }
public void testWithNextSameInstance() { [EOL] Linked<Object> original = new Linked<>(null, null, null, false, false); [EOL] Linked<Object> result = original.withNext(null); [EOL] assertSame(original, result); [EOL] }
public void testWithNextDifferentInstance() { [EOL] Linked<Object> original = new Linked<>(null, null, null, false, false); [EOL] Linked<Object> newNext = new Linked<>(null, null, null, false, false); [EOL] Linked<Object> result = original.withNext(newNext); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(newNext, result.next); [EOL] }
public void testAppendWhenNextIsNull() { [EOL] Linked<Object> initial = new Linked<>(null, null, false); [EOL] Linked<Object> appendable = new Linked<>(null, null, false); [EOL] Linked<Object> result = initial.append(appendable); [EOL] assertSame(appendable, result.getNext()); [EOL] }
public void testAppendWhenNextIsNotNull() { [EOL] Linked<Object> next = new Linked<>(null, null, false); [EOL] Linked<Object> initial = new Linked<>(next, null, false); [EOL] Linked<Object> appendable = new Linked<>(null, null, false); [EOL] Linked<Object> result = initial.append(appendable); [EOL] assertSame(next, result.getNext().getNext()); [EOL] }
public void testTrimByVisibilityWithNextNull() { [EOL] Linked<Object> linked = new Linked<>(null, null, null, false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertSame(linked, result); [EOL] }
public void testTrimByVisibilityWithNonNullNextAndExplicitName() { [EOL] Linked<Object> next = new Linked<>(null, null, "nextName", false); [EOL] Linked<Object> linked = new Linked<>(next, null, "explicitName", false); [EOL] Linked<Object> trimmedNext = next.trimByVisibility(); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNotNull(result.getNext()); [EOL] assertEquals("explicitName", result.getExplicitName()); [EOL] }
public void testTrimByVisibilityWithNonNullNextAndNoExplicitName() { [EOL] Linked<Object> next = new Linked<>(null, null, null, false); [EOL] Linked<Object> linked = new Linked<>(next, null, null, false); [EOL] Linked<Object> trimmedNext = next.trimByVisibility(); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNull(result.getExplicitName()); [EOL] assertNull(result.getNext()); [EOL] }
public void testTrimByVisibilityWithVisibilityMismatch() { [EOL] Linked<Object> next = new Linked<>(null, null, null, true); [EOL] Linked<Object> linked = new Linked<>(next, null, null, false); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNotSame(linked, result); [EOL] assertTrue(result.isVisible()); [EOL] }
public void testTrimByVisibilityWithVisibilityMatch() { [EOL] Linked<Object> next = new Linked<>(null, null, null, true); [EOL] Linked<Object> linked = new Linked<>(next, null, null, true); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertSame(linked.getNext(), result.getNext()); [EOL] assertTrue(result.isVisible()); [EOL] }
public void testNullSerializerConstructor() throws Exception { [EOL] Constructor<NullSerializer> constructor = NullSerializer.class.getDeclaredConstructor(); [EOL] constructor.setAccessible(true); [EOL] NullSerializer instance = constructor.newInstance(); [EOL] assertNotNull(instance); [EOL] assertTrue(instance.getClass() == NullSerializer.class); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new TestSerializer().serialize(null, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNull(); [EOL] }
public void testIsMissingNode_WhenNodeTypeIsMissing_ShouldReturnTrue() { [EOL] JsonNode node = JsonNodeFactory.instance.missingNode(); [EOL] boolean result = node.isMissingNode(); [EOL] assert result; [EOL] }
public void testIsMissingNode_WhenNodeTypeIsNotMissing_ShouldReturnFalse() { [EOL] JsonNode node = JsonNodeFactory.instance.objectNode(); [EOL] boolean result = node.isMissingNode(); [EOL] assert !result; [EOL] }
public void testIsPojo_NodeTypeIsPojo() { [EOL] JsonNode node = mock(JsonNode.class); [EOL] when(node.getNodeType()).thenReturn(JsonNodeType.POJO); [EOL] assertTrue(node.isPojo()); [EOL] }
public void testIsPojo_NodeTypeIsNotPojo() { [EOL] JsonNode node = mock(JsonNode.class); [EOL] when(node.getNodeType()).thenReturn(JsonNodeType.ARRAY); // Use a different JsonNodeType for negative case [EOL] assertFalse(node.isPojo()); [EOL] }
public void testIsLong() { [EOL] JsonNode node = new TextNode("test"); [EOL] assertFalse(node.isLong()); [EOL] }
public boolean isDouble() { [EOL] return false; [EOL] }
public void testIsNullWithNullNode() { [EOL] JsonNode nullNode = JsonNodeFactory.instance.nullNode(); [EOL] assertTrue(nullNode.isNull()); [EOL] }
public void testIsNullWithNonNullNode() { [EOL] JsonNode stringNode = JsonNodeFactory.instance.textNode("text"); [EOL] assertFalse(stringNode.isNull()); [EOL] }
public void testTextValueReturnsNull() { [EOL] JsonNode node = new TextNode(null); [EOL] String result = node.textValue(); [EOL] assertNull(result); [EOL] }
public void testThrowAsIAEWithNullExceptionMessage() { [EOL] Exception e = new Exception((String) null); [EOL] try { [EOL] JacksonDatabindUtils.throwAsIAE(e); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertNull(iae.getMessage()); [EOL] } [EOL] }
public void testThrowAsIAEWithNonNullExceptionMessage() { [EOL] Exception e = new Exception("Error message"); [EOL] try { [EOL] JacksonDatabindUtils.throwAsIAE(e); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Error message", iae.getMessage()); [EOL] } [EOL] }
public void testUnwrapAndThrowAsIAEWithIAE() { [EOL] IllegalArgumentException iae = new IllegalArgumentException("Test exception"); [EOL] try { [EOL] ExceptionUtil.unwrapAndThrowAsIAE(iae); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Test exception", e.getMessage()); [EOL] } [EOL] }
public void testUnwrapAndThrowAsIAEWithNonIAE() { [EOL] Exception e = new Exception("Root cause"); [EOL] try { [EOL] ExceptionUtil.unwrapAndThrowAsIAE(e); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Root cause", iae.getCause().getMessage()); [EOL] } [EOL] }
public void testUnwrapAndThrowAsIAEWithNestedIAE() { [EOL] IllegalArgumentException nestedIae = new IllegalArgumentException("Nested IAE"); [EOL] RuntimeException re = new RuntimeException(nestedIae); [EOL] try { [EOL] ExceptionUtil.unwrapAndThrowAsIAE(re); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Nested IAE", iae.getMessage()); [EOL] } [EOL] }
public void testFindEnumTypeWithNonEmptyEnumMap() { [EOL] EnumMap<TimeUnit, String> enumMap = new EnumMap<>(TimeUnit.class); [EOL] enumMap.put(TimeUnit.SECONDS, "Seconds"); [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(enumMap); [EOL] assertEquals(TimeUnit.class, result); [EOL] } [EOL] public void testFindEnumTypeWithEmptyEnumMap() { [EOL] EnumMap<TimeUnit, String> enumMap = new EnumMap<>(TimeUnit.class); [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(enumMap); [EOL] assertNotNull(result); [EOL] }
public void testFindEnumTypeWithEnumClass() { [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(SomeEnum.class); [EOL] assertEquals(SomeEnum.class, result); [EOL] }
public void testFindEnumTypeWithSubclassOfEnum() { [EOL] Class<? extends Enum<?>> result = JacksonDatabindUtils.findEnumType(SomeEnumSubclass.class); [EOL] assertEquals(SomeEnum.class, result); [EOL] }
protected TypeNameIdResolver(MapperConfig<?> config, JavaType baseType, HashMap<String, String> typeToId, HashMap<String, JavaType> idToType) { [EOL] super(baseType, config.getTypeFactory()); [EOL] _config = config; [EOL] _typeToId = typeToId; [EOL] _idToType = idToType; [EOL] }
public void testConstructWithIllegalArguments() { [EOL] MapperConfig<?> config = null; // Assuming we have a mock or a concrete implementation [EOL] JavaType baseType = null; // Assuming we have a mock or a concrete implementation [EOL] Collection<NamedType> subtypes = null; // Assuming we have a mock or a concrete implementation [EOL] try { [EOL] TypeNameIdResolver.construct(config, baseType, subtypes, true, true); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] TypeNameIdResolver.construct(config, baseType, subtypes, false, false); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructForSerialization() { [EOL] MapperConfig<?> config = null; // Assuming we have a mock or a concrete implementation [EOL] JavaType baseType = null; // Assuming we have a mock or a concrete implementation [EOL] Collection<NamedType> subtypes = new ArrayList<>(); // Assuming we have a mock or a concrete implementation [EOL] subtypes.add(new NamedType(String.class, "String")); [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, true, false); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructForDeserialization() { [EOL] MapperConfig<?> config = null; // Assuming we have a mock or a concrete implementation [EOL] JavaType baseType = null; // Assuming we have a mock or a concrete implementation [EOL] Collection<NamedType> subtypes = new ArrayList<>(); // Assuming we have a mock or a concrete implementation [EOL] subtypes.add(new NamedType(String.class, "String")); [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, false, true); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructWithSubtypesForDeserialization() { [EOL] MapperConfig<?> config = null; // Assuming we have a mock or a concrete implementation [EOL] JavaType baseType = null; // Assuming we have a mock or a concrete implementation [EOL] Collection<NamedType> subtypes = new ArrayList<>(); // Assuming we have a mock or a concrete implementation [EOL] subtypes.add(new NamedType(String.class, "String")); [EOL] subtypes.add(new NamedType(Integer.class, "Integer")); [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, false, true); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructWithSubtypesForSerialization() { [EOL] MapperConfig<?> config = null; // Assuming we have a mock or a concrete implementation [EOL] JavaType baseType = null; // Assuming we have a mock or a concrete implementation [EOL] Collection<NamedType> subtypes = new ArrayList<>(); // Assuming we have a mock or a concrete implementation [EOL] subtypes.add(new NamedType(String.class, "String")); [EOL] subtypes.add(new NamedType(Integer.class, "Integer")); [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(config, baseType, subtypes, true, false); [EOL] assertNotNull(resolver); [EOL] }
public void testIdFromValueWithCachedName() { [EOL] Object value = new Object(); [EOL] String expectedName = "CachedName"; [EOL] _typeToId.put(value.getClass().getName(), expectedName); [EOL] String actualName = idFromValue(value); [EOL] assertEquals(expectedName, actualName); [EOL] }
public void testIdFromValueWithAnnotationProcessingEnabledAndNameFound() { [EOL] Object value = new Object(); [EOL] String expectedName = "AnnotatedName"; [EOL] when(_config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(_config.introspectClassAnnotations(value.getClass())).thenReturn(beanDesc); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(_config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findTypeName(any(ClassInfo.class))).thenReturn(expectedName); [EOL] String actualName = idFromValue(value); [EOL] assertEquals(expectedName, actualName); [EOL] }
public void testIdFromValueWithAnnotationProcessingEnabledAndNameNotFound() { [EOL] Object value = new Object(); [EOL] String expectedName = "DefaultName"; [EOL] when(_config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(_config.introspectClassAnnotations(value.getClass())).thenReturn(beanDesc); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(_config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findTypeName(any(ClassInfo.class))).thenReturn(null); [EOL] when(_defaultTypeId(value.getClass())).thenReturn(expectedName); [EOL] String actualName = idFromValue(value); [EOL] assertEquals(expectedName, actualName); [EOL] }
public void testIdFromValueWithAnnotationProcessingDisabled() { [EOL] Object value = new Object(); [EOL] String expectedName = "DefaultName"; [EOL] when(_config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(_defaultTypeId(value.getClass())).thenReturn(expectedName); [EOL] String actualName = idFromValue(value); [EOL] assertEquals(expectedName, actualName); [EOL] }
public void testTypeFromIdWithExistingId() { [EOL] String existingId = "someExistingId"; [EOL] JavaType expectedType = _idToType.get(existingId); [EOL] JavaType resultType = typeFromId(existingId); [EOL] assertNotNull(resultType); [EOL] assertEquals(expectedType, resultType); [EOL] }
public void testTypeFromIdWithNonExistingId() { [EOL] String nonExistingId = "someNonExistingId"; [EOL] JavaType resultType = typeFromId(nonExistingId); [EOL] assertNull(resultType); [EOL] }
public void testDefaultTypeIdWithNoPackage() { [EOL] String result = YourClass._defaultTypeId(SomeClassWithoutPackage.class); [EOL] assertEquals("SomeClassWithoutPackage", result); [EOL] }
public void testDefaultTypeIdWithPackage() { [EOL] String result = YourClass._defaultTypeId(SomeClassWithPackage.class); [EOL] assertEquals("SomeClassWithPackage", result); [EOL] }
public void testWithTypeHandlerNonNull() { [EOL] CollectionType originalType = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] Object typeHandler = new Object(); [EOL] CollectionType newType = originalType.withTypeHandler(typeHandler); [EOL] assertNotNull(newType); [EOL] assertNotSame(originalType, newType); [EOL] assertSame(typeHandler, newType.getTypeHandler()); [EOL] assertSame(Collection.class, newType.getRawClass()); [EOL] assertSame(SimpleType.constructUnsafe(String.class), newType.getContentType()); [EOL] }
public void testWithTypeHandlerNull() { [EOL] CollectionType originalType = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] CollectionType newType = originalType.withTypeHandler(null); [EOL] assertNotNull(newType); [EOL] assertNotSame(originalType, newType); [EOL] assertNull(newType.getTypeHandler()); [EOL] assertSame(Collection.class, newType.getRawClass()); [EOL] assertSame(SimpleType.constructUnsafe(String.class), newType.getContentType()); [EOL] }
public void testSerializeWithTypeEmptyEnumMap() throws IOException { [EOL] EnumMap<AnEnum, String> enumMap = new EnumMap<>(AnEnum.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] EnumMapSerializer serializer = new EnumMapSerializer(null, false, null); [EOL] serializer.serializeWithType(enumMap, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(enumMap, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(enumMap, jgen); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithTypeNonEmptyEnumMap() throws IOException { [EOL] EnumMap<AnEnum, String> enumMap = new EnumMap<>(AnEnum.class); [EOL] enumMap.put(AnEnum.VALUE1, "value1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] EnumMapSerializer serializer = new EnumMapSerializer(null, false, null); [EOL] serializer.serializeWithType(enumMap, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(enumMap, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(enumMap, jgen); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeString(anyString()); [EOL] }
public void testFindCollectionSerializerWithNonNullTypeSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = CollectionType.construct(ArrayList.class, SimpleType.construct(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<Object>(); [EOL] JsonSerializer<?> result = findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testFindCollectionSerializerWithNullTypeSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = CollectionType.construct(ArrayList.class, SimpleType.construct(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> result = findCollectionSerializer(config, type, beanDesc, null, null); [EOL] assertNotNull(result); [EOL] }
public void testAsArraySerializerBaseWithStaticTyping() { [EOL] Class<?> cls = Object.class; [EOL] JavaType et = mock(JavaType.class); [EOL] boolean staticTyping = true; [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AsArraySerializerBase serializer = new AsArraySerializerBase(cls, et, staticTyping, vts, property, elementSerializer); [EOL] assertNotNull(serializer); [EOL] assertEquals(et, serializer._elementType); [EOL] assertTrue(serializer._staticTyping); [EOL] assertEquals(vts, serializer._valueTypeSerializer); [EOL] assertEquals(property, serializer._property); [EOL] assertEquals(elementSerializer, serializer._elementSerializer); [EOL] assertNotNull(serializer._dynamicSerializers); [EOL] }
public void testAsArraySerializerBaseWithoutStaticTypingButFinalElementType() { [EOL] Class<?> cls = Object.class; [EOL] JavaType et = mock(JavaType.class); [EOL] when(et.isFinal()).thenReturn(true); [EOL] boolean staticTyping = false; [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AsArraySerializerBase serializer = new AsArraySerializerBase(cls, et, staticTyping, vts, property, elementSerializer); [EOL] assertNotNull(serializer); [EOL] assertEquals(et, serializer._elementType); [EOL] assertTrue(serializer._staticTyping); // Should be true because et.isFinal() is true [EOL] assertEquals(vts, serializer._valueTypeSerializer); [EOL] assertEquals(property, serializer._property); [EOL] assertEquals(elementSerializer, serializer._elementSerializer); [EOL] assertNotNull(serializer._dynamicSerializers); [EOL] }
public void testAsArraySerializerBaseWithoutStaticTypingAndNonFinalElementType() { [EOL] Class<?> cls = Object.class; [EOL] JavaType et = mock(JavaType.class); [EOL] when(et.isFinal()).thenReturn(false); [EOL] boolean staticTyping = false; [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AsArraySerializerBase serializer = new AsArraySerializerBase(cls, et, staticTyping, vts, property, elementSerializer); [EOL] assertNotNull(serializer); [EOL] assertEquals(et, serializer._elementType); [EOL] assertFalse(serializer._staticTyping); // Should be false because staticTyping is false and et.isFinal() is false [EOL] assertEquals(vts, serializer._valueTypeSerializer); [EOL] assertEquals(property, serializer._property); [EOL] assertEquals(elementSerializer, serializer._elementSerializer); [EOL] assertNotNull(serializer._dynamicSerializers); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyButNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(_staticTyping).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithContentTypeAnnotation() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(hasContentTypeAnnotation(provider, property)).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNonContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> nonContextualSerializer = mock(JsonSerializer.class); [EOL] when(_elementSerializer).thenReturn(nonContextualSerializer); [EOL] when(findConvertingContentSerializer(provider, property, nonContextualSerializer)).thenReturn(nonContextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<Object> newSerializer = mock(JsonSerializer.class); [EOL] when(_elementSerializer).thenReturn(contextualSerializer); [EOL] when(findConvertingContentSerializer(provider, property, contextualSerializer)).thenReturn(contextualSerializer); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(newSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testSerializeWithSingleElementArrayUnwrapped() throws IOException { [EOL] T value = createSingleElementValue(); // Implement this method to create a single element value [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verifySerializeContentsCalled(value, jgen, provider); // Implement this method to verify serializeContents was called [EOL] }
public void testSerializeWithNonSingleElementArray() throws IOException { [EOL] T value = createNonSingleElementValue(); // Implement this method to create a non-single element value [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verifySerializeContentsCalled(value, jgen, provider); // Implement this method to verify serializeContents was called [EOL] }
public void testSerializeWithSingleElementArrayWrapped() throws IOException { [EOL] T value = createSingleElementValue(); // Implement this method to create a single element value [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verifySerializeContentsCalled(value, jgen, provider); // Implement this method to verify serializeContents was called [EOL] }
public void testDeserializationConfigWithView() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(); [EOL] Class<?> viewClass = String.class; [EOL] DeserializationConfig newConfig = new DeserializationConfig(originalConfig, viewClass); [EOL] assertNotNull(newConfig); [EOL] assertEquals(viewClass, newConfig.getActiveView()); [EOL] assertEquals(originalConfig.getDeserializationFeatures(), newConfig.getDeserializationFeatures()); [EOL] assertEquals(originalConfig.getNodeFactory(), newConfig.getNodeFactory()); [EOL] assertEquals(originalConfig.getProblemHandlers(), newConfig.getProblemHandlers()); [EOL] }

public void testWithClassIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ClassIntrospector ci = new MyClassIntrospector(); // Assuming MyClassIntrospector is a valid implementation of ClassIntrospector [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = originalConfig.with(ci); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertSame(ci, newConfig.getClassIntrospector()); [EOL] }
public void testWithVisibilityCheckerNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> originalVC = mapper.getDeserializationConfig().getDefaultVisibilityChecker(); [EOL] VisibilityChecker<?> newVC = originalVC.with(JsonAutoDetect.Visibility.NONE); [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = originalConfig.with(newVC); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertEquals(newVC, newConfig.getDefaultVisibilityChecker()); [EOL] }
public void testWithVisibilityCheckerNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] try { [EOL] originalConfig.with((VisibilityChecker<?>) null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithVisibility_NewVisibility() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = originalConfig.withVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertEquals(JsonAutoDetect.Visibility.ANY, newConfig.getDefaultVisibilityChecker().findFieldVisibility(Field.class)); [EOL] }
public void testWithVisibility_SameVisibility() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] JsonAutoDetect.Visibility originalVisibility = originalConfig.getDefaultVisibilityChecker().findFieldVisibility(Field.class); [EOL] DeserializationConfig newConfig = originalConfig.withVisibility(PropertyAccessor.FIELD, originalVisibility); [EOL] assertNotNull(newConfig); [EOL] assertSame(originalConfig, newConfig); [EOL] }
public void testWithNewTypeFactory() { [EOL] TypeFactory typeFactory = new TypeFactory(); [EOL] DeserializationConfig originalConfig = new DeserializationConfig(); [EOL] DeserializationConfig newConfig = originalConfig.with(typeFactory); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertEquals(typeFactory, newConfig.getTypeFactory()); [EOL] }
public void testWithNullDateFormat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = config.with(null); [EOL] assertNull(newConfig.getDateFormat()); [EOL] }
public void testWithNonNullDateFormat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); [EOL] DeserializationConfig newConfig = config.with(df); [EOL] assertEquals(df, newConfig.getDateFormat()); [EOL] }
public void testWithView_SameView() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] Class<?> viewClass = SomeViewClass.class; // Replace with actual view class [EOL] config = config.withView(viewClass); // Set the initial view [EOL] DeserializationConfig newConfig = config.withView(viewClass); // Try to set the same view again [EOL] assertSame("Should return the same config object for the same view", config, newConfig); [EOL] }
public void testWithView_DifferentView() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] Class<?> viewClass1 = SomeViewClass.class; // Replace with actual view class [EOL] Class<?> viewClass2 = AnotherViewClass.class; // Replace with another view class [EOL] config = config.withView(viewClass1); // Set the initial view [EOL] DeserializationConfig newConfig = config.withView(viewClass2); // Try to set a different view [EOL] assertNotSame("Should return a new config object for a different view", config, newConfig); [EOL] }
public void testWithTimeZoneNull() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization parameters [EOL] TimeZone tz = null; [EOL] DeserializationConfig newConfig = config.with(tz); [EOL] assertNotNull(newConfig); [EOL] assertNull(newConfig.getTimeZone()); [EOL] }
public void testWithTimeZoneNonNull() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization parameters [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DeserializationConfig newConfig = config.with(tz); [EOL] assertNotNull(newConfig); [EOL] assertEquals(tz, newConfig.getTimeZone()); [EOL] }
public void testWithSameJsonNodeFactory() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(true); [EOL] DeserializationConfig config = new DeserializationConfig(...); // Assuming constructor and other necessary setup [EOL] config = config.with(factory); [EOL] DeserializationConfig newConfig = config.with(factory); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithDifferentJsonNodeFactory() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(true); [EOL] JsonNodeFactory anotherFactory = new JsonNodeFactory(false); [EOL] DeserializationConfig config = new DeserializationConfig(...); // Assuming constructor and other necessary setup [EOL] DeserializationConfig newConfig = config.with(anotherFactory); [EOL] assertNotSame(config, newConfig); [EOL] assertSame(anotherFactory, newConfig.getNodeFactory()); [EOL] }
public void testSizeWhenAnnotationsAreNull() { [EOL] AnnotationMap annotationMap = new AnnotationMap(); [EOL] int size = annotationMap.size(); [EOL] assert size == 0; [EOL] }
public void testSizeWhenAnnotationsAreNotEmpty() { [EOL] AnnotationMap annotationMap = new AnnotationMap(); [EOL] annotationMap.add(null, new SomeAnnotation()); [EOL] int size = annotationMap.size(); [EOL] assert size == 1; [EOL] }
public void testForPropertySameProperty() { [EOL] AsArrayTypeDeserializer original = new AsArrayTypeDeserializer(); [EOL] BeanProperty sameProperty = original.getProperty(); [EOL] TypeDeserializer result = original.forProperty(sameProperty); [EOL] assertSame(original, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] AsArrayTypeDeserializer original = new AsArrayTypeDeserializer(); [EOL] BeanProperty differentProperty = new SomeBeanPropertyImplementation(); [EOL] TypeDeserializer result = original.forProperty(differentProperty); [EOL] assertNotSame(original, result); [EOL] assertTrue(result instanceof AsArrayTypeDeserializer); [EOL] }
public void testGetTypeInclusion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonTypeInfo info = mapper.getSerializationConfig().getDefaultPropertyInclusion().getValueInclusion(); [EOL] As inclusionType = info.getTypeInclusion(); [EOL] assertEquals(As.WRAPPER_ARRAY, inclusionType); [EOL] }
public void testDeserializeTypedFromArrayWithValidInput() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expectedResult = new Object(); [EOL] TypedArrayDeserializer deserializer = new TypedArrayDeserializer(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenReturn(expectedResult); [EOL] Object result = deserializer.deserializeTypedFromArray(jp, ctxt); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testDeserializeTypedFromArrayWithIOException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypedArrayDeserializer deserializer = new TypedArrayDeserializer(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] assertThrows(IOException.class, () -> { [EOL] deserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeTypedFromArrayWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypedArrayDeserializer deserializer = new TypedArrayDeserializer(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] deserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeTypedFromObject() throws IOException, JsonProcessingException { [EOL] MyTypedDeserializer deserializer = new MyTypedDeserializer(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expected = new Object(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializer.deserializeTypedFromObject(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(ctxt.wrongTokenException(any(JsonParser.class), any(JsonToken.class), anyString())).thenThrow(JsonProcessingException.class); [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] try { [EOL] _deserialize(jp, ctxt); [EOL] } catch (JsonProcessingException e) { [EOL] fail("No exception should be thrown"); [EOL] } [EOL] }
public void testDeserializeWithoutStartArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeIdVisible() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] _typeIdVisible = true; [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithWrongEndArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); // Simulate wrong token [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] assertThrows(JsonProcessingException.class, () -> _deserialize(jp, ctxt)); [EOL] }
public void testTokenBufferSerializerConstructor() { [EOL] TokenBufferSerializer serializer = new TokenBufferSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(TokenBuffer.class, serializer.handledType()); [EOL] }
public void testSerializeWithNonNullValueAndGenerator() throws IOException { [EOL] TokenBuffer value = new TokenBuffer(null, false); // Assuming TokenBuffer has a constructor that takes ObjectMapper and boolean [EOL] JsonGenerator jgen = mock(JsonGenerator.class); // Mocking JsonGenerator [EOL] SerializerProvider provider = mock(SerializerProvider.class); // Mocking SerializerProvider [EOL] value.serialize(jgen); // Call the method to ensure it's covered [EOL] verify(value).serialize(jgen); // Verify the serialize method was called on value with jgen [EOL] }
public void testSerializeWithNullValueShouldNotThrowException() throws IOException { [EOL] TokenBuffer value = null; // Null value for TokenBuffer [EOL] JsonGenerator jgen = mock(JsonGenerator.class); // Mocking JsonGenerator [EOL] SerializerProvider provider = mock(SerializerProvider.class); // Mocking SerializerProvider [EOL] try { [EOL] new TokenBufferSerializer().serialize(value, jgen, provider); // Call serialize with null value [EOL] } catch (Exception e) { [EOL] fail("Serializing null value should not throw exception"); [EOL] } [EOL] }
public void testSerializeWithType_NullValues() throws IOException { [EOL] TokenBuffer value = null; [EOL] JsonGenerator jgen = null; [EOL] SerializerProvider provider = null; [EOL] TypeSerializer typeSer = null; [EOL] try { [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] fail("Expected exception due to null values."); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSerializeWithType_ValidValues() throws IOException { [EOL] TokenBuffer value = new TokenBuffer(null, false); [EOL] JsonGenerator jgen = new JsonFactory().createGenerator(new StringWriter()); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] TypeSerializer typeSer = new StdTypeSerializer(); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] }
public void testGetBlueprintISO8601Format() { [EOL] DateFormat df = StdDateFormat.getBlueprintISO8601Format(); [EOL] assertNotNull(df); [EOL] }
public void testStdDateFormatConstructors() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] assertNotNull(stdDateFormat); [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] StdDateFormat stdDateFormatWithTz = new StdDateFormat(tz); [EOL] assertNotNull(stdDateFormatWithTz); [EOL] }
public void testGetDefaultTimeZone() { [EOL] TimeZone tz = StdDateFormat.getDefaultTimeZone(); [EOL] assertNotNull(tz); [EOL] }
public void testWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat stdDateFormatWithTz = stdDateFormat.withTimeZone(tz); [EOL] assertNotNull(stdDateFormatWithTz); [EOL] }
public void testClone() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat cloned = stdDateFormat.clone(); [EOL] assertNotNull(cloned); [EOL] }
public void testGetISO8601Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat df = StdDateFormat.getISO8601Format(tz); [EOL] assertNotNull(df); [EOL] }
public void testGetBlueprintRFC1123Format() { [EOL] DateFormat df = StdDateFormat.getBlueprintRFC1123Format(); [EOL] assertNotNull(df); [EOL] }
public void testGetRFC1123Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat df = StdDateFormat.getRFC1123Format(tz); [EOL] assertNotNull(df); [EOL] }
public void testSetTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] stdDateFormat.setTimeZone(tz); [EOL] }
public void testParseString() throws ParseException { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] Date date = stdDateFormat.parse(dateStr); [EOL] assertNotNull(date); [EOL] }
public void testParseStringParsePosition() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = stdDateFormat.parse(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer formatted = stdDateFormat.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(formatted); [EOL] }
public void testLooksLikeISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(dateStr); [EOL] assertTrue(result); [EOL] }
public void testParseAsISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = stdDateFormat.parseAsISO8601(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testParseAsRFC1123() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "Sat, 01 Apr 2023 12:00:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = stdDateFormat.parseAsRFC1123(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testHasTimeZone() { [EOL] String dateStr = "2023-04-01T12:00:00.000+0000"; [EOL] boolean result = StdDateFormat.hasTimeZone(dateStr); [EOL] assertTrue(result); [EOL] }
public void testCloneFormat() { [EOL] DateFormat df = new SimpleDateFormat(); [EOL] DateFormat clonedDf = StdDateFormat._cloneFormat(df); [EOL] assertNotNull(clonedDf); [EOL] }
public void testCloneFormatWithTimeZone() { [EOL] DateFormat df = new SimpleDateFormat(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat clonedDfWithTz = StdDateFormat._cloneFormat(df, tz); [EOL] assertNotNull(clonedDfWithTz); [EOL] }
public void testGetISO8601FormatWithNullTimeZone() { [EOL] DateFormat format = StdDateFormat.getISO8601Format(null); [EOL] assertNotNull(format); [EOL] } [EOL] public void testGetISO8601FormatWithNonNullTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat format = StdDateFormat.getISO8601Format(tz); [EOL] assertNotNull(format); [EOL] assertEquals(tz, format.getTimeZone()); [EOL] }
public void testGetISO8601FormatWithDefaultTimeZone() { [EOL] TimeZone defaultTZ = StdDateFormat.getDefaultTimeZone(); [EOL] DateFormat format = StdDateFormat.getISO8601Format(defaultTZ); [EOL] assertNotNull(format); [EOL] assertEquals(defaultTZ, format.getTimeZone()); [EOL] }
public void testGetBlueprintRFC1123Format() { [EOL] DateFormat df = StdDateFormat.getBlueprintRFC1123Format(); [EOL] assertNotNull(df); [EOL] }
public void testStdDateFormatConstructors() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] assertNotNull(stdDateFormat); [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] StdDateFormat stdDateFormatWithTz = new StdDateFormat(tz); [EOL] assertNotNull(stdDateFormatWithTz); [EOL] }
public void testGetDefaultTimeZone() { [EOL] TimeZone tz = StdDateFormat.getDefaultTimeZone(); [EOL] assertNotNull(tz); [EOL] }
public void testWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat stdDateFormatWithTz = stdDateFormat.withTimeZone(tz); [EOL] assertNotNull(stdDateFormatWithTz); [EOL] }
public void testClone() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat cloned = stdDateFormat.clone(); [EOL] assertNotNull(cloned); [EOL] }
public void testGetBlueprintISO8601Format() { [EOL] DateFormat df = StdDateFormat.getBlueprintISO8601Format(); [EOL] assertNotNull(df); [EOL] }
public void testGetISO8601Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat df = StdDateFormat.getISO8601Format(tz); [EOL] assertNotNull(df); [EOL] }
public void testGetRFC1123Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat df = StdDateFormat.getRFC1123Format(tz); [EOL] assertNotNull(df); [EOL] }
public void testSetTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] stdDateFormat.setTimeZone(tz); [EOL] }
public void testParseString() throws ParseException { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] Date date = stdDateFormat.parse(dateStr); [EOL] assertNotNull(date); [EOL] }
public void testParseStringParsePosition() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = stdDateFormat.parse(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer formatted = stdDateFormat.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(formatted); [EOL] }
public void testLooksLikeISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] boolean looksLikeISO8601 = stdDateFormat.looksLikeISO8601(dateStr); [EOL] assertTrue(looksLikeISO8601); [EOL] }
public void testParseAsISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = stdDateFormat.parseAsISO8601(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testParseAsRFC1123() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "Fri, 01 Apr 2023 12:00:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = stdDateFormat.parseAsRFC1123(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testHasTimeZone() { [EOL] String dateStr = "2023-04-01T12:00:00.000+0000"; [EOL] boolean hasTimeZone = StdDateFormat.hasTimeZone(dateStr); [EOL] assertTrue(hasTimeZone); [EOL] }
public void testCloneFormat() { [EOL] DateFormat df = new SimpleDateFormat(); [EOL] DateFormat clonedDf = StdDateFormat._cloneFormat(df); [EOL] assertNotNull(clonedDf); [EOL] }
public void testCloneFormatWithTimeZone() { [EOL] DateFormat df = new SimpleDateFormat(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat clonedDf = StdDateFormat._cloneFormat(df, tz); [EOL] assertNotNull(clonedDf); [EOL] }
public void testGetRFC1123FormatWithNullTimeZone() { [EOL] DateFormat format = StdDateFormat.getRFC1123Format(null); [EOL] assertNotNull(format); [EOL] }
public void testGetRFC1123FormatWithNonNullTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] DateFormat format = StdDateFormat.getRFC1123Format(tz); [EOL] assertNotNull(format); [EOL] assertEquals(tz, format.getTimeZone()); [EOL] }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL] int len = dateStr.length(); [EOL] char c = dateStr.charAt(len - 1); [EOL] DateFormat df; [EOL] if (len <= 10 && Character.isDigit(c)) { [EOL] df = _formatPlain; [EOL] if (df == null) { [EOL] df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL] } [EOL] } else if (c == 'Z') { [EOL] df = _formatISO8601_z; [EOL] if (df == null) { [EOL] df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL] } [EOL] if (dateStr.charAt(len - 4) == ':') { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.insert(len - 1, ".000"); [EOL] dateStr = sb.toString(); [EOL] } [EOL] } else { [EOL] if (hasTimeZone(dateStr)) { [EOL] c = dateStr.charAt(len - 3); [EOL] if (c == ':') { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.delete(len - 3, len - 2); [EOL] dateStr = sb.toString(); [EOL] } else if (c == '+' || c == '-') { [EOL] dateStr += "00"; [EOL] } [EOL] len = dateStr.length(); [EOL] c = dateStr.charAt(len - 9); [EOL] if (Character.isDigit(c)) { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.insert(len - 5, ".000"); [EOL] dateStr = sb.toString(); [EOL] } [EOL] df = _formatISO8601; [EOL] if (_formatISO8601 == null) { [EOL] df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL] } [EOL] } else { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL] if (timeLen <= 8) { [EOL] sb.append(".000"); [EOL] } [EOL] sb.append('Z'); [EOL] dateStr = sb.toString(); [EOL] df = _formatISO8601_z; [EOL] if (df == null) { [EOL] df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL] } [EOL] } [EOL] } [EOL] return df.parse(dateStr, pos); [EOL] } [EOL] public StdDateFormat(); [EOL] public StdDateFormat(TimeZone tz); [EOL] public static TimeZone getDefaultTimeZone(); [EOL] public StdDateFormat withTimeZone(TimeZone tz); [EOL] public StdDateFormat clone(); [EOL] public static DateFormat getBlueprintISO8601Format(); [EOL] public static DateFormat getISO8601Format(TimeZone tz); [EOL] public static DateFormat getBlueprintRFC1123Format(); [EOL] public static DateFormat getRFC1123Format(TimeZone tz); [EOL] public void setTimeZone(TimeZone tz); [EOL] public Date parse(String dateStr) throws ParseException; [EOL] public Date parse(String dateStr, ParsePosition pos); [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); [EOL] protected boolean looksLikeISO8601(String dateStr); [EOL] protected Date parseAsISO8601(String dateStr, ParsePosition pos); [EOL] protected Date parseAsRFC1123(String dateStr, ParsePosition pos); [EOL] private static final boolean hasTimeZone(String str); [EOL] private final DateFormat _cloneFormat(DateFormat df); [EOL] private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); [EOL] String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; [EOL] String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; [EOL] String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; [EOL] String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; [EOL] String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }];
public void testCloneFormatWithNullTimeZone() { [EOL] DateFormat originalFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] DateFormat clonedFormat = _cloneFormat(originalFormat, null); [EOL] assertNotNull(clonedFormat); [EOL] assertEquals(originalFormat.getClass(), clonedFormat.getClass()); [EOL] assertEquals(originalFormat.getTimeZone(), clonedFormat.getTimeZone()); [EOL] }
public void testCloneFormatWithNonNullTimeZone() { [EOL] DateFormat originalFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat clonedFormat = _cloneFormat(originalFormat, tz); [EOL] assertNotNull(clonedFormat); [EOL] assertEquals(originalFormat.getClass(), clonedFormat.getClass()); [EOL] assertNotEquals(originalFormat.getTimeZone(), clonedFormat.getTimeZone()); [EOL] assertEquals(tz, clonedFormat.getTimeZone()); [EOL] }
public void testCopyConstructor() { [EOL] SettableBeanProperty original = createDummySettableBeanProperty(); [EOL] SettableBeanProperty copy = new SettableBeanProperty(original); [EOL] assertEquals(original.getName(), copy.getName()); [EOL] assertEquals(original.getType(), copy.getType()); [EOL] assertEquals(original.getWrapperName(), copy.getWrapperName()); [EOL] assertEquals(original.isRequired(), copy.isRequired()); [EOL] assertEquals(original.getContextAnnotations(), copy.getContextAnnotations()); [EOL] assertEquals(original.getValueDeserializer(), copy.getValueDeserializer()); [EOL] assertEquals(original.getValueTypeDeserializer(), copy.getValueTypeDeserializer()); [EOL] assertEquals(original.getNullProvider(), copy.getNullProvider()); [EOL] assertEquals(original.getManagedReferenceName(), copy.getManagedReferenceName()); [EOL] assertEquals(original.getPropertyIndex(), copy.getPropertyIndex()); [EOL] assertEquals(original.getViewMatcher(), copy.getViewMatcher()); [EOL] }
public void testSetManagedReferenceName() { [EOL] YourClass instance = new YourClass(); [EOL] String expectedManagedReferenceName = "myManagedRef"; [EOL] instance.setManagedReferenceName(expectedManagedReferenceName); [EOL] assertEquals(expectedManagedReferenceName, instance.getManagedReferenceName()); [EOL] }
public void testSetViewsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setViews(null); [EOL] assertNull(mapper.getSerializationConfig().getViewMatcher()); [EOL] }
public void testSetViewsNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?>[] views = new Class<?>[] {View.Public.class, View.Private.class}; [EOL] mapper.setViews(views); [EOL] assertNotNull(mapper.getSerializationConfig().getViewMatcher()); [EOL] }
public void testIsRequiredWhenTrue() { [EOL] YourClass instance = new YourClass(true); [EOL] boolean result = instance.isRequired(); [EOL] assert result : "isRequired should return true when _isRequired is true"; [EOL] } [EOL] public void testIsRequiredWhenFalse() { [EOL] YourClass instance = new YourClass(false); [EOL] boolean result = instance.isRequired(); [EOL] assert !result : "isRequired should return false when _isRequired is false"; [EOL] }
public void testGetWrapperName_Null() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] assertNull(bpw.getWrapperName()); [EOL] }
public void testGetWrapperName_NonNull() { [EOL] PropertyName propertyName = new PropertyName("testWrapper"); [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw.assignWrapperName(propertyName); [EOL] assertEquals(propertyName, bpw.getWrapperName()); [EOL] }
public void testGetValueDeserializerWhenDeserializerIsMissing() { [EOL] MyDeserializationContext context = new MyDeserializationContext(); [EOL] context._valueDeserializer = MyDeserializationContext.MISSING_VALUE_DESERIALIZER; [EOL] JsonDeserializer<Object> result = context.getValueDeserializer(); [EOL] assertNull(result); [EOL] }
public void testGetValueDeserializerWhenDeserializerIsPresent() { [EOL] MyDeserializationContext context = new MyDeserializationContext(); [EOL] context._valueDeserializer = validDeserializer; [EOL] JsonDeserializer<Object> result = context.getValueDeserializer(); [EOL] assertSame(validDeserializer, result); [EOL] }
public void testVisibleInView_NullViewMatcher() { [EOL] JsonProperty prop = new JsonProperty(); [EOL] assertTrue(prop.visibleInView(Object.class)); [EOL] }
public void testVisibleInView_ViewMatcherVisible() { [EOL] JsonProperty prop = new JsonProperty(); [EOL] prop._viewMatcher = new ViewMatcher() { [EOL] @Override [EOL] public boolean isVisibleForView(Class<?> activeView) { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(prop.visibleInView(Object.class)); [EOL] }
public void testVisibleInView_ViewMatcherNotVisible() { [EOL] JsonProperty prop = new JsonProperty(); [EOL] prop._viewMatcher = new ViewMatcher() { [EOL] @Override [EOL] public boolean isVisibleForView(Class<?> activeView) { [EOL] return false; [EOL] } [EOL] }; [EOL] assertFalse(prop.visibleInView(Object.class)); [EOL] }
public void testMethodPropertyConstructorWithNonNullMethod() { [EOL] MethodProperty src = createMockMethodProperty(); [EOL] Method m = createMockMethod(); [EOL] MethodProperty result = new MethodProperty(src, m); [EOL] assertNotNull(result); [EOL] assertEquals(m, result.getSetter()); [EOL] }
public void testMethodPropertyConstructorWithNullMethod() { [EOL] MethodProperty src = createMockMethodProperty(); [EOL] MethodProperty result = new MethodProperty(src, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getSetter()); [EOL] }
public void testReadResolve() { [EOL] MethodProperty original = new MethodProperty(/* parameters to construct a valid MethodProperty */); [EOL] Object resolved = original.readResolve(); [EOL] assertNotNull(resolved); [EOL] assertTrue(resolved instanceof MethodProperty); [EOL] MethodProperty resolvedMethodProperty = (MethodProperty) resolved; [EOL] assertEquals(original.getAnnotated(), resolvedMethodProperty.getAnnotated()); [EOL] }
public void testSerializeWritesNull() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] YourSerializer serializer = new YourSerializer(); [EOL] serializer.serialize(mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeNull(); [EOL] }
public void testDeserializeFromObjectWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(mock(PropertyBasedCreator.class)); [EOL] when(_deserializeUsingPropertyBased(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithAbstractBeanType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(true); [EOL] assertThrows(JsonMappingException.class, () -> deserializeFromObject(jp, ctxt)); [EOL] }
public void testDeserializeFromObjectWithoutStringCreatorAndDefaultCtor() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> deserializeFromObject(jp, ctxt)); [EOL] }
public void testDeserializeFromObjectWithPendingProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(_beanProperties.size()).thenReturn(1); [EOL] when(_beanProperties.find(anyString())).thenReturn(mock(SettableBeanProperty.class)); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorableProp"); [EOL] when(_ignorableProps).thenReturn(new HashSet<>(Arrays.asList("ignorableProp"))); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("anySetterProp"); [EOL] when(_anySetter).thenReturn(mock(SettableAnyProperty.class)); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProp"); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testAnnotatedFieldWithNullSerialization() { [EOL] Serialization ser = null; [EOL] AnnotatedField annotatedField = new AnnotatedField(ser); [EOL] assertNull(annotatedField.getField()); [EOL] assertNull(annotatedField.getSerialization()); [EOL] }
public void testAnnotatedFieldWithNonNullSerialization() { [EOL] Serialization ser = new Serialization(); // Assuming Serialization is a valid class that can be instantiated [EOL] AnnotatedField annotatedField = new AnnotatedField(ser); [EOL] assertNull(annotatedField.getField()); [EOL] assertSame(ser, annotatedField.getSerialization()); [EOL] }
public void testSetValueWithValidArguments() { [EOL] Object pojo = new SomeClass(); [EOL] Object value = "someValue"; [EOL] FieldProperty fieldProperty = new FieldProperty(SomeClass.class.getDeclaredField("someField")); [EOL] fieldProperty.setValue(pojo, value); [EOL] assertEquals("someValue", SomeClass.someField); [EOL] }
public void testSetValueWithIllegalAccess() { [EOL] Object pojo = new SomeClass(); [EOL] Object value = "someValue"; [EOL] FieldProperty fieldProperty = new FieldProperty(SomeClass.class.getDeclaredField("privateField")); [EOL] try { [EOL] fieldProperty.setValue(pojo, value); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Failed to setValue() for field SomeClass.privateField: " + e.getCause().getMessage(), e.getMessage()); [EOL] } [EOL] }
public void testWriteReplace() { [EOL] AnnotatedField originalField = new AnnotatedField(); [EOL] Object replacedObject = originalField.writeReplace(); [EOL] assertNotNull(replacedObject); [EOL] assertTrue(replacedObject instanceof AnnotatedField); [EOL] AnnotatedField serializedField = (AnnotatedField) replacedObject; [EOL] assertNotNull(serializedField.getSerialization()); [EOL] }
public void testReadResolveAccessibleField() throws NoSuchFieldException { [EOL] SerializationConfig serializationConfig = new SerializationConfig(); [EOL] AnnotatedClass annotatedClass = new AnnotatedClass(SomeClass.class, serializationConfig); [EOL] Field accessibleField = SomeClass.class.getDeclaredField("accessibleField"); [EOL] accessibleField.setAccessible(true); [EOL] AnnotatedField expectedAnnotatedField = new AnnotatedField(accessibleField, null); [EOL] Object result = annotatedClass.readResolve(); [EOL] assertEquals(expectedAnnotatedField, result); [EOL] }
public void testReadResolveInaccessibleField() throws NoSuchFieldException { [EOL] SerializationConfig serializationConfig = new SerializationConfig(); [EOL] AnnotatedClass annotatedClass = new AnnotatedClass(SomeClass.class, serializationConfig); [EOL] Field inaccessibleField = SomeClass.class.getDeclaredField("inaccessibleField"); [EOL] inaccessibleField.setAccessible(false); [EOL] AnnotatedField expectedAnnotatedField = new AnnotatedField(inaccessibleField, null); [EOL] Object result = annotatedClass.readResolve(); [EOL] assertEquals(expectedAnnotatedField, result); [EOL] }
public void testReadResolveNonExistentField() { [EOL] SerializationConfig serializationConfig = new SerializationConfig(); [EOL] AnnotatedClass annotatedClass = new AnnotatedClass(SomeClass.class, serializationConfig); [EOL] annotatedClass._serialization.name = "nonExistentField"; [EOL] try { [EOL] annotatedClass.readResolve(); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSerializationConstructorWithValidField() throws NoSuchFieldException { [EOL] Field field = SomeClass.class.getDeclaredField("someFieldName"); [EOL] Serialization serialization = new Serialization(field); [EOL] assertEquals(SomeClass.class, serialization.clazz); [EOL] assertEquals("someFieldName", serialization.name); [EOL] }
public void testSerializationConstructorWithInheritedField() throws NoSuchFieldException { [EOL] Field field = SomeSubClass.class.getSuperclass().getDeclaredField("inheritedFieldName"); [EOL] Serialization serialization = new Serialization(field); [EOL] assertEquals(SomeSuperClass.class, serialization.clazz); [EOL] assertEquals("inheritedFieldName", serialization.name); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerWithObjectArray() throws IOException { [EOL] Object instance = new Object(); [EOL] Object[] value = new Object[] { new Object(), null }; [EOL] Object result = setAndReturn(instance, value); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerWithCollection() throws IOException { [EOL] Object instance = new Object(); [EOL] Collection<Object> value = Arrays.asList(new Object(), null); [EOL] Object result = setAndReturn(instance, value); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerWithMap() throws IOException { [EOL] Object instance = new Object(); [EOL] Map<String, Object> value = new HashMap<>(); [EOL] value.put("key1", new Object()); [EOL] value.put("key2", null); [EOL] Object result = setAndReturn(instance, value); [EOL] }
public void testSetAndReturnWithNonNullValueAndNotContainer() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Object result = setAndReturn(instance, value); [EOL] }
public void testSetAndReturnWithNullValue() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = null; [EOL] Object result = setAndReturn(instance, value); [EOL] }
public void testSetAndReturnWithUnsupportedContainerType() { [EOL] Object instance = new Object(); [EOL] Object value = new UnsupportedContainerType(); [EOL] try { [EOL] Object result = setAndReturn(instance, value); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalStateException, not IOException"); [EOL] } [EOL] }
protected BeanSerializer(BeanSerializerBase src, String[] toIgnore) { [EOL] super(src, toIgnore); [EOL] }
protected BeanSerializer withIgnorals(String[] toIgnore) { [EOL] return new BeanSerializer(this, toIgnore); [EOL] }
public void testCompleteWithEmptyProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(new ExternalTypeHandler.ExtTypedProperty[0], new String[0], new TokenBuffer[0]); [EOL] Object result = handler.complete(jp, ctxt, bean); [EOL] assertSame("The bean should be the same as the one passed in", bean, result); [EOL] }
public void testCompleteWithNullTypeIdsAndTokens() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(mock(SettableBeanProperty.class)); [EOL] String[] typeIds = {null}; [EOL] TokenBuffer[] tokens = {null}; [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(properties, typeIds, tokens); [EOL] Object result = handler.complete(jp, ctxt, bean); [EOL] assertSame("The bean should be the same as the one passed in", bean, result); [EOL] }
public void testCompleteWithNonNullTokenButMissingTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(mock(SettableBeanProperty.class)); [EOL] when(properties[0].hasDefaultType()).thenReturn(false); [EOL] when(properties[0].getTypePropertyName()).thenReturn("typeProperty"); [EOL] String[] typeIds = {null}; [EOL] TokenBuffer[] tokens = {new TokenBuffer(jp, ctxt)}; [EOL] tokens[0].writeNumber(123); [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(properties, typeIds, tokens); [EOL] try { [EOL] handler.complete(jp, ctxt, bean); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testCompleteWithNonNullTokenAndScalarValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] SettableBeanProperty beanProperty = mock(SettableBeanProperty.class); [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(beanProperty); [EOL] when(properties[0].hasDefaultType()).thenReturn(true); [EOL] when(properties[0].getDefaultTypeId()).thenReturn("defaultTypeId"); [EOL] String[] typeIds = {null}; [EOL] TokenBuffer[] tokens = {new TokenBuffer(jp, ctxt)}; [EOL] tokens[0].writeString("test"); [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(properties, typeIds, tokens); [EOL] Object result = handler.complete(jp, ctxt, bean); [EOL] assertSame("The bean should be the same as the one passed in", bean, result); [EOL] verify(beanProperty, times(1)).set(eq(bean), any()); [EOL] }
public void testCompleteWithNonNullTypeIdAndNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] SettableBeanProperty beanProperty = mock(SettableBeanProperty.class); [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(beanProperty); [EOL] when(properties[0].getTypePropertyName()).thenReturn("typeProperty"); [EOL] when(beanProperty.getName()).thenReturn("propertyName"); [EOL] String[] typeIds = {"typeId"}; [EOL] TokenBuffer[] tokens = {null}; [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(properties, typeIds, tokens); [EOL] try { [EOL] handler.complete(jp, ctxt, bean); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testGetDateFormat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DateFormat df = mapper.getSerializationConfig().getDateFormat(); [EOL] assertNotNull(df); [EOL] assertTrue(df instanceof DateFormat); [EOL] }
public void testGetTimeZone() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone expectedTimeZone = TimeZone.getDefault(); [EOL] assertEquals(expectedTimeZone, mapper.getTimeZone()); [EOL] }
public void testTypeIdResolverInstanceWithHandlerInstantiatorProvidingNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated annotated = mock(Annotated.class); [EOL] Class<? extends TypeIdResolver> resolverClass = MyTypeIdResolver.class; [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] TypeIdResolver resolver = mock(TypeIdResolver.class); [EOL] when(mapper.getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.typeIdResolverInstance(mapper, annotated, resolverClass)).thenReturn(resolver); [EOL] TypeIdResolver result = mapper.typeIdResolverInstance(annotated, resolverClass); [EOL] assertNotNull(result); [EOL] assertSame(resolver, result); [EOL] }
public void testTypeIdResolverInstanceWithHandlerInstantiatorProvidingNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated annotated = mock(Annotated.class); [EOL] Class<? extends TypeIdResolver> resolverClass = MyTypeIdResolver.class; [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] when(mapper.getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.typeIdResolverInstance(mapper, annotated, resolverClass)).thenReturn(null); [EOL] TypeIdResolver result = mapper.typeIdResolverInstance(annotated, resolverClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyTypeIdResolver); [EOL] }
public void testTypeIdResolverInstanceWithoutHandlerInstantiator() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated annotated = mock(Annotated.class); [EOL] Class<? extends TypeIdResolver> resolverClass = MyTypeIdResolver.class; [EOL] when(mapper.getHandlerInstantiator()).thenReturn(null); [EOL] TypeIdResolver result = mapper.typeIdResolverInstance(annotated, resolverClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyTypeIdResolver); [EOL] }
public void testSimpleValueInstantiatorsConstructor() { [EOL] SimpleValueInstantiators instantiators = new SimpleValueInstantiators(); [EOL] assertNotNull(instantiators); [EOL] assertTrue(instantiators._classMappings.isEmpty()); [EOL] }
public void testAddValueInstantiatorWithNonNullValues() { [EOL] SimpleValueInstantiators instantiators = new SimpleValueInstantiators(); [EOL] Class<?> forType = String.class; [EOL] ValueInstantiator inst = new StdValueInstantiator(null, forType); [EOL] SimpleValueInstantiators result = instantiators.addValueInstantiator(forType, inst); [EOL] assertNotNull(result); [EOL] assertSame(instantiators, result); [EOL] assertTrue(instantiators.hasValueInstantiator(forType)); [EOL] assertSame(inst, instantiators.findValueInstantiator(null, null, forType, null, null)); [EOL] }
public void testAddValueInstantiatorWithNullType() { [EOL] SimpleValueInstantiators instantiators = new SimpleValueInstantiators(); [EOL] ValueInstantiator inst = new StdValueInstantiator(null, String.class); [EOL] try { [EOL] instantiators.addValueInstantiator(null, inst); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddValueInstantiatorWithNullInstantiator() { [EOL] SimpleValueInstantiators instantiators = new SimpleValueInstantiators(); [EOL] Class<?> forType = String.class; [EOL] try { [EOL] instantiators.addValueInstantiator(forType, null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindValueInstantiatorWithDefault() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] ValueInstantiator defaultInstantiator = new ValueInstantiator(); [EOL] ValueInstantiator result = findValueInstantiator(config, beanDesc, defaultInstantiator); [EOL] assertEquals(defaultInstantiator, result); [EOL] }
public void testFindValueInstantiatorWithCustom() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] ValueInstantiator defaultInstantiator = new ValueInstantiator(); [EOL] ValueInstantiator customInstantiator = new ValueInstantiator(); [EOL] _classMappings.put(new ClassKey(beanDesc.getBeanClass()), customInstantiator); [EOL] ValueInstantiator result = findValueInstantiator(config, beanDesc, defaultInstantiator); [EOL] assertEquals(customInstantiator, result); [EOL] }
public void testGetWithValidIndex() { [EOL] JsonNode node = createTestNode(); [EOL] JsonNode result = node.get(0); [EOL] assertNull(result); [EOL] }
public void testGetWithInvalidIndex() { [EOL] JsonNode node = createTestNode(); [EOL] JsonNode result = node.get(-1); [EOL] assertNull(result); [EOL] }
public void testPathWithIndex() { [EOL] JsonNode node = new TestNode(); [EOL] JsonNode result = node.path(5); [EOL] assertTrue(result instanceof MissingNode); [EOL] }
public void testGetWithNullFieldName() { [EOL] JsonNode node = createNode(); [EOL] JsonNode result = node.get(null); [EOL] assertNull(result); [EOL] }
public void testGetWithNonExistentFieldName() { [EOL] JsonNode node = createNode(); [EOL] JsonNode result = node.get("nonExistentField"); [EOL] assertNull(result); [EOL] }
public void testBuildTypeSerializerWithIdNone() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.NONE; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeSerializerWithWrapperArray() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id for this context [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_ARRAY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.PROPERTY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithWrapperObject() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_OBJECT; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithExternalProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.EXTERNAL_PROPERTY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithIllegalStateException() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = null; // Assuming null will trigger the default case [EOL] assertThrows(IllegalStateException.class, () -> { [EOL] buildTypeSerializer(config, baseType, subtypes); [EOL] }); [EOL] }
public void testBuildTypeDeserializerWithIdTypeNone() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.NONE, null); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeDeserializerWithWrapperArray() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_ARRAY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithWrapperObject() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_OBJECT); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithExternalProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithInvalidInclusion() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(null); // Invalid inclusion type to trigger the IllegalStateException [EOL] assertThrows(IllegalStateException.class, () -> { [EOL] builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] }); [EOL] }
public void testDefaultImplWithNonNullClass() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] Class<?> defaultImplClass = Object.class; [EOL] StdTypeResolverBuilder result = builder.defaultImpl(defaultImplClass); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] assertSame(defaultImplClass, result.defaultImpl()); [EOL] }
public void testDefaultImplWithNullClass() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] StdTypeResolverBuilder result = builder.defaultImpl(null); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] assertNull(result.defaultImpl()); [EOL] }
public void testIdResolverWithCustomIdResolver() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] TypeIdResolver customIdResolver = mock(TypeIdResolver.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CUSTOM, customIdResolver); [EOL] TypeIdResolver resolver = builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] assertSame("Expected custom id resolver to be returned", customIdResolver, resolver); [EOL] }
public void testIdResolverWithUninitializedIdType() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] try { [EOL] builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] fail("Expected IllegalStateException due to uninitialized idType"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Can not build, 'init()' not yet called", e.getMessage()); [EOL] } [EOL] }
public void testIdResolverWithIdTypeCLASS() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(config.getTypeFactory()).thenReturn(mock(TypeFactory.class)); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] TypeIdResolver resolver = builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] assertTrue("Expected ClassNameIdResolver to be returned", resolver instanceof ClassNameIdResolver); [EOL] }
public void testIdResolverWithIdTypeMINIMAL_CLASS() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(config.getTypeFactory()).thenReturn(mock(TypeFactory.class)); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.MINIMAL_CLASS, null); [EOL] TypeIdResolver resolver = builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] assertTrue("Expected MinimalClassNameIdResolver to be returned", resolver instanceof MinimalClassNameIdResolver); [EOL] }
public void testIdResolverWithIdTypeNAME() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.NAME, null); [EOL] TypeIdResolver resolver = builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] assertTrue("Expected TypeNameIdResolver to be returned", resolver instanceof TypeNameIdResolver); [EOL] }
public void testIdResolverWithIdTypeNONE() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.NONE, null); [EOL] TypeIdResolver resolver = builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] assertNull("Expected null to be returned for Id.NONE", resolver); [EOL] }
public void testIdResolverWithInvalidIdType() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] boolean forSer = true; [EOL] boolean forDeser = true; [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(null, null); [EOL] try { [EOL] builder.idResolver(config, baseType, subtypes, forSer, forDeser); [EOL] fail("Expected IllegalStateException due to invalid idType"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains("Do not know how to construct standard type id resolver for idType")); [EOL] } [EOL] }
public void testCollectAndResolveNamedTypeWithName() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class, "SomeName"); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertTrue(collectedSubtypes.containsKey(namedType)); [EOL] }
public void testCollectAndResolveNamedTypeWithoutName() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] when(ai.findTypeName(annotatedType)).thenReturn("GeneratedName"); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] NamedType expectedNamedType = new NamedType(SomeClass.class, "GeneratedName"); [EOL] assertTrue(collectedSubtypes.containsKey(expectedNamedType)); [EOL] }
public void testCollectAndResolveWithExistingNonNamedSubtype() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class, "SomeName"); [EOL] NamedType unnamedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] collectedSubtypes.put(unnamedType, unnamedType); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] NamedType retrievedNamedType = collectedSubtypes.get(unnamedType); [EOL] assertEquals("SomeName", retrievedNamedType.getName()); [EOL] }
public void testCollectAndResolveWithSubtypes() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] Collection<NamedType> subtypes = Arrays.asList( [EOL] new NamedType(SubClass1.class), [EOL] new NamedType(SubClass2.class, "SubName2") [EOL] ); [EOL] when(ai.findSubtypes(annotatedType)).thenReturn(subtypes); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertEquals(3, collectedSubtypes.size()); [EOL] assertTrue(collectedSubtypes.containsKey(new NamedType(SubClass1.class))); [EOL] assertTrue(collectedSubtypes.containsKey(new NamedType(SubClass2.class, "SubName2"))); [EOL] }
public void testWithContentValueHandlerSameHandler() { [EOL] Object handler = new Object(); [EOL] JavaType componentType = new SimpleType(Object.class); [EOL] componentType = componentType.withValueHandler(handler); [EOL] ArrayType arrayType = new ArrayType(componentType, null, null, null, false); [EOL] ArrayType result = arrayType.withContentValueHandler(handler); [EOL] assertSame(arrayType, result); [EOL] }
public void testWithContentValueHandlerDifferentHandler() { [EOL] Object handler1 = new Object(); [EOL] Object handler2 = new Object(); [EOL] JavaType componentType = new SimpleType(Object.class); [EOL] componentType = componentType.withValueHandler(handler1); [EOL] ArrayType arrayType = new ArrayType(componentType, null, null, null, false); [EOL] ArrayType result = arrayType.withContentValueHandler(handler2); [EOL] assertNotSame(arrayType, result); [EOL] assertNotNull(result); [EOL] assertSame(handler2, result.getContentType().getValueHandler()); [EOL] }
public void testWithStaticTypingAlreadyStatic() { [EOL] ArrayType arrayType = new ArrayType(...); // Provide the necessary arguments [EOL] arrayType._asStatic = true; [EOL] ArrayType result = arrayType.withStaticTyping(); [EOL] assertSame(arrayType, result); [EOL] }
public void testWithStaticTypingNotStatic() { [EOL] ArrayType arrayType = new ArrayType(...); // Provide the necessary arguments [EOL] arrayType._asStatic = false; [EOL] ArrayType result = arrayType.withStaticTyping(); [EOL] assertNotNull(result); [EOL] assertNotSame(arrayType, result); [EOL] assertTrue(result._asStatic); [EOL] }
public void testNarrowContentsBy_SameClass() { [EOL] Class<?> originalClass = instance.getComponentType().getRawClass(); [EOL] JavaType result = instance.narrowContentsBy(originalClass); [EOL] assertSame("narrowContentsBy should return the same instance when the class is the same", instance, result); [EOL] }
public void testNarrowContentsBy_DifferentClass() { [EOL] Class<?> differentClass = String.class; // Use String class for example, assuming it's different from the original [EOL] JavaType originalComponentType = instance.getComponentType(); [EOL] JavaType result = instance.narrowContentsBy(differentClass); [EOL] assertNotSame("narrowContentsBy should not return the same instance when the class is different", instance, result); [EOL] assertEquals("The raw class of the narrowed component type should be the new class", differentClass, result.getComponentType().getRawClass()); [EOL] }
public void testIsArrayType() { [EOL] ConcreteArrayType concreteArrayType = new ConcreteArrayType(); [EOL] assertTrue(concreteArrayType.isArrayType()); [EOL] }
public void testIsAbstract() { [EOL] TestClass instance = new TestClass(); [EOL] boolean result = instance.isAbstract(); [EOL] assert !result; // The method is expected to return false [EOL] }
public void testIsConcrete() { [EOL] SomeClass instance = new SomeClass(); [EOL] boolean result = instance.isConcrete(); [EOL] assert result; [EOL] }
public void testGetContentType_WhenComponentTypeIsSet_ShouldReturnComponentType() { [EOL] JavaType expectedType = mock(JavaType.class); [EOL] ConcreteJavaType concreteJavaType = new ConcreteJavaType(expectedType); [EOL] JavaType result = concreteJavaType.getContentType(); [EOL] assertSame("The content type should be the same as the component type set", expectedType, result); [EOL] }
protected StringArraySerializer() { [EOL] super(String[].class, null); [EOL] _elementSerializer = null; [EOL] }
public void testCreateContextualWithNullProperty() { [EOL] JsonSerializer<?> serializer = new StringArraySerializer(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, null); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerializerDef() { [EOL] JsonSerializer<?> serializer = new StringArraySerializer(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArraySerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDef() { [EOL] JsonSerializer<?> serializer = new StringArraySerializer(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<?> customSerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(customSerializer); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertNotSame(serializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefButDefaultSerializer() { [EOL] JsonSerializer<?> serializer = new StringArraySerializer(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<?> customSerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(customSerializer); [EOL] when(serializer.isDefaultSerializer(customSerializer)).thenReturn(true); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefAndContextualSerializer() { [EOL] JsonSerializer<?> serializer = new StringArraySerializer(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<?> contextualInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(contextualSerializer); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(contextualInstance); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertSame(contextualInstance, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefAndNonContextualSerializer() { [EOL] JsonSerializer<?> serializer = new StringArraySerializer(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<?> nonContextualSerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(nonContextualSerializer); [EOL] when(serializer.isDefaultSerializer(nonContextualSerializer)).thenReturn(false); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArraySerializer); [EOL] }
public void testIsEmptyWithNullArray() { [EOL] String[] nullArray = null; [EOL] assertTrue(isEmpty(nullArray)); [EOL] }
public void testIsEmptyWithEmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] assertTrue(isEmpty(emptyArray)); [EOL] }
public void testIsEmptyWithNonEmptyArray() { [EOL] String[] nonEmptyArray = new String[]{"element"}; [EOL] assertFalse(isEmpty(nonEmptyArray)); [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] String[] value = new String[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] String[] value = new String[]{"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] setElementSerializer(elementSerializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(elementSerializer).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithNullValue() throws IOException { [EOL] String[] value = new String[]{null}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeContentsWithNonNullValue() throws IOException { [EOL] String[] value = new String[]{"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(jgen).writeString("test"); [EOL] }
public void testGetSchema() { [EOL] JsonSerializer<?> serializer = new MyArraySerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] Type typeHint = String[].class; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.isObject()); [EOL] ObjectNode objectNode = (ObjectNode) schemaNode; [EOL] JsonNode itemsNode = objectNode.get("items"); [EOL] assertNotNull(itemsNode); [EOL] assertTrue(itemsNode.isObject()); [EOL] assertEquals("string", itemsNode.get("type").asText()); [EOL] }
public void testGetBinaryValueWithValidInput() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String validBase64String = "TWFu"; // "Man" in Base64 [EOL] TextNode textNode = new TextNode(validBase64String); [EOL] byte[] binaryValue = textNode.getBinaryValue(b64variant); [EOL] byte[] expectedValue = new byte[]{77, 97, 110}; // "Man" as bytes [EOL] assertArrayEquals(expectedValue, binaryValue); [EOL] }
public void testGetBinaryValueWithPadding() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String base64StringWithPadding = "TQ=="; // "M" with padding in Base64 [EOL] TextNode textNode = new TextNode(base64StringWithPadding); [EOL] byte[] binaryValue = textNode.getBinaryValue(b64variant); [EOL] byte[] expectedValue = new byte[]{77}; // "M" as bytes [EOL] assertArrayEquals(expectedValue, binaryValue); [EOL] }
public void testGetBinaryValueWithInvalidCharacter() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String invalidBase64String = "T$"; // Invalid Base64 character [EOL] TextNode textNode = new TextNode(invalidBase64String); [EOL] assertThrows(IOException.class, () -> textNode.getBinaryValue(b64variant)); [EOL] }
public void testGetBinaryValueWithInvalidPadding() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String invalidBase64String = "T=W="; // Invalid padding in Base64 [EOL] TextNode textNode = new TextNode(invalidBase64String); [EOL] assertThrows(IOException.class, () -> textNode.getBinaryValue(b64variant)); [EOL] }
public void testGetBinaryValueWithIncompletePadding() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String incompletePaddingBase64String = "TQ="; // Incomplete padding in Base64 [EOL] TextNode textNode = new TextNode(incompletePaddingBase64String); [EOL] assertThrows(IOException.class, () -> textNode.getBinaryValue(b64variant)); [EOL] }
public void testGetBinaryValueWithNoPaddingVariant() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getMimeNoPaddingVariant(); [EOL] String base64StringNoPadding = "TWFu"; // "Man" in Base64 without padding [EOL] TextNode textNode = new TextNode(base64StringNoPadding); [EOL] byte[] binaryValue = textNode.getBinaryValue(b64variant); [EOL] byte[] expectedValue = new byte[]{77, 97, 110}; // "Man" as bytes [EOL] assertArrayEquals(expectedValue, binaryValue); [EOL] }
public void testBinaryValueWithDefaultVariant() throws IOException { [EOL] JsonNode node = new TextNode("dGVzdA=="); // Base64 encoded string for "test" [EOL] byte[] expected = new byte[]{116, 101, 115, 116}; // byte array for string "test" [EOL] byte[] actual = node.binaryValue(); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testBinaryValueWithInvalidInput() throws IOException { [EOL] JsonNode node = new TextNode("not-base64"); [EOL] try { [EOL] node.binaryValue(); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("Illegal base64 character 6e", e.getMessage()); [EOL] } [EOL] }
public void testSerializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] MySerializer serializer = new MySerializer(null); [EOL] serializer.serialize(mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeNull(); [EOL] }
public void testSerializeWithNonNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] MySerializer serializer = new MySerializer("testValue"); [EOL] serializer.serialize(mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeString("testValue"); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL] String baseMsg; [EOL] if (ch <= INT_SPACE) { [EOL] baseMsg = "Illegal white space character (code 0x"+Integer.toHexString(ch)+") as character #"+(bindex+1)+" of 4-char base64 unit: can only be used between units"; [EOL] } else if (b64variant.usesPaddingChar(ch)) { [EOL] baseMsg = "Unexpected padding character ('"+b64variant.getPaddingChar()+"') as character #"+(bindex+1)+" of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL] } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL] baseMsg = "Illegal character (code 0x"+Integer.toHexString(ch)+") in base64 content"; [EOL] } else { [EOL] baseMsg = "Illegal character '"+ch+"' (code 0x"+Integer.toHexString(ch)+") in base64 content"; [EOL] } [EOL] if (msg != null) { [EOL] baseMsg = baseMsg + ": " + msg; [EOL] } [EOL] throw new JsonParseException(baseMsg, JsonLocation.NA); [EOL] }
public void testReportInvalidBase64WithWhiteSpaceCharacter() throws JsonParseException { [EOL] Base64Variant b64variant = new Base64Variant("test", "ABC=", false, '=', 123); [EOL] char ch = ' '; [EOL] int bindex = 0; [EOL] String msg = "additional message"; [EOL] try { [EOL] _reportInvalidBase64(b64variant, ch, bindex, msg); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Illegal white space character (code 0x20) as character #1 of 4-char base64 unit: can only used between units: additional message", e.getMessage()); [EOL] } [EOL] }
public void testReportInvalidBase64WithPaddingCharacter() throws JsonParseException { [EOL] Base64Variant b64variant = new Base64Variant("test", "ABC=", true, '=', 123); [EOL] char ch = '='; [EOL] int bindex = 1; [EOL] String msg = "additional message"; [EOL] try { [EOL] _reportInvalidBase64(b64variant, ch, bindex, msg); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Unexpected padding character ('=') as character #2 of 4-char base64 unit: padding only legal as 3rd or 4th character: additional message", e.getMessage()); [EOL] } [EOL] }
public void testReportInvalidBase64WithUndefinedCharacter() throws JsonParseException { [EOL] Base64Variant b64variant = new Base64Variant("test", "ABC=", false, '=', 123); [EOL] char ch = '\uFFFF'; [EOL] int bindex = 2; [EOL] String msg = "additional message"; [EOL] try { [EOL] _reportInvalidBase64(b64variant, ch, bindex, msg); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Illegal character (code 0xffff) in base64 content: additional message", e.getMessage()); [EOL] } [EOL] }
public void testReportInvalidBase64WithISOControlCharacter() throws JsonParseException { [EOL] Base64Variant b64variant = new Base64Variant("test", "ABC=", false, '=', 123); [EOL] char ch = '\n'; [EOL] int bindex = 3; [EOL] String msg = "additional message"; [EOL] try { [EOL] _reportInvalidBase64(b64variant, ch, bindex, msg); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Illegal character (code 0xa) in base64 content: additional message", e.getMessage()); [EOL] } [EOL] }
public void testReportInvalidBase64WithRegularCharacter() throws JsonParseException { [EOL] Base64Variant b64variant = new Base64Variant("test", "ABC=", false, '=', 123); [EOL] char ch = 'A'; [EOL] int bindex = 4; [EOL] String msg = "additional message"; [EOL] try { [EOL] _reportInvalidBase64(b64variant, ch, bindex, msg); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Illegal character 'A' (code 0x41) in base64 content: additional message", e.getMessage()); [EOL] } [EOL] }
public void testReportInvalidBase64WithNullMessage() throws JsonParseException { [EOL] Base64Variant b64variant = new Base64Variant("test", "ABC=", false, '=', 123); [EOL] char ch = 'A'; [EOL] int bindex = 4; [EOL] String msg = null; [EOL] try { [EOL] _reportInvalidBase64(b64variant, ch, bindex, msg); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Illegal character 'A' (code 0x41) in base64 content", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(ctxt, times(1)).handleNonArray(jp, ctxt); [EOL] }
public void testDeserializeWithCustomDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] deserializer._elementDeserializer = mock(JsonDeserializer.class); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] verify(deserializer._elementDeserializer, times(1)).deserialize(jp, ctxt); [EOL] }
public void testDeserializeArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.VALUE_NULL, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("test"); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] deserializer._elementDeserializer = null; [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("test", result[0]); [EOL] }
public void testDeserializeArrayWithNonStringValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("1"); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] deserializer._elementDeserializer = null; [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("1", result[0]); [EOL] }
public void testAddBackReferencePropertyWithNullBackRefProperties() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.getName()).thenReturn("testProperty"); [EOL] beanPropertyMap.addBackReferenceProperty("testBackRef", prop); [EOL] assertNotNull(beanPropertyMap._backRefProperties); [EOL] assertTrue(beanPropertyMap._backRefProperties.containsKey("testBackRef")); [EOL] assertEquals(prop, beanPropertyMap._backRefProperties.get("testBackRef")); [EOL] assertNull(beanPropertyMap._properties); [EOL] }
public void testAddBackReferencePropertyWithNonNullBackRefProperties() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] beanPropertyMap._backRefProperties = new HashMap<>(); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.getName()).thenReturn("testProperty"); [EOL] beanPropertyMap.addBackReferenceProperty("testBackRef", prop); [EOL] assertTrue(beanPropertyMap._backRefProperties.containsKey("testBackRef")); [EOL] assertEquals(prop, beanPropertyMap._backRefProperties.get("testBackRef")); [EOL] }
public void testAddBackReferencePropertyWithNonNullProperties() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] beanPropertyMap._properties = new LinkedHashMap<>(); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.getName()).thenReturn("testProperty"); [EOL] beanPropertyMap._properties.put("testProperty", prop); [EOL] beanPropertyMap.addBackReferenceProperty("testBackRef", prop); [EOL] assertFalse(beanPropertyMap._properties.containsKey("testProperty")); [EOL] }
public void testAddInjectableWithNullInjectables() { [EOL] InjectableValues.Std std = new InjectableValues.Std(); [EOL] String propertyName = "testProperty"; [EOL] JavaType propertyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] Annotations contextAnnotations = null; [EOL] AnnotatedMember member = null; [EOL] Object valueId = "testValueId"; [EOL] std.addInjectable(propertyName, propertyType, contextAnnotations, member, valueId); [EOL] assertNotNull(std.findInjectableValue(propertyName, null, null, null)); [EOL] }
public void testAddInjectableWithExistingInjectables() { [EOL] InjectableValues.Std std = new InjectableValues.Std(); [EOL] String firstPropertyName = "firstProperty"; [EOL] JavaType firstPropertyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] Annotations firstContextAnnotations = null; [EOL] AnnotatedMember firstMember = null; [EOL] Object firstValueId = "firstValueId"; [EOL] std.addInjectable(firstPropertyName, firstPropertyType, firstContextAnnotations, firstMember, firstValueId); [EOL] String secondPropertyName = "secondProperty"; [EOL] JavaType secondPropertyType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] Annotations secondContextAnnotations = null; [EOL] AnnotatedMember secondMember = null; [EOL] Object secondValueId = "secondValueId"; [EOL] std.addInjectable(secondPropertyName, secondPropertyType, secondContextAnnotations, secondMember, secondValueId); [EOL] assertNotNull(std.findInjectableValue(secondPropertyName, null, null, null)); [EOL] assertNotSame(std.findInjectableValue(firstPropertyName, null, null, null), std.findInjectableValue(secondPropertyName, null, null, null)); [EOL] }
public void testBuildWithDefaultViewInclusionAndNoViews() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder._defaultViewInclusion = true; [EOL] builder._properties.put("prop", new SettableBeanProperty.DummyProperty()); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertFalse(beanDeserializer.anyView()); [EOL] }
public void testBuildWithDefaultViewInclusionAndViewProperties() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder._defaultViewInclusion = true; [EOL] SettableBeanProperty propWithView = new SettableBeanProperty.DummyProperty(); [EOL] propWithView.assignViews(new Class<?>[]{Object.class}); [EOL] builder._properties.put("propWithView", propWithView); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertTrue(beanDeserializer.anyView()); [EOL] }
public void testBuildWithObjectIdReader() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder._objectIdReader = ObjectIdReader.construct(null, null, null); [EOL] builder._properties.put("prop", new SettableBeanProperty.DummyProperty()); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertNotNull(beanDeserializer.getObjectIdReader()); [EOL] }
public void testSerializeWithSingleElementArrayUnwrapped() throws IOException { [EOL] Object bean = ...; // Initialize bean with a single element array [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] when(hasSingleElement(provider)).thenReturn(true); [EOL] serialize(bean, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(serializeAsArray(bean, jgen, provider)).times(1); [EOL] }
public void testSerializeWithNonSingleElementArray() throws IOException { [EOL] Object bean = ...; // Initialize bean with a non-single element array [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] when(hasSingleElement(provider)).thenReturn(false); [EOL] serialize(bean, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(serializeAsArray(bean, jgen, provider)).times(1); [EOL] }
public void testSerializeWithSingleElementArrayWrapped() throws IOException { [EOL] Object bean = ...; // Initialize bean with a single element array [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] when(hasSingleElement(provider)).thenReturn(true); [EOL] serialize(bean, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(serializeAsArray(bean, jgen, provider)).times(1); [EOL] }
public void testSerializeAsArrayWithActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(Object.class); [EOL] BeanPropertyWriter[] filteredProps = new BeanPropertyWriter[0]; [EOL] BeanSerializerBase serializer = new BeanSerializerBase(null, null, filteredProps, null) { [EOL] @Override [EOL] protected void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { [EOL] super.serializeAsArray(bean, jgen, provider); [EOL] } [EOL] }; [EOL] serializer.serializeAsArray(bean, jgen, provider); [EOL] verify(jgen, never()).writeNull(); [EOL] }
public void testSerializeAsArrayWithoutActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[0]; [EOL] BeanSerializerBase serializer = new BeanSerializerBase(null, props, null, null) { [EOL] @Override [EOL] protected void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { [EOL] super.serializeAsArray(bean, jgen, provider); [EOL] } [EOL] }; [EOL] serializer.serializeAsArray(bean, jgen, provider); [EOL] verify(jgen, never()).writeNull(); [EOL] }
public void testSerializeAsArrayWithNullProperty() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = {null}; [EOL] BeanSerializerBase serializer = new BeanSerializerBase(null, props, null, null) { [EOL] @Override [EOL] protected void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { [EOL] super.serializeAsArray(bean, jgen, provider); [EOL] } [EOL] }; [EOL] serializer.serializeAsArray(bean, jgen, provider); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeAsArrayWithException() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] BeanPropertyWriter[] props = {prop}; [EOL] doThrow(new IOException()).when(prop).serializeAsColumn(any(), any(), any()); [EOL] BeanSerializerBase serializer = new BeanSerializerBase(null, props, null, null) { [EOL] @Override [EOL] protected void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { [EOL] super.serializeAsArray(bean, jgen, provider); [EOL] } [EOL] }; [EOL] try { [EOL] serializer.serializeAsArray(bean, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSerializeAsArrayWithStackOverflowError() { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] BeanPropertyWriter[] props = {prop}; [EOL] doThrow(new StackOverflowError()).when(prop).serializeAsColumn(any(), any(), any()); [EOL] BeanSerializerBase serializer = new BeanSerializerBase(null, props, null, null) { [EOL] @Override [EOL] protected void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { [EOL] super.serializeAsArray(bean, jgen, provider); [EOL] } [EOL] }; [EOL] try { [EOL] serializer.serializeAsArray(bean, jgen, provider); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testConstructWithNonNullTypes() { [EOL] Class<?> rawType = Map.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] MapLikeType mapLikeType = MapLikeType.construct(rawType, keyType, valueType); [EOL] assertNotNull(mapLikeType); [EOL] assertEquals(rawType, mapLikeType.getRawClass()); [EOL] assertEquals(keyType, mapLikeType.getKeyType()); [EOL] assertEquals(valueType, mapLikeType.getContentType()); [EOL] }
public void testBuildCanonicalNameWithoutKeyType() { [EOL] MyType myType = new MyType(String.class); [EOL] String canonicalName = myType.buildCanonicalName(); [EOL] assertEquals("java.lang.String", canonicalName); [EOL] }
public void testBuildCanonicalNameWithKeyTypeAndValueType() { [EOL] MyType myType = new MyType(Map.class, new MyType(String.class), new MyType(Integer.class)); [EOL] String canonicalName = myType.buildCanonicalName(); [EOL] assertEquals("java.util.Map<java.lang.String,java.lang.Integer>", canonicalName); [EOL] }
public void testSimpleModuleWithNameAndVersion() { [EOL] String moduleName = "TestModule"; [EOL] Version moduleVersion = new Version(1, 0, 0, null, null, null); [EOL] SimpleModule module = new SimpleModule(moduleName, moduleVersion); [EOL] assertEquals(moduleName, module.getName()); [EOL] assertEquals(moduleVersion, module.version()); [EOL] }
public void testSetSerializerModifierWithNonNull() { [EOL] SimpleModule module = new SimpleModule(); [EOL] BeanSerializerModifier modifier = new BeanSerializerModifier() { /* custom implementation */ }; [EOL] SimpleModule result = module.setSerializerModifier(modifier); [EOL] assertNotNull(result); [EOL] assertSame(modifier, result.serializerModifier()); [EOL] }
public void testSetSerializerModifierWithNull() { [EOL] SimpleModule module = new SimpleModule(); [EOL] SimpleModule result = module.setSerializerModifier(null); [EOL] assertNotNull(result); [EOL] assertNull(result.serializerModifier()); [EOL] }
public void testAddAbstractTypeMapping_WithNullAbstractTypes() { [EOL] SimpleModule module = new SimpleModule(); [EOL] Class<?> superType = Object.class; [EOL] Class<?> subType = String.class; [EOL] SimpleModule result = module.addAbstractTypeMapping(superType, subType); [EOL] assertNotNull(result); [EOL] assertSame(module, result); [EOL] assertNotNull(result.getAbstractTypeResolver()); [EOL] assertEquals(subType, result.getAbstractTypeResolver().findTypeMapping(superType)); [EOL] }
public void testAddAbstractTypeMapping_WithNonNullAbstractTypes() { [EOL] SimpleModule module = new SimpleModule(); [EOL] SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver(); [EOL] module._abstractTypes = resolver; // Assuming there's a way to set this, like a package-private field [EOL] Class<?> superType = Number.class; [EOL] Class<?> subType = Integer.class; [EOL] SimpleModule result = module.addAbstractTypeMapping(superType, subType); [EOL] assertNotNull(result); [EOL] assertSame(module, result); [EOL] assertSame(resolver, result.getAbstractTypeResolver()); [EOL] assertEquals(subType, result.getAbstractTypeResolver().findTypeMapping(superType)); [EOL] }
public void testSetMixInAnnotation_WithNewMixinsMap() { [EOL] SimpleModule module = new SimpleModule(); [EOL] Class<?> targetType = String.class; [EOL] Class<?> mixinClass = Integer.class; [EOL] SimpleModule result = module.setMixInAnnotation(targetType, mixinClass); [EOL] assertNotNull(result.getMixIns()); [EOL] assertEquals(mixinClass, result.getMixIns().get(targetType)); [EOL] }
public void testSetMixInAnnotation_WithExistingMixinsMap() { [EOL] SimpleModule module = new SimpleModule(); [EOL] module.setMixInAnnotation(String.class, Integer.class); // Pre-populate the map [EOL] Class<?> newTargetType = List.class; [EOL] Class<?> newMixinClass = Map.class; [EOL] SimpleModule result = module.setMixInAnnotation(newTargetType, newMixinClass); [EOL] assertNotNull(result.getMixIns()); [EOL] assertEquals(newMixinClass, result.getMixIns().get(newTargetType)); [EOL] assertEquals(Integer.class, result.getMixIns().get(String.class)); // Check if previous entry still exists [EOL] }
public void testGetModuleName() { [EOL] Module testModule = new TestModule("TestModuleName"); [EOL] String moduleName = testModule.getModuleName(); [EOL] assertEquals("TestModuleName", moduleName); [EOL] }
public void testSetupModuleWithAllFieldsNull() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] setupModule(context); [EOL] verify(context, never()).addSerializers(any()); [EOL] verify(context, never()).addDeserializers(any()); [EOL] verify(context, never()).addKeySerializers(any()); [EOL] verify(context, never()).addKeyDeserializers(any()); [EOL] verify(context, never()).addAbstractTypeResolver(any()); [EOL] verify(context, never()).addValueInstantiators(any()); [EOL] verify(context, never()).addBeanDeserializerModifier(any()); [EOL] verify(context, never()).addBeanSerializerModifier(any()); [EOL] verify(context, never()).registerSubtypes((NamedType[]) any()); [EOL] verify(context, never()).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullFields() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _serializers = mock(Serializers.class); [EOL] _deserializers = mock(Deserializers.class); [EOL] _keySerializers = mock(Serializers.class); [EOL] _keyDeserializers = mock(KeyDeserializers.class); [EOL] _abstractTypes = mock(AbstractTypeResolver.class); [EOL] _valueInstantiators = mock(ValueInstantiators.class); [EOL] _deserializerModifier = mock(BeanDeserializerModifier.class); [EOL] _serializerModifier = mock(BeanSerializerModifier.class); [EOL] _subtypes = new ArrayList<>(); [EOL] _subtypes.add(mock(NamedType.class)); [EOL] _mixins = new HashMap<>(); [EOL] _mixins.put(Object.class, String.class); [EOL] setupModule(context); [EOL] verify(context).addSerializers(_serializers); [EOL] verify(context).addDeserializers(_deserializers); [EOL] verify(context).addKeySerializers(_keySerializers); [EOL] verify(context).addKeyDeserializers(_keyDeserializers); [EOL] verify(context).addAbstractTypeResolver(_abstractTypes); [EOL] verify(context).addValueInstantiators(_valueInstantiators); [EOL] verify(context).addBeanDeserializerModifier(_deserializerModifier); [EOL] verify(context).addBeanSerializerModifier(_serializerModifier); [EOL] verify(context).registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL] for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL] verify(context).setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL] } [EOL] }
public void testVersion() { [EOL] MyClass obj = new MyClass(Version.unknownVersion()); [EOL] assertEquals(Version.unknownVersion(), obj.version()); [EOL] }
public void testWriteTypePrefixForArrayWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] Object value = new int[]{1, 2, 3}; [EOL] String id = resolver.idFromValue(value); [EOL] resolver.writeTypePrefixForArray(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeArrayFieldStart(id); [EOL] }
public void testWriteTypePrefixForArrayWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] Object value = null; [EOL] resolver.writeTypePrefixForArray(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator, never()).writeArrayFieldStart(anyString()); [EOL] }
public void testWriteTypeSuffixForArray() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException { [EOL] jgen.writeEndArray(); [EOL] jgen.writeEndObject(); [EOL] } [EOL] }; [EOL] Object value = new Object(); [EOL] serializer.writeTypeSuffixForArray(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeEndArray(); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void writeCustomTypePrefixForObject_withValidParams_shouldWriteStartObjectAndObjectFieldStart() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String typeId = "customType"; [EOL] Object value = new Object(); [EOL] writeCustomTypePrefixForObject(value, mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeObjectFieldStart(typeId); [EOL] }
public void testWriteCustomTypeSuffixForObject() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] String typeId = "customType"; [EOL] serializer.writeCustomTypeSuffixForObject(value, jsonGenerator, typeId); [EOL] }

public void testConstructWithMapClass() { [EOL] try { [EOL] SimpleType.construct(java.util.HashMap.class); [EOL] fail("Expected IllegalArgumentException for Map class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for a Map (class: java.util.HashMap)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithCollectionClass() { [EOL] try { [EOL] SimpleType.construct(java.util.ArrayList.class); [EOL] fail("Expected IllegalArgumentException for Collection class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for a Collection (class: java.util.ArrayList)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithArrayClass() { [EOL] try { [EOL] SimpleType.construct(String[].class); [EOL] fail("Expected IllegalArgumentException for array class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for an array (class: [Ljava.lang.String;)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithRegularClass() { [EOL] SimpleType type = SimpleType.construct(String.class); [EOL] assertNotNull(type); [EOL] assertEquals(String.class, type.getRawClass()); [EOL] }
public void testWithValueHandlerSameHandler() { [EOL] Object handler = new Object(); [EOL] SimpleType type = new SimpleType(Object.class, null, null, handler, null, false); [EOL] SimpleType result = type.withValueHandler(handler); [EOL] assertSame("Should return the same SimpleType object if handler is the same", type, result); [EOL] } [EOL] public void testWithValueHandlerDifferentHandler() { [EOL] Object handler1 = new Object(); [EOL] Object handler2 = new Object(); [EOL] SimpleType type = new SimpleType(Object.class, null, null, handler1, null, false); [EOL] SimpleType result = type.withValueHandler(handler2); [EOL] assertNotSame("Should not return the same SimpleType object if handler is different", type, result); [EOL] assertNotNull("Resulting SimpleType should not be null", result); [EOL] assertSame("Value handler should be the new handler", handler2, result.getValueHandler()); [EOL] }
public void testTypeFactoryWithNullParserAndModifiers() { [EOL] TypeFactory typeFactory = new TypeFactory(null, null); [EOL] assertNull(typeFactory._parser); [EOL] assertNull(typeFactory._modifiers); [EOL] }
public void testTypeFactoryWithNonNullParserAndEmptyModifiers() { [EOL] TypeParser parser = new TypeParser(null); [EOL] TypeFactory typeFactory = new TypeFactory(parser, new TypeModifier[0]); [EOL] assertNotNull(typeFactory._parser); [EOL] assertNotNull(typeFactory._modifiers); [EOL] assertEquals(0, typeFactory._modifiers.length); [EOL] }
public void testTypeFactoryWithNonNullParserAndModifiers() { [EOL] TypeParser parser = new TypeParser(null); [EOL] TypeModifier modifier = new TypeModifier() {}; [EOL] TypeFactory typeFactory = new TypeFactory(parser, new TypeModifier[] {modifier}); [EOL] assertNotNull(typeFactory._parser); [EOL] assertNotNull(typeFactory._modifiers); [EOL] assertEquals(1, typeFactory._modifiers.length); [EOL] assertSame(modifier, typeFactory._modifiers[0]); [EOL] }
public void testWithModifierWhenModifiersAreNull() { [EOL] TypeFactory typeFactory = new TypeFactory(null, null); [EOL] TypeModifier mod = new TypeModifier() { [EOL] }; [EOL] TypeFactory modifiedTypeFactory = typeFactory.withModifier(mod); [EOL] assertNotNull(modifiedTypeFactory); [EOL] assertEquals(1, modifiedTypeFactory.getModifiers().length); [EOL] assertSame(mod, modifiedTypeFactory.getModifiers()[0]); [EOL] }
public void testWithModifierWhenModifiersAreNotNull() { [EOL] TypeModifier existingModifier = new TypeModifier() { [EOL] }; [EOL] TypeModifier newModifier = new TypeModifier() { [EOL] }; [EOL] TypeFactory typeFactory = new TypeFactory(null, new TypeModifier[] { existingModifier }); [EOL] TypeFactory modifiedTypeFactory = typeFactory.withModifier(newModifier); [EOL] assertNotNull(modifiedTypeFactory); [EOL] assertEquals(2, modifiedTypeFactory.getModifiers().length); [EOL] assertSame(existingModifier, modifiedTypeFactory.getModifiers()[0]); [EOL] assertSame(newModifier, modifiedTypeFactory.getModifiers()[1]); [EOL] }
public void testUnknownType() { [EOL] JavaType result = TypeFactory.unknownType(); [EOL] assertNotNull(result); [EOL] assertEquals(Object.class, result.getRawClass()); [EOL] }
public void testConstructTypeWithClass() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] JavaType result = _constructType(String.class, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testConstructTypeWithParameterizedType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testConstructTypeWithJavaType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] JavaType javaType = new SimpleType(String.class); [EOL] JavaType result = _constructType(javaType, context); [EOL] assertSame(javaType, result); [EOL] }
public void testConstructTypeWithGenericArrayType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = getClass().getDeclaredField("arrayOfListOfString").getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayType); [EOL] }
public void testConstructTypeWithTypeVariable() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] TypeVariable<?> typeVariable = getClass().getTypeParameters()[0]; [EOL] JavaType result = _constructType(typeVariable, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeVariableType); [EOL] }
public void testConstructTypeWithWildcardType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Field field = getClass().getDeclaredField("wildcardType"); [EOL] WildcardType wildcardType = (WildcardType) field.getGenericType(); [EOL] JavaType result = _constructType(wildcardType, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof WildcardType); [EOL] }
public void testConstructTypeWithUnrecognizedType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = new Type() {}; [EOL] try { [EOL] _constructType(type, context); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Unrecognized Type: " + type.toString(), e.getMessage()); [EOL] } [EOL] }
public void testConstructCollectionLikeTypeWithValidParameters() { [EOL] Class<?> collectionClass = List.class; [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionLikeType collectionLikeType = constructCollectionLikeType(collectionClass, elementType); [EOL] assertNotNull(collectionLikeType); [EOL] assertEquals(collectionClass, collectionLikeType.getRawClass()); [EOL] assertEquals(elementType, collectionLikeType.getContentType()); [EOL] }
public void testConstructCollectionLikeTypeWithNullCollectionClass() { [EOL] Class<?> collectionClass = null; [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] try { [EOL] constructCollectionLikeType(collectionClass, elementType); [EOL] fail("Expected IllegalArgumentException for null collectionClass"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructCollectionLikeTypeWithNullElementType() { [EOL] Class<?> collectionClass = List.class; [EOL] JavaType elementType = null; [EOL] try { [EOL] constructCollectionLikeType(collectionClass, elementType); [EOL] fail("Expected IllegalArgumentException for null elementType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructRawMapTypeWithHashMap() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] MapType type = mapper.getTypeFactory().constructRawMapType(HashMap.class); [EOL] assertNotNull(type); [EOL] assertTrue(type.getKeyType().isTypeOrSubTypeOf(Object.class)); [EOL] assertTrue(type.getContentType().isTypeOrSubTypeOf(Object.class)); [EOL] assertEquals(HashMap.class, type.getRawClass()); [EOL] }
public void testConstructRawMapTypeWithLinkedHashMap() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] MapType type = mapper.getTypeFactory().constructRawMapType(LinkedHashMap.class); [EOL] assertNotNull(type); [EOL] assertTrue(type.getKeyType().isTypeOrSubTypeOf(Object.class)); [EOL] assertTrue(type.getContentType().isTypeOrSubTypeOf(Object.class)); [EOL] assertEquals(LinkedHashMap.class, type.getRawClass()); [EOL] }
public void testConstructRawMapTypeWithTreeMap() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] MapType type = mapper.getTypeFactory().constructRawMapType(TreeMap.class); [EOL] assertNotNull(type); [EOL] assertTrue(type.getKeyType().isTypeOrSubTypeOf(Object.class)); [EOL] assertTrue(type.getContentType().isTypeOrSubTypeOf(Object.class)); [EOL] assertEquals(TreeMap.class, type.getRawClass()); [EOL] }
public void testConstructRawMapLikeTypeWithValidClass() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] MapLikeType mapLikeType = typeFactory.constructRawMapLikeType(HashMap.class); [EOL] assertNotNull(mapLikeType); [EOL] assertEquals(HashMap.class, mapLikeType.getRawClass()); [EOL] assertTrue(mapLikeType.isMapLikeType()); [EOL] }
public void testConstructRawMapLikeTypeWithInvalidClass() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] try { [EOL] typeFactory.constructRawMapLikeType(String.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFromArrayTypeWithGenericComponentType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] GenericArrayType genericArrayType = Mockito.mock(GenericArrayType.class); [EOL] Type genericComponentType = Mockito.mock(Type.class); [EOL] Mockito.when(genericArrayType.getGenericComponentType()).thenReturn(genericComponentType); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] JavaType result = typeFactory._fromArrayType(genericArrayType, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayType); [EOL] assertNotNull(result.getContentType()); [EOL] }
protected JavaType _unknownType() { [EOL] return new SimpleType(Object.class); [EOL] }
public void testForPropertySameProperty() { [EOL] AsPropertyTypeDeserializer original = new AsPropertyTypeDeserializer(/* parameters to construct the instance */); [EOL] BeanProperty sameProperty = original.getProperty(); [EOL] TypeDeserializer result = original.forProperty(sameProperty); [EOL] assertSame("Should return the same instance when property is the same", original, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] AsPropertyTypeDeserializer original = new AsPropertyTypeDeserializer(/* parameters to construct the instance */); [EOL] BeanProperty differentProperty = new BeanProperty.Bogus(); // Assuming BeanProperty.Bogus is a placeholder for an actual implementation [EOL] TypeDeserializer result = original.forProperty(differentProperty); [EOL] assertNotSame("Should return a new instance when property is different", original, result); [EOL] assertTrue("Result should be an instance of AsPropertyTypeDeserializer", result instanceof AsPropertyTypeDeserializer); [EOL] assertNotEquals("Property should be different in the new instance", original.getProperty(), ((AsPropertyTypeDeserializer) result).getProperty()); [EOL] }
public void testDeserializeTypedFromObjectWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromObjectWithStartArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromObjectWithUnexpectedToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromObjectWithFieldNameToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("typePropertyName"); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithVisibleTypeIdAndNonNullTokenBuffer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = mock(TokenBuffer.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] Object result = _deserializeTypedForId(jp, ctxt, tb); [EOL] verify(tb).writeFieldName("fieldName"); [EOL] verify(tb).writeString("typeId"); [EOL] verify(deser).deserialize(any(JsonParser.class), eq(ctxt)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithVisibleTypeIdAndNullTokenBuffer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] Object result = _deserializeTypedForId(jp, ctxt, null); [EOL] verify(deser).deserialize(any(JsonParser.class), eq(ctxt)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithoutVisibleTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = null; [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] Object result = _deserializeTypedForId(jp, ctxt, tb); [EOL] verify(deser).deserialize(any(JsonParser.class), eq(ctxt)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = mock(TokenBuffer.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] assertNotNull(result); [EOL] verify(deser).deserialize(jp, ctxt); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithTokenBuffer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = mock(TokenBuffer.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(deser); [EOL] when(tb.asParser(jp)).thenReturn(jp); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] assertNotNull(result); [EOL] verify(tb).writeEndObject(); [EOL] verify(tb).asParser(jp); [EOL] verify(jp).nextToken(); [EOL] verify(deser).deserialize(jp, ctxt); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithNaturalTypes() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType)).thenReturn(new Object()); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType)).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeExpectedType); // Replace with the expected type returned by super.deserializeTypedFromAny [EOL] }
public void testDeserializeTypedUsingDefaultImplWithWrongTokenException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType)).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] }); [EOL] }
public void testTokenBufferWithNullCodec() { [EOL] TokenBuffer buffer = new TokenBuffer(null); [EOL] assertNull(buffer.getCodec()); [EOL] assertEquals(JsonWriteContext.createRootContext(), buffer.getOutputContext()); [EOL] assertNotNull(buffer.firstSegment()); [EOL] assertEquals(0, buffer.getAppendOffset()); [EOL] }
public void testTokenBufferWithNonNullCodec() { [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TokenBuffer buffer = new TokenBuffer(codec); [EOL] assertSame(codec, buffer.getCodec()); [EOL] assertEquals(JsonWriteContext.createRootContext(), buffer.getOutputContext()); [EOL] assertNotNull(buffer.firstSegment()); [EOL] assertEquals(0, buffer.getAppendOffset()); [EOL] }
public void testAsParserWithNonNullObjectCodec() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.setObjectCodec(new ObjectMapper()); [EOL] JsonParser parser = node.asParser(); [EOL] assertNotNull(parser); [EOL] assertEquals(node.getObjectCodec(), parser.getCodec()); [EOL] } [EOL] public void testAsParserWithNullObjectCodec() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.setObjectCodec(null); [EOL] JsonParser parser = node.asParser(); [EOL] assertNotNull(parser); [EOL] assertNull(parser.getCodec()); [EOL] }
public void testAsParserWithNonNullCodec() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null, false); // Assuming TokenBuffer is the class where asParser is defined [EOL] ObjectCodec codec = new ObjectMapper(); // Assuming ObjectMapper can be used as an ObjectCodec [EOL] JsonParser parser = tokenBuffer.asParser(codec); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof Parser); // Assuming Parser is the actual class of the returned object [EOL] assertEquals(codec, parser.getCodec()); [EOL] }
public void testAsParserWithNullCodec() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null, false); [EOL] JsonParser parser = tokenBuffer.asParser(null); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof Parser); [EOL] assertNull(parser.getCodec()); [EOL] }
public void testFirstTokenWithNonNullFirst() { [EOL] JsonToken expectedToken = JsonToken.VALUE_STRING; // Example token [EOL] TokenBuffer mockFirst = Mockito.mock(TokenBuffer.class); [EOL] Mockito.when(mockFirst.type(0)).thenReturn(expectedToken); [EOL] instance._first = mockFirst; [EOL] JsonToken result = instance.firstToken(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedToken, result); [EOL] }
public void testFirstTokenWithNullFirst() { [EOL] instance._first = null; [EOL] JsonToken result = instance.firstToken(); [EOL] assertNull(result); [EOL] }
public void testAppendWithEmptyTokenBuffer() throws IOException { [EOL] TokenBuffer buffer1 = new TokenBuffer(null); [EOL] TokenBuffer buffer2 = new TokenBuffer(null); [EOL] TokenBuffer result = buffer1.append(buffer2); [EOL] assertNotNull(result); [EOL] assertEquals(buffer1, result); [EOL] }
public void testAppendWithNonEmptyTokenBuffer() throws IOException { [EOL] TokenBuffer buffer1 = new TokenBuffer(null); [EOL] buffer1.writeStartObject(); [EOL] buffer1.writeEndObject(); [EOL] TokenBuffer buffer2 = new TokenBuffer(null); [EOL] buffer2.writeFieldName("field"); [EOL] buffer2.writeString("value"); [EOL] TokenBuffer result = buffer1.append(buffer2); [EOL] assertNotNull(result); [EOL] JsonParser jp = result.asParser(); [EOL] assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL] assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL] assertEquals("field", jp.getCurrentName()); [EOL] assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL] assertEquals("value", jp.getText()); [EOL] assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL] assertNull(jp.nextToken()); [EOL] }
public void testSerializeWithEmptySegment() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer.Segment segment = new TokenBuffer.Segment(); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] tokenBuffer.serialize(jgen); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithMultipleTokens() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.START_OBJECT); [EOL] segment.append(1, JsonToken.FIELD_NAME, "fieldName"); [EOL] segment.append(2, JsonToken.VALUE_STRING, "value"); [EOL] segment.append(3, JsonToken.END_OBJECT); [EOL] tokenBuffer.serialize(jgen); [EOL] InOrder inOrder = inOrder(jgen); [EOL] inOrder.verify(jgen).writeStartObject(); [EOL] inOrder.verify(jgen).writeFieldName("fieldName"); [EOL] inOrder.verify(jgen).writeString("value"); [EOL] inOrder.verify(jgen).writeEndObject(); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithValueNumberInt() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.VALUE_NUMBER_INT, 123); [EOL] tokenBuffer.serialize(jgen); [EOL] verify(jgen).writeNumber(123); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithValueNumberFloat() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.VALUE_NUMBER_FLOAT, 1.23d); [EOL] tokenBuffer.serialize(jgen); [EOL] verify(jgen).writeNumber(1.23d); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithBooleanTrue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.VALUE_TRUE); [EOL] tokenBuffer.serialize(jgen); [EOL] verify(jgen).writeBoolean(true); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithBooleanFalse() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.VALUE_FALSE); [EOL] tokenBuffer.serialize(jgen); [EOL] verify(jgen).writeBoolean(false); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithNull() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.VALUE_NULL); [EOL] tokenBuffer.serialize(jgen); [EOL] verify(jgen).writeNull(); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithEmbeddedObject() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] Object embeddedObject = new Object(); [EOL] segment.append(0, JsonToken.VALUE_EMBEDDED_OBJECT, embeddedObject); [EOL] tokenBuffer.serialize(jgen); [EOL] verify(jgen).writeObject(embeddedObject); [EOL] verifyNoMoreInteractions(jgen); [EOL] } [EOL] public void testSerializeWithUnrecognizedValueTypeForNumberFloat() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] TokenBuffer tokenBuffer = new TokenBuffer(jgen, false); [EOL] TokenBuffer.Segment segment = tokenBuffer.getSegment(); [EOL] segment.append(0, JsonToken.VALUE_NUMBER_FLOAT, new Object()); [EOL] assertThrows(JsonGenerationException.class, () -> tokenBuffer.serialize(jgen)); [EOL] }
public void testGetOutputContext() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] JsonWriteContext writeContext = generator.getOutputContext(); [EOL] assertNotNull(writeContext); [EOL] }
public void testWriteStartArray() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); // Assuming createGenerator() is a method that creates a JsonGenerator instance [EOL] generator.writeStartArray(); [EOL] assertEquals(JsonToken.START_ARRAY, getLastToken(generator)); // Assuming getLastToken() retrieves the last token written [EOL] assertTrue(generator.getOutputContext().inArray()); // Assuming getOutputContext() retrieves the current context [EOL] }
public void testWriteEndArrayWithNonNullParentContext() throws IOException { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.writeStartArray(); [EOL] buffer.writeEndArray(); [EOL] assertNotNull(buffer.getOutputContext().getParent()); [EOL] }
public void testWriteEndArrayWithNullParentContext() throws IOException { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.writeEndArray(); [EOL] assertNull(buffer.getOutputContext().getParent()); [EOL] }
public void testWriteStartObject_NewContext() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation method [EOL] generator.writeStartObject(); [EOL] assertEquals(JsonToken.START_OBJECT, generator.getLastToken()); // Replace with actual method to get the last token [EOL] assertNotNull(generator.getWriteContext()); // Replace with actual method to get the write context [EOL] assertTrue(generator.getWriteContext().inObject()); // Replace with actual method to check if the context is in an object [EOL] }
public void testWriteEndObjectWithNonNullParentContext() throws IOException, JsonGenerationException { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.writeStartObject(); [EOL] buffer.writeEndObject(); // This should set the parent context [EOL] buffer.writeEndObject(); // This should trigger the if condition [EOL] } [EOL] public void testWriteEndObjectWithNullParentContext() throws IOException, JsonGenerationException { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.writeEndObject(); // This should not trigger the if condition because parent is null [EOL] }
public void testWriteFieldNameWithValidName() throws IOException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation method [EOL] generator.writeFieldName("testFieldName"); [EOL] assertEquals(JsonToken.FIELD_NAME, generator.getCurrentToken()); [EOL] assertEquals("testFieldName", generator.getCurrentName()); [EOL] }
public void testWriteFieldNameWithNullName() throws IOException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation method [EOL] try { [EOL] generator.writeFieldName(null); [EOL] fail("Expected JsonGenerationException not thrown"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testWriteStringWithValidInput() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates an instance of the JsonGenerator [EOL] char[] text = "Hello, World!".toCharArray(); [EOL] int offset = 0; [EOL] int len = text.length; [EOL] generator.writeString(text, offset, len); [EOL] String expectedOutput = "Hello, World!"; [EOL] String actualOutput = getOutputAsString(generator); // Assuming getOutputAsString() is a method that retrieves the output of the JsonGenerator [EOL] assertEquals(expectedOutput, actualOutput); [EOL] }
public void testWriteStringWithOffsetAndLength() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] char[] text = "Hello, World!".toCharArray(); [EOL] int offset = 7; [EOL] int len = 5; [EOL] generator.writeString(text, offset, len); [EOL] String expectedOutput = "World"; [EOL] String actualOutput = getOutputAsString(generator); [EOL] assertEquals(expectedOutput, actualOutput); [EOL] }
public void testWriteStringWithEmptyString() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] char[] text = "".toCharArray(); [EOL] int offset = 0; [EOL] int len = 0; [EOL] generator.writeString(text, offset, len); [EOL] String expectedOutput = ""; [EOL] String actualOutput = getOutputAsString(generator); [EOL] assertEquals(expectedOutput, actualOutput); [EOL] }
public void writeNumber_withPositiveInt() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] int input = 42; [EOL] generator.writeNumber(input); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, generator.getLastToken()); [EOL] assertEquals(Integer.valueOf(input), generator.getLastValue()); [EOL] }
public void writeNumber_withNegativeInt() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] int input = -42; [EOL] generator.writeNumber(input); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, generator.getLastToken()); [EOL] assertEquals(Integer.valueOf(input), generator.getLastValue()); [EOL] }
public void writeNumber_withZero() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] int input = 0; [EOL] generator.writeNumber(input); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, generator.getLastToken()); [EOL] assertEquals(Integer.valueOf(input), generator.getLastValue()); [EOL] }
public void testWriteBooleanTrue() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual method to create a JsonGenerator [EOL] boolean state = true; [EOL] generator.writeBoolean(state); [EOL] assertTrue(generator.hasToken(JsonToken.VALUE_TRUE)); // Replace with actual method to check if the token is VALUE_TRUE [EOL] }
public void testWriteBooleanFalse() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual method to create a JsonGenerator [EOL] boolean state = false; [EOL] generator.writeBoolean(state); [EOL] assertTrue(generator.hasToken(JsonToken.VALUE_FALSE)); // Replace with actual method to check if the token is VALUE_FALSE [EOL] }
public void testWriteNull() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); [EOL] generator.writeNull(); [EOL] assertEquals(JsonToken.VALUE_NULL, generator.getLastToken()); [EOL] }
public void testWriteObjectWithNull() throws IOException, JsonProcessingException { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.writeObject(null); [EOL] JsonToken token = buffer.asParser().nextToken(); [EOL] assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, token); [EOL] assertNull(buffer.asParser().getEmbeddedObject()); [EOL] }
public void testWriteObjectWithNonNull() throws IOException, JsonProcessingException { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] String testObject = "test"; [EOL] buffer.writeObject(testObject); [EOL] JsonToken token = buffer.asParser().nextToken(); [EOL] assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, token); [EOL] assertEquals(testObject, buffer.asParser().getEmbeddedObject()); [EOL] }
public void testWriteBinaryWithValidInput() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; [EOL] int offset = 2; [EOL] int len = 5; [EOL] JsonGenerator generator = createGenerator(); // Assume createGenerator() properly creates a JsonGenerator instance [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] generator.flush(); [EOL] byte[] expectedOutput = {3, 4, 5, 6, 7}; [EOL] assertArrayEquals(expectedOutput, getOutput(generator)); [EOL] }
public void testWriteBinaryWithOffsetZeroAndFullLength() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonGenerator generator = createGenerator(); // Assume createGenerator() properly creates a JsonGenerator instance [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] generator.flush(); [EOL] assertArrayEquals(data, getOutput(generator)); [EOL] }
public void testWriteBinaryWithOffsetAndLengthExceedingArraySize() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = {1, 2, 3, 4, 5}; [EOL] int offset = 3; [EOL] int len = 5; [EOL] JsonGenerator generator = createGenerator(); // Assume createGenerator() properly creates a JsonGenerator instance [EOL] try { [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWriteBinaryWithNegativeOffset() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = {1, 2, 3, 4, 5}; [EOL] int offset = -1; [EOL] int len = 3; [EOL] JsonGenerator generator = createGenerator(); // Assume createGenerator() properly creates a JsonGenerator instance [EOL] try { [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWriteBinaryWithNegativeLength() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = {1, 2, 3, 4, 5}; [EOL] int offset = 1; [EOL] int len = -1; [EOL] JsonGenerator generator = createGenerator(); // Assume createGenerator() properly creates a JsonGenerator instance [EOL] try { [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] fail("Should have thrown NegativeArraySizeException"); [EOL] } catch (NegativeArraySizeException e) { [EOL] } [EOL] }
public void testCopyCurrentEventWithStartObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartObject(); [EOL] }
public void testCopyCurrentEventWithEndObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndObject(); [EOL] }
public void testCopyCurrentEventWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartArray(); [EOL] }
public void testCopyCurrentEventWithEndArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentEventWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeFieldName("fieldName"); [EOL] }
public void testCopyCurrentEventWithValueStringUsingTextCharacters() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(true); [EOL] when(jp.getTextCharacters()).thenReturn(new char[]{'t', 'e', 'x', 't'}); [EOL] when(jp.getTextOffset()).thenReturn(0); [EOL] when(jp.getTextLength()).thenReturn(4); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString(new char[]{'t', 'e', 'x', 't'}, 0, 4); [EOL] }
public void testCopyCurrentEventWithValueStringWithoutUsingTextCharacters() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(false); [EOL] when(jp.getText()).thenReturn("text"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString("text"); [EOL] }
public void testCopyCurrentEventWithValueNumberIntWithIntType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123); [EOL] }
public void testCopyCurrentEventWithValueNumberIntWithBigIntegerType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] BigInteger bigInteger = new BigInteger("12345678901234567890"); [EOL] when(jp.getBigIntegerValue()).thenReturn(bigInteger); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(bigInteger); [EOL] }
public void testCopyCurrentEventWithValueNumberIntWithDefaultType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); // Assuming LONG is the default type [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123L); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatWithBigDecimalType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] BigDecimal bigDecimal = new BigDecimal("123.456"); [EOL] when(jp.getDecimalValue()).thenReturn(bigDecimal); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(bigDecimal); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatWithFloatType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(123.45f); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.45f); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatWithDefaultType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); // Assuming DOUBLE is the default type [EOL] when(jp.getDoubleValue()).thenReturn(123.456d); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.456d); [EOL] }
public void testCopyCurrentEventWithValueTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(true); [EOL] }
public void testCopyCurrentEventWithValueFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(false); [EOL] }
public void testCopyCurrentEventWithValueNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNull(); [EOL] }
public void testCopyCurrentEventWithValueEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeObject(embeddedObject); [EOL] }
public void testCopyCurrentEventWithDefaultCase() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); // Assuming null will trigger the default case [EOL] assertThrows(RuntimeException.class, () -> { [EOL] copyCurrentEvent(jp); [EOL] }); [EOL] }
public void testCopyCurrentStructureWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp).getCurrentName(); [EOL] verify(jp).nextToken(); [EOL] verify(jp, times(2)).nextToken(); // Verify that nextToken is called twice [EOL] }
public void testCopyCurrentStructureWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp).nextToken(); [EOL] }
public void testCopyCurrentStructureWithStartObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp).nextToken(); [EOL] }
public void testCopyCurrentStructureWithOtherToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testAppendWithNonNullSegment() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer._appendOffset = 0; // Ensure _appendOffset is initially 0 [EOL] buffer._last = new Segment(); [EOL] buffer._append(JsonToken.VALUE_STRING); [EOL] assertNotNull(buffer._last); [EOL] assertEquals(1, buffer._appendOffset); [EOL] }
public void testAppendWithNullSegment() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer._appendOffset = Segment.TOKENS_PER_SEGMENT - 1; // Set to max offset [EOL] buffer._last = new Segment(); [EOL] buffer._append(JsonToken.VALUE_STRING); [EOL] assertNotNull(buffer._last); [EOL] assertEquals(Segment.TOKENS_PER_SEGMENT, buffer._appendOffset); [EOL] }
public void testAppendWithNullNextSegment() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); // Assuming TokenBuffer is the class containing the _append method [EOL] buffer._append(JsonToken.VALUE_STRING, "test"); // Assuming the initial state has _last not null and _appendOffset not at max value [EOL] assertEquals(1, buffer._appendOffset); // Check if _appendOffset is incremented [EOL] }
public void testAppendWithNonNullNextSegment() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); // Assuming TokenBuffer is the class containing the _append method [EOL] setupFullLastSegment(buffer); // This method is not shown, but it would configure the buffer so that _last.append(...) returns a new Segment [EOL] buffer._append(JsonToken.VALUE_STRING, "test"); [EOL] assertNotNull(buffer._last); // Check if _last is updated [EOL] assertEquals(1, buffer._appendOffset); // Check if _appendOffset is reset to 1 [EOL] }
public void testParserConstructorWithNonNullSegmentAndCodec() { [EOL] Segment firstSeg = new Segment(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] Parser parser = new Parser(firstSeg, codec); [EOL] assertNotNull(parser); [EOL] assertEquals(firstSeg, parser._segment); [EOL] assertEquals(-1, parser._segmentPtr); [EOL] assertEquals(codec, parser._codec); [EOL] assertNotNull(parser._parsingContext); [EOL] }
public void testParserConstructorWithNullSegmentAndCodec() { [EOL] Parser parser = new Parser(null, null); [EOL] assertNotNull(parser); [EOL] assertNull(parser._segment); [EOL] assertEquals(-1, parser._segmentPtr); [EOL] assertNull(parser._codec); [EOL] assertNotNull(parser._parsingContext); [EOL] }
public void testCloseWhenAlreadyClosed() { [EOL] YourClass instance = new YourClass(); [EOL] instance.close(); // First call to close, should set _closed to true [EOL] boolean wasClosed = instance.isClosed(); [EOL] assertTrue(wasClosed); // Check if _closed is true after first call [EOL] instance.close(); // Second call to close, _closed should already be true [EOL] wasClosed = instance.isClosed(); [EOL] assertTrue(wasClosed); // Check if _closed is still true [EOL] }
public void testCloseWhenNotClosed() { [EOL] YourClass instance = new YourClass(); [EOL] boolean wasClosed = instance.isClosed(); [EOL] assertFalse(wasClosed); // Check if _closed is false initially [EOL] instance.close(); // Call to close, should set _closed to true [EOL] wasClosed = instance.isClosed(); [EOL] assertTrue(wasClosed); // Check if _closed is true after the call [EOL] }
public void testNextTokenClosedOrNoSegment() throws IOException, JsonParseException { [EOL] YourJacksonParserClass parser = new YourJacksonParserClass(); [EOL] parser.close(); // This should set _closed to true [EOL] JsonToken result = parser.nextToken(); [EOL] assertNull(result); [EOL] }
public void testNextTokenEndOfSegment() throws IOException, JsonParseException { [EOL] YourJacksonParserClass parser = new YourJacksonParserClass(); [EOL] parser.setSegment(new Segment()); // Assuming Segment is a class and setSegment is a method to set _segment [EOL] parser.setSegmentPtr(Segment.TOKENS_PER_SEGMENT - 1); // Assuming setSegmentPtr is a method to set _segmentPtr [EOL] JsonToken result = parser.nextToken(); [EOL] assertNotNull(result); // Assuming that the next segment is not null and has tokens [EOL] }
public void testNextTokenFieldName() throws IOException, JsonParseException { [EOL] YourJacksonParserClass parser = new YourJacksonParserClass(); [EOL] parser.setSegment(new Segment()); // Assuming Segment is a class and setSegment is a method to set _segment [EOL] parser.setSegmentPtr(0); // Set to a position where the next token is FIELD_NAME [EOL] JsonToken result = parser.nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenStartObject() throws IOException, JsonParseException { [EOL] YourJacksonParserClass parser = new YourJacksonParserClass(); [EOL] parser.setSegment(new Segment()); // Assuming Segment is a class and setSegment is a method to set _segment [EOL] parser.setSegmentPtr(0); // Set to a position where the next token is START_OBJECT [EOL] JsonToken result = parser.nextToken(); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenStartArray() throws IOException, JsonParseException { [EOL] YourJacksonParserClass parser = new YourJacksonParserClass(); [EOL] parser.setSegment(new Segment()); // Assuming Segment is a class and setSegment is a method to set _segment [EOL] parser.setSegmentPtr(0); // Set to a position where the next token is START_ARRAY [EOL] JsonToken result = parser.nextToken(); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenEndObjectOrArray() throws IOException, JsonParseException { [EOL] YourJacksonParserClass parser = new YourJacksonParserClass(); [EOL] parser.setSegment(new Segment()); // Assuming Segment is a class and setSegment is a method to set _segment [EOL] parser.setSegmentPtr(0); // Set to a position where the next token is END_OBJECT or END_ARRAY [EOL] JsonToken result = parser.nextToken(); [EOL] assertTrue(result == JsonToken.END_OBJECT || result == JsonToken.END_ARRAY); [EOL] }
public void testGetParsingContext() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] JsonStreamContext context = parser.getParsingContext(); [EOL] assertNotNull(context); [EOL] parser.close(); [EOL] }
public void testGetTextWithValueStringToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, "testString"); [EOL] assertEquals("testString", jp.getText()); [EOL] } [EOL] public void testGetTextWithFieldNameToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.FIELD_NAME, "fieldName"); [EOL] assertEquals("fieldName", jp.getText()); [EOL] } [EOL] public void testGetTextWithNullCurrentObject() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, null); [EOL] assertNull(jp.getText()); [EOL] } [EOL] public void testGetTextWithNonStringCurrentObject() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, new Integer(123)); [EOL] assertEquals("123", jp.getText()); [EOL] } [EOL] public void testGetTextWithNullToken() { [EOL] JsonParser jp = createParserWithToken(null, null); [EOL] assertNull(jp.getText()); [EOL] } [EOL] public void testGetTextWithNumberIntToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_INT, new Integer(123)); [EOL] assertEquals("123", jp.getText()); [EOL] } [EOL] public void testGetTextWithNumberFloatToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT, new Double(12.3)); [EOL] assertEquals("12.3", jp.getText()); [EOL] } [EOL] public void testGetTextWithOtherToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.START_OBJECT, null); [EOL] assertEquals("{", jp.getText()); [EOL] }
private JsonParser createParserWithToken(JsonToken token, Object value) { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(token); [EOL] when(jp.getText()).thenCallRealMethod(); [EOL] when(jp._currentObject()).thenReturn(value); [EOL] return jp; [EOL] }
public void testGetTextCharactersWhenTextIsNull() { [EOL] JsonParser parser = createParserWithNullText(); [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNull("The result should be null when text is null", result); [EOL] } [EOL] public void testGetTextCharactersWhenTextIsNotNull() { [EOL] JsonParser parser = createParserWithNonNullText("someText"); [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull("The result should not be null when text is not null", result); [EOL] assertArrayEquals("The result should match the text's toCharArray", "someText".toCharArray(), result); [EOL] }
public void testGetTextLengthWithNonNullText() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setText("Test String"); [EOL] int length = obj.getTextLength(); [EOL] assertEquals("Test String".length(), length); [EOL] }
public void testGetTextLengthWithNullText() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj.setText(null); [EOL] int length = obj.getTextLength(); [EOL] assertEquals(0, length); [EOL] }
public void testGetTextOffset() { [EOL] JsonParser parser = new MyJsonParser(); [EOL] int offset = parser.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testGetIntValueWithIntToken() throws IOException, JsonParseException { [EOL] JsonParser jp = new JsonParser(); [EOL] jp._currToken = JsonToken.VALUE_NUMBER_INT; [EOL] jp._currentObject = 123; [EOL] int result = jp.getIntValue(); [EOL] assertEquals(123, result); [EOL] }
public void testGetIntValueWithNonIntToken() throws IOException, JsonParseException { [EOL] JsonParser jp = new JsonParser(); [EOL] jp._currToken = JsonToken.VALUE_STRING; [EOL] jp._currentObject = "123"; [EOL] int result = jp.getIntValue(); [EOL] assertEquals(123, result); [EOL] }
public void testGetNumberTypeWithInteger() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(Integer.valueOf(10)); [EOL] assertEquals(NumberType.INT, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithLong() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(Long.valueOf(10L)); [EOL] assertEquals(NumberType.LONG, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithDouble() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(Double.valueOf(10.0)); [EOL] assertEquals(NumberType.DOUBLE, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithBigDecimal() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(new BigDecimal("10")); [EOL] assertEquals(NumberType.BIG_DECIMAL, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithBigInteger() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(new BigInteger("10")); [EOL] assertEquals(NumberType.BIG_INTEGER, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithFloat() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(Float.valueOf(10.0f)); [EOL] assertEquals(NumberType.FLOAT, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithShort() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(Short.valueOf((short)10)); [EOL] assertEquals(NumberType.INT, parser.getNumberType()); [EOL] }
public void testGetNumberTypeWithUnknownNumberType() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumberValue(new AtomicLong(10L)); [EOL] assertNull(parser.getNumberType()); [EOL] }
public void testGetNumberValue_Number() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserForObject(123); // Assuming createParserForObject is a method that sets up a JsonParser with a given object [EOL] jp.nextToken(); // Assuming this method advances the parser to the next token [EOL] Number result = jp.getNumberValue(); [EOL] assertNotNull(result); [EOL] assertEquals(123, result.intValue()); [EOL] }
public void testGetNumberValue_ThrowsJsonParseException() { [EOL] JsonParser jp = createParserForObject("not a number"); // Assuming createParserForObject is a method that sets up a JsonParser with a non-number object [EOL] jp.nextToken(); // Assuming this method advances the parser to the next token [EOL] try { [EOL] jp.getNumberValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, got IOException"); [EOL] } [EOL] }
public void testGetEmbeddedObjectWhenCurrentTokenIsEmbeddedObject() { [EOL] JsonParser parser = createParserWithEmbeddedObjectToken(); [EOL] Object expectedObject = new Object(); [EOL] when(parser.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(parser.getEmbeddedObject()).thenCallRealMethod(); [EOL] when(parser._currentObject()).thenReturn(expectedObject); [EOL] Object result = parser.getEmbeddedObject(); [EOL] assertNotNull(result); [EOL] assertSame(expectedObject, result); [EOL] } [EOL] public void testGetEmbeddedObjectWhenCurrentTokenIsNotEmbeddedObject() { [EOL] JsonParser parser = createParserWithNonEmbeddedObjectToken(); [EOL] when(parser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(parser.getEmbeddedObject()).thenCallRealMethod(); [EOL] Object result = parser.getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testGetBinaryValueWithEmbeddedObject() throws IOException { [EOL] JsonParser parser = createParserWithEmbeddedObject(); [EOL] parser.nextToken(); // Move to VALUE_EMBEDDED_OBJECT [EOL] byte[] result = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof byte[]); [EOL] } [EOL] public void testGetBinaryValueWithString() throws IOException { [EOL] JsonParser parser = createParserWithStringValue(); [EOL] parser.nextToken(); // Move to VALUE_STRING [EOL] byte[] result = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] } [EOL] public void testGetBinaryValueWithInvalidToken() throws IOException { [EOL] JsonParser parser = createParserWithNonStringValue(); [EOL] parser.nextToken(); // Move to a non VALUE_STRING token [EOL] try { [EOL] parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testGetBinaryValueWithNullString() throws IOException { [EOL] JsonParser parser = createParserWithNullStringValue(); [EOL] parser.nextToken(); // Move to VALUE_STRING with null text [EOL] byte[] result = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertNull(result); [EOL] }
private JsonParser createParserWithEmbeddedObject() { [EOL] } [EOL] private JsonParser createParserWithStringValue() { [EOL] } [EOL] private JsonParser createParserWithNonStringValue() { [EOL] } [EOL] private JsonParser createParserWithNullStringValue() { [EOL] }
protected final Object _currentObject() { [EOL] return _segment.get(_segmentPtr); [EOL] }
public void testCheckIsNumberWithNullToken() throws JsonParseException { [EOL] JsonParser jp = createParserWithNullToken(); [EOL] try { [EOL] jp._checkIsNumber(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Current token (null) not numeric, can not use numeric value accessors", e.getMessage()); [EOL] } [EOL] }
public void testCheckIsNumberWithNonNumericToken() throws JsonParseException { [EOL] JsonParser jp = createParserWithNonNumericToken(); [EOL] try { [EOL] jp._checkIsNumber(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Current token (VALUE_STRING) not numeric, can not use numeric value accessors", e.getMessage()); [EOL] } [EOL] }
public void testCheckIsNumberWithNumericToken() throws JsonParseException { [EOL] JsonParser jp = createParserWithNumericToken(); [EOL] jp._checkIsNumber(); [EOL] }
It appears that the provided input text is for a constructor of a class named `Segment` which does not contain any executable lines of code. Since constructors that only contain an opening and closing bracket without any code (`public Segment() { [EOL] }`) do not alter the state of an object or have side effects, there is no meaningful way to generate unit test cases that cover lines of code within the constructor itself. [EOL] However, if the `Segment` class has other methods or state that can be affected or checked, then unit tests could be written for those. Without additional information about the `Segment` class, such as its fields or other methods, it is not possible to generate meaningful unit test cases. [EOL] If you provide more context or additional methods from the `Segment` class, I could help generate unit test cases for those methods.
public void testTypeWithIndexZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance._tokenTypes = 0x0L; // Set the _tokenTypes to a known value [EOL] JsonToken expected = TOKEN_TYPES_BY_INDEX[0]; [EOL] JsonToken actual = instance.type(0); [EOL] assertEquals(expected, actual); [EOL] }
public void testTypeWithPositiveIndex() { [EOL] YourClass instance = new YourClass(); [EOL] instance._tokenTypes = 0xFL; // Set the _tokenTypes to a known value where shifting is needed [EOL] JsonToken expected = TOKEN_TYPES_BY_INDEX[1]; // Assuming the second token type is at index 1 [EOL] JsonToken actual = instance.type(1); [EOL] assertEquals(expected, actual); [EOL] }
public void testTypeWithIndexCausingShiftBeyondTokenTypeArray() { [EOL] YourClass instance = new YourClass(); [EOL] instance._tokenTypes = 0xFFFFFFFFFFFFFFFFL; // Set the _tokenTypes to the max long value [EOL] int index = 16; // This should shift the bits completely out of range [EOL] JsonToken expected = TOKEN_TYPES_BY_INDEX[0]; // Assuming it wraps around to the first token type [EOL] JsonToken actual = instance.type(index); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithValidIndex() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); // Assuming TokenBuffer is the class containing the get method [EOL] buffer.append(1); // Assuming append method exists to add elements [EOL] buffer.append(2); [EOL] buffer.append(3); [EOL] Object result = buffer.get(1); // Index 1 should return the second element [EOL] assertEquals(2, result); // Assuming the elements are of type Integer [EOL] }
public void testGetWithInvalidIndex() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.append(1); [EOL] buffer.append(2); [EOL] try { [EOL] buffer.get(3); // Index 3 is out of bounds [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetWithNegativeIndex() { [EOL] TokenBuffer buffer = new TokenBuffer(null, false); [EOL] buffer.append(1); [EOL] try { [EOL] buffer.get(-1); // Negative index is invalid [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testNextWhenNextIsNull() { [EOL] Segment segment = new Segment(); // Assuming Segment is the class where next() is defined [EOL] assertNull(segment.next()); [EOL] }
public void testNextWhenNextIsNotNull() { [EOL] Segment nextSegment = new Segment(); // Assuming a constructor is available [EOL] Segment segment = new Segment(nextSegment); // Assuming a constructor that takes a Segment [EOL] assertSame(nextSegment, segment.next()); [EOL] }
public void testAppendWithinSegment() { [EOL] Segment segment = new Segment(); [EOL] JsonToken tokenType = JsonToken.VALUE_STRING; [EOL] int index = 5; // Assuming TOKENS_PER_SEGMENT > 5 [EOL] Segment result = segment.append(index, tokenType); [EOL] assertNull(result); [EOL] assertEquals(tokenType, segment.get(index)); [EOL] }
public void testAppendCreatesNewSegment() { [EOL] Segment segment = new Segment(); [EOL] JsonToken tokenType = JsonToken.VALUE_STRING; [EOL] int index = 16; // Assuming TOKENS_PER_SEGMENT <= 16 [EOL] Segment result = segment.append(index, tokenType); [EOL] assertNotNull(result); [EOL] assertEquals(tokenType, result.get(0)); [EOL] }
public void testAppendWithinSegment() { [EOL] Segment segment = new Segment(); [EOL] JsonToken tokenType = JsonToken.VALUE_STRING; [EOL] Object value = "testValue"; [EOL] Segment result = segment.append(0, tokenType, value); [EOL] assertNull(result); [EOL] }
public void testAppendNewSegment() { [EOL] Segment segment = new Segment(); [EOL] JsonToken tokenType = JsonToken.VALUE_STRING; [EOL] Object value = "testValue"; [EOL] Segment result = segment.append(Segment.TOKENS_PER_SEGMENT, tokenType, value); [EOL] assertNotNull(result); [EOL] }
public void testSetWithIndexZero() { [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] tb.set(0, JsonToken.START_OBJECT); [EOL] assertEquals(JsonToken.START_OBJECT, tb.get(0)); [EOL] }
public void testSetWithPositiveIndex() { [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] tb.set(0, JsonToken.START_OBJECT); // Set initial value [EOL] tb.set(1, JsonToken.FIELD_NAME); // Set at index 1 [EOL] assertEquals(JsonToken.FIELD_NAME, tb.get(1)); [EOL] assertEquals(JsonToken.START_OBJECT, tb.get(0)); [EOL] }
public void testSetWithIndexZero() { [EOL] JsonToken tokenType = JsonToken.VALUE_STRING; [EOL] Object value = "test"; [EOL] int index = 0; [EOL] set(index, tokenType, value); [EOL] assertEquals("The value should be set at index 0", value, _tokens[index]); [EOL] assertEquals("The token type code should be set correctly", tokenType.ordinal(), _tokenTypes); [EOL] }
public void testSetWithPositiveIndex() { [EOL] JsonToken tokenType = JsonToken.VALUE_NUMBER_INT; [EOL] Object value = 123; [EOL] int index = 1; [EOL] set(index, tokenType, value); [EOL] assertEquals("The value should be set at index 1", value, _tokens[index]); [EOL] long expectedTokenTypeCode = tokenType.ordinal() << (index << 2); [EOL] assertEquals("The token type code should be shifted left by 4 bits and ORed with existing _tokenTypes", expectedTokenTypeCode, _tokenTypes); [EOL] }
public void testSerializeWithDate() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Date date = new Date(); [EOL] serialize(date, mockJsonGenerator, mockProvider); [EOL] verify(mockProvider).defaultSerializeDateKey(date, mockJsonGenerator); [EOL] verify(mockJsonGenerator, never()).writeFieldName(anyString()); [EOL] }
public void testSerializeWithNonDate() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object nonDateValue = new Object(); [EOL] serialize(nonDateValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeFieldName(nonDateValue.toString()); [EOL] verify(mockProvider, never()).defaultSerializeDateKey(any(Date.class), any(JsonGenerator.class)); [EOL] }
public void testForcedNarrowBySameClass() { [EOL] JavaType originalType = ...; // Initialize with a JavaType instance [EOL] Class<?> sameClass = originalType.getRawClass(); [EOL] JavaType result = originalType.forcedNarrowBy(sameClass); [EOL] assertSame("Forced narrow by the same class should return the same JavaType instance", originalType, result); [EOL] }
public void testForcedNarrowByDifferentClass() { [EOL] JavaType originalType = ...; // Initialize with a JavaType instance [EOL] Class<?> differentClass = ...; // Some different class than originalType's [EOL] JavaType result = originalType.forcedNarrowBy(differentClass); [EOL] assertNotSame("Forced narrow by a different class should not return the same JavaType instance", originalType, result); [EOL] assertNotNull("Resulting JavaType should not be null", result); [EOL] assertEquals("Value handler should be the same after narrowing", originalType.getValueHandler(), result.getValueHandler()); [EOL] assertEquals("Type handler should be the same after narrowing", originalType.getTypeHandler(), result.getTypeHandler()); [EOL] }
public void testForcedNarrowByDifferentClassWithDifferentHandlers() { [EOL] JavaType originalType = ...; // Initialize with a JavaType instance with specific value and type handlers [EOL] Class<?> differentClass = ...; // Some different class than originalType's [EOL] JavaType result = originalType.forcedNarrowBy(differentClass); [EOL] assertNotSame("Forced narrow by a different class should not return the same JavaType instance", originalType, result); [EOL] assertNotNull("Resulting JavaType should not be null", result); [EOL] assertEquals("Value handler should be set to original after narrowing", originalType.getValueHandler(), result.getValueHandler()); [EOL] assertEquals("Type handler should be set to original after narrowing", originalType.getTypeHandler(), result.getTypeHandler()); [EOL] }
public void testPOJONodeWithNull() { [EOL] POJONode node = new POJONode(null); [EOL] assertNull(node.getPojo()); [EOL] }
public void testPOJONodeWithNonNull() { [EOL] Object value = new Object(); [EOL] POJONode node = new POJONode(value); [EOL] assertSame(value, node.getPojo()); [EOL] }
public void testGetNodeType() { [EOL] PojoNode pojoNode = new PojoNode(); [EOL] assertEquals(JsonNodeType.POJO, pojoNode.getNodeType()); [EOL] }
public void testAsToken() { [EOL] MyJsonNode node = new MyJsonNode(); [EOL] JsonToken token = node.asToken(); [EOL] assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, token); [EOL] }
public void testBinaryValueWithByteArray() throws IOException { [EOL] byte[] testData = new byte[]{1, 2, 3, 4}; [EOL] JsonNode node = new JsonNode(testData); [EOL] byte[] result = node.binaryValue(); [EOL] assertArrayEquals(testData, result); [EOL] }
public void testBinaryValueWithNonByteArray() throws IOException { [EOL] String testData = "Not a byte array"; [EOL] JsonNode node = new JsonNode(testData); [EOL] byte[] result = node.binaryValue(); [EOL] byte[] expected = superBinaryValueImplementation(testData); [EOL] assertArrayEquals(expected, result); [EOL] }
public Object getPojo() { [EOL] return _value; [EOL] }
public void testTraverseCreatesTreeTraversingParser() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonParser parser = node.traverse(); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof TreeTraversingParser); [EOL] }
public void testObjectMapperDefaultConstructor() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] assertNotNull(objectMapper); [EOL] }
public void testObjectMapperWithNullFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(null, null, null); [EOL] assertNotNull(mapper); [EOL] assertTrue(mapper.getFactory() instanceof MappingJsonFactory); [EOL] assertNotNull(mapper.getSerializationConfig()); [EOL] assertNotNull(mapper.getDeserializationConfig()); [EOL] assertNotNull(mapper.getSerializerProvider()); [EOL] assertNotNull(mapper.getDeserializationContext()); [EOL] }
public void testObjectMapperWithNonNullFactoryAndCodecNotSet() { [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] assertNull(jsonFactory.getCodec()); [EOL] ObjectMapper mapper = new ObjectMapper(jsonFactory, null, null); [EOL] assertNotNull(mapper); [EOL] assertSame(jsonFactory, mapper.getFactory()); [EOL] assertSame(mapper, jsonFactory.getCodec()); [EOL] assertNotNull(mapper.getSerializationConfig()); [EOL] assertNotNull(mapper.getDeserializationConfig()); [EOL] assertNotNull(mapper.getSerializerProvider()); [EOL] assertNotNull(mapper.getDeserializationContext()); [EOL] }
public void testObjectMapperWithNonNullFactoryAndCodecSet() { [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] ObjectMapper codec = new ObjectMapper(); [EOL] jsonFactory.setCodec(codec); [EOL] ObjectMapper mapper = new ObjectMapper(jsonFactory, null, null); [EOL] assertNotNull(mapper); [EOL] assertSame(jsonFactory, mapper.getFactory()); [EOL] assertSame(codec, jsonFactory.getCodec()); [EOL] assertNotNull(mapper.getSerializationConfig()); [EOL] assertNotNull(mapper.getDeserializationConfig()); [EOL] assertNotNull(mapper.getSerializerProvider()); [EOL] assertNotNull(mapper.getDeserializationContext()); [EOL] }
public void testRegisterModuleWithNullName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new SimpleModule(null, new Version(1, 0, 0, null, null, null)) { [EOL] }; [EOL] try { [EOL] mapper.registerModule(module); [EOL] fail("Should throw IllegalArgumentException for null module name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Module without defined name", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleWithNullVersion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new SimpleModule("TestModule", null) { [EOL] }; [EOL] try { [EOL] mapper.registerModule(module); [EOL] fail("Should throw IllegalArgumentException for null module version"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Module without defined version", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleSuccessfully() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new SimpleModule("TestModule", new Version(1, 0, 0, null, null, null)) { [EOL] }; [EOL] try { [EOL] ObjectMapper result = mapper.registerModule(module); [EOL] assertSame("Expected the same ObjectMapper instance to be returned", mapper, result); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("Should not throw an exception for valid module"); [EOL] } [EOL] }
public void testGetSerializationConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertNotNull(config); [EOL] }
public void testGetDeserializationConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] assertNotNull(config); [EOL] }
public void testSetMixInAnnotationsWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setMixInAnnotations(null); [EOL] assertTrue(mapper._mixInAnnotations.isEmpty()); [EOL] }
public void testSetMixInAnnotationsWithEmptyMap() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Map<Class<?>, Class<?>> sourceMixins = new HashMap<>(); [EOL] mapper.setMixInAnnotations(sourceMixins); [EOL] assertTrue(mapper._mixInAnnotations.isEmpty()); [EOL] }
public void testSetMixInAnnotationsWithNonEmptyMap() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Map<Class<?>, Class<?>> sourceMixins = new HashMap<>(); [EOL] sourceMixins.put(String.class, Integer.class); [EOL] mapper.setMixInAnnotations(sourceMixins); [EOL] assertFalse(mapper._mixInAnnotations.isEmpty()); [EOL] assertEquals(Integer.class, mapper._mixInAnnotations.get(new ClassKey(String.class))); [EOL] }
public void testGetVisibilityChecker() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> visibilityChecker = mapper.getVisibilityChecker(); [EOL] assertNotNull(visibilityChecker); [EOL] }
public void testSetVisibilityCheckerWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> initialVisibilityChecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] VisibilityChecker<?> newVisibilityChecker = VisibilityChecker.Std.defaultInstance().withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL] mapper.setVisibilityChecker(newVisibilityChecker); [EOL] assertNotSame(initialVisibilityChecker, mapper.getSerializationConfig().getDefaultVisibilityChecker()); [EOL] assertNotSame(initialVisibilityChecker, mapper.getDeserializationConfig().getDefaultVisibilityChecker()); [EOL] assertEquals(newVisibilityChecker, mapper.getSerializationConfig().getDefaultVisibilityChecker()); [EOL] assertEquals(newVisibilityChecker, mapper.getDeserializationConfig().getDefaultVisibilityChecker()); [EOL] }
public void testSetVisibilityCheckerWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertThrows(IllegalArgumentException.class, () -> mapper.setVisibilityChecker(null)); [EOL] }
public void testSetVisibilityNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonAutoDetect.Visibility visibility = JsonAutoDetect.Visibility.ANY; [EOL] ObjectMapper result = mapper.setVisibility(PropertyAccessor.FIELD, visibility); [EOL] assertNotNull(result); [EOL] assertEquals(visibility, result.getSerializationConfig().getDefaultVisibilityChecker().getFieldVisibility()); [EOL] assertEquals(visibility, result.getDeserializationConfig().getDefaultVisibilityChecker().getFieldVisibility()); [EOL] }
public void testSetVisibilityNullAccessor() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.setVisibility(null, JsonAutoDetect.Visibility.ANY); [EOL] fail("Should not allow null PropertyAccessor"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetVisibilityNullVisibility() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.setVisibility(PropertyAccessor.FIELD, null); [EOL] fail("Should not allow null Visibility"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetTypeFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] assertNotNull(typeFactory); [EOL] }
public void testSetTypeFactoryWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] ObjectMapper resultMapper = mapper.setTypeFactory(typeFactory); [EOL] assertNotNull(resultMapper); [EOL] assertSame(typeFactory, resultMapper.getTypeFactory()); [EOL] assertSame(typeFactory, resultMapper.getDeserializationConfig().getTypeFactory()); [EOL] assertSame(typeFactory, resultMapper.getSerializationConfig().getTypeFactory()); [EOL] }
public void testSetTypeFactoryWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.setTypeFactory(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetNodeFactoryWithNonNullFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNodeFactory factory = new JsonNodeFactory(true); [EOL] ObjectMapper result = mapper.setNodeFactory(factory); [EOL] assertNotNull(result); [EOL] assertEquals(factory, result.getNodeFactory()); [EOL] } [EOL] public void testSetNodeFactoryWithNullFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.setNodeFactory(null); [EOL] fail("Should not allow setting null JsonNodeFactory"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFactory() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] JsonFactory factory = objectMapper.getFactory(); [EOL] assertNotNull(factory); [EOL] }
public void testSetDateFormatWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); [EOL] ObjectMapper returnedMapper = mapper.setDateFormat(df); [EOL] assertSame(mapper, returnedMapper); [EOL] assertSame(df, mapper.getSerializationConfig().getDateFormat()); [EOL] assertSame(df, mapper.getDeserializationConfig().getDateFormat()); [EOL] }
public void testSetDateFormatWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper returnedMapper = mapper.setDateFormat(null); [EOL] assertSame(mapper, returnedMapper); [EOL] assertNull(mapper.getSerializationConfig().getDateFormat()); [EOL] assertNull(mapper.getDeserializationConfig().getDateFormat()); [EOL] }
public void testSetTimeZoneWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] ObjectMapper returnedMapper = mapper.setTimeZone(timeZone); [EOL] assertSame(mapper, returnedMapper); [EOL] assertEquals(timeZone, mapper.getSerializationConfig().getTimeZone()); [EOL] assertEquals(timeZone, mapper.getDeserializationConfig().getTimeZone()); [EOL] }
public void testSetTimeZoneWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone defaultTimeZone = TimeZone.getDefault(); [EOL] ObjectMapper returnedMapper = mapper.setTimeZone(null); [EOL] assertSame(mapper, returnedMapper); [EOL] assertEquals(defaultTimeZone, mapper.getSerializationConfig().getTimeZone()); [EOL] assertEquals(defaultTimeZone, mapper.getDeserializationConfig().getTimeZone()); [EOL] }
public void testConfigureEnableSerializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] boolean state = true; [EOL] ObjectMapper result = mapper.configure(feature, state); [EOL] assertTrue(result.getSerializationConfig().isEnabled(feature)); [EOL] } [EOL] public void testConfigureDisableSerializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] boolean state = false; [EOL] ObjectMapper result = mapper.configure(feature, state); [EOL] assertFalse(result.getSerializationConfig().isEnabled(feature)); [EOL] }
public void testDisableSingleFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES); [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue(mapper.getSerializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] mapper.disable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES); [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertFalse(mapper.getSerializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testDisableMultipleFeatures() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, MapperFeature.AUTO_DETECT_FIELDS); [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue(mapper.getSerializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] assertTrue(mapper.getSerializationConfig().isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] mapper.disable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, MapperFeature.AUTO_DETECT_FIELDS); [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertFalse(mapper.getSerializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] assertFalse(mapper.getSerializationConfig().isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] mapper.enable(feature); [EOL] boolean result = mapper.isEnabled(feature); [EOL] assert result; [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] mapper.disable(feature); [EOL] boolean result = mapper.isEnabled(feature); [EOL] assert !result; [EOL] }
public void testGetNodeFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNodeFactory factory = mapper.getNodeFactory(); [EOL] assertNotNull(factory); [EOL] assertTrue(factory instanceof JsonNodeFactory); [EOL] }
public void testReadValuesWithValidParserAndType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] when(getDeserializationConfig()).thenReturn(config); [EOL] when(createDeserializationContext(jp, config)).thenReturn(ctxt); [EOL] when(_findRootDeserializer(ctxt, valueType)).thenReturn(deser); [EOL] MappingIterator<?> result = readValues(jp, valueType); [EOL] assertNotNull(result); [EOL] assertEquals(jp, result.getParser()); [EOL] assertEquals(ctxt, result.getContext()); [EOL] assertEquals(deser, result.getDeserializer()); [EOL] assertFalse(result.isClosed()); [EOL] }
public void testReadValuesWithIOException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(getDeserializationConfig()).thenReturn(config); [EOL] when(createDeserializationContext(jp, config)).thenReturn(ctxt); [EOL] when(_findRootDeserializer(ctxt, valueType)).thenThrow(new IOException()); [EOL] assertThrows(IOException.class, () -> { [EOL] readValues(jp, valueType); [EOL] }); [EOL] }
public void testReadValuesWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(getDeserializationConfig()).thenReturn(config); [EOL] when(createDeserializationContext(jp, config)).thenReturn(ctxt); [EOL] when(_findRootDeserializer(ctxt, valueType)).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] readValues(jp, valueType); [EOL] }); [EOL] }
public void testReadValuesWithValidParserAndClass() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] MappingIterator<String> iterator = mapper.readValues(jp, String.class); [EOL] assertNotNull(iterator); [EOL] }
public void testReadValuesWithNullParser() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValues(null, String.class); [EOL] fail("Should not pass when parser is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException was not expected"); [EOL] } [EOL] }
public void testReadValuesWithNullClass() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValues(jp, null); [EOL] fail("Should not pass when class is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException was not expected"); [EOL] } [EOL] }
public void writeTreeTest_NullRootNode() throws IOException, JsonProcessingException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode rootNode = null; [EOL] mapper.writeTree(jgen, rootNode); [EOL] verify(jgen, never()).flush(); [EOL] } [EOL] public void writeTreeTest_NonNullRootNode_FlushDisabled() throws IOException, JsonProcessingException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode rootNode = mock(JsonNode.class); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] when(config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)).thenReturn(false); [EOL] mapper.writeTree(jgen, rootNode); [EOL] verify(jgen, never()).flush(); [EOL] } [EOL] public void writeTreeTest_NonNullRootNode_FlushEnabled() throws IOException, JsonProcessingException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode rootNode = mock(JsonNode.class); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] when(config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)).thenReturn(true); [EOL] mapper.writeTree(jgen, rootNode); [EOL] verify(jgen).flush(); [EOL] }
public void testTreeToValueWithNonObjectClassAssignable() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = new JsonNodeFactory(false).objectNode(); [EOL] Class<TreeNode> valueType = TreeNode.class; [EOL] TreeNode result = mapper.treeToValue(treeNode, valueType); [EOL] assertSame(treeNode, result); [EOL] } [EOL] public void testTreeToValueWithObjectClass() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = new JsonNodeFactory(false).objectNode(); [EOL] Class<Object> valueType = Object.class; [EOL] Object result = mapper.treeToValue(treeNode, valueType); [EOL] assertNotNull(result); [EOL] assertNotSame(treeNode, result); [EOL] } [EOL] public void testTreeToValueWithIOException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = mock(TreeNode.class); [EOL] Class<Object> valueType = Object.class; [EOL] when(treeNode.traverse()).thenThrow(IOException.class); [EOL] try { [EOL] mapper.treeToValue(treeNode, valueType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertNotNull(e.getCause()); [EOL] assertTrue(e.getCause() instanceof IOException); [EOL] } catch (JsonProcessingException e) { [EOL] fail("Expected IllegalArgumentException, not JsonProcessingException"); [EOL] } [EOL] } [EOL] public void testTreeToValueWithJsonProcessingException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = mock(TreeNode.class); [EOL] Class<Object> valueType = Object.class; [EOL] when(treeNode.traverse()).thenThrow(JsonProcessingException.class); [EOL] try { [EOL] mapper.treeToValue(treeNode, valueType); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected JsonProcessingException, not " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testReadValueWithValidStringAndClass() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "{\"name\":\"John\", \"age\":30}"; [EOL] Person result = mapper.readValue(jsonContent, Person.class); [EOL] assertNotNull(result); [EOL] assertEquals("John", result.getName()); [EOL] assertEquals(30, result.getAge()); [EOL] } [EOL] public void testReadValueWithInvalidJsonString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String invalidJsonContent = "Invalid JSON"; [EOL] try { [EOL] mapper.readValue(invalidJsonContent, Person.class); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, not IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithNullString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue((String) null, Person.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalArgumentException, not IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithEmptyString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue("", Person.class); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, not IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "{\"name\":\"John\", \"age\":30}"; [EOL] try { [EOL] mapper.readValue(jsonContent, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalArgumentException, not IOException"); [EOL] } [EOL] }
public void testWriteValueWithValidWriterAndValue() throws IOException, JsonGenerationException, JsonMappingException { [EOL] Writer mockWriter = new StringWriter(); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.writeValue(mockWriter, value); [EOL] assertFalse(mockWriter.toString().isEmpty()); [EOL] }
public void testWriteValueWithNullWriter() { [EOL] Writer mockWriter = null; [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] assertThrows(NullPointerException.class, () -> objectMapper.writeValue(mockWriter, value)); [EOL] }
public void testWriteValueWithNullValue() throws IOException, JsonGenerationException, JsonMappingException { [EOL] Writer mockWriter = new StringWriter(); [EOL] Object value = null; [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.writeValue(mockWriter, value); [EOL] assertTrue(mockWriter.toString().isEmpty() || mockWriter.toString().equals("null")); [EOL] }
public void testWriterWithType_NullRootType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithType((JavaType) null); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithType_ValidRootType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.constructType(String.class); [EOL] ObjectWriter writer = mapper.writerWithType(javaType); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithValidSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FormatSchema schema = new MyFormatSchemaImpl(); // Assuming MyFormatSchemaImpl is a valid implementation of FormatSchema [EOL] ObjectWriter writer = mapper.writer(schema); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithNullSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] ObjectWriter writer = mapper.writer(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReaderForUpdatingWithNonNullValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object valueToUpdate = new Object(); [EOL] ObjectReader reader = mapper.readerForUpdating(valueToUpdate); [EOL] assertNotNull(reader); [EOL] }
public void testReaderForUpdatingWithNullValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] ObjectReader reader = mapper.readerForUpdating(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReaderWithNonNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(String.class); [EOL] ObjectReader reader = mapper.reader(type); [EOL] assertNotNull(reader); [EOL] }
public void testReaderWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] ObjectReader reader = mapper.reader(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReaderWithValidClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(String.class); [EOL] assertNotNull(reader); [EOL] assertEquals(reader.getValueType(), String.class); [EOL] }
public void testReaderWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.reader(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void test_serializerProviderWithNonNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] DefaultSerializerProvider provider = mapper._serializerProvider(config); [EOL] assertNotNull(provider); [EOL] }
public void test_serializerProviderWithNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper._serializerProvider(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateDeserializationContextWithNonNullValues() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationConfig cfg = mock(DeserializationConfig.class); [EOL] InjectableValues injectableValues = mock(InjectableValues.class); [EOL] DefaultDeserializationContext baseContext = mock(DefaultDeserializationContext.class); [EOL] when(baseContext.createInstance(any(DeserializationConfig.class), any(JsonParser.class), any(InjectableValues.class))) [EOL] .thenReturn(mock(DefaultDeserializationContext.class)); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setInjectableValues(injectableValues); [EOL] DefaultDeserializationContext initialContext = mapper.getDeserializationContext(); [EOL] setField(initialContext, "_deserializationContext", baseContext); [EOL] DefaultDeserializationContext resultContext = initialContext.createDeserializationContext(jp, cfg); [EOL] assertNotNull(resultContext); [EOL] }
public void testCreateDeserializationContextWithNullParserAndConfig() { [EOL] JsonParser jp = null; [EOL] DeserializationConfig cfg = null; [EOL] InjectableValues injectableValues = mock(InjectableValues.class); [EOL] DefaultDeserializationContext baseContext = mock(DefaultDeserializationContext.class); [EOL] when(baseContext.createInstance(any(DeserializationConfig.class), any(JsonParser.class), any(InjectableValues.class))) [EOL] .thenReturn(mock(DefaultDeserializationContext.class)); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setInjectableValues(injectableValues); [EOL] DefaultDeserializationContext initialContext = mapper.getDeserializationContext(); [EOL] setField(initialContext, "_deserializationContext", baseContext); [EOL] DefaultDeserializationContext resultContext = initialContext.createDeserializationContext(jp, cfg); [EOL] assertNotNull(resultContext); [EOL] }
public void testReadMapAndCloseWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(deser.getNullValue()).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] when(createDeserializationContext(jp, getDeserializationConfig())).thenReturn(ctxt); [EOL] when(_findRootDeserializer(ctxt, valueType)).thenReturn(deser); [EOL] Object result = _readMapAndClose(jp, valueType); [EOL] verify(jp).close(); [EOL] assertNull(result); [EOL] }
public void testReadMapAndCloseWithEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = _readMapAndClose(jp, valueType); [EOL] verify(jp).close(); [EOL] assertNull(result); [EOL] }
public void testReadMapAndCloseWithRegularValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationConfig cfg = mock(DeserializationConfig.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_STRING); [EOL] when(getDeserializationConfig()).thenReturn(cfg); [EOL] when(createDeserializationContext(jp, cfg)).thenReturn(ctxt); [EOL] when(_findRootDeserializer(ctxt, valueType)).thenReturn(deser); [EOL] when(cfg.useRootWrapping()).thenReturn(false); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _readMapAndClose(jp, valueType); [EOL] verify(jp).close(); [EOL] assertNotNull(result); [EOL] }
public void testReadMapAndCloseWithRootWrapping() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] DeserializationConfig cfg = mock(DeserializationConfig.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_STRING); [EOL] when(getDeserializationConfig()).thenReturn(cfg); [EOL] when(createDeserializationContext(jp, cfg)).thenReturn(ctxt); [EOL] when(_findRootDeserializer(ctxt, valueType)).thenReturn(deser); [EOL] when(cfg.useRootWrapping()).thenReturn(true); [EOL] when(_unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser)).thenReturn(new Object()); [EOL] Object result = _readMapAndClose(jp, valueType); [EOL] verify(jp).close(); [EOL] assertNotNull(result); [EOL] }
public void testInitForReadingWithCurrentTokenNotNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonToken result = _initForReading(jp); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testInitForReadingWithCurrentTokenNullAndNextTokenNotNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonToken result = _initForReading(jp); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testInitForReadingWithCurrentTokenNullAndNextTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(null); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] _initForReading(jp); [EOL] }); [EOL] assertEquals("No content to map due to end-of-input", exception.getMessage()); [EOL] }
public void testFindRootDeserializerWithCachedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] ConcurrentHashMap<JavaType, JsonDeserializer<Object>> rootDeserializers = new ConcurrentHashMap<>(); [EOL] rootDeserializers.put(valueType, expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers = rootDeserializers; [EOL] JsonDeserializer<Object> actualDeserializer = mapper._findRootDeserializer(ctxt, valueType); [EOL] assertSame(expectedDeserializer, actualDeserializer); [EOL] }
public void testFindRootDeserializerWithoutCachedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers = new ConcurrentHashMap<>(); [EOL] JsonDeserializer<Object> actualDeserializer = mapper._findRootDeserializer(ctxt, valueType); [EOL] assertSame(expectedDeserializer, actualDeserializer); [EOL] assertTrue(mapper._rootDeserializers.containsKey(valueType)); [EOL] }
public void testFindRootDeserializerThrowsException() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers = new ConcurrentHashMap<>(); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] mapper._findRootDeserializer(ctxt, valueType); [EOL] }); [EOL] assertEquals("Can not find a deserializer for type " + valueType, exception.getMessage()); [EOL] }
public void testBooleanNodeTrue() { [EOL] BooleanNode node = new BooleanNode(true); [EOL] assertTrue(node.booleanValue()); [EOL] }
public void testBooleanNodeFalse() { [EOL] BooleanNode node = new BooleanNode(false); [EOL] assertFalse(node.booleanValue()); [EOL] }
public void testAsIntWithTrueValue() { [EOL] JsonBoolean jsonBooleanTrue = new JsonBoolean(true); [EOL] int result = jsonBooleanTrue.asInt(0); [EOL] assert result == 1; [EOL] }
public void testAsIntWithFalseValue() { [EOL] JsonBoolean jsonBooleanFalse = new JsonBoolean(false); [EOL] int result = jsonBooleanFalse.asInt(0); [EOL] assert result == 0; [EOL] }
public void testSerializeTrueValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] BooleanSerializer serializer = new BooleanSerializer(); [EOL] serializer.serialize(mockJsonGenerator, null, true); [EOL] verify(mockJsonGenerator).writeBoolean(true); [EOL] }
public void testSerializeFalseValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] BooleanSerializer serializer = new BooleanSerializer(); [EOL] serializer.serialize(mockJsonGenerator, null, false); [EOL] verify(mockJsonGenerator).writeBoolean(false); [EOL] }
public void testChainedTransformerWithNonNullTransformers() { [EOL] NameTransformer prefixTransformer = NameTransformer.simpleTransformer("Mr. ", null); [EOL] NameTransformer suffixTransformer = NameTransformer.simpleTransformer(null, " Jr."); [EOL] NameTransformer chained = NameTransformer.chainedTransformer(prefixTransformer, suffixTransformer); [EOL] String originalName = "John Doe"; [EOL] String transformedName = chained.transform(originalName); [EOL] String reversedName = chained.reverse(transformedName); [EOL] assertEquals("Mr. John Doe Jr.", transformedName); [EOL] assertEquals("John Doe", reversedName); [EOL] }
public void testChainedTransformerWithNoOpTransformers() { [EOL] NameTransformer chained = NameTransformer.chainedTransformer(NameTransformer.NOP, NameTransformer.NOP); [EOL] String originalName = "Jane Doe"; [EOL] String transformedName = chained.transform(originalName); [EOL] String reversedName = chained.reverse(transformedName); [EOL] assertEquals("Jane Doe", transformedName); [EOL] assertEquals("Jane Doe", reversedName); [EOL] }
public void testChainedTransformerWithOneNoOpTransformer() { [EOL] NameTransformer prefixTransformer = NameTransformer.simpleTransformer("Ms. ", null); [EOL] NameTransformer chained = NameTransformer.chainedTransformer(prefixTransformer, NameTransformer.NOP); [EOL] String originalName = "Alice Smith"; [EOL] String transformedName = chained.transform(originalName); [EOL] String reversedName = chained.reverse(transformedName); [EOL] assertEquals("Ms. Alice Smith", transformedName); [EOL] assertEquals("Alice Smith", reversedName); [EOL] }
public void testChainedConstructor() { [EOL] NameTransformer t1 = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "t1_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] return transformed.substring(3); [EOL] } [EOL] }; [EOL] NameTransformer t2 = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "t2_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] return transformed.substring(3); [EOL] } [EOL] }; [EOL] NameTransformer chained = new Chained(t1, t2); [EOL] assertNotNull(chained); [EOL] assertEquals("t2_t1_testName", chained.transform("testName")); [EOL] assertEquals("testName", chained.reverse("t2_t1_testName")); [EOL] }
public void testSimpleTransformer() { [EOL] String prefix = "prefix_"; [EOL] String suffix = "_suffix"; [EOL] NameTransformer simpleTransformer = NameTransformer.simpleTransformer(prefix, suffix); [EOL] assertNotNull(simpleTransformer); [EOL] assertEquals(prefix + "testName" + suffix, simpleTransformer.transform("testName")); [EOL] assertEquals("testName", simpleTransformer.reverse(prefix + "testName" + suffix)); [EOL] }
public void testChainedTransformer() { [EOL] NameTransformer t1 = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "t1_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] return transformed.substring(3); [EOL] } [EOL] }; [EOL] NameTransformer t2 = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "t2_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] return transformed.substring(3); [EOL] } [EOL] }; [EOL] NameTransformer chainedTransformer = NameTransformer.chainedTransformer(t1, t2); [EOL] assertNotNull(chainedTransformer); [EOL] assertEquals("t2_t1_testName", chainedTransformer.transform("testName")); [EOL] assertEquals("testName", chainedTransformer.reverse("t2_t1_testName")); [EOL] }
public void testNOPTransformer() { [EOL] NameTransformer nopTransformer = NameTransformer.NOP; [EOL] assertNotNull(nopTransformer); [EOL] assertEquals("testName", nopTransformer.transform("testName")); [EOL] assertEquals("testName", nopTransformer.reverse("testName")); [EOL] }
public void testChainedTransformWithSimpleTransformers() { [EOL] NameTransformer prefixTransformer = NameTransformer.simpleTransformer("Mr. ", null); [EOL] NameTransformer suffixTransformer = NameTransformer.simpleTransformer(null, " Jr."); [EOL] NameTransformer chainedTransformer = NameTransformer.chainedTransformer(prefixTransformer, suffixTransformer); [EOL] String originalName = "John Doe"; [EOL] String transformedName = chainedTransformer.transform(originalName); [EOL] assertEquals("Mr. John Doe Jr.", transformedName); [EOL] }
public void testChainedTransformWithNoOpAndSimpleTransformer() { [EOL] NameTransformer noOpTransformer = NameTransformer.NOP; [EOL] NameTransformer suffixTransformer = NameTransformer.simpleTransformer(null, " Sr."); [EOL] NameTransformer chainedTransformer = NameTransformer.chainedTransformer(noOpTransformer, suffixTransformer); [EOL] String originalName = "Jane Doe"; [EOL] String transformedName = chainedTransformer.transform(originalName); [EOL] assertEquals("Jane Doe Sr.", transformedName); [EOL] }
public void testChainedTransformWithTwoNoOps() { [EOL] NameTransformer noOpTransformer1 = NameTransformer.NOP; [EOL] NameTransformer noOpTransformer2 = NameTransformer.NOP; [EOL] NameTransformer chainedTransformer = NameTransformer.chainedTransformer(noOpTransformer1, noOpTransformer2); [EOL] String originalName = "Alice Smith"; [EOL] String transformedName = chainedTransformer.transform(originalName); [EOL] assertEquals("Alice Smith", transformedName); [EOL] }
public void testIsDefaultDeserializerWithNonNullDeserializerHavingJacksonStdImpl() { [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] when(deserializer.getClass().getAnnotation(JacksonStdImpl.class)).thenReturn(mock(JacksonStdImpl.class)); [EOL] boolean result = isDefaultDeserializer(deserializer); [EOL] assertTrue(result); [EOL] }
public void testIsDefaultDeserializerWithNonNullDeserializerNotHavingJacksonStdImpl() { [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] when(deserializer.getClass().getAnnotation(JacksonStdImpl.class)).thenReturn(null); [EOL] boolean result = isDefaultDeserializer(deserializer); [EOL] assertFalse(result); [EOL] }
public void testIsDefaultDeserializerWithNullDeserializer() { [EOL] boolean result = isDefaultDeserializer(null); [EOL] assertFalse(result); [EOL] }
public void testParseIntPrimitiveWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntPrimitiveWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getIntValue()).thenReturn(456); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(456, result); [EOL] }
public void testParseIntPrimitiveWithStringTokenLongValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("2147483648"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonMappingException("Overflow: numeric value (2147483648) out of range of int (-2147483648 - 2147483647)")); [EOL] assertThrows(JsonMappingException.class, () -> _parseIntPrimitive(jp, ctxt)); [EOL] }
public void testParseIntPrimitiveWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntPrimitiveWithStringTokenValidValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123"); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntPrimitiveWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] int result = _parseIntPrimitive(jp, ctxt); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntPrimitiveWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("Cannot map NOT_AVAILABLE token")); [EOL] assertThrows(JsonMappingException.class, () -> _parseIntPrimitive(jp, ctxt)); [EOL] }
public void testParseFloatWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(10.0f), result); [EOL] }
public void testParseFloatWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(20.0f); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(20.0f), result); [EOL] }
public void testParseFloatWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(null); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseFloatWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.POSITIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NEGATIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NaN, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] _parseFloat(jp, ctxt); [EOL] }); [EOL] }
public void testParseFloatWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseFloatWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] _parseFloat(jp, ctxt); [EOL] }); [EOL] }
public void testParseFloatPrimitiveWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(10.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(20.0f); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(20.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(Float.POSITIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(Float.NaN, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(Float.NEGATIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenValidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(123.45f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithStringTokenInvalidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a float"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonMappingException("not a valid float value")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] _parseFloatPrimitive(jp, ctxt); [EOL] }); [EOL] }
public void testParseFloatPrimitiveWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] float result = _parseFloatPrimitive(jp, ctxt); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testParseFloatPrimitiveWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("Unexpected token")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] _parseFloatPrimitive(jp, ctxt); [EOL] }); [EOL] }
public void testParseDoublePrimitiveWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getDoubleValue()).thenReturn(123.0); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(123.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(456.0); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(456.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(Double.POSITIVE_INFINITY, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(Double.NEGATIVE_INFINITY, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(Double.NaN, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithStringTokenValidNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(123.45, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithStringTokenInvalidNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonMappingException("not a valid double value")); [EOL] assertThrows(JsonMappingException.class, () -> _parseDoublePrimitive(jp, ctxt)); [EOL] }
public void testParseDoublePrimitiveWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("Unexpected token")); [EOL] assertThrows(JsonMappingException.class, () -> _parseDoublePrimitive(jp, ctxt)); [EOL] }
public void testParseStringWithValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("testString"); [EOL] String result = _parseString(jp, ctxt); [EOL] assertEquals("testString", result); [EOL] }
public void testParseStringWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.mappingException(String.class, JsonToken.VALUE_STRING)).thenThrow(new JsonMappingException("Mapping exception")); [EOL] try { [EOL] _parseString(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testWithNonNullTypeResolverBuilder() { [EOL] TypeResolverBuilder<?> trb = new StdTypeResolverBuilder(); [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.with(trb); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithNullTypeResolverBuilder() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.with(null); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithVisibilityCheckerNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> originalVisibilityChecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] VisibilityChecker<?> newVisibilityChecker = VisibilityChecker.Std.defaultInstance().withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL] SerializationConfig originalConfig = mapper.getSerializationConfig(); [EOL] SerializationConfig newConfig = originalConfig.with(newVisibilityChecker); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertNotSame(originalVisibilityChecker, newConfig.getDefaultVisibilityChecker()); [EOL] assertEquals(JsonAutoDetect.Visibility.ANY, newConfig.getDefaultVisibilityChecker().getFieldVisibility()); [EOL] }
public void testWithVisibilityCheckerNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig originalConfig = mapper.getSerializationConfig(); [EOL] try { [EOL] SerializationConfig newConfig = originalConfig.with(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithVisibilityForMethodNullVisibilityNonNull() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] PropertyAccessor forMethod = PropertyAccessor.GETTER; // or any other valid PropertyAccessor [EOL] JsonAutoDetect.Visibility visibility = null; [EOL] SerializationConfig newConfig = config.withVisibility(forMethod, visibility); [EOL] assertNotNull(newConfig); [EOL] assertEquals(config.getDefaultVisibilityChecker().withVisibility(forMethod, visibility), [EOL] newConfig.getDefaultVisibilityChecker()); [EOL] }
public void testWithVisibilityForMethodNonNullVisibilityNonNull() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] PropertyAccessor forMethod = PropertyAccessor.GETTER; // or any other valid PropertyAccessor [EOL] JsonAutoDetect.Visibility visibility = JsonAutoDetect.Visibility.ANY; [EOL] SerializationConfig newConfig = config.withVisibility(forMethod, visibility); [EOL] assertNotNull(newConfig); [EOL] assertEquals(visibility, newConfig.getDefaultVisibilityChecker().findVisibility(forMethod)); [EOL] }
public void testFindWithUnregisteredClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(String.class, "UnregisteredClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithURI() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "java.net.URI"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URIDeserializer); [EOL] }
public void testFindWithURL() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URL.class, "java.net.URL"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URLDeserializer); [EOL] }
public void testFindWithFile() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(File.class, "java.io.File"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FileDeserializer); [EOL] }
public void testFindWithUUID() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(UUID.class, "java.util.UUID"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof UUIDDeserializer); [EOL] }
public void testFindWithCurrency() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Currency.class, "java.util.Currency"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CurrencyDeserializer); [EOL] }
public void testFindWithPattern() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Pattern.class, "java.util.regex.Pattern"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof PatternDeserializer); [EOL] }
public void testFindWithLocale() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Locale.class, "java.util.Locale"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LocaleDeserializer); [EOL] }
public void testFindWithInetAddress() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(InetAddress.class, "java.net.InetAddress"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof InetAddressDeserializer); [EOL] }
public void testFindWithCharset() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Charset.class, "java.nio.charset.Charset"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharsetDeserializer); [EOL] }
public void testFindWithClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Class.class, "java.lang.Class"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ClassDeserializer); [EOL] }
public void testFindWithStackTraceElement() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(StackTraceElement.class, "java.lang.StackTraceElement"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StackTraceElementDeserializer); [EOL] }
public void testFindWithAtomicBoolean() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(AtomicBoolean.class, "java.util.concurrent.atomic.AtomicBoolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof AtomicBooleanDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(Object.class, "java.lang.Object"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testURIDeserializerConstructor() { [EOL] URIDeserializer deserializer = new URIDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeValidURI() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validURIString = "http://www.example.com"; [EOL] URI expectedURI = URI.create(validURIString); [EOL] URI result = _deserialize(validURIString, ctxt); [EOL] assertEquals(expectedURI, result); [EOL] }
public void testDeserializeInvalidURI() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String invalidURIString = "invalid_uri"; [EOL] try { [EOL] _deserialize(invalidURIString, ctxt); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCurrencyDeserializerConstructor() { [EOL] CurrencyDeserializer deserializer = new CurrencyDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeValidCurrencyCode() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CurrencyDeserializer deserializer = new CurrencyDeserializer(); [EOL] String validCurrencyCode = "USD"; [EOL] Currency expectedCurrency = Currency.getInstance(validCurrencyCode); [EOL] Currency actualCurrency = deserializer._deserialize(validCurrencyCode, ctxt); [EOL] assertEquals(expectedCurrency, actualCurrency); [EOL] }
public void testDeserializeInvalidCurrencyCode() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CurrencyDeserializer deserializer = new CurrencyDeserializer(); [EOL] String invalidCurrencyCode = "XYZ"; [EOL] try { [EOL] deserializer._deserialize(invalidCurrencyCode, ctxt); [EOL] fail("Expected IllegalArgumentException for invalid currency code"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPatternDeserializerConstructor() { [EOL] PatternDeserializer deserializer = new PatternDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(Pattern.class, deserializer.handledType()); [EOL] }
public void testDeserializeValidPattern() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validPatternString = "[a-zA-Z]+"; [EOL] PatternDeserializer deserializer = new PatternDeserializer(); [EOL] Pattern result = deserializer._deserialize(validPatternString, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(validPatternString, result.pattern()); [EOL] }
public void testDeserializeInvalidPattern() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String invalidPatternString = "[a-z"; [EOL] PatternDeserializer deserializer = new PatternDeserializer(); [EOL] try { [EOL] deserializer._deserialize(invalidPatternString, ctxt); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFileDeserializerConstructor() { [EOL] FileDeserializer deserializer = new FileDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithValidPath() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validPath = "valid/path/to/file.txt"; [EOL] File result = _deserialize(validPath, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(validPath, result.getPath()); [EOL] } [EOL] public void testDeserializeWithEmptyString() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String emptyPath = ""; [EOL] File result = _deserialize(emptyPath, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(emptyPath, result.getPath()); [EOL] } [EOL] public void testDeserializeWithNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String nullPath = null; [EOL] try { [EOL] _deserialize(nullPath, ctxt); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("File path cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testForPropertySameProperty() { [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] AsPropertyTypeSerializer serializer = new AsPropertyTypeSerializer(mock(TypeIdResolver.class), prop, "typePropertyName"); [EOL] AsPropertyTypeSerializer result = serializer.forProperty(prop); [EOL] assertSame(serializer, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] BeanProperty prop1 = mock(BeanProperty.class); [EOL] BeanProperty prop2 = mock(BeanProperty.class); [EOL] AsPropertyTypeSerializer serializer = new AsPropertyTypeSerializer(mock(TypeIdResolver.class), prop1, "typePropertyName"); [EOL] AsPropertyTypeSerializer result = serializer.forProperty(prop2); [EOL] assertNotNull(result); [EOL] assertNotSame(serializer, result); [EOL] assertEquals("typePropertyName", result.getTypePropertyName()); [EOL] }
public void testWriteTypePrefixForObject_NullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] resolver.writeTypePrefixForObject(null, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator, never()).writeStringField(anyString(), anyString()); [EOL] }
public void testWriteTypePrefixForObject_WithValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] Object value = new Object(); [EOL] resolver.writeTypePrefixForObject(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeStringField(anyString(), eq(resolver.idFromValue(value))); [EOL] }
public void writeTypeSuffixForObject_withValidJsonGenerator_shouldWriteEndObject() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] MinimalPrettyPrinter prettyPrinter = new MinimalPrettyPrinter(); [EOL] prettyPrinter.writeTypeSuffixForObject(new Object(), mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testFieldPropertyWithNonNullField() { [EOL] FieldProperty src = createMockFieldProperty(); [EOL] Field f = createMockField(); [EOL] FieldProperty result = new FieldProperty(src, f); [EOL] assertNotNull(result); [EOL] assertEquals(f, result.getField()); [EOL] } [EOL] public void testFieldPropertyWithNullField() { [EOL] FieldProperty src = createMockFieldProperty(); [EOL] try { [EOL] new FieldProperty(src, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetAndReturnValidValue() throws Exception { [EOL] Object instance = new MyClass("initialValue"); [EOL] Object value = "newValue"; [EOL] Field field = MyClass.class.getDeclaredField("fieldName"); [EOL] field.setAccessible(true); [EOL] FieldAccessor accessor = new FieldAccessor(field); [EOL] Object result = accessor.setAndReturn(instance, value); [EOL] assertSame("The returned instance should be the same as the one passed in.", instance, result); [EOL] assertEquals("The field value should be updated to the new value.", value, field.get(instance)); [EOL] }
public void testSetAndReturnWithIllegalAccessException() throws Exception { [EOL] Object instance = new MyClass("initialValue"); [EOL] Object value = "newValue"; [EOL] Field field = MyClass.class.getDeclaredField("fieldName"); [EOL] field.setAccessible(false); // Make the field not accessible to induce an IllegalAccessException [EOL] FieldAccessor accessor = new FieldAccessor(field); [EOL] try { [EOL] accessor.setAndReturn(instance, value); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSetAndReturnWithIllegalArgumentException() throws Exception { [EOL] Object instance = new MyClass("initialValue"); [EOL] Object value = new Object(); // Assuming the field does not accept this type, causing an IllegalArgumentException [EOL] Field field = MyClass.class.getDeclaredField("fieldName"); [EOL] field.setAccessible(true); [EOL] FieldAccessor accessor = new FieldAccessor(field); [EOL] try { [EOL] accessor.setAndReturn(instance, value); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testReadResolve() { [EOL] FieldProperty original = new FieldProperty(/* parameters to construct a valid FieldProperty */); [EOL] Object resolved = original.readResolve(); [EOL] assertNotNull(resolved); [EOL] assertTrue(resolved instanceof FieldProperty); [EOL] FieldProperty resolvedFieldProperty = (FieldProperty) resolved; [EOL] assertEquals(original.getAnnotated(), resolvedFieldProperty.getAnnotated()); [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src) { [EOL] this(src, src._ignoreAllUnknown); [EOL] }
public void testResolveWithObjectCreatableFromObjectWith() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(_valueInstantiator.getFromObjectArguments(any(DeserializationConfig.class))).thenReturn(creatorProps); [EOL] _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL] when(_propertyBasedCreator.properties()).thenReturn(new SettableBeanProperty[0]); [EOL] resolve(ctxt); [EOL] assertNull(_externalTypeIdHandler); [EOL] assertFalse(_nonStandardCreation); [EOL] assertTrue(_vanillaProcessing); [EOL] }
public void testResolveWithObjectCreatableAndExternalTypeProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[1]; [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] creatorProps[0] = prop; [EOL] when(_valueInstantiator.getFromObjectArguments(any(DeserializationConfig.class))).thenReturn(creatorProps); [EOL] _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL] when(_propertyBasedCreator.properties()).thenReturn(creatorProps); [EOL] when(prop.hasValueTypeDeserializer()).thenReturn(true); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(prop.getValueTypeDeserializer()).thenReturn(typeDeser); [EOL] when(typeDeser.getTypeInclusion()).thenReturn(JsonTypeInfo.As.EXTERNAL_PROPERTY); [EOL] resolve(ctxt); [EOL] assertNotNull(_externalTypeIdHandler); [EOL] assertTrue(_nonStandardCreation); [EOL] assertFalse(_vanillaProcessing); [EOL] }
public void testResolveWithUnwrappedProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] SettableBeanProperty[] beanProps = new SettableBeanProperty[1]; [EOL] SettableBeanProperty origProp = mock(SettableBeanProperty.class); [EOL] beanProps[0] = origProp; [EOL] when(_beanProperties.iterator()).thenReturn(Arrays.asList(beanProps).iterator()); [EOL] when(origProp.hasValueDeserializer()).thenReturn(false); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(findDeserializer(ctxt, origProp.getType(), origProp)).thenReturn(deser); [EOL] SettableBeanProperty prop = origProp.withValueDeserializer(deser); [EOL] when(_resolveUnwrappedProperty(ctxt, prop)).thenReturn(prop); [EOL] resolve(ctxt); [EOL] assertNotNull(_unwrappedPropertyHandler); [EOL] assertTrue(_nonStandardCreation); [EOL] assertFalse(_vanillaProcessing); [EOL] }
public void testResolveWithDelegateType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(delegateType); [EOL] AnnotatedWithParams delegateCreator = mock(AnnotatedWithParams.class); [EOL] when(_valueInstantiator.getDelegateCreator()).thenReturn(delegateCreator); [EOL] BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(findDeserializer(ctxt, delegateType, property)).thenReturn(deser); [EOL] resolve(ctxt); [EOL] assertNotNull(_delegateDeserializer); [EOL] assertFalse(_vanillaProcessing); [EOL] }
public void testResolveWithInvalidDelegateType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(null); [EOL] assertThrows(IllegalArgumentException.class, () -> resolve(ctxt)); [EOL] }
public void testCreateContextualWithNullPropertyAndIntr() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDeserializerBase instance = new BeanDeserializerBase() { [EOL] }; [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullIntr() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] BeanDeserializerBase instance = new BeanDeserializerBase() { [EOL] }; [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithIgnorals() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findPropertiesToIgnore(accessor)).thenReturn(new String[]{"propToIgnore"}); [EOL] BeanDeserializerBase instance = new BeanDeserializerBase() { [EOL] }; [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithObjectIdInfo() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] BeanDeserializerBase instance = new BeanDeserializerBase() { [EOL] @Override [EOL] public SettableBeanProperty findProperty(String propertyName) { [EOL] return mock(SettableBeanProperty.class); [EOL] } [EOL] }; [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithInvalidObjectIdDefinition() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] BeanDeserializerBase instance = new BeanDeserializerBase() { [EOL] @Override [EOL] public SettableBeanProperty findProperty(String propertyName) { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] instance.createContextual(ctxt, property); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateContextualWithArrayShape() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findFormat(accessor)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] BeanDeserializerBase instance = new BeanDeserializerBase() { [EOL] @Override [EOL] public JsonDeserializer<Object> asArrayDeserializer() { [EOL] return mock(JsonDeserializer.class); [EOL] } [EOL] }; [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testResolveManagedReferencePropertyWithNullRefName() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithNullRefName(); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertSame("Property should be the same when refName is null", prop, result); [EOL] } [EOL] public void testResolveManagedReferencePropertyWithBeanDeserializerBase() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createBeanDeserializerBase()); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Result should not be null for BeanDeserializerBase", result); [EOL] assertTrue("Result should be instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithContainerDeserializerBaseAndInvalidContentDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createContainerDeserializerBaseWithInvalidContentDeserializer()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected for invalid content deserializer"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithContainerDeserializerBaseAndBeanDeserializerBase() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createContainerDeserializerBaseWithBeanDeserializerBase()); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Result should not be null for valid ContainerDeserializerBase", result); [EOL] assertTrue("Result should be instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithAbstractDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createAbstractDeserializer()); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Result should not be null for AbstractDeserializer", result); [EOL] assertTrue("Result should be instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithInvalidDeserializerType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createInvalidDeserializer()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected for invalid deserializer type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithNoBackReferenceProperty() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createDeserializerWithNoBackReference()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected when no back reference property is found"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithIncompatibleTypes() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createDeserializerWithIncompatibleTypes()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected for incompatible types"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindBackReferenceWithNullBackRefs() { [EOL] SettableBeanProperty result = instance.findBackReference("someLogicalName"); [EOL] assertNull(result); [EOL] }
public void testFindBackReferenceWithNonNullBackRefsAndKeyExists() { [EOL] instance.setBackRefs(new HashMap<String, SettableBeanProperty>()); [EOL] instance.getBackRefs().put("existingKey", expectedProperty); [EOL] SettableBeanProperty result = instance.findBackReference("existingKey"); [EOL] assertSame(expectedProperty, result); [EOL] }
public void testFindBackReferenceWithNonNullBackRefsAndKeyDoesNotExist() { [EOL] instance.setBackRefs(new HashMap<String, SettableBeanProperty>()); [EOL] SettableBeanProperty result = instance.findBackReference("nonExistingKey"); [EOL] assertNull(result); [EOL] }
public void testInjectValuesWithNoInjectables() throws IOException, JsonProcessingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] BeanPropertyMapTestWrapper beanPropertyMap = new BeanPropertyMapTestWrapper(Collections.emptyList()); [EOL] beanPropertyMap.injectValues(ctxt, bean); [EOL] }
public void testInjectValuesWithSingleInjectable() throws IOException, JsonProcessingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ValueInjector injector = mock(ValueInjector.class); [EOL] List<ValueInjector> injectables = Collections.singletonList(injector); [EOL] BeanPropertyMapTestWrapper beanPropertyMap = new BeanPropertyMapTestWrapper(injectables); [EOL] beanPropertyMap.injectValues(ctxt, bean); [EOL] verify(injector, times(1)).inject(ctxt, bean); [EOL] }
public void testInjectValuesWithMultipleInjectables() throws IOException, JsonProcessingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ValueInjector injector1 = mock(ValueInjector.class); [EOL] ValueInjector injector2 = mock(ValueInjector.class); [EOL] List<ValueInjector> injectables = Arrays.asList(injector1, injector2); [EOL] BeanPropertyMapTestWrapper beanPropertyMap = new BeanPropertyMapTestWrapper(injectables); [EOL] beanPropertyMap.injectValues(ctxt, bean); [EOL] verify(injector1, times(1)).inject(ctxt, bean); [EOL] verify(injector2, times(1)).inject(ctxt, bean); [EOL] }
public void testHandleUnknownPropertiesWithEmptyTokenBuffer() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer unknownTokens = new TokenBuffer(null, false); [EOL] unknownTokens.writeStartObject(); // to balance the writeEndObject call [EOL] unknownTokens.writeEndObject(); [EOL] Object result = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL] assertEquals("The bean should be returned as is", bean, result); [EOL] }
public void testHandleUnknownPropertiesWithOneUnknownProperty() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer unknownTokens = new TokenBuffer(null, false); [EOL] unknownTokens.writeStartObject(); [EOL] unknownTokens.writeFieldName("unknownProperty"); [EOL] unknownTokens.writeString("unknownValue"); [EOL] unknownTokens.writeEndObject(); [EOL] doAnswer(invocation -> { [EOL] String propName = invocation.getArgument(3); [EOL] assertEquals("The property name should be 'unknownProperty'", "unknownProperty", propName); [EOL] return null; [EOL] }).when(ctxt).handleUnknownProperty(any(JsonParser.class), any(DeserializationContext.class), any(), anyString()); [EOL] Object result = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL] assertEquals("The bean should be returned as is", bean, result); [EOL] }
public void testHandleUnknownPropertiesWithMultipleUnknownProperties() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer unknownTokens = new TokenBuffer(null, false); [EOL] unknownTokens.writeStartObject(); [EOL] unknownTokens.writeFieldName("unknownProperty1"); [EOL] unknownTokens.writeString("unknownValue1"); [EOL] unknownTokens.writeFieldName("unknownProperty2"); [EOL] unknownTokens.writeString("unknownValue2"); [EOL] unknownTokens.writeEndObject(); [EOL] final List<String> handledProperties = new ArrayList<>(); [EOL] doAnswer(invocation -> { [EOL] String propName = invocation.getArgument(3); [EOL] handledProperties.add(propName); [EOL] return null; [EOL] }).when(ctxt).handleUnknownProperty(any(JsonParser.class), any(DeserializationContext.class), any(), anyString()); [EOL] Object result = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL] assertEquals("The bean should be returned as is", bean, result); [EOL] assertTrue("Both unknown properties should be handled", handledProperties.containsAll(Arrays.asList("unknownProperty1", "unknownProperty2"))); [EOL] }
public void testWrapAndThrowWithInvocationTargetException() throws IOException { [EOL] Throwable cause = new Throwable("root cause"); [EOL] Throwable t = new InvocationTargetException(cause); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = null; // Assuming DeserializationContext can be null or a mock if required [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals(cause, e.getCause()); [EOL] assertEquals("field", e.getPathReference()); [EOL] } [EOL] }
public void testWrapAndThrowWithError() { [EOL] Throwable t = new Error("error"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = null; [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected Error to be thrown"); [EOL] } catch (Error e) { [EOL] assertEquals("error", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithIOExceptionAndWrapDisabled() throws IOException { [EOL] Throwable t = new IOException("io exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(false); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("io exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithRuntimeExceptionAndWrapDisabled() { [EOL] Throwable t = new RuntimeException("runtime exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(false); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithOtherExceptionAndWrapEnabled() throws IOException { [EOL] Throwable t = new Exception("exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)).thenReturn(true); [EOL] try { [EOL] wrapAndThrow(t, bean, fieldName, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals(t, e.getCause()); [EOL] assertEquals("field", e.getPathReference()); [EOL] } [EOL] }
protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt) throws IOException { [EOL] while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL] t = t.getCause(); [EOL] } [EOL] if (t instanceof Error) { [EOL] throw (Error) t; [EOL] } [EOL] boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL] if (t instanceof IOException) { [EOL] throw (IOException) t; [EOL] } else if (!wrap) { [EOL] if (t instanceof RuntimeException) { [EOL] throw (RuntimeException) t; [EOL] } [EOL] } [EOL] throw ctxt.instantiationException(_beanType.getRawClass(), t); [EOL] }
public void testDeserializeAnyWithStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] }
public void testDeserializeAnyWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(data); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBinary()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectPojo() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] Object pojo = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(pojo); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isPojo()); [EOL] }
public void testDeserializeAnyWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isTextual()); [EOL] }
public void testDeserializeAnyWithValueNumberIntBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345678901234567890")); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBigInteger()); [EOL] }
public void testDeserializeAnyWithValueNumberIntInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isInt()); [EOL] }
public void testDeserializeAnyWithValueNumberIntLong() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isLong()); [EOL] }
public void testDeserializeAnyWithValueNumberFloatBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBigDecimal()); [EOL] }
public void testDeserializeAnyWithValueNumberFloatDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isDouble()); [EOL] }
public void testDeserializeAnyWithValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertTrue(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertFalse(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(null); // Invalid token [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeAny(jp, ctxt, nodeFactory); [EOL] }); [EOL] }
public void testAddReferencePropertiesWithNonNullRefsAndMethodMember() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] Map<String, AnnotatedMember> refs = new HashMap<>(); [EOL] AnnotatedMethod method = mock(AnnotatedMethod.class); [EOL] when(method.getGenericParameterType(0)).thenReturn(String.class); [EOL] refs.put("backRef", method); [EOL] when(beanDesc.findBackReferenceProperties()).thenReturn(refs); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] verify(builder).addBackReferenceProperty(eq("backRef"), any(SettableBeanProperty.class)); [EOL] }
public void testAddReferencePropertiesWithNonNullRefsAndNonMethodMember() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] Map<String, AnnotatedMember> refs = new HashMap<>(); [EOL] AnnotatedMember nonMethod = mock(AnnotatedMember.class); [EOL] when(nonMethod.getRawType()).thenReturn(String.class); [EOL] refs.put("backRef", nonMethod); [EOL] when(beanDesc.findBackReferenceProperties()).thenReturn(refs); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] verify(builder).addBackReferenceProperty(eq("backRef"), any(SettableBeanProperty.class)); [EOL] }
public void testAddReferencePropertiesWithNullRefs() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(beanDesc.findBackReferenceProperties()).thenReturn(null); [EOL] addReferenceProperties(ctxt, beanDesc, builder); [EOL] verify(builder, never()).addBackReferenceProperty(anyString(), any(SettableBeanProperty.class)); [EOL] }
public void testAddInjectablesWithNonNullRawAndFixAccessTrue() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] Map<Object, AnnotatedMember> raw = new HashMap<>(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] raw.put("key", member); [EOL] when(beanDesc.findInjectables()).thenReturn(raw); [EOL] when(ctxt.canOverrideAccessModifiers()).thenReturn(true); [EOL] doNothing().when(member).fixAccess(); [EOL] when(member.getName()).thenReturn("memberName"); [EOL] when(member.getGenericType()).thenReturn(mock(Type.class)); [EOL] when(beanDesc.resolveType(any(Type.class))).thenReturn(mock(JavaType.class)); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] verify(member).fixAccess(); [EOL] verify(builder).addInjectable(anyString(), any(JavaType.class), any(Annotations.class), any(AnnotatedMember.class), any()); [EOL] } [EOL] public void testAddInjectablesWithNonNullRawAndFixAccessFalse() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] Map<Object, AnnotatedMember> raw = new HashMap<>(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] raw.put("key", member); [EOL] when(beanDesc.findInjectables()).thenReturn(raw); [EOL] when(ctxt.canOverrideAccessModifiers()).thenReturn(false); [EOL] when(member.getName()).thenReturn("memberName"); [EOL] when(member.getGenericType()).thenReturn(mock(Type.class)); [EOL] when(beanDesc.resolveType(any(Type.class))).thenReturn(mock(JavaType.class)); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] verify(member, never()).fixAccess(); [EOL] verify(builder).addInjectable(anyString(), any(JavaType.class), any(Annotations.class), any(AnnotatedMember.class), any()); [EOL] } [EOL] public void testAddInjectablesWithNullRaw() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(beanDesc.findInjectables()).thenReturn(null); [EOL] addInjectables(ctxt, beanDesc, builder); [EOL] verify(builder, never()).addInjectable(anyString(), any(JavaType.class), any(Annotations.class), any(AnnotatedMember.class), any()); [EOL] }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL] AnnotatedMember mutator = propDef.getMutator(); [EOL] if (ctxt.canOverrideAccessModifiers()) { [EOL] mutator.fixAccess(); [EOL] } [EOL] JavaType t0 = beanDesc.resolveType(jdkType); [EOL] BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL] JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL] if (type != t0) { [EOL] property = property.withType(type); [EOL] } [EOL] JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL] type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL] TypeDeserializer typeDeser = type.getTypeHandler(); [EOL] SettableBeanProperty prop; [EOL] if (mutator instanceof AnnotatedMethod) { [EOL] prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL] } else { [EOL] prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL] } [EOL] if (propDeser != null) { [EOL] prop = prop.withValueDeserializer(propDeser); [EOL] } [EOL] AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL] if (ref != null && ref.isManagedReference()) { [EOL] prop.setManagedReferenceName(ref.getName()); [EOL] } [EOL] return prop; [EOL] }
public void testCreateKeySerializerWithKeySerializers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = new JsonSerializer<Object>() {}; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = null; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (factoryConfig.hasKeySerializers()) { [EOL] for (Serializers serializers : factoryConfig.keySerializers()) { [EOL] ser = serializers.findSerializer(config, keyType, beanDesc); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] ser = defaultImpl; [EOL] if (ser == null) { [EOL] ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL] } [EOL] } [EOL] if (factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertNotNull(result); [EOL] }
public void testCreateKeySerializerWithDefaultImpl() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = new JsonSerializer<Object>() {}; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = null; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (ser == null) { [EOL] ser = defaultImpl; [EOL] if (ser == null) { [EOL] ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertNotNull(result); [EOL] }
public void testCreateKeySerializerWithSerializerModifiers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType keyType = new JavaType(); [EOL] JsonSerializer<Object> defaultImpl = new JsonSerializer<Object>() {}; [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL] JsonSerializer<?> ser = null; [EOL] FactoryConfig factoryConfig = new FactoryConfig(); [EOL] if (ser == null) { [EOL] ser = defaultImpl; [EOL] if (ser == null) { [EOL] ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL] } [EOL] } [EOL] if (factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL] } [EOL] } [EOL] JsonSerializer<Object> result = (JsonSerializer<Object>) ser; [EOL] assertNotNull(result); [EOL] }
public void testCreateTypeSerializerWithNoTypeResolverAndNoDefaultTyper() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNull(result); [EOL] }
public void testCreateTypeSerializerWithTypeResolverFromAnnotationIntrospector() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] when(ai.findTypeResolver(config, null, baseType)).thenReturn(builder); [EOL] when(builder.buildTypeSerializer(config, baseType, null)).thenReturn(mock(TypeSerializer.class)); [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testCreateTypeSerializerWithDefaultTyper() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findTypeResolver(config, null, baseType)).thenReturn(null); [EOL] TypeResolverBuilder<?> defaultBuilder = mock(TypeResolverBuilder.class); [EOL] when(config.getDefaultTyper(baseType)).thenReturn(defaultBuilder); [EOL] when(defaultBuilder.buildTypeSerializer(config, baseType, null)).thenReturn(mock(TypeSerializer.class)); [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testCreateTypeSerializerWithTypeResolverAndSubtypes() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] SubtypeResolver subtypeResolver = mock(SubtypeResolver.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(config.getSubtypeResolver()).thenReturn(subtypeResolver); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] when(ai.findTypeResolver(config, null, baseType)).thenReturn(builder); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] when(subtypeResolver.collectAndResolveSubtypes(null, config, ai)).thenReturn(subtypes); [EOL] when(builder.buildTypeSerializer(config, baseType, subtypes)).thenReturn(mock(TypeSerializer.class)); [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByLookupWithConcrete() { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] _concrete.put(String.class.getName(), expectedSerializer); [EOL] JsonSerializer<?> result = findSerializerByLookup(type, config, beanDesc, true); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindSerializerByLookupWithConcreteLazy() throws Exception { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] Class<? extends JsonSerializer<?>> serClass = mock(Class.class); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] when(serClass.newInstance()).thenReturn(expectedSerializer); [EOL] _concreteLazy.put(String.class.getName(), serClass); [EOL] JsonSerializer<?> result = findSerializerByLookup(type, config, beanDesc, true); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindSerializerByLookupWithException() { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] Class<? extends JsonSerializer<?>> serClass = mock(Class.class); [EOL] when(serClass.newInstance()).thenThrow(new InstantiationException()); [EOL] _concreteLazy.put(String.class.getName(), serClass); [EOL] try { [EOL] findSerializerByLookup(type, config, beanDesc, true); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindSerializerByLookupWithNull() { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonSerializer<?> result = findSerializerByLookup(type, config, beanDesc, true); [EOL] assertNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithInetAddress() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(InetAddress.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof InetAddressSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithTimeZone() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(TimeZone.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithCharset() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.nio.charset.Charset.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof ToStringSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithNumber() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Number.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof NumberSerializers.NumberSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithEnum() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Enum.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithCalendar() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof CalendarSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithDate() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.util.Date.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof DateSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithOptionalStdSerializer() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(SomeOtherClass.class); // Replace with a class that triggers the optional standard serializer [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; // Adjust based on the scenario [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithNull() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); // Use a class that does not match any condition [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNull(result); [EOL] }
public void testFindSerializerByAddonTypeWithIterator() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(javaType.getRawClass()).thenReturn(Iterator.class); [EOL] JsonSerializer<?> result = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IteratorSerializer); [EOL] }
public void testFindSerializerByAddonTypeWithIterable() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(javaType.getRawClass()).thenReturn(Iterable.class); [EOL] JsonSerializer<?> result = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IterableSerializer); [EOL] }
public void testFindSerializerByAddonTypeWithCharSequence() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(javaType.getRawClass()).thenReturn(CharSequence.class); [EOL] JsonSerializer<?> result = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNotNull(result); [EOL] assertSame(ToStringSerializer.instance, result); [EOL] }
public void testFindSerializerByAddonTypeWithUnmatchedType() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType javaType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(javaType.getRawClass()).thenReturn(Object.class); [EOL] JsonSerializer<?> result = findSerializerByAddonType(config, javaType, beanDesc, true); [EOL] assertNull(result); [EOL] }
public void testBuildCollectionSerializerWithCustomSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndEnumSet() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(EnumSet.class, new JavaType(EnumType.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdContainerSerializers.EnumSetSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndIndexedList() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(ArrayList.class, new JavaType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndStringCollection() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndOtherCollection() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(Object.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertFalse(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithSerializerModifiers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(Object.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] _factoryConfig.addSerializerModifier(new BeanSerializerModifier()); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testBuildMapSerializerWithCustomSerializer() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] MapType type = new MapType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<Object> keySerializer = new JsonSerializer<>(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<>(); [EOL] JsonSerializer<?> result = buildMapSerializer(config, type, beanDesc, true, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testBuildMapSerializerWithEnumMap() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] MapType type = new MapType(EnumMap.class, new JavaType(), new JavaType()); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<Object> keySerializer = new JsonSerializer<>(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<>(); [EOL] JsonSerializer<?> result = buildMapSerializer(config, type, beanDesc, true, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] assertTrue(result instanceof EnumMapSerializer); [EOL] }
public void testBuildMapSerializerWithModifiers() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] MapType type = new MapType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<Object> keySerializer = new JsonSerializer<>(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<>(); [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] _factoryConfig.addSerializerModifier(new BeanSerializerModifier()); [EOL] JsonSerializer<?> result = buildMapSerializer(config, type, beanDesc, true, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL] JsonSerializer<?> ser = null; [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] Class<?> raw = type.getRawClass(); [EOL] if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL] if (String[].class == raw) { [EOL] ser = StringArraySerializer.instance; [EOL] } else { [EOL] ser = StdArraySerializers.findStandardImpl(raw); [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL] } [EOL] } [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL] } [EOL] } [EOL] return ser; [EOL] }
public void testBuildIteratorSerializerWithNullContainedType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization with a type that has null containedType [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = false; // or true, depending on what you want to test [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, staticTyping); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof SomeExpectedTypeSerializer); // Replace with the expected serializer type [EOL] }
public void testBuildIteratorSerializerWithNonNullContainedType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization with a type that has non-null containedType [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = false; // or true, depending on what you want to test [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, staticTyping); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof SomeExpectedTypeSerializer); // Replace with the expected serializer type [EOL] }
public void testBuildIteratorSerializerWithStaticTyping() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = true; [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, staticTyping); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof SomeExpectedTypeSerializer); // Replace with the expected serializer type [EOL] }
public void testBuildEnumSerializerWithFormatShapeObject() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.OBJECT); [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertNull(result); [EOL] verify((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL] }
public void testBuildEnumSerializerWithoutFormatShapeObject() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // Different shape to cover the else branch [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testBuildEnumSerializerWithSerializerModifiers() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // To avoid entering the if block [EOL] SerializerFactoryConfig factoryConfig = mock(SerializerFactoryConfig.class); [EOL] when(factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] BeanSerializerModifier modifier = mock(BeanSerializerModifier.class); [EOL] when(factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonSerializer<?> modifiedSerializer = mock(JsonSerializer.class); [EOL] when(modifier.modifyEnumSerializer(any(), any(), any(), any())).thenReturn(modifiedSerializer); [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertSame(modifiedSerializer, result); [EOL] }
protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL] Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); [EOL] if (superclass != null) { [EOL] try { [EOL] type = (T) type.widenBy(superclass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new IllegalArgumentException("Failed to widen type " + type + " with concrete-type annotation (value " + superclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage()); [EOL] } [EOL] } [EOL] return modifySecondaryTypesByAnnotation(config, a, type); [EOL] }
public void testUsesStaticTypingWithTypeSerializerNotNull() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] boolean result = usesStaticTyping(config, beanDesc, typeSer); [EOL] assertFalse(result); [EOL] }
public void testUsesStaticTypingWithAnnotationTypingStatic() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationTyping(any())).thenReturn(JsonSerialize.Typing.STATIC); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertTrue(result); [EOL] }
public void testUsesStaticTypingWithAnnotationTypingNonStatic() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationTyping(any())).thenReturn(JsonSerialize.Typing.DYNAMIC); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertFalse(result); [EOL] }
public void testUsesStaticTypingWithConfigEnabled() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertTrue(result); [EOL] }
public void testUsesStaticTypingWithConfigDisabled() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(false); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertFalse(result); [EOL] }
public void testAnnotatedClassConstructor() { [EOL] Class<?> cls = Object.class; [EOL] List<Class<?>> superTypes = new ArrayList<>(); [EOL] superTypes.add(String.class); [EOL] AnnotationIntrospector aintr = null; [EOL] MixInResolver mir = null; [EOL] AnnotationMap classAnnotations = new AnnotationMap(); [EOL] AnnotatedClass ac = new AnnotatedClass(cls, superTypes, aintr, mir, classAnnotations); [EOL] assertNotNull(ac); [EOL] assertEquals(cls, ac._class); [EOL] assertEquals(superTypes, ac._superTypes); [EOL] assertNull(ac._annotationIntrospector); [EOL] assertNull(ac._mixInResolver); [EOL] assertNull(ac._primaryMixIn); [EOL] assertEquals(classAnnotations, ac._classAnnotations); [EOL] }
public void testAnnotatedClassConstructorWithMixInResolver() { [EOL] Class<?> cls = Object.class; [EOL] List<Class<?>> superTypes = new ArrayList<>(); [EOL] superTypes.add(String.class); [EOL] AnnotationIntrospector aintr = null; [EOL] MixInResolver mir = new MixInResolver() { [EOL] @Override [EOL] public Class<?> findMixInClassFor(Class<?> target) { [EOL] return (target == Object.class) ? String.class : null; [EOL] } [EOL] }; [EOL] AnnotationMap classAnnotations = new AnnotationMap(); [EOL] AnnotatedClass ac = new AnnotatedClass(cls, superTypes, aintr, mir, classAnnotations); [EOL] assertNotNull(ac); [EOL] assertEquals(cls, ac._class); [EOL] assertEquals(superTypes, ac._superTypes); [EOL] assertNull(ac._annotationIntrospector); [EOL] assertNotNull(ac._mixInResolver); [EOL] assertEquals(String.class, ac._primaryMixIn); [EOL] assertEquals(classAnnotations, ac._classAnnotations); [EOL] }
public void testConstructWithNonNullValues() { [EOL] Class<?> cls = Object.class; [EOL] AnnotationIntrospector aintr = mock(AnnotationIntrospector.class); [EOL] MixInResolver mir = mock(MixInResolver.class); [EOL] AnnotatedClass annotatedClass = AnnotatedClass.construct(cls, aintr, mir); [EOL] assertNotNull(annotatedClass); [EOL] }
public void testConstructWithNullValues() { [EOL] Class<?> cls = Object.class; [EOL] AnnotatedClass annotatedClass = AnnotatedClass.construct(cls, null, null); [EOL] assertNotNull(annotatedClass); [EOL] }
public void testHasAnnotationsWhenClassAnnotationsIsNull() { [EOL] boolean result = hasAnnotations(); [EOL] assertTrue(result); [EOL] }
public void testHasAnnotationsWhenClassAnnotationsIsEmpty() { [EOL] _classAnnotations = Collections.emptyMap(); [EOL] boolean result = hasAnnotations(); [EOL] assertFalse(result); [EOL] }
public void testHasAnnotationsWhenClassAnnotationsIsNotEmpty() { [EOL] _classAnnotations = Collections.singletonMap("key", "value"); [EOL] boolean result = hasAnnotations(); [EOL] assertTrue(result); [EOL] }
public void testGetFieldCountWithNullFields() { [EOL] instance.setFields(null); // This method is assumed to exist for the purpose of the test [EOL] int count = instance.getFieldCount(); [EOL] assertEquals(0, count); // Assuming that resolveFields() initializes _fields as an empty list [EOL] }
public void testGetFieldCountWithNonNullFields() { [EOL] instance.populateFieldsWithTestData(); // This method is assumed to exist for the purpose of the test [EOL] int count = instance.getFieldCount(); [EOL] assertEquals(expectedCount, count); // expectedCount should be the number of fields populated in populateFieldsWithTestData [EOL] }
public void testFieldsWhenFieldsAreNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.fields(); // This should trigger resolveFields() [EOL] assertNotNull("Fields should not be null after calling fields()", instance.fields()); [EOL] }
public void testFieldsWhenFieldsAreNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.fields(); // This should trigger resolveFields() the first time [EOL] Iterable<AnnotatedField> firstCallResult = instance.fields(); [EOL] Iterable<AnnotatedField> secondCallResult = instance.fields(); // This should not trigger resolveFields() [EOL] assertSame("Subsequent calls to fields() should return the same object", firstCallResult, secondCallResult); [EOL] }
public void testResolveFieldsWithNullFoundFields() { [EOL] resolveFields(); [EOL] assertTrue(_fields.isEmpty()); [EOL] }
public void testResolveFieldsWithEmptyFoundFields() { [EOL] resolveFields(); [EOL] assertTrue(_fields.isEmpty()); [EOL] }
public void testResolveFieldsWithNonEmptyFoundFields() { [EOL] resolveFields(); [EOL] assertFalse(_fields.isEmpty()); [EOL] assertEquals(foundFields.size(), _fields.size()); [EOL] }
public void testAddConstructorMixIns_NoConstructors() { [EOL] _constructors = null; [EOL] _defaultConstructor = null; [EOL] Class<?> mixin = MixinClassWithDefaultConstructor.class; [EOL] _addConstructorMixIns(mixin); [EOL] assertNull(_defaultConstructor); [EOL] assertNull(_constructors); [EOL] }
public void testAddConstructorMixIns_WithDefaultConstructor() { [EOL] _defaultConstructor = createMockConstructor(); [EOL] _constructors = null; [EOL] Class<?> mixin = MixinClassWithDefaultConstructor.class; [EOL] _addConstructorMixIns(mixin); [EOL] assertNotNull(_defaultConstructor); [EOL] verifyMixIn(_defaultConstructor, MixinClassWithDefaultConstructor.class); [EOL] }
public void testAddConstructorMixIns_WithParameterizedConstructors() { [EOL] _defaultConstructor = null; [EOL] _constructors = new ArrayList<>(); [EOL] _constructors.add(createMockConstructorWithParameters(int.class)); [EOL] _constructors.add(createMockConstructorWithParameters(String.class)); [EOL] Class<?> mixin = MixinClassWithParameterizedConstructors.class; [EOL] _addConstructorMixIns(mixin); [EOL] assertEquals(2, _constructors.size()); [EOL] verifyMixIn(_constructors.get(0), MixinClassWithParameterizedConstructors.class, int.class); [EOL] verifyMixIn(_constructors.get(1), MixinClassWithParameterizedConstructors.class, String.class); [EOL] }
public void testAddConstructorMixIns_WithParameterizedAndDefaultConstructors() { [EOL] _defaultConstructor = createMockConstructor(); [EOL] _constructors = new ArrayList<>(); [EOL] _constructors.add(createMockConstructorWithParameters(int.class)); [EOL] Class<?> mixin = MixinClassWithDefaultAndParameterizedConstructors.class; [EOL] _addConstructorMixIns(mixin); [EOL] assertNotNull(_defaultConstructor); [EOL] assertEquals(1, _constructors.size()); [EOL] verifyMixIn(_defaultConstructor, MixinClassWithDefaultAndParameterizedConstructors.class); [EOL] verifyMixIn(_constructors.get(0), MixinClassWithDefaultAndParameterizedConstructors.class, int.class); [EOL] }
public void testAddFactoryMixIns_withNoStaticMethods() { [EOL] Class<?> mixin = NoStaticMethodsClass.class; // Assume this class has no static methods [EOL] _addFactoryMixIns(mixin); [EOL] } [EOL] public void testAddFactoryMixIns_withStaticNoArgMethods() { [EOL] Class<?> mixin = StaticNoArgMethodsClass.class; // Assume this class has static methods with no arguments [EOL] _addFactoryMixIns(mixin); [EOL] } [EOL] public void testAddFactoryMixIns_withStaticMethodsWithArgs() { [EOL] Class<?> mixin = StaticMethodsWithArgsClass.class; // Assume this class has static methods with arguments [EOL] _addFactoryMixIns(mixin); [EOL] }
public void testAddFactoryMixIns_withStaticMethodsWithArgsAndMatchingKeys() { [EOL] Class<?> mixin = StaticMethodsWithArgsAndMatchingKeysClass.class; // Assume this class has static methods with arguments and matching keys [EOL] _addFactoryMixIns(mixin); [EOL] }
public void testAddMemberMethods_NullMixInCls() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_WithMixInCls() { [EOL] Class<?> cls = MyClass.class; [EOL] Class<?> mixInCls = MyMixIn.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_NullCls() { [EOL] _addMemberMethods(null, new AnnotatedMethodMap(), null, null); [EOL] } [EOL] public void testAddMemberMethods_NonIncludableMemberMethod() { [EOL] Class<?> cls = MyClassWithNonIncludableMethods.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_ExistingMethodInMethods() { [EOL] Class<?> cls = MyClass.class; [EOL] Method existingMethod = cls.getDeclaredMethods()[0]; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] methods.add(_constructMethod(existingMethod)); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_ExistingMethodInMixIns() { [EOL] Class<?> cls = MyClass.class; [EOL] Class<?> mixInCls = MyMixIn.class; [EOL] Method mixInMethod = mixInCls.getDeclaredMethods()[0]; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] mixIns.add(_constructMethod(mixInMethod)); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_MethodFromInterface() { [EOL] Class<?> cls = MyClassImplementingInterface.class; [EOL] Class<?> interfaceCls = MyInterface.class; [EOL] Method interfaceMethod = interfaceCls.getDeclaredMethods()[0]; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] methods.add(_constructMethod(interfaceMethod)); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] }
public void testAddMethodMixIns_WithValidMixIn() { [EOL] Class<?> targetClass = TargetClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = MixInClass.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] assertTrue("MixIns should contain methods from mixInCls", mixInsContainsMethodsFrom(mixInCls, mixIns)); [EOL] assertTrue("Methods should contain mix under methods from mixInCls", methodsContainsMixUndersFrom(mixInCls, methods)); [EOL] }
public void testAddMethodMixIns_WithInheritedMixIn() { [EOL] Class<?> targetClass = TargetClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = ChildMixInClass.class; // ChildMixInClass extends MixInClass [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] assertTrue("MixIns should contain methods from mixInCls", mixInsContainsMethodsFrom(mixInCls, mixIns)); [EOL] assertTrue("MixIns should contain methods from superclass of mixInCls", mixInsContainsMethodsFrom(MixInClass.class, mixIns)); [EOL] }
public void testAddMethodMixIns_WithNoMethodsToMixIn() { [EOL] Class<?> targetClass = TargetClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = EmptyMixInClass.class; // EmptyMixInClass has no methods [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] assertTrue("MixIns should be empty as there are no methods to mix in", mixIns.isEmpty()); [EOL] }
public void testFindFieldsWithNullParent() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] Map<String, AnnotatedField> result = _findFields(Object.class, fields); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindFieldsWithNonNullParent() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindFieldsWithMixIn() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] _mixInResolver = new MixInResolver() { [EOL] @Override [EOL] public Class<?> findMixInClassFor(Class<?> cls) { [EOL] return MixInClass.class; [EOL] } [EOL] }; [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue(result.containsKey("mixedInField")); [EOL] }
public void testAddFieldMixIns_WithNoFieldsInMixIn() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithNoFields.class, fields); [EOL] assertTrue(fields.isEmpty()); [EOL] } [EOL] public void testAddFieldMixIns_WithIncludableFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] fields.put("existingField", new AnnotatedField(null, null, null)); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithFields.class, fields); [EOL] assertNotNull(fields.get("existingField")); [EOL] assertNotNull(fields.get("newField")); [EOL] } [EOL] public void testAddFieldMixIns_WithExcludedFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] fields.put("excludedField", new AnnotatedField(null, null, null)); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithExcludedFields.class, fields); [EOL] assertNull(fields.get("excludedField")); [EOL] } [EOL] public void testAddFieldMixIns_WithOverride() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] AnnotatedField originalField = new AnnotatedField(null, null, null); [EOL] fields.put("fieldToOverride", originalField); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithFields.class, fields); [EOL] AnnotatedField overriddenField = fields.get("fieldToOverride"); [EOL] assertNotSame(originalField, overriddenField); [EOL] }
public void testAddFieldMixIns_WithMultipleLevelsOfInheritance() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] fields.put("inheritedField", new AnnotatedField(null, null, null)); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithInheritance.class, fields); [EOL] assertNotNull(fields.get("inheritedField")); [EOL] assertNotNull(fields.get("newField")); [EOL] }
public void test_constructFieldWithNullIntrospector() { [EOL] Field f = String.class.getDeclaredFields()[0]; // Assuming String class has at least one field [EOL] MyObjectMapper objectMapper = new MyObjectMapper(null); // Assuming MyObjectMapper is a subclass with a constructor that accepts an AnnotationIntrospector [EOL] AnnotatedField result = objectMapper._constructField(f); [EOL] assertNotNull(result); [EOL] assertEquals(f, result.getAnnotated()); [EOL] assertTrue(result.getAllAnnotations().isEmpty()); [EOL] }
public void test_constructFieldWithNonNullIntrospector() { [EOL] Field f = String.class.getDeclaredFields()[0]; // Assuming String class has at least one field [EOL] AnnotationIntrospector introspector = new MyAnnotationIntrospector(); // Assuming MyAnnotationIntrospector is a concrete implementation [EOL] MyObjectMapper objectMapper = new MyObjectMapper(introspector); // Assuming MyObjectMapper is a subclass with a constructor that accepts an AnnotationIntrospector [EOL] AnnotatedField result = objectMapper._constructField(f); [EOL] assertNotNull(result); [EOL] assertEquals(f, result.getAnnotated()); [EOL] assertFalse(result.getAllAnnotations().isEmpty()); [EOL] }
public void testIsIncludableField_Synthetic() { [EOL] Field syntheticField = getSyntheticField(); // Assume this method provides a synthetic field [EOL] boolean result = _isIncludableField(syntheticField); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableField_Static() { [EOL] Field staticField = getStaticField(); // Assume this method provides a static field [EOL] boolean result = _isIncludableField(staticField); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableField_Transient() { [EOL] Field transientField = getTransientField(); // Assume this method provides a transient field [EOL] boolean result = _isIncludableField(transientField); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableField_Includable() { [EOL] Field includableField = getIncludableField(); // Assume this method provides a non-static, non-transient, non-synthetic field [EOL] boolean result = _isIncludableField(includableField); [EOL] assertTrue(result); [EOL] }
private Field getSyntheticField() { [EOL] } [EOL] private Field getStaticField() { [EOL] } [EOL] private Field getTransientField() { [EOL] } [EOL] private Field getIncludableField() { [EOL] }
public void testCollectRelevantAnnotationsWithNonNullAnnotations() { [EOL] Annotation[] anns = new Annotation[] { /* instantiate annotations here */ }; [EOL] AnnotationMap result = _collectRelevantAnnotations(anns); [EOL] assertNotNull(result); [EOL] }
public void testCollectRelevantAnnotationsWithEmptyAnnotations() { [EOL] Annotation[] anns = new Annotation[0]; [EOL] AnnotationMap result = _collectRelevantAnnotations(anns); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testCollectRelevantAnnotationsWithNullAnnotations() { [EOL] Annotation[] anns = null; [EOL] AnnotationMap result = _collectRelevantAnnotations(anns); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testAddAnnotationsIfNotPresentWithNullAnnotations() { [EOL] AnnotationMap result = new AnnotationMap(); [EOL] _addAnnotationsIfNotPresent(result, null); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddAnnotationsIfNotPresentWithEmptyAnnotations() { [EOL] AnnotationMap result = new AnnotationMap(); [EOL] _addAnnotationsIfNotPresent(result, new Annotation[0]); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddAnnotationsIfNotPresentWithNonBundleAnnotations() { [EOL] AnnotationMap result = new AnnotationMap(); [EOL] Annotation ann = new SomeAnnotationImpl(); [EOL] _addAnnotationsIfNotPresent(result, new Annotation[]{ann}); [EOL] assertTrue(result.size() == 1); [EOL] assertTrue(result.has(ann)); [EOL] }
public void testAddAnnotationsIfNotPresentWithBundleAnnotations() { [EOL] AnnotationMap result = new AnnotationMap(); [EOL] Annotation bundleAnn = new SomeBundleAnnotationImpl(); [EOL] Annotation ann = new SomeAnnotationImpl(); [EOL] _addAnnotationsIfNotPresent(result, new Annotation[]{bundleAnn, ann}); [EOL] assertTrue(result.size() == 2); [EOL] assertTrue(result.has(ann)); [EOL] assertTrue(result.has(bundleAnn.annotationType().getDeclaredAnnotations()[0])); [EOL] }
public void testAddOrOverrideAnnotationsWithNullAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addOrOverrideAnnotations(target, null); [EOL] verify(target, never()).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithEmptyAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addOrOverrideAnnotations(target, new Annotation[0]); [EOL] verify(target, never()).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithNonBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation ann = mock(Annotation.class); [EOL] when(_isAnnotationBundle(ann)).thenReturn(false); [EOL] _addOrOverrideAnnotations(target, new Annotation[]{ann}); [EOL] verify(target).addOrOverride(ann); [EOL] }
public void testAddOrOverrideAnnotationsWithBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation bundleAnn = mock(Annotation.class); [EOL] Annotation nonBundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(bundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nonBundleAnn)).thenReturn(false); [EOL] when(bundleAnn.annotationType().getDeclaredAnnotations()).thenReturn(new Annotation[]{nonBundleAnn}); [EOL] _addOrOverrideAnnotations(target, new Annotation[]{bundleAnn, nonBundleAnn}); [EOL] verify(target).addOrOverride(nonBundleAnn); [EOL] verify(target, times(2)).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddOrOverrideAnnotationsWithNestedBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation bundleAnn = mock(Annotation.class); [EOL] Annotation nestedBundleAnn = mock(Annotation.class); [EOL] Annotation nonBundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(bundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nestedBundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nonBundleAnn)).thenReturn(false); [EOL] when(bundleAnn.annotationType().getDeclaredAnnotations()).thenReturn(new Annotation[]{nestedBundleAnn}); [EOL] when(nestedBundleAnn.annotationType().getDeclaredAnnotations()).thenReturn(new Annotation[]{nonBundleAnn}); [EOL] _addOrOverrideAnnotations(target, new Annotation[]{bundleAnn}); [EOL] verify(target).addOrOverride(nonBundleAnn); [EOL] verify(target, times(1)).addOrOverride(any(Annotation.class)); [EOL] }
public void testAddMixOversWithoutParamAnnotations() { [EOL] Constructor<?> mixin = getMixinConstructor(); [EOL] AnnotatedConstructor target = getAnnotatedConstructor(); [EOL] boolean addParamAnnotations = false; [EOL] _addMixOvers(mixin, target, addParamAnnotations); [EOL] }
public void testAddMixOversWithParamAnnotations() { [EOL] Constructor<?> mixin = getMixinConstructor(); [EOL] AnnotatedConstructor target = getAnnotatedConstructor(); [EOL] boolean addParamAnnotations = true; [EOL] _addMixOvers(mixin, target, addParamAnnotations); [EOL] }
public void testAddMixOversWithoutParamAnnotations() { [EOL] Method mixinMethod = ...; // Obtain or mock a Method instance [EOL] AnnotatedMethod targetMethod = ...; // Obtain or mock an AnnotatedMethod instance [EOL] boolean addParamAnnotations = false; [EOL] _addMixOvers(mixinMethod, targetMethod, addParamAnnotations); [EOL] }
public void testAddMixOversWithParamAnnotations() { [EOL] Method mixinMethod = ...; // Obtain or mock a Method instance with parameter annotations [EOL] AnnotatedMethod targetMethod = ...; // Obtain or mock an AnnotatedMethod instance [EOL] boolean addParamAnnotations = true; [EOL] _addMixOvers(mixinMethod, targetMethod, addParamAnnotations); [EOL] }
public void testIsAnnotationBundleWithNonNullIntrospectorAndBundle() { [EOL] AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); [EOL] Annotation ann = Mockito.mock(Annotation.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setAnnotationIntrospector(introspector); [EOL] Mockito.when(introspector.isAnnotationBundle(ann)).thenReturn(true); [EOL] boolean result = mapper._isAnnotationBundle(ann); [EOL] assertTrue(result); [EOL] }
public void testIsAnnotationBundleWithNonNullIntrospectorAndNotBundle() { [EOL] AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); [EOL] Annotation ann = Mockito.mock(Annotation.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setAnnotationIntrospector(introspector); [EOL] Mockito.when(introspector.isAnnotationBundle(ann)).thenReturn(false); [EOL] boolean result = mapper._isAnnotationBundle(ann); [EOL] assertFalse(result); [EOL] }
public void testIsAnnotationBundleWithNullIntrospector() { [EOL] Annotation ann = Mockito.mock(Annotation.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setAnnotationIntrospector(null); [EOL] boolean result = mapper._isAnnotationBundle(ann); [EOL] assertFalse(result); [EOL] }
public void testTypeDeserializerBaseWithNullDefaultImpl() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = null; [EOL] TypeDeserializerBase deserializer = new TypeDeserializerBase(baseType, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNull(deserializer._defaultImpl); [EOL] assertEquals(baseType, deserializer._baseType); [EOL] assertEquals(idRes, deserializer._idResolver); [EOL] assertEquals(typePropertyName, deserializer._typePropertyName); [EOL] assertTrue(deserializer._typeIdVisible); [EOL] assertNotNull(deserializer._deserializers); [EOL] assertNull(deserializer._property); [EOL] }
public void testTypeDeserializerBaseWithNonNullDefaultImpl() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = Object.class; [EOL] when(baseType.forcedNarrowBy(defaultImpl)).thenReturn(baseType); [EOL] TypeDeserializerBase deserializer = new TypeDeserializerBase(baseType, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertEquals(baseType, deserializer._defaultImpl); [EOL] assertEquals(baseType, deserializer._baseType); [EOL] assertEquals(idRes, deserializer._idResolver); [EOL] assertEquals(typePropertyName, deserializer._typePropertyName); [EOL] assertTrue(deserializer._typeIdVisible); [EOL] assertNotNull(deserializer._deserializers); [EOL] assertNull(deserializer._property); [EOL] }
public void testFindDeserializerWithUnknownTypeId() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "unknownTypeId"; [EOL] when(ctxt.unknownTypeException(any(JavaType.class), eq(typeId))).thenThrow(new JsonMappingException("Unknown type")); [EOL] try { [EOL] _findDeserializer(ctxt, typeId); [EOL] fail("Should have thrown JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testFindDeserializerWithKnownTypeId() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "knownTypeId"; [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(type); [EOL] when(ctxt.findContextualValueDeserializer(type, _property)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _findDeserializer(ctxt, typeId); [EOL] assertSame("Deserializers should be the same", expectedDeserializer, actualDeserializer); [EOL] }
public void testFindDeserializerWithDefaultImpl() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "defaultImplTypeId"; [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(null); [EOL] JsonDeserializer<Object> defaultDeserializer = mock(JsonDeserializer.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(defaultDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _findDeserializer(ctxt, typeId); [EOL] assertSame("Deserializers should be the same", defaultDeserializer, actualDeserializer); [EOL] }
public void testFindDeserializerWithBaseTypeNarrowing() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "baseTypeNarrowingTypeId"; [EOL] JavaType baseType = mock(JavaType.class); [EOL] JavaType narrowType = mock(JavaType.class); [EOL] Class<?> rawClass = Object.class; [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(narrowType); [EOL] when(_baseType.getClass()).thenReturn(JavaType.class); [EOL] when(_baseType.getRawClass()).thenReturn(rawClass); [EOL] when(narrowType.getClass()).thenReturn(JavaType.class); [EOL] when(narrowType.getRawClass()).thenReturn(rawClass); [EOL] when(_baseType.narrowBy(rawClass)).thenReturn(baseType); [EOL] when(ctxt.findContextualValueDeserializer(baseType, _property)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _findDeserializer(ctxt, typeId); [EOL] assertSame("Deserializers should be the same", expectedDeserializer, actualDeserializer); [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeDisabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(false); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertSame(NullifyingDeserializer.instance, result); [EOL] } [EOL] public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeEnabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(true); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertNull(result); [EOL] }
public void testFindDefaultImplDeserializerWithNoClassAsDefaultImpl() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _defaultImpl = JavaType.constructFromCanonical(NoClass.class.getCanonicalName()); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertSame(NullifyingDeserializer.instance, result); [EOL] }
public void testFindDefaultImplDeserializerWithNonNullDefaultImpl() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _defaultImpl = JavaType.constructFromCanonical("java.lang.String"); [EOL] _defaultImplDeserializer = new StdDeserializer.StringDeserializer(); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertSame(_defaultImplDeserializer, result); [EOL] }
public void testEnumDeserializerWithNonNullResolver() { [EOL] EnumResolver<?> resolver = EnumResolver.constructFor(EnumType.class, null); [EOL] EnumDeserializer deserializer = new EnumDeserializer(resolver); [EOL] assertNotNull(deserializer); [EOL] }
public void testEnumDeserializerWithNullResolver() { [EOL] try { [EOL] EnumDeserializer deserializer = new EnumDeserializer(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("ENUM_VALUE"); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals("ENUM_VALUE", result.name()); [EOL] }
public void testDeserializeWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getText()).thenReturn("ENUM_VALUE"); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals("ENUM_VALUE", result.name()); [EOL] }
public void testDeserializeWithEmptyStringAndAcceptEmptyAsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithUnknownEnumValueAsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM_VALUE"); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithUnknownEnumValueAndException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM_VALUE"); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] assertThrows(JsonProcessingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithValueNumberIntAndFailOnNumbersForEnums() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)).thenReturn(true); [EOL] assertThrows(JsonProcessingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithValueNumberIntAndUnknownEnumIndexAsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(999); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithValueNumberIntAndUnknownEnumIndexException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(999); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] assertThrows(JsonProcessingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] assertThrows(JsonProcessingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testIdFromWithEnumClass() { [EOL] String result = _idFrom(EnumSet.of(Thread.State.NEW), Thread.State.class); [EOL] assertEquals("java.util.EnumSet<java.lang.Thread$State>", result); [EOL] }
public void testIdFromWithEnumMap() { [EOL] EnumMap<Thread.State, String> enumMap = new EnumMap<>(Thread.State.class); [EOL] String result = _idFrom(enumMap, Thread.State.class); [EOL] assertEquals("java.util.EnumMap<java.lang.Thread$State,java.lang.Object>", result); [EOL] }
public void testIdFromWithNonEnumClass() { [EOL] String result = _idFrom(new ArrayList<>(), ArrayList.class); [EOL] assertEquals("java.util.ArrayList", result); [EOL] }
public void testIdFromWithInnerClass() { [EOL] class Outer { [EOL] class Inner { [EOL] } [EOL] } [EOL] String result = _idFrom(new Outer().new Inner(), Outer.Inner.class); [EOL] assertTrue(result.contains("$")); [EOL] }
public void testIdFromWithStaticInnerClass() { [EOL] class Outer { [EOL] static class Inner { [EOL] } [EOL] } [EOL] String result = _idFrom(new Outer.Inner(), Outer.Inner.class); [EOL] assertFalse(result.contains("$")); [EOL] }
public void testBuildWriterWithContentTypeSerializerNull() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithNonNullContentTypeSerializer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] when(declaredType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithSerializationInclusionNonNull() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.NON_DEFAULT); [EOL] when(_beanDesc.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)).thenReturn(true); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithUnwrappingNameTransformer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] when(_annotationIntrospector.findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] assertTrue(writer.isUnwrapping()); [EOL] }
protected StringCollectionSerializer() { [EOL] this(null); [EOL] }
protected void testStringCollectionSerializerWithNonNullSerializer() { [EOL] JsonSerializer<?> jsonSerializer = Mockito.mock(JsonSerializer.class); [EOL] StringCollectionSerializer serializer = new StringCollectionSerializer(jsonSerializer); [EOL] assertNotNull(serializer); [EOL] }
protected void testStringCollectionSerializerWithNullSerializer() { [EOL] try { [EOL] new StringCollectionSerializer(null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The serializer should not be null", e.getMessage()); [EOL] } [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] JsonSerializer<?> result = createContextual(null, null); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerializerDefinition() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinition() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonSerializer<?> serializerInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(new Object()); [EOL] when(provider.serializerInstance(member, new Object())).thenReturn(serializerInstance); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testCreateContextualWithDefaultSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> defaultSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(defaultSerializer); [EOL] when(isDefaultSerializer(defaultSerializer)).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonDefaultSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> nonDefaultSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(nonDefaultSerializer); [EOL] when(isDefaultSerializer(nonDefaultSerializer)).thenReturn(false); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testCreateContextualWithNonDefaultContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<?> contextualInstance = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, property)).thenReturn(contextualSerializer); [EOL] when(isDefaultSerializer(contextualSerializer)).thenReturn(false); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(contextualInstance); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertSame(contextualInstance, result); [EOL] }
public void testSerializeWithTypeNullSerializer() throws IOException { [EOL] Collection<String> value = Arrays.asList("one", "two", "three"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForArray(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForArray(value, jgen); [EOL] verify(this, times(1)).serializeContents(value, jgen, provider); [EOL] verify(this, never()).serializeUsingCustom(value, jgen, provider); [EOL] }
public void testSerializeWithTypeCustomSerializer() throws IOException { [EOL] Collection<String> value = Arrays.asList("one", "two", "three"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] _serializer = mock(JsonSerializer.class); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForArray(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForArray(value, jgen); [EOL] verify(this, never()).serializeContents(value, jgen, provider); [EOL] verify(this, times(1)).serializeUsingCustom(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNonNullSerializer() throws IOException { [EOL] Collection<String> value = Arrays.asList("string1", "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MySerializer instance = new MySerializer(); [EOL] instance._serializer = mock(JsonSerializer.class); [EOL] instance.serializeContents(value, jgen, provider); [EOL] verify(instance._serializer, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithNullValues() throws IOException { [EOL] Collection<String> value = Arrays.asList("string1", null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MySerializer instance = new MySerializer(); [EOL] instance.serializeContents(value, jgen, provider); [EOL] verify(jgen).writeString("string1"); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] Collection<String> value = Arrays.asList("string1", "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MySerializer instance = new MySerializer(); [EOL] doThrow(new IOException()).when(jgen).writeString("string2"); [EOL] try { [EOL] instance.serializeContents(value, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(jgen).writeString("string1"); [EOL] }
public void testWithVisibilityCheckerSameInstance() { [EOL] VisibilityChecker<?> originalVC = _visibilityChecker; // Assuming _visibilityChecker is initialized [EOL] BaseSettings originalSettings = new BaseSettings(_classIntrospector, _annotationIntrospector, originalVC, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); // Assuming all other fields are initialized [EOL] BaseSettings resultSettings = originalSettings.withVisibilityChecker(originalVC); [EOL] assertSame(originalSettings, resultSettings); [EOL] }
public void testWithVisibilityCheckerDifferentInstance() { [EOL] VisibilityChecker<?> originalVC = _visibilityChecker; // Assuming _visibilityChecker is initialized [EOL] VisibilityChecker<?> newVC = mock(VisibilityChecker.class); // Assuming mock framework is used [EOL] BaseSettings originalSettings = new BaseSettings(_classIntrospector, _annotationIntrospector, originalVC, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); // Assuming all other fields are initialized [EOL] BaseSettings resultSettings = originalSettings.withVisibilityChecker(newVC); [EOL] assertNotSame(originalSettings, resultSettings); [EOL] assertSame(newVC, resultSettings.getVisibilityChecker()); [EOL] }
public void testWithVisibility_NewVisibilitySettings() { [EOL] BaseSettings originalSettings = new BaseSettings( [EOL] null, null, VisibilityChecker.Std.defaultInstance(), [EOL] null, null, null, null, null, null, null, null [EOL] ); [EOL] PropertyAccessor accessor = PropertyAccessor.FIELD; [EOL] JsonAutoDetect.Visibility visibility = JsonAutoDetect.Visibility.ANY; [EOL] BaseSettings newSettings = originalSettings.withVisibility(accessor, visibility); [EOL] assertNotNull(newSettings); [EOL] assertNotSame(originalSettings, newSettings); [EOL] assertEquals(visibility, newSettings.getVisibilityChecker().findVisibility(accessor)); [EOL] }
public void testWithVisibility_SameVisibilitySettings() { [EOL] BaseSettings originalSettings = new BaseSettings( [EOL] null, null, VisibilityChecker.Std.defaultInstance(), [EOL] null, null, null, null, null, null, null, null [EOL] ); [EOL] PropertyAccessor accessor = PropertyAccessor.FIELD; [EOL] JsonAutoDetect.Visibility originalVisibility = originalSettings.getVisibilityChecker().findVisibility(accessor); [EOL] BaseSettings newSettings = originalSettings.withVisibility(accessor, originalVisibility); [EOL] assertNotNull(newSettings); [EOL] assertNotSame(originalSettings, newSettings); [EOL] assertEquals(originalVisibility, newSettings.getVisibilityChecker().findVisibility(accessor)); [EOL] }
public void testWithTypeFactorySameInstance() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, typeFactory, null, null, null, null, null, null); [EOL] BaseSettings result = baseSettings.withTypeFactory(typeFactory); [EOL] assertSame(baseSettings, result); [EOL] }
public void testWithTypeFactoryDifferentInstance() { [EOL] TypeFactory typeFactory1 = TypeFactory.defaultInstance(); [EOL] TypeFactory typeFactory2 = TypeFactory.defaultInstance().withModifier(null); [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, typeFactory1, null, null, null, null, null, null); [EOL] BaseSettings result = baseSettings.withTypeFactory(typeFactory2); [EOL] assertNotSame(baseSettings, result); [EOL] assertNotNull(result); [EOL] assertSame(typeFactory2, result.getTypeFactory()); [EOL] }
public void testWithDateFormatSameInstance() { [EOL] DateFormat df = new SimpleDateFormat(); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, df, null, null, null, null); [EOL] BaseSettings result = settings.withDateFormat(df); [EOL] assertSame(settings, result); [EOL] }
public void testWithDateFormatDifferentInstance() { [EOL] DateFormat df1 = new SimpleDateFormat(); [EOL] DateFormat df2 = new SimpleDateFormat(); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, df1, null, null, null, null); [EOL] BaseSettings result = settings.withDateFormat(df2); [EOL] assertNotSame(settings, result); [EOL] assertNotNull(result); [EOL] assertEquals(df2, result.getDateFormat()); [EOL] }
public void testWithNullTimeZone() { [EOL] try { [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); [EOL] settings.with(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithStdDateFormatAndNonNullTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, stdDateFormat, null, null, null, null); [EOL] BaseSettings newSettings = settings.with(tz); [EOL] assertNotNull(newSettings); [EOL] DateFormat df = newSettings.getDateFormat(); [EOL] assertTrue(df instanceof StdDateFormat); [EOL] assertEquals(tz, ((StdDateFormat) df).getTimeZone()); [EOL] }
public void testWithNonStdDateFormatAndNonNullTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] DateFormat nonStdDateFormat = new SimpleDateFormat(); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, nonStdDateFormat, null, null, null, null); [EOL] BaseSettings newSettings = settings.with(tz); [EOL] assertNotNull(newSettings); [EOL] DateFormat df = newSettings.getDateFormat(); [EOL] assertFalse(df instanceof StdDateFormat); [EOL] assertEquals(tz, df.getTimeZone()); [EOL] }
public void testGetDateFormat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DateFormat df = mapper.getSerializationConfig().getDateFormat(); [EOL] assertNotNull(df); [EOL] assertEquals(df, mapper.getDateFormat()); [EOL] }
public void testGetTimeZone_WhenTimeZoneIsSet() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone expectedTimeZone = TimeZone.getTimeZone("GMT"); [EOL] mapper.setTimeZone(expectedTimeZone); [EOL] TimeZone actualTimeZone = mapper.getTimeZone(); [EOL] assertSame(expectedTimeZone, actualTimeZone); [EOL] }
public void testGetTimeZone_WhenTimeZoneIsNotSet() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone actualTimeZone = mapper.getTimeZone(); [EOL] assertNotNull(actualTimeZone); [EOL] assertEquals(TimeZone.getTimeZone("UTC"), actualTimeZone); [EOL] }
It appears that the provided input text is for a constructor of a class named `ArrayBuilders` which does not contain any executable code. Since constructors that only contain an empty body do not have any logic to test, generating unit test cases for this constructor would not cover any new lines of code or meaningful assertions. [EOL] In a typical scenario, if there were executable lines of code within the constructor, you would create test cases to instantiate the class and assert the initial state of the object. However, for an empty constructor like this, there is no need for a test case as it does not initialize any fields or perform any operations. [EOL] If you have a different method or a constructor with executable code that you would like to generate test cases for, please provide the relevant input text.
public void testGetIntBuilderFirstCall() { [EOL] YourClass instance = new YourClass(); [EOL] IntBuilder result = instance.getIntBuilder(); [EOL] assertNotNull(result); [EOL] }
public void testGetIntBuilderSubsequentCall() { [EOL] YourClass instance = new YourClass(); [EOL] IntBuilder firstCallResult = instance.getIntBuilder(); [EOL] IntBuilder secondCallResult = instance.getIntBuilder(); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
public void testGetFloatBuilder_WhenFloatBuilderIsNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] FloatBuilder result = instance.getFloatBuilder(); [EOL] assertNotNull(result); [EOL] }
public void testGetFloatBuilder_WhenFloatBuilderIsNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] FloatBuilder expectedBuilder = new FloatBuilder(); [EOL] instance.getFloatBuilder(); // Call once to initialize _floatBuilder [EOL] FloatBuilder result = instance.getFloatBuilder(); [EOL] assertSame(expectedBuilder, result); [EOL] }
public void testIntBuilderConstructor() { [EOL] IntBuilder intBuilder = new IntBuilder(); [EOL] assertNotNull("IntBuilder instance should not be null", intBuilder); [EOL] }
public void testConstructArrayWithZeroLength() { [EOL] int len = 0; [EOL] int[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testConstructArrayWithPositiveLength() { [EOL] int len = 5; [EOL] int[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length); [EOL] } [EOL] public void testConstructArrayWithMaxIntLength() { [EOL] int len = Integer.MAX_VALUE; [EOL] try { [EOL] int[] result = _constructArray(len); [EOL] fail("Should have thrown an OutOfMemoryError"); [EOL] } catch (OutOfMemoryError e) { [EOL] } [EOL] }
public void testFloatBuilderConstructor() { [EOL] new FloatBuilder(); [EOL] }
public void testConstructArrayWithZeroLength() { [EOL] float[] result = _constructArray(0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testConstructArrayWithPositiveLength() { [EOL] int len = 5; [EOL] float[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(len, result.length); [EOL] }
public void testArrayToSetWithNonNullElements() { [EOL] Integer[] elements = new Integer[]{1, 2, 3, 4}; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertEquals(4, resultSet.size()); [EOL] assertTrue(resultSet.contains(1)); [EOL] assertTrue(resultSet.contains(2)); [EOL] assertTrue(resultSet.contains(3)); [EOL] assertTrue(resultSet.contains(4)); [EOL] }
public void testArrayToSetWithNull() { [EOL] Integer[] elements = null; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertTrue(resultSet.isEmpty()); [EOL] }
public void testArrayToSetWithEmptyArray() { [EOL] Integer[] elements = new Integer[]{}; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertTrue(resultSet.isEmpty()); [EOL] }
public void testArrayToSetWithDuplicateElements() { [EOL] Integer[] elements = new Integer[]{1, 2, 2, 3, 3, 3}; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertEquals(3, resultSet.size()); [EOL] assertTrue(resultSet.contains(1)); [EOL] assertTrue(resultSet.contains(2)); [EOL] assertTrue(resultSet.contains(3)); [EOL] }
public void testSetAndArrayWithNonNullSetAndElements() { [EOL] Set<String> set = new HashSet<>(); [EOL] set.add("test1"); [EOL] String[] elements = new String[]{"test2", "test3"}; [EOL] HashSet<String> result = ClassName.setAndArray(set, elements); [EOL] assertTrue(result.contains("test1")); [EOL] assertTrue(result.contains("test2")); [EOL] assertTrue(result.contains("test3")); [EOL] assertEquals(3, result.size()); [EOL] }
public void testSetAndArrayWithNullSet() { [EOL] String[] elements = new String[]{"test2", "test3"}; [EOL] HashSet<String> result = ClassName.setAndArray(null, elements); [EOL] assertTrue(result.contains("test2")); [EOL] assertTrue(result.contains("test3")); [EOL] assertEquals(2, result.size()); [EOL] }
public void testSetAndArrayWithNullElements() { [EOL] Set<String> set = new HashSet<>(); [EOL] set.add("test1"); [EOL] HashSet<String> result = ClassName.setAndArray(set, null); [EOL] assertTrue(result.contains("test1")); [EOL] assertEquals(1, result.size()); [EOL] }
public void testSetAndArrayWithNullSetAndElements() { [EOL] HashSet<String> result = ClassName.setAndArray(null, null); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testUnwrappingBeanPropertyWriterConstructorWithNullTransformer() { [EOL] UnwrappingBeanPropertyWriter base = createMockUnwrappingBeanPropertyWriter(); [EOL] SerializedString name = new SerializedString("testName"); [EOL] UnwrappingBeanPropertyWriter writer = new UnwrappingBeanPropertyWriter(base, null, name); [EOL] assertNull(writer.getNameTransformer()); [EOL] assertEquals(name, writer.getSerializedName()); [EOL] }
public void testUnwrappingBeanPropertyWriterConstructorWithNonNullTransformer() { [EOL] UnwrappingBeanPropertyWriter base = createMockUnwrappingBeanPropertyWriter(); [EOL] NameTransformer transformer = NameTransformer.NOP; [EOL] SerializedString name = new SerializedString("testName"); [EOL] UnwrappingBeanPropertyWriter writer = new UnwrappingBeanPropertyWriter(base, transformer, name); [EOL] assertNotNull(writer.getNameTransformer()); [EOL] assertEquals(transformer, writer.getNameTransformer()); [EOL] assertEquals(name, writer.getSerializedName()); [EOL] }
public void testRenameWithSimpleTransformer() { [EOL] NameTransformer transformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "prefix_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] UnwrappingBeanPropertyWriter originalWriter = createUnwrappingBeanPropertyWriter("originalName"); [EOL] UnwrappingBeanPropertyWriter renamedWriter = originalWriter.rename(transformer); [EOL] assertEquals("prefix_originalName", renamedWriter.getName().getValue()); [EOL] } [EOL] public void testRenameWithChainedTransformer() { [EOL] NameTransformer firstTransformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "first_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] NameTransformer secondTransformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "second_" + name; [EOL] } [EOL] @Override [EOL] public String reverse(String transformed) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] UnwrappingBeanPropertyWriter originalWriter = createUnwrappingBeanPropertyWriter("originalName", firstTransformer); [EOL] UnwrappingBeanPropertyWriter renamedWriter = originalWriter.rename(secondTransformer); [EOL] assertEquals("second_first_originalName", renamedWriter.getName().getValue()); [EOL] } [EOL] private UnwrappingBeanPropertyWriter createUnwrappingBeanPropertyWriter(String name) { [EOL] return createUnwrappingBeanPropertyWriter(name, NameTransformer.NOP); [EOL] } [EOL] private UnwrappingBeanPropertyWriter createUnwrappingBeanPropertyWriter(String name, NameTransformer transformer) { [EOL] BeanPropertyDefinition propDef = BeanPropertyDefinition.construct(null, new AnnotatedField(null, null, null), new PropertyName(name)); [EOL] return new UnwrappingBeanPropertyWriter(null, null, propDef, null, null, transformer, null, false); [EOL] }
public void testBeanSerializerBaseWithIgnoredProperties() { [EOL] BeanSerializerBase src = createBeanSerializerBase(); [EOL] String[] toIgnore = new String[]{"propToIgnore"}; [EOL] BeanSerializerBase newSerializer = new BeanSerializerBase(src, toIgnore); [EOL] assertNotNull(newSerializer); [EOL] assertEquals(src._handledType, newSerializer._handledType); [EOL] assertFalse(Arrays.asList(newSerializer._props).contains("propToIgnore")); [EOL] assertEquals(src._typeId, newSerializer._typeId); [EOL] assertEquals(src._anyGetterWriter, newSerializer._anyGetterWriter); [EOL] assertEquals(src._objectIdWriter, newSerializer._objectIdWriter); [EOL] assertEquals(src._propertyFilterId, newSerializer._propertyFilterId); [EOL] assertEquals(src._serializationShape, newSerializer._serializationShape); [EOL] }
public void testBeanSerializerBaseWithoutIgnoredProperties() { [EOL] BeanSerializerBase src = createBeanSerializerBase(); [EOL] String[] toIgnore = new String[]{}; [EOL] BeanSerializerBase newSerializer = new BeanSerializerBase(src, toIgnore); [EOL] assertNotNull(newSerializer); [EOL] assertEquals(src._handledType, newSerializer._handledType); [EOL] assertEquals(src._props.length, newSerializer._props.length); [EOL] assertEquals(src._typeId, newSerializer._typeId); [EOL] assertEquals(src._anyGetterWriter, newSerializer._anyGetterWriter); [EOL] assertEquals(src._objectIdWriter, newSerializer._objectIdWriter); [EOL] assertEquals(src._propertyFilterId, newSerializer._propertyFilterId); [EOL] assertEquals(src._serializationShape, newSerializer._serializationShape); [EOL] }
public void testBeanSerializerBaseWithFilteredProps() { [EOL] BeanSerializerBase src = createBeanSerializerBaseWithFilteredProps(); [EOL] String[] toIgnore = new String[]{"propToIgnore"}; [EOL] BeanSerializerBase newSerializer = new BeanSerializerBase(src, toIgnore); [EOL] assertNotNull(newSerializer); [EOL] assertEquals(src._handledType, newSerializer._handledType); [EOL] assertFalse(Arrays.asList(newSerializer._props).contains("propToIgnore")); [EOL] assertNotNull(newSerializer._filteredProps); [EOL] assertFalse(Arrays.asList(newSerializer._filteredProps).contains("propToIgnore")); [EOL] assertEquals(src._typeId, newSerializer._typeId); [EOL] assertEquals(src._anyGetterWriter, newSerializer._anyGetterWriter); [EOL] assertEquals(src._objectIdWriter, newSerializer._objectIdWriter); [EOL] assertEquals(src._propertyFilterId, newSerializer._propertyFilterId); [EOL] assertEquals(src._serializationShape, newSerializer._serializationShape); [EOL] }
public void testBeanSerializerBaseWithNullFilteredProps() { [EOL] BeanSerializerBase src = createBeanSerializerBaseWithNullFilteredProps(); [EOL] String[] toIgnore = new String[]{"propToIgnore"}; [EOL] BeanSerializerBase newSerializer = new BeanSerializerBase(src, toIgnore); [EOL] assertNotNull(newSerializer); [EOL] assertEquals(src._handledType, newSerializer._handledType); [EOL] assertFalse(Arrays.asList(newSerializer._props).contains("propToIgnore")); [EOL] assertNull(newSerializer._filteredProps); [EOL] assertEquals(src._typeId, newSerializer._typeId); [EOL] assertEquals(src._anyGetterWriter, newSerializer._anyGetterWriter); [EOL] assertEquals(src._objectIdWriter, newSerializer._objectIdWriter); [EOL] assertEquals(src._propertyFilterId, newSerializer._propertyFilterId); [EOL] assertEquals(src._serializationShape, newSerializer._serializationShape); [EOL] }
public void testRenameWithNullProps() { [EOL] BeanPropertyWriter[] result = rename(null, new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformed_" + name; [EOL] } [EOL] }); [EOL] assertNull(result); [EOL] }
public void testRenameWithEmptyProps() { [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] result = rename(props, new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformed_" + name; [EOL] } [EOL] }); [EOL] assertArrayEquals(props, result); [EOL] }
public void testRenameWithNullTransformer() { [EOL] BeanPropertyWriter[] props = { new BeanPropertyWriter() }; [EOL] BeanPropertyWriter[] result = rename(props, null); [EOL] assertArrayEquals(props, result); [EOL] }
public void testRenameWithNoOpTransformer() { [EOL] BeanPropertyWriter[] props = { new BeanPropertyWriter() }; [EOL] BeanPropertyWriter[] result = rename(props, NameTransformer.NOP); [EOL] assertArrayEquals(props, result); [EOL] }
public void testRenameWithNonNullPropsAndTransformer() { [EOL] BeanPropertyWriter[] props = { new BeanPropertyWriter(), null }; [EOL] BeanPropertyWriter[] result = rename(props, new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformed_" + name; [EOL] } [EOL] }); [EOL] assertNotNull(result); [EOL] assertEquals("transformed_" + props[0].getName(), result[0].getName()); [EOL] assertNull(result[1]); [EOL] }
public void testResolveWithNonNullSerializerAndNonNullNullSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] JsonSerializer<Object> nullSer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(_props.length).thenReturn(1); [EOL] when(_props[0]).thenReturn(prop); [EOL] when(provider.findNullValueSerializer(prop)).thenReturn(nullSer); [EOL] when(prop.willSuppressNulls()).thenReturn(false); [EOL] when(prop.hasNullSerializer()).thenReturn(false); [EOL] when(prop.hasSerializer()).thenReturn(false); [EOL] when(prop.getSerializationType()).thenReturn(type); [EOL] when(type.isFinal()).thenReturn(true); [EOL] when(provider.findValueSerializer(type, prop)).thenReturn(ser); [EOL] resolve(provider); [EOL] verify(prop).assignNullSerializer(nullSer); [EOL] verify(prop).assignSerializer(ser); [EOL] }
public void testResolveWithNullSerializerAndNonFinalType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(_props.length).thenReturn(1); [EOL] when(_props[0]).thenReturn(prop); [EOL] when(provider.findNullValueSerializer(prop)).thenReturn(null); [EOL] when(prop.willSuppressNulls()).thenReturn(false); [EOL] when(prop.hasNullSerializer()).thenReturn(false); [EOL] when(prop.hasSerializer()).thenReturn(false); [EOL] when(prop.getSerializationType()).thenReturn(null); [EOL] when(prop.getGenericPropertyType()).thenReturn(String.class); [EOL] when(provider.constructType(String.class)).thenReturn(type); [EOL] when(type.isFinal()).thenReturn(false); [EOL] resolve(provider); [EOL] verify(prop, never()).assignNullSerializer(any(JsonSerializer.class)); [EOL] verify(prop).setNonTrivialBaseType(type); [EOL] }
public void testResolveWithContainerTypeAndTypeHandler() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] ContainerSerializer<?> containerSer = mock(ContainerSerializer.class); [EOL] when(_props.length).thenReturn(1); [EOL] when(_props[0]).thenReturn(prop); [EOL] when(prop.hasSerializer()).thenReturn(false); [EOL] when(prop.getSerializationType()).thenReturn(type); [EOL] when(type.isFinal()).thenReturn(true); [EOL] when(provider.findValueSerializer(type, prop)).thenReturn(containerSer); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getTypeHandler()).thenReturn(typeSer); [EOL] when(containerSer.withValueTypeSerializer(typeSer)).thenReturn(ser); [EOL] resolve(provider); [EOL] verify(prop).assignSerializer(ser); [EOL] }
public void testResolveWithAnyGetterWriter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] JavaType type = mock(JavaType.class); [EOL] AnyGetterWriter anyGetterWriter = mock(AnyGetterWriter.class); [EOL] when(_props.length).thenReturn(0); [EOL] when(_anyGetterWriter).thenReturn(anyGetterWriter); [EOL] resolve(provider); [EOL] verify(anyGetterWriter).resolve(provider); [EOL] }
public void testCreateContextualWithNullPropertyAndIntr() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] BeanSerializerBase instance = createInstance(); [EOL] JsonSerializer<?> result = instance.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullIntr() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] BeanSerializerBase instance = createInstance(); [EOL] JsonSerializer<?> result = instance.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullIntr() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(accessor)).thenReturn(new String[]{"propToIgnore"}); [EOL] BeanSerializerBase instance = createInstance(); [EOL] JsonSerializer<?> result = instance.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithObjectIdInfo() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo("", null, null); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] BeanSerializerBase instance = createInstance(); [EOL] JsonSerializer<?> result = instance.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithPropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo("propName", ObjectIdGenerators.PropertyGenerator.class, null); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(intr.findObjectReferenceInfo(accessor, objectIdInfo)).thenReturn(objectIdInfo); [EOL] BeanSerializerBase instance = createInstanceWithProps(); [EOL] JsonSerializer<?> result = instance.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonPropertyGenerator() throws JsonMappingException { [EOL] }
public void testCreateContextualWithArraySerializationShape() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] JsonFormat.Value format = new JsonFormat.Value(); [EOL] format.setShape(JsonFormat.Shape.ARRAY); [EOL] when(intr.findFormat(accessor)).thenReturn(format); [EOL] BeanSerializerBase instance = createInstance(); [EOL] JsonSerializer<?> result = instance.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArraySerializerBase); [EOL] }
public void testModifyMapSerializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] MapType valueType = config.constructType(Map.class); [EOL] BeanDescription beanDesc = config.introspect(valueType); [EOL] JsonSerializer<?> serializer = new MapSerializer(null, valueType, false, null, null, null, null); [EOL] JsonSerializer<?> modifiedSerializer = modifyMapSerializer(config, valueType, beanDesc, serializer); [EOL] assertSame(serializer, modifiedSerializer); [EOL] }
public void testFindSerializerWithDuration() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(Duration.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof ToStringSerializer); [EOL] }
public void testFindSerializerWithQName() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(QName.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof ToStringSerializer); [EOL] }
public void testFindSerializerWithXMLGregorianCalendar() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(XMLGregorianCalendar.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof XMLGregorianCalendarSerializer); [EOL] }
public void testFindSerializerWithUnrelatedClass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(String.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNull(serializer); [EOL] }
public void testXMLGregorianCalendarSerializerConstructor() { [EOL] XMLGregorianCalendarSerializer serializer = new XMLGregorianCalendarSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] XMLGregorianCalendarSerializer serializer = new XMLGregorianCalendarSerializer(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] serializer.serialize(null, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator, never()).writeStartObject(); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] XMLGregorianCalendarSerializer serializer = new XMLGregorianCalendarSerializer(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] XMLGregorianCalendar mockXMLGregorianCalendar = mock(XMLGregorianCalendar.class); [EOL] GregorianCalendar mockGregorianCalendar = mock(GregorianCalendar.class); [EOL] when(mockXMLGregorianCalendar.toGregorianCalendar()).thenReturn(mockGregorianCalendar); [EOL] serializer.serialize(mockXMLGregorianCalendar, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] }
public void testConstructViewBasedWithSingleView() { [EOL] BeanPropertyWriter base = mock(BeanPropertyWriter.class); [EOL] Class<?>[] singleView = new Class<?>[]{String.class}; [EOL] BeanPropertyWriter result = BeanPropertyWriter.constructViewBased(base, singleView); [EOL] assertTrue(result instanceof SingleView); [EOL] }
public void testConstructViewBasedWithMultipleViews() { [EOL] BeanPropertyWriter base = mock(BeanPropertyWriter.class); [EOL] Class<?>[] multipleViews = new Class<?>[]{String.class, Integer.class}; [EOL] BeanPropertyWriter result = BeanPropertyWriter.constructViewBased(base, multipleViews); [EOL] assertTrue(result instanceof MultiView); [EOL] }
public void testConstructViewBasedWithEmptyViews() { [EOL] BeanPropertyWriter base = mock(BeanPropertyWriter.class); [EOL] Class<?>[] noViews = new Class<?>[]{}; [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] BeanPropertyWriter.constructViewBased(base, noViews); [EOL] }); [EOL] }
public void testSingleViewWithNonNullValues() { [EOL] BeanPropertyWriter mockDelegate = mock(BeanPropertyWriter.class); [EOL] Class<?> mockViewClass = Object.class; [EOL] SingleView singleView = new SingleView(mockDelegate, mockViewClass); [EOL] assertNotNull(singleView); [EOL] assertEquals(mockDelegate, singleView.getDelegate()); [EOL] assertEquals(mockViewClass, singleView.getView()); [EOL] }
public void testSingleViewWithNullDelegate() { [EOL] Class<?> mockViewClass = Object.class; [EOL] try { [EOL] SingleView singleView = new SingleView(null, mockViewClass); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSingleViewWithNullView() { [EOL] BeanPropertyWriter mockDelegate = mock(BeanPropertyWriter.class); [EOL] SingleView singleView = new SingleView(mockDelegate, null); [EOL] assertNotNull(singleView); [EOL] assertEquals(mockDelegate, singleView.getDelegate()); [EOL] assertNull(singleView.getView()); [EOL] }
public void testSerializeAsFieldWithNoActiveView() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] when(prov.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(writer._delegate).serializeAsField(bean, jgen, prov); [EOL] }
public void testSerializeAsFieldWithActiveViewAssignable() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Class<?> activeView = SomeView.class; [EOL] when(prov.getActiveView()).thenReturn(activeView); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer._view = SomeView.class; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(writer._delegate).serializeAsField(bean, jgen, prov); [EOL] }
public void testSerializeAsFieldWithActiveViewNotAssignable() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Class<?> activeView = SomeOtherView.class; [EOL] when(prov.getActiveView()).thenReturn(activeView); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer._view = SomeView.class; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(writer._delegate, never()).serializeAsField(bean, jgen, prov); [EOL] }
public void testSerializeAsColumnWithActiveView() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Class<?> activeView = Object.class; // Assuming Object.class as a mock active view [EOL] when(prov.getActiveView()).thenReturn(activeView); [EOL] MySerializer serializer = new MySerializer(); [EOL] serializer.serializeAsColumn(bean, jgen, prov); [EOL] verify(prov).getActiveView(); [EOL] verify(serializer._delegate).serializeAsColumn(bean, jgen, prov); [EOL] }
public void testSerializeAsColumnWithNoActiveView() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] when(prov.getActiveView()).thenReturn(null); [EOL] MySerializer serializer = new MySerializer(); [EOL] serializer.serializeAsColumn(bean, jgen, prov); [EOL] verify(prov).getActiveView(); [EOL] verify(serializer._delegate).serializeAsColumn(bean, jgen, prov); [EOL] }
public void testSerializeAsColumnWithNonAssignableActiveView() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Class<?> nonAssignableActiveView = String.class; // Assuming String.class as a non-assignable active view [EOL] when(prov.getActiveView()).thenReturn(nonAssignableActiveView); [EOL] MySerializer serializer = new MySerializer(); [EOL] serializer.serializeAsColumn(bean, jgen, prov); [EOL] verify(prov).getActiveView(); [EOL] verify(serializer._delegate).serializeAsPlaceholder(bean, jgen, prov); [EOL] }
public void testGetObjectIdInfoWithNullIntrospector() { [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(null); [EOL] ObjectIdInfo result = testInstance.getObjectIdInfo(); [EOL] assertNull(result); [EOL] }
public void testGetObjectIdInfoWithNonNullIntrospectorButNoObjectIdInfo() { [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.findObjectIdInfo(any())).thenReturn(null); [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(introspector); [EOL] ObjectIdInfo result = testInstance.getObjectIdInfo(); [EOL] assertNull(result); [EOL] }
public void testGetObjectIdInfoWithNonNullIntrospectorAndObjectIdInfo() { [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(...); // Provide necessary arguments [EOL] when(introspector.findObjectIdInfo(any())).thenReturn(objectIdInfo); [EOL] when(introspector.findObjectReferenceInfo(any(), any())).thenReturn(objectIdInfo); [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(introspector); [EOL] ObjectIdInfo result = testInstance.getObjectIdInfo(); [EOL] assertSame(objectIdInfo, result); [EOL] }
protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL] String implName; [EOL] boolean visible; [EOL] PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL] String explName = (pn == null) ? null : pn.getSimpleName(); [EOL] if (explName == null) { [EOL] implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL] if (implName == null) { [EOL] return; [EOL] } [EOL] visible = _visibilityChecker.isSetterVisible(m); [EOL] } else { [EOL] implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL] if (implName == null) { [EOL] implName = m.getName(); [EOL] } [EOL] if (explName.length() == 0) { [EOL] explName = implName; [EOL] } [EOL] visible = true; [EOL] } [EOL] boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL] _property(implName).addSetter(m, explName, visible, ignore); [EOL] }
public void testRenamePropertiesWithNoRename() { [EOL] POJOPropertyBuilder prop1 = createPropertyBuilder("prop1"); [EOL] POJOPropertyBuilder prop2 = createPropertyBuilder("prop2"); [EOL] Map<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("prop1", prop1); [EOL] properties.put("prop2", prop2); [EOL] _renameProperties(properties, null); [EOL] assertEquals("prop1", properties.get("prop1").getName()); [EOL] assertEquals("prop2", properties.get("prop2").getName()); [EOL] assertNull("No properties should be renamed", renamed); [EOL] }
public void testRenamePropertiesWithRename() { [EOL] POJOPropertyBuilder prop1 = createPropertyBuilder("prop1"); [EOL] POJOPropertyBuilder prop2 = createPropertyBuilder("prop2"); [EOL] prop2.setNewName("newProp2"); [EOL] Map<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("prop1", prop1); [EOL] properties.put("prop2", prop2); [EOL] _renameProperties(properties, null); [EOL] assertEquals("prop1", properties.get("prop1").getName()); [EOL] assertEquals("newProp2", properties.get("newProp2").getName()); [EOL] assertNotNull("Properties should be renamed", renamed); [EOL] assertFalse("Original property name should be removed", properties.containsKey("prop2")); [EOL] }
public void testRenamePropertiesWithCreatorProperties() { [EOL] POJOPropertyBuilder prop1 = createPropertyBuilder("prop1"); [EOL] POJOPropertyBuilder prop2 = createPropertyBuilder("prop2"); [EOL] prop2.setNewName("newProp2"); [EOL] Map<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("prop1", prop1); [EOL] properties.put("prop2", prop2); [EOL] List<POJOPropertyBuilder> creatorProperties = new ArrayList<>(); [EOL] creatorProperties.add(prop2); [EOL] _renameProperties(properties, creatorProperties); [EOL] assertEquals("prop1", properties.get("prop1").getName()); [EOL] assertEquals("newProp2", properties.get("newProp2").getName()); [EOL] assertEquals("newProp2", creatorProperties.get(0).getName()); [EOL] assertNotNull("Properties should be renamed", renamed); [EOL] assertFalse("Original property name should be removed", properties.containsKey("prop2")); [EOL] }
public void testRenameUsingSerializationWithGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForGetterMethod(any(), any(), anyString())).thenReturn("renamedGetter"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(prop.getGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedGetter"); [EOL] }
public void testRenameUsingSerializationWithField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("renamedField"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedField"); [EOL] }
public void testRenameUsingDeserializationWithSetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForSetterMethod(any(), any(), anyString())).thenReturn("renamedSetter"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasSetter()).thenReturn(true); [EOL] when(prop.getSetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedSetter"); [EOL] }
public void testRenameUsingDeserializationWithConstructorParameter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForConstructorParameter(any(), any(), anyString())).thenReturn("renamedCtorParam"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasConstructorParameter()).thenReturn(true); [EOL] when(prop.getConstructorParameter()).thenReturn(mock(AnnotatedParameter.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedCtorParam"); [EOL] }
public void testRenameUsingDeserializationWithField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("renamedField"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedField"); [EOL] }
public void testRenameUsingDeserializationWithGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForGetterMethod(any(), any(), anyString())).thenReturn("renamedGetter"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(prop.getGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedGetter"); [EOL] }
public void testRenameUsingNoChanges() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("original"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _renameUsing(naming); [EOL] verify(prop, never()).withName(anyString()); [EOL] }
public void testFindNamingStrategyWithNullIntrospectorAndConfigStrategy() { [EOL] _annotationIntrospector = null; [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] Mockito.when(_config.getPropertyNamingStrategy()).thenReturn(Mockito.mock(PropertyNamingStrategy.class)); [EOL] PropertyNamingStrategy result = _findNamingStrategy(); [EOL] assertNotNull(result); [EOL] }
public void testFindNamingStrategyWithDirectNamingStrategy() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] PropertyNamingStrategy namingStrategy = Mockito.mock(PropertyNamingStrategy.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(namingStrategy); [EOL] PropertyNamingStrategy result = _findNamingStrategy(); [EOL] assertSame(namingStrategy, result); [EOL] }
public void testFindNamingStrategyWithInvalidType() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(new Object()); [EOL] try { [EOL] _findNamingStrategy(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindNamingStrategyWithClassNotOfTypePropertyNamingStrategy() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(String.class); [EOL] try { [EOL] _findNamingStrategy(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindNamingStrategyWithHandlerInstantiator() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] HandlerInstantiator hi = Mockito.mock(HandlerInstantiator.class); [EOL] PropertyNamingStrategy namingStrategy = Mockito.mock(PropertyNamingStrategy.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(PropertyNamingStrategy.class); [EOL] Mockito.when(_config.getHandlerInstantiator()).thenReturn(hi); [EOL] Mockito.when(hi.namingStrategyInstance(_config, _classDef, PropertyNamingStrategy.class)).thenReturn(namingStrategy); [EOL] PropertyNamingStrategy result = _findNamingStrategy(); [EOL] assertSame(namingStrategy, result); [EOL] }
public void testFindNamingStrategyWithClassAndNoHandlerInstantiator() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(PropertyNamingStrategy.class); [EOL] Mockito.when(_config.getHandlerInstantiator()).thenReturn(null); [EOL] Mockito.when(_config.canOverrideAccessModifiers()).thenReturn(true); [EOL] PropertyNamingStrategy result = _findNamingStrategy(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyNamingStrategy); [EOL] }
public void testConstructUsingToStringWithValidEnum() { [EOL] EnumResolver<DayOfWeek> resolver = EnumResolver.constructUsingToString(DayOfWeek.class); [EOL] assertNotNull(resolver); [EOL] assertEquals(DayOfWeek.class, resolver.getEnumClass()); [EOL] assertEquals(7, resolver.getEnums().length); [EOL] assertEquals(DayOfWeek.MONDAY, resolver.getEnums()[1]); [EOL] assertEquals(DayOfWeek.MONDAY, resolver.getEnum(DayOfWeek.MONDAY.toString())); [EOL] }
public void testConstructUsingToStringWithEmptyEnum() { [EOL] EnumResolver<EmptyEnum> resolver = EnumResolver.constructUsingToString(EmptyEnum.class); [EOL] assertNotNull(resolver); [EOL] assertEquals(EmptyEnum.class, resolver.getEnumClass()); [EOL] assertEquals(0, resolver.getEnums().length); [EOL] } [EOL] enum DayOfWeek { [EOL] MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY [EOL] } [EOL] enum EmptyEnum { [EOL] }
public void testConstructUnsafeUsingToStringWithValidEnum() { [EOL] Class<?> rawEnumCls = MyEnum.class; [EOL] EnumResolver<?> result = EnumResolver.constructUnsafeUsingToString(rawEnumCls); [EOL] assertNotNull(result); [EOL] assertTrue(result.getEnumClass().equals(MyEnum.class)); [EOL] } [EOL] public void testConstructUnsafeUsingToStringWithNonEnum() { [EOL] Class<?> rawNonEnumCls = Object.class; [EOL] try { [EOL] EnumResolver.constructUnsafeUsingToString(rawNonEnumCls); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetEnumWithNegativeIndex() { [EOL] EnumContainer container = new EnumContainer(); // Assuming EnumContainer is the class containing getEnum [EOL] T result = container.getEnum(-1); [EOL] assertNull(result); [EOL] }
public void testGetEnumWithIndexOutOfBounds() { [EOL] EnumContainer container = new EnumContainer(); // Assuming EnumContainer is the class containing getEnum [EOL] T result = container.getEnum(container.size()); // Assuming size() returns the length of _enums [EOL] assertNull(result); [EOL] }
public void testGetEnumWithValidIndex() { [EOL] EnumContainer container = new EnumContainer(); // Assuming EnumContainer is the class containing getEnum [EOL] T expected = container.getExpectedEnum(0); // Assuming getExpectedEnum(int index) is a method to get expected enum value [EOL] T result = container.getEnum(0); [EOL] assertEquals(expected, result); [EOL] }
public void testGetEnumClass() { [EOL] MyClass instance = new MyClass(); [EOL] Class<T> result = instance.getEnumClass(); [EOL] assertNotNull("The result should not be null", result); [EOL] assertEquals("The result should be the expected enum class", ExpectedEnumClass.class, result); [EOL] }
protected StaticListSerializerBase(Class<?> cls) { [EOL] super(cls, false); [EOL] }
public void testIsEmptyWithNullValue() { [EOL] boolean result = isEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithEmptyCollection() { [EOL] Collection<?> emptyCollection = Collections.emptySet(); [EOL] boolean result = isEmpty(emptyCollection); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithNonEmptyCollection() { [EOL] Collection<?> nonEmptyCollection = Arrays.asList("item"); [EOL] boolean result = isEmpty(nonEmptyCollection); [EOL] assertFalse(result); [EOL] }
public void testObjectReaderConstructionWithNonNullValues() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] JavaType valueType = mapper.constructType(String.class); [EOL] Object valueToUpdate = "initialValue"; [EOL] FormatSchema schema = new MockSchema(); [EOL] InjectableValues injectableValues = new InjectableValues.Std(); [EOL] ObjectReader reader = new ObjectReader(mapper, config, valueType, valueToUpdate, schema, injectableValues); [EOL] assertNotNull(reader); [EOL] } [EOL] public void testObjectReaderConstructionWithArrayValueType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] JavaType valueType = mapper.constructType(String[].class); [EOL] Object valueToUpdate = new String[]{"initialValue"}; [EOL] try { [EOL] new ObjectReader(mapper, config, valueType, valueToUpdate, null, null); [EOL] fail("Expected IllegalArgumentException for array value type with valueToUpdate"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testObjectReaderConstructionWithNullValues() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] JavaType valueType = mapper.constructType(String.class); [EOL] ObjectReader reader = new ObjectReader(mapper, config, valueType, null, null, null); [EOL] assertNotNull(reader); [EOL] }
public void testWithType_ClassNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] Class<?> valueType = String.class; [EOL] ObjectReader resultReader = reader.withType(valueType); [EOL] assertNotNull(resultReader); [EOL] assertNotSame(reader, resultReader); [EOL] }
public void testWithType_ClassNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] try { [EOL] reader.withType((Class<?>) null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithView_NullView() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader readerWithNullView = reader.withView(null); [EOL] assertNotNull(readerWithNullView); [EOL] assertNotSame(reader, readerWithNullView); [EOL] }
public void testWithView_ActiveView() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader readerWithActiveView = reader.withView(Object.class); [EOL] assertNotNull(readerWithActiveView); [EOL] assertNotSame(reader, readerWithActiveView); [EOL] }
public void testWithFormatDetectionWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader result = mapper.reader().withFormatDetection((ObjectReader[]) null); [EOL] assertNotNull(result); [EOL] }
public void testWithFormatDetectionWithEmptyArray() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader result = mapper.reader().withFormatDetection(new ObjectReader[0]); [EOL] assertNotNull(result); [EOL] }
public void testWithFormatDetectionWithSingleReader() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader result = mapper.reader().withFormatDetection(reader); [EOL] assertNotNull(result); [EOL] }
public void testWithFormatDetectionWithMultipleReaders() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader1 = mapper.reader(); [EOL] ObjectReader reader2 = mapper.reader(); [EOL] ObjectReader result = mapper.reader().withFormatDetection(reader1, reader2); [EOL] assertNotNull(result); [EOL] }
public void testWithFormatDetectionNull() { [EOL] ObjectReader reader = new ObjectReader(); [EOL] DataFormatReaders formatReaders = null; [EOL] ObjectReader result = reader.withFormatDetection(formatReaders); [EOL] assertNotNull(result); [EOL] }
public void testWithFormatDetectionNonNull() { [EOL] ObjectReader reader = new ObjectReader(); [EOL] DataFormatReaders formatReaders = new DataFormatReaders(new JsonFactory()); [EOL] ObjectReader result = reader.withFormatDetection(formatReaders); [EOL] assertNotNull(result); [EOL] assertSame(formatReaders, result._dataFormatReaders); [EOL] }
public void testReadValueWithNonNullDataFormatReaders() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = "\"test\""; [EOL] mapper._dataFormatReaders = new DataFormatReaders(); // Assuming this is a valid way to set non-null _dataFormatReaders [EOL] try { [EOL] mapper.readValue(json); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testReadValueWithNullDataFormatReaders() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = "\"test\""; [EOL] mapper._dataFormatReaders = null; // Assuming this is a valid way to set null _dataFormatReaders [EOL] String result = mapper.readValue(json); [EOL] assertEquals("test", result); [EOL] }
public void testReadValueWithNonNullDataFormatReaders() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DataFormatReaders dataFormatReaders = mock(DataFormatReaders.class); [EOL] byte[] src = new byte[] {1, 2, 3}; [EOL] Object expectedValue = new Object(); [EOL] when(dataFormatReaders.detectAndReadValue(eq(src), anyInt(), anyInt(), any(ObjectMapper.class), any(JavaType.class))).thenReturn(expectedValue); [EOL] ReflectionTestUtils.setField(mapper, "_dataFormatReaders", dataFormatReaders); [EOL] Object result = mapper.readValue(src); [EOL] assertSame("The returned object should be the one returned by DataFormatReaders.", expectedValue, result); [EOL] }
public void testReadValueWithNullDataFormatReaders() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] src = new byte[] {1, 2, 3}; [EOL] Object expectedValue = new Object(); [EOL] JsonParser jsonParser = mock(JsonParser.class); [EOL] when(mapper.getFactory().createParser(src)).thenReturn(jsonParser); [EOL] when(mapper.readValue(jsonParser, Object.class)).thenReturn(expectedValue); [EOL] ReflectionTestUtils.setField(mapper, "_dataFormatReaders", null); [EOL] ReflectionTestUtils.setField(mapper, "_valueToUpdate", null); [EOL] Object result = mapper.readValue(src); [EOL] assertSame("The returned object should be the one read by the mapper.", expectedValue, result); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenEndObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_OBJECT); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenNotEndNorNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for this case [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNotEndNorNullAndUnwrapRoot() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for this case [EOL] when(_unwrapRoot).thenReturn(true); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNotEndNorNullAndNotUnwrapRoot() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.setSchema(any(FormatSchema.class))).thenReturn(null); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for this case [EOL] when(_unwrapRoot).thenReturn(false); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] verify(jp).setSchema(any(FormatSchema.class)); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void testInitForReadingWithCurrentTokenNotNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonToken result = _initForReading(jp); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testInitForReadingWithCurrentTokenNullAndNextTokenNotNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonToken result = _initForReading(jp); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testInitForReadingWithCurrentTokenNullAndNextTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(null); [EOL] try { [EOL] _initForReading(jp); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("No content to map due to end-of-input", e.getMessage()); [EOL] } [EOL] }
public void testFindRootDeserializerWithNonNullRootDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType valueType = createJavaType(); [EOL] JsonDeserializer<Object> expectedDeserializer = createJsonDeserializer(); [EOL] ObjectReader reader = createObjectReaderWithRootDeserializer(expectedDeserializer); [EOL] JsonDeserializer<Object> result = reader._findRootDeserializer(ctxt, valueType); [EOL] assertSame("Expected the provided root deserializer to be returned", expectedDeserializer, result); [EOL] }
public void testFindRootDeserializerWithNullValueType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType valueType = null; [EOL] ObjectReader reader = createObjectReaderWithNoRootDeserializer(); [EOL] try { [EOL] reader._findRootDeserializer(ctxt, valueType); [EOL] fail("Expected JsonMappingException to be thrown due to null valueType"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("No value type configured for ObjectReader", e.getMessage()); [EOL] } [EOL] }
public void testFindRootDeserializerWithCachedDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType valueType = createJavaType(); [EOL] JsonDeserializer<Object> expectedDeserializer = createJsonDeserializer(); [EOL] ObjectReader reader = createObjectReaderWithCachedDeserializer(valueType, expectedDeserializer); [EOL] JsonDeserializer<Object> result = reader._findRootDeserializer(ctxt, valueType); [EOL] assertSame("Expected the cached deserializer to be returned", expectedDeserializer, result); [EOL] }
public void testFindRootDeserializerWithNoCachedDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType valueType = createJavaType(); [EOL] JsonDeserializer<Object> expectedDeserializer = createJsonDeserializer(); [EOL] ObjectReader reader = createObjectReaderWithNoRootDeserializer(); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> result = reader._findRootDeserializer(ctxt, valueType); [EOL] assertSame("Expected the deserializer found by context to be returned", expectedDeserializer, result); [EOL] }
public void testFindRootDeserializerWithNullDeserializerFromContext() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType valueType = createJavaType(); [EOL] ObjectReader reader = createObjectReaderWithNoRootDeserializer(); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(null); [EOL] try { [EOL] reader._findRootDeserializer(ctxt, valueType); [EOL] fail("Expected JsonMappingException to be thrown due to null deserializer from context"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not find a deserializer for type " + valueType, e.getMessage()); [EOL] } [EOL] }
public void testPrefetchRootDeserializerWithValueTypeNull() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType valueType = null; [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithEagerDeserializerFetchDisabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.disable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithCacheHit() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] JsonDeserializer<Object> expectedDeserializer = new JsonDeserializer<>() { ... }; // Provide actual deserializer [EOL] _rootDeserializers.put(valueType, expectedDeserializer); [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertSame(expectedDeserializer, result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithCacheMissAndSuccessfulDeserialization() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] DeserializationContext ctxt = new DeserializationContext(...); // Provide actual initialization [EOL] JsonDeserializer<Object> expectedDeserializer = ctxt.findRootValueDeserializer(valueType); [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] } [EOL] public void testPrefetchRootDeserializerWithCacheMissAndException() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = new JavaType(...); // Provide actual initialization [EOL] DeserializationContext ctxt = new DeserializationContext(...); // Provide actual initialization [EOL] doThrow(new JsonProcessingException("")).when(ctxt).findRootValueDeserializer(valueType); [EOL] JsonDeserializer<Object> result = _prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testDetectBindAndCloseWithNoMatch() throws IOException { [EOL] byte[] src = new byte[] { /* some byte array that does not match any format */ }; [EOL] int offset = 0; [EOL] int length = src.length; [EOL] DataFormatReaders mockDataFormatReaders = Mockito.mock(DataFormatReaders.class); [EOL] DataFormatReaders.Match mockMatch = Mockito.mock(DataFormatReaders.Match.class); [EOL] Mockito.when(mockDataFormatReaders.findFormat(src, offset, length)).thenReturn(mockMatch); [EOL] Mockito.when(mockMatch.hasMatch()).thenReturn(false); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper._dataFormatReaders = mockDataFormatReaders; [EOL] try { [EOL] objectMapper._detectBindAndClose(src, offset, length); [EOL] fail("Should have thrown an exception for unknown format"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDetectBindAndCloseWithMatch() throws IOException { [EOL] byte[] src = new byte[] { /* some byte array that matches a format */ }; [EOL] int offset = 0; [EOL] int length = src.length; [EOL] DataFormatReaders mockDataFormatReaders = Mockito.mock(DataFormatReaders.class); [EOL] DataFormatReaders.Match mockMatch = Mockito.mock(DataFormatReaders.Match.class); [EOL] JsonParser mockJsonParser = Mockito.mock(JsonParser.class); [EOL] ObjectReader mockObjectReader = Mockito.mock(ObjectReader.class); [EOL] Object expectedValue = new Object(); [EOL] Mockito.when(mockDataFormatReaders.findFormat(src, offset, length)).thenReturn(mockMatch); [EOL] Mockito.when(mockMatch.hasMatch()).thenReturn(true); [EOL] Mockito.when(mockMatch.createParserWithMatch()).thenReturn(mockJsonParser); [EOL] Mockito.when(mockMatch.getReader()).thenReturn(mockObjectReader); [EOL] Mockito.when(mockObjectReader._bindAndClose(mockJsonParser, null)).thenReturn(expectedValue); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper._dataFormatReaders = mockDataFormatReaders; [EOL] Object actualValue = objectMapper._detectBindAndClose(src, offset, length); [EOL] assertSame("The returned object should be the one returned by _bindAndClose", expectedValue, actualValue); [EOL] }
public void testReportUnknownFormatWithNonNullDetectorAndMatch() throws JsonProcessingException { [EOL] DataFormatReaders detector = new DataFormatReaders(); [EOL] DataFormatReaders.Match match = detector.findFormat(new byte[0]); [EOL] try { [EOL] _reportUnkownFormat(detector, match); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Can not detect format from input, does not look like any of detectable formats " + detector.toString(), e.getMessage()); [EOL] } [EOL] }
protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { [EOL] return _context.createInstance(cfg, jp, _injectableValues); [EOL] }
public void testConstructWithNonNullTypes() { [EOL] Class<?> rawType = List.class; [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionLikeType collectionLikeType = CollectionLikeType.construct(rawType, elemType); [EOL] assertNotNull(collectionLikeType); [EOL] assertEquals(rawType, collectionLikeType.getRawClass()); [EOL] assertEquals(elemType, collectionLikeType.getContentType()); [EOL] }
public void testConstructWithNullElemType() { [EOL] Class<?> rawType = Set.class; [EOL] JavaType elemType = null; [EOL] try { [EOL] CollectionLikeType.construct(rawType, elemType); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testObjectWriterConstructionWithNonNullSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] FormatSchema schema = new BogusFormatSchema(); [EOL] ObjectWriter writer = new ObjectWriter(mapper, config, schema); [EOL] assertNotNull(writer); [EOL] assertSame(config, writer._config); [EOL] assertSame(mapper._serializerProvider, writer._serializerProvider); [EOL] assertSame(mapper._serializerFactory, writer._serializerFactory); [EOL] assertSame(mapper._jsonFactory, writer._jsonFactory); [EOL] assertNull(writer._rootType); [EOL] assertNull(writer._rootSerializer); [EOL] assertNull(writer._prettyPrinter); [EOL] assertSame(schema, writer._schema); [EOL] }
public void testObjectWriterConstructionWithNullSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] ObjectWriter writer = new ObjectWriter(mapper, config, null); [EOL] assertNotNull(writer); [EOL] assertSame(config, writer._config); [EOL] assertSame(mapper._serializerProvider, writer._serializerProvider); [EOL] assertSame(mapper._serializerFactory, writer._serializerFactory); [EOL] assertSame(mapper._jsonFactory, writer._jsonFactory); [EOL] assertNull(writer._rootType); [EOL] assertNull(writer._rootSerializer); [EOL] assertNull(writer._prettyPrinter); [EOL] assertNull(writer._schema); [EOL] }
public void testWithSerializationFeatureEnabled() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] SerializationFeature feature = SerializationFeature.WRAP_ROOT_VALUE; [EOL] ObjectWriter modifiedWriter = writer.with(feature); [EOL] assertNotSame(writer, modifiedWriter); [EOL] assertTrue(modifiedWriter._config.hasSerializationFeatures(feature.getMask())); [EOL] }
public void testWithSerializationFeatureDisabled() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] SerializationFeature feature = SerializationFeature.WRAP_ROOT_VALUE; [EOL] ObjectWriter modifiedWriter = writer.with(feature); [EOL] ObjectWriter secondModification = modifiedWriter.with(feature); [EOL] assertSame(modifiedWriter, secondModification); [EOL] }
public void testWriteValueWithCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(value).close(); [EOL] }
public void testWriteValueWithNonCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, false); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).close(); [EOL] }
public void testWriteValueFlushAfterWrite() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, true); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen).flush(); [EOL] }
public void testWriteValueWithoutFlushAfterWrite() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, false); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).flush(); [EOL] }
public void testWriteValueWithRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> rootSerializer = mock(JsonSerializer.class); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, false); [EOL] objectMapper.setConfig(objectMapper.getSerializationConfig().with(rootType).with(rootSerializer)); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(rootSerializer).serialize(eq(value), eq(jgen), any(SerializerProvider.class)); [EOL] }
public void testWriteValueWithoutRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.configure(SerializationFeature.CLOSE_CLOSEABLE, false); [EOL] objectMapper.setConfig(objectMapper.getSerializationConfig().withoutRootName()); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).writeObjectFieldStart(anyString()); [EOL] }
public void testConfigureJsonGeneratorWithPrettyPrinterNull() { [EOL] JsonGenerator jgen = createMockJsonGenerator(); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setPrettyPrinter(null); [EOL] }
public void testConfigureJsonGeneratorWithNonNullPrettyPrinter() { [EOL] JsonGenerator jgen = createMockJsonGenerator(); [EOL] PrettyPrinter pp = createMockPrettyPrinter(); [EOL] setPrettyPrinter(pp); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setPrettyPrinter(pp); [EOL] }
public void testConfigureJsonGeneratorWithInstantiatablePrettyPrinter() { [EOL] JsonGenerator jgen = createMockJsonGenerator(); [EOL] PrettyPrinter pp = createMockInstantiatablePrettyPrinter(); [EOL] setPrettyPrinter(pp); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setPrettyPrinter(any(PrettyPrinter.class)); [EOL] }
public void testConfigureJsonGeneratorWithIndentOutputEnabled() { [EOL] JsonGenerator jgen = createMockJsonGenerator(); [EOL] enableSerializationFeature(SerializationFeature.INDENT_OUTPUT); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] }
public void testConfigureJsonGeneratorWithSchema() { [EOL] JsonGenerator jgen = createMockJsonGenerator(); [EOL] FormatSchema schema = createMockFormatSchema(); [EOL] setSchema(schema); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setSchema(schema); [EOL] }
public void testWriteReplaceClearsIncompleteDeserializers() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper._incompleteDeserializers.put(someKey, someValue); // Assuming someKey and someValue are valid objects for the map [EOL] Object result = objectMapper.writeReplace(); [EOL] assertTrue(objectMapper._incompleteDeserializers.isEmpty()); [EOL] assertSame(objectMapper, result); [EOL] }
public void testCreateDeserializer2WithEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(true); [EOL] when(factory.createEnumDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithArrayType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isArrayType()).thenReturn(true); [EOL] when(factory.createArrayDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithMapType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapType type = mock(MapType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(((MapLikeType) type).isTrueMapType()).thenReturn(true); [EOL] when(factory.createMapDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(type.isTrueMapType()).thenReturn(false); [EOL] when(factory.createMapLikeDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithCollectionType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(((CollectionLikeType) type).isTrueCollectionType()).thenReturn(true); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(null); [EOL] when(factory.createCollectionDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithCollectionLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(type.isTrueCollectionType()).thenReturn(false); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] when(factory.createCollectionLikeDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithJsonNodeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(JsonNode.class); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(true); [EOL] when(factory.createTreeDeserializer(config, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithBeanType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(false); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(false); [EOL] when(factory.createBeanDeserializer(ctxt, type, beanDesc)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> deserializer = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCompleteAndClearBufferWithEmptyBuffer() { [EOL] Object[] lastChunk = new Object[] {"a", "b", "c"}; [EOL] int lastChunkEntries = 3; [EOL] List<Object> resultList = new ArrayList<>(); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertEquals(3, resultList.size()); [EOL] assertTrue(resultList.contains("a")); [EOL] assertTrue(resultList.contains("b")); [EOL] assertTrue(resultList.contains("c")); [EOL] }
public void testCompleteAndClearBufferWithNonEmptyBuffer() { [EOL] Node firstNode = new Node(new Object[] {"1", "2"}); [EOL] Node secondNode = new Node(new Object[] {"3"}); [EOL] firstNode.setNext(secondNode); [EOL] _bufferHead = firstNode; [EOL] Object[] lastChunk = new Object[] {"a", "b"}; [EOL] int lastChunkEntries = 2; [EOL] List<Object> resultList = new ArrayList<>(); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertEquals(5, resultList.size()); [EOL] assertTrue(resultList.contains("1")); [EOL] assertTrue(resultList.contains("2")); [EOL] assertTrue(resultList.contains("3")); [EOL] assertTrue(resultList.contains("a")); [EOL] assertTrue(resultList.contains("b")); [EOL] }
public void testCompleteAndClearBufferWithPartialLastChunk() { [EOL] _bufferHead = null; // No nodes in the buffer [EOL] Object[] lastChunk = new Object[] {"a", "b", "c", null, null}; [EOL] int lastChunkEntries = 3; // Only first 3 entries are valid [EOL] List<Object> resultList = new ArrayList<>(); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertEquals(3, resultList.size()); [EOL] assertTrue(resultList.contains("a")); [EOL] assertTrue(resultList.contains("b")); [EOL] assertTrue(resultList.contains("c")); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithValueEmbeddedObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(new Object()); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithValueStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string"); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals("string", result); [EOL] }
public void testDeserializeWithValueNumberIntTokenUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(BigInteger.ONE); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(BigInteger.ONE, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(1); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(1, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(BigDecimal.ONE); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(BigDecimal.ONE, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(1.0); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(1.0), result); [EOL] }
public void testDeserializeWithValueTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeWithValueFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeWithValueNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithDefaultCaseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); // Any token that is not covered by the switch cases [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testMapArrayWithJavaArrayFeatureEnabled() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(true); [EOL] Object expected = new Object(); [EOL] when(this.mapArrayToArray(jp, ctxt)).thenReturn(expected); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testMapArrayWithEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertTrue(((ArrayList) result).isEmpty()); [EOL] }
public void testMapArrayWithNonEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = mock(ObjectBuffer.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] when(buffer.resetAndStart()).thenReturn(new Object[4]); [EOL] when(this.deserialize(jp, ctxt)).thenReturn("value"); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertFalse(((ArrayList) result).isEmpty()); [EOL] assertEquals("value", ((ArrayList) result).get(0)); [EOL] }
public void testMapArrayWithGrowingArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = mock(ObjectBuffer.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] Object[] initialArray = new Object[1]; [EOL] Object[] expandedArray = new Object[2]; [EOL] when(buffer.resetAndStart()).thenReturn(initialArray); [EOL] when(buffer.appendCompletedChunk(initialArray)).thenReturn(expandedArray); [EOL] when(this.deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2"); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertEquals(2, ((ArrayList) result).size()); [EOL] assertEquals("value1", ((ArrayList) result).get(0)); [EOL] assertEquals("value2", ((ArrayList) result).get(1)); [EOL] }
public void testMapObjectWithEmptyObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertTrue(((LinkedHashMap) result).isEmpty()); [EOL] }
public void testMapObjectWithOneField() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertEquals(1, ((LinkedHashMap) result).size()); [EOL] assertEquals("value1", ((LinkedHashMap) result).get("field1")); [EOL] }
public void testMapObjectWithTwoFields() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1").thenReturn("field2"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertEquals(2, ((LinkedHashMap) result).size()); [EOL] assertEquals("value1", ((LinkedHashMap) result).get("field1")); [EOL] assertEquals("value2", ((LinkedHashMap) result).get("field2")); [EOL] }
public void testMapObjectWithMultipleFields() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1").thenReturn("field2").thenReturn("field3"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2").thenReturn("value3"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] LinkedHashMap resultMap = (LinkedHashMap) result; [EOL] assertEquals(3, resultMap.size()); [EOL] assertEquals("value1", resultMap.get("field1")); [EOL] assertEquals("value2", resultMap.get("field2")); [EOL] assertEquals("value3", resultMap.get("field3")); [EOL] }
public void testAnnotatedMethodWithSerialization() { [EOL] Serialization serialization = new Serialization(); // Assuming Serialization is a valid class [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(serialization); [EOL] assertNull(annotatedMethod.getMember()); // Assuming getMember() returns the _method [EOL] assertEquals(serialization, annotatedMethod.getSerialization()); // Assuming getSerialization() returns the _serialization [EOL] }
public void testWithMethodNonNull() { [EOL] Method method = SomeClass.class.getMethod("someMethod"); [EOL] AnnotatedMethod originalAnnotatedMethod = new AnnotatedMethod(method, null, null); [EOL] AnnotatedMethod newAnnotatedMethod = originalAnnotatedMethod.withMethod(method); [EOL] assertNotNull(newAnnotatedMethod); [EOL] assertEquals(method, newAnnotatedMethod.getAnnotated()); [EOL] }
public void testWithMethodDifferentMethod() throws NoSuchMethodException { [EOL] Method method1 = SomeClass.class.getMethod("someMethod"); [EOL] Method method2 = SomeOtherClass.class.getMethod("someOtherMethod"); [EOL] AnnotatedMethod originalAnnotatedMethod = new AnnotatedMethod(method1, null, null); [EOL] AnnotatedMethod newAnnotatedMethod = originalAnnotatedMethod.withMethod(method2); [EOL] assertNotNull(newAnnotatedMethod); [EOL] assertEquals(method2, newAnnotatedMethod.getAnnotated()); [EOL] }
public void testSetValueSuccess() { [EOL] Object pojo = new MyClass(); [EOL] Object value = "someValue"; [EOL] MyMethodContainer methodContainer = new MyMethodContainer(); // This class wraps the method to be tested [EOL] methodContainer.setValue(pojo, value); [EOL] assertEquals("someValue", pojo.getSomeField()); [EOL] }
public void testSetValueIllegalAccessException() { [EOL] Object pojo = new MyClass(); [EOL] Object value = "someValue"; [EOL] MyMethodContainer methodContainer = new MyMethodContainer() { [EOL] @Override [EOL] public void setValue(Object pojo, Object value) { [EOL] throw new IllegalAccessException("Access denied"); [EOL] } [EOL] }; [EOL] try { [EOL] methodContainer.setValue(pojo, value); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Failed to setValue() with method " + methodContainer.getFullName() + ": Access denied", e.getMessage()); [EOL] } [EOL] }
public void testSetValueInvocationTargetException() { [EOL] Object pojo = new MyClass(); [EOL] Object value = "someValue"; [EOL] MyMethodContainer methodContainer = new MyMethodContainer() { [EOL] @Override [EOL] public void setValue(Object pojo, Object value) throws InvocationTargetException { [EOL] throw new InvocationTargetException(new Throwable("Invocation failed")); [EOL] } [EOL] }; [EOL] try { [EOL] methodContainer.setValue(pojo, value); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Failed to setValue() with method " + methodContainer.getFullName() + ": Invocation failed", e.getMessage()); [EOL] } [EOL] }
public void testWriteReplace() { [EOL] Method method = MyClass.class.getDeclaredMethod("myMethod"); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(method); [EOL] Object replacedObject = annotatedMethod.writeReplace(); [EOL] assertNotNull(replacedObject); [EOL] assertTrue(replacedObject instanceof AnnotatedMethod.Serialization); [EOL] AnnotatedMethod.Serialization serialization = (AnnotatedMethod.Serialization) replacedObject; [EOL] assertEquals(method, serialization.getMethod()); [EOL] }
public void testReadResolveWithAccessibleMethod() { [EOL] SerializationConfig _serialization = createSerializationConfig("accessibleMethod", new Class<?>[]{}); [EOL] Object result = readResolve(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof AnnotatedMethod); [EOL] } [EOL] public void testReadResolveWithInaccessibleMethod() { [EOL] SerializationConfig _serialization = createSerializationConfig("inaccessibleMethod", new Class<?>[]{}); [EOL] Object result = readResolve(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof AnnotatedMethod); [EOL] } [EOL] public void testReadResolveMethodNotFound() { [EOL] SerializationConfig _serialization = createSerializationConfig("nonExistentMethod", new Class<?>[]{}); [EOL] try { [EOL] Object result = readResolve(); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Could not find method 'nonExistentMethod' from Class '" + _serialization.clazz.getName(), e.getMessage()); [EOL] } [EOL] }
private SerializationConfig createSerializationConfig(String methodName, Class<?>[] argTypes) { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] config.clazz = SomeClass.class; // Replace SomeClass with the actual class you want to test [EOL] config.name = methodName; [EOL] config.args = argTypes; [EOL] return config; [EOL] }
public void testSerializationWithValidSetter() { [EOL] Class<?> clazz = SomeClass.class; [EOL] Method setter = clazz.getMethod("setSomeField", String.class); [EOL] Serialization serialization = new Serialization(setter); [EOL] assertEquals(clazz, serialization.clazz); [EOL] assertEquals("setSomeField", serialization.name); [EOL] assertArrayEquals(new Class<?>[]{String.class}, serialization.args); [EOL] }
public void testTreeTraversingParserWithNonNullNode() { [EOL] JsonNode node = JsonNodeFactory.instance.objectNode(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(node); [EOL] assertNotNull(parser); [EOL] }
public void testTreeTraversingParserWithNullNode() { [EOL] JsonNode node = null; [EOL] try { [EOL] TreeTraversingParser parser = new TreeTraversingParser(node); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTreeTraversingParserWithArrayNode() { [EOL] JsonNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(arrayNode, codec); [EOL] assertEquals(JsonToken.START_ARRAY, parser.nextToken()); [EOL] }
public void testTreeTraversingParserWithObjectNode() { [EOL] JsonNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(objectNode, codec); [EOL] assertEquals(JsonToken.START_OBJECT, parser.nextToken()); [EOL] }
public void testTreeTraversingParserWithOtherNode() { [EOL] JsonNode valueNode = JsonNodeFactory.instance.textNode("value"); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(valueNode, codec); [EOL] assertNull(parser.nextToken()); [EOL] }
public void testCloseWhenAlreadyClosed() { [EOL] JsonParser parser = createParser(); // Assume createParser() is a method that creates a JsonParser instance [EOL] parser.close(); // Close the parser for the first time [EOL] boolean wasClosed = parser.isClosed(); // Assume isClosed() is a method that checks if the parser is closed [EOL] parser.close(); // Try to close the parser again [EOL] boolean isStillClosed = parser.isClosed(); [EOL] assertTrue(wasClosed); [EOL] assertTrue(isStillClosed); [EOL] } [EOL] public void testCloseWhenNotClosed() { [EOL] JsonParser parser = createParser(); [EOL] boolean wasClosed = parser.isClosed(); [EOL] parser.close(); [EOL] boolean isNowClosed = parser.isClosed(); [EOL] assertFalse(wasClosed); [EOL] assertTrue(isNowClosed); [EOL] }
public void testNextTokenWithNextTokenNotNull() throws IOException, JsonParseException { [EOL] JsonToken expectedToken = JsonToken.VALUE_STRING; [EOL] TestParser parser = new TestParser(); [EOL] parser._nextToken = expectedToken; [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(expectedToken, actualToken); [EOL] assertNull(parser._nextToken); [EOL] }
public void testNextTokenWithStartContainerAndNoChildren() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._startContainer = true; [EOL] parser._currToken = JsonToken.START_OBJECT; [EOL] parser._nodeCursor = new TestNodeCursor(false); // Simulate no children [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, actualToken); [EOL] assertFalse(parser._startContainer); [EOL] }
public void testNextTokenWithStartContainerAndHasChildren() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._startContainer = true; [EOL] parser._nodeCursor = new TestNodeCursor(true); // Simulate has children [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNotNull(actualToken); [EOL] assertTrue(parser._startContainer == (actualToken == JsonToken.START_OBJECT || actualToken == JsonToken.START_ARRAY)); [EOL] }
public void testNextTokenWithNodeCursorNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._nodeCursor = null; [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNull(actualToken); [EOL] assertTrue(parser._closed); [EOL] }
public void testNextTokenWithNodeCursorNotNullAndNextTokenNotNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._nodeCursor = new TestNodeCursor(true); // Simulate next token is not null [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNotNull(actualToken); [EOL] assertTrue(parser._startContainer == (actualToken == JsonToken.START_OBJECT || actualToken == JsonToken.START_ARRAY)); [EOL] }
public void testNextTokenWithNodeCursorNotNullAndNextTokenNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._nodeCursor = new TestNodeCursor(true); // Simulate next token is null, end token is not null [EOL] parser._nodeCursor.setNextTokenNull(true); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNotNull(actualToken); [EOL] assertEquals(parser._nodeCursor.endToken(), actualToken); [EOL] assertEquals(parser._nodeCursor.getParent(), parser._nodeCursor); [EOL] }
public void testIsClosedWhenClosed() { [EOL] JsonParser parser = new JsonParser() { [EOL] private boolean _closed = true; [EOL] @Override [EOL] public boolean isClosed() { [EOL] return _closed; [EOL] } [EOL] }; [EOL] assertTrue(parser.isClosed()); [EOL] }
public void testIsClosedWhenNotClosed() { [EOL] JsonParser parser = new JsonParser() { [EOL] private boolean _closed = false; [EOL] @Override [EOL] public boolean isClosed() { [EOL] return _closed; [EOL] } [EOL] }; [EOL] assertFalse(parser.isClosed()); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsPojo() { [EOL] POJONode pojoNode = new POJONode(new Object()); [EOL] setCurrentNode(pojoNode); // hypothetical method to set the current node [EOL] Object result = getEmbeddedObject(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof POJONode); [EOL] assertEquals(pojoNode.getPojo(), result); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsBinary() { [EOL] byte[] data = new byte[] {1, 2, 3}; [EOL] BinaryNode binaryNode = new BinaryNode(data); [EOL] setCurrentNode(binaryNode); // hypothetical method to set the current node [EOL] Object result = getEmbeddedObject(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof byte[]); [EOL] assertArrayEquals(data, (byte[]) result); [EOL] }
public void testGetEmbeddedObjectWhenClosed() { [EOL] close(); // hypothetical method to close the context [EOL] Object result = getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsNull() { [EOL] setCurrentNode(null); // hypothetical method to set the current node [EOL] Object result = getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testGetEmbeddedObjectWhenNotClosedAndCurrentNodeIsNotPojoOrBinary() { [EOL] JsonNode node = mock(JsonNode.class); [EOL] when(node.isPojo()).thenReturn(false); [EOL] when(node.isBinary()).thenReturn(false); [EOL] setCurrentNode(node); // hypothetical method to set the current node [EOL] Object result = getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testGetBinaryValueWithNonNullNodeAndNonNullBinary() throws IOException, JsonParseException { [EOL] JsonNode mockNode = mock(JsonNode.class); [EOL] byte[] expectedData = new byte[]{1, 2, 3}; [EOL] when(mockNode.binaryValue()).thenReturn(expectedData); [EOL] when(mockNode.isPojo()).thenReturn(false); [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.currentNode()).thenReturn(mockNode); [EOL] byte[] actualData = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertArrayEquals(expectedData, actualData); [EOL] }
public void testGetBinaryValueWithNonNullNodeAndNullBinaryButPojoNode() throws IOException, JsonParseException { [EOL] JsonNode mockNode = mock(JsonNode.class); [EOL] when(mockNode.binaryValue()).thenReturn(null); [EOL] when(mockNode.isPojo()).thenReturn(true); [EOL] byte[] expectedData = new byte[]{4, 5, 6}; [EOL] POJONode pojoNode = new POJONode(expectedData); [EOL] when(mockNode.getPojo()).thenReturn(pojoNode.getPojo()); [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.currentNode()).thenReturn(mockNode); [EOL] byte[] actualData = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertArrayEquals(expectedData, actualData); [EOL] }
public void testGetBinaryValueWithNonNullNodeAndNullBinaryAndNotPojoNode() throws IOException, JsonParseException { [EOL] JsonNode mockNode = mock(JsonNode.class); [EOL] when(mockNode.binaryValue()).thenReturn(null); [EOL] when(mockNode.isPojo()).thenReturn(false); [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.currentNode()).thenReturn(mockNode); [EOL] byte[] actualData = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertNull(actualData); [EOL] }
public void testGetBinaryValueWithNullNode() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.currentNode()).thenReturn(null); [EOL] byte[] actualData = parser.getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] assertNull(actualData); [EOL] }
public void testCurrentNodeWhenClosed() { [EOL] JsonNodeCursor cursor = mock(JsonNodeCursor.class); [EOL] JsonParser parser = new JsonParser(cursor); [EOL] parser.close(); [EOL] assertNull(parser.currentNode()); [EOL] }
public void testCurrentNodeWhenCursorIsNull() { [EOL] JsonParser parser = new JsonParser(null); [EOL] assertNull(parser.currentNode()); [EOL] }
public void testCurrentNodeWhenActive() { [EOL] JsonNode expectedNode = mock(JsonNode.class); [EOL] JsonNodeCursor cursor = mock(JsonNodeCursor.class); [EOL] when(cursor.currentNode()).thenReturn(expectedNode); [EOL] JsonParser parser = new JsonParser(cursor); [EOL] assertSame(expectedNode, parser.currentNode()); [EOL] }
protected ArraySerializerBase(Class<T> cls) { [EOL] super(cls); [EOL] _property = null; [EOL] }
public void testLongNodeConstructor() { [EOL] long testValue = 5L; [EOL] LongNode node = new LongNode(testValue); [EOL] assertEquals(testValue, node.longValue()); [EOL] }
public void testValueOf_PositiveLong() { [EOL] long input = 123L; [EOL] LongNode result = LongNode.valueOf(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.longValue()); [EOL] }
public void testValueOf_NegativeLong() { [EOL] long input = -123L; [EOL] LongNode result = LongNode.valueOf(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.longValue()); [EOL] }
public void testValueOf_Zero() { [EOL] long input = 0L; [EOL] LongNode result = LongNode.valueOf(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.longValue()); [EOL] }
public void testIsIntegralNumber() { [EOL] JsonNode node = new NumericNode() { [EOL] @Override [EOL] public boolean isIntegralNumber() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(node.isIntegralNumber()); [EOL] }
public void testIsLong() { [EOL] JsonNode node = new LongNode(123L); [EOL] assertTrue(node.isLong()); [EOL] }
public void testNumberValueReturnsLong() { [EOL] JsonNumber jsonNumber = new JsonNumber("12345"); [EOL] Number result = jsonNumber.numberValue(); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(12345L, result.longValue()); [EOL] }
public void testIntValue_Positive() { [EOL] JsonNode node = new IntNode(123); [EOL] int result = node.intValue(); [EOL] assertEquals(123, result); [EOL] }
public void testIntValue_Negative() { [EOL] JsonNode node = new IntNode(-123); [EOL] int result = node.intValue(); [EOL] assertEquals(-123, result); [EOL] }
public void testIntValue_Zero() { [EOL] JsonNode node = new IntNode(0); [EOL] int result = node.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testLongValue_Positive() { [EOL] LongNode node = new LongNode(5L); [EOL] assertEquals(5L, node.longValue()); [EOL] }
public void testLongValue_Negative() { [EOL] LongNode node = new LongNode(-5L); [EOL] assertEquals(-5L, node.longValue()); [EOL] }
public void testLongValue_Zero() { [EOL] LongNode node = new LongNode(0L); [EOL] assertEquals(0L, node.longValue()); [EOL] }
public void testDoubleValue_Positive() { [EOL] DoubleNode node = new DoubleNode(5.5); [EOL] double result = node.doubleValue(); [EOL] assertEquals(5.5, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] DoubleNode node = new DoubleNode(-3.3); [EOL] double result = node.doubleValue(); [EOL] assertEquals(-3.3, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] DoubleNode node = new DoubleNode(0.0); [EOL] double result = node.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testAsTextWithPositiveValue() { [EOL] DoubleNode node = new DoubleNode(10.5); [EOL] String result = node.asText(); [EOL] assertEquals("10.5", result); [EOL] }
public void testAsTextWithNegativeValue() { [EOL] DoubleNode node = new DoubleNode(-10.5); [EOL] String result = node.asText(); [EOL] assertEquals("-10.5", result); [EOL] }
public void testAsTextWithZeroValue() { [EOL] DoubleNode node = new DoubleNode(0.0); [EOL] String result = node.asText(); [EOL] assertEquals("0.0", result); [EOL] }
public void testEquals_sameObject() { [EOL] LongNode node = new LongNode(5); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] LongNode node = new LongNode(5); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_differentClass() { [EOL] LongNode node = new LongNode(5); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] } [EOL] public void testEquals_differentValue() { [EOL] LongNode node1 = new LongNode(5); [EOL] LongNode node2 = new LongNode(10); [EOL] assertFalse(node1.equals(node2)); [EOL] } [EOL] public void testEquals_sameValue() { [EOL] LongNode node1 = new LongNode(5); [EOL] LongNode node2 = new LongNode(5); [EOL] assertTrue(node1.equals(node2)); [EOL] }
private void readObject(ObjectInputStream in) throws IOException { [EOL] _jdkSerializeMaxEntries = in.readInt(); [EOL] }
private void writeObject(ObjectOutputStream out) throws IOException { [EOL] out.writeInt(_jdkSerializeMaxEntries); [EOL] }
protected Object readResolve() { [EOL] return new LRUMap<Object, Object>(_jdkSerializeMaxEntries, _jdkSerializeMaxEntries); [EOL] }
public void testStringCollectionDeserializerWithNonNullParameters() { [EOL] JavaType collectionType = mock(JavaType.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] StringCollectionDeserializer deserializer = new StringCollectionDeserializer(collectionType, valueDeser, valueInstantiator); [EOL] assertNotNull(deserializer); [EOL] }
public void testStringCollectionDeserializerWithNullParameters() { [EOL] JavaType collectionType = null; [EOL] JsonDeserializer<?> valueDeser = null; [EOL] ValueInstantiator valueInstantiator = null; [EOL] try { [EOL] StringCollectionDeserializer deserializer = new StringCollectionDeserializer(collectionType, valueDeser, valueInstantiator); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testStringCollectionDeserializerWithNonNullValues() { [EOL] JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(List.class, String.class); [EOL] ValueInstantiator valueInstantiator = new StdValueInstantiator(null, collectionType); [EOL] JsonDeserializer<?> delegateDeser = new JsonDeserializer<Object>() { [EOL] @Override [EOL] public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { [EOL] return p.getText(); [EOL] } [EOL] }; [EOL] JsonDeserializer<?> valueDeser = new JsonDeserializer<String>() { [EOL] @Override [EOL] public String deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { [EOL] return p.getText(); [EOL] } [EOL] }; [EOL] StringCollectionDeserializer deserializer = new StringCollectionDeserializer(collectionType, valueInstantiator, delegateDeser, valueDeser); [EOL] assertNotNull(deserializer); [EOL] }
public void testStringCollectionDeserializerWithNullDelegateAndValueDeserializers() { [EOL] JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(List.class, String.class); [EOL] ValueInstantiator valueInstantiator = new StdValueInstantiator(null, collectionType); [EOL] StringCollectionDeserializer deserializer = new StringCollectionDeserializer(collectionType, valueInstantiator, null, null); [EOL] assertNotNull(deserializer); [EOL] }
public void testWithResolvedSameDeserializers() { [EOL] JsonDeserializer<?> delegateDeser = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] StringCollectionDeserializer original = new StringCollectionDeserializer(null, null, delegateDeser, valueDeser); [EOL] StringCollectionDeserializer result = original.withResolved(delegateDeser, valueDeser); [EOL] assertSame(original, result); [EOL] }
public void testWithResolvedDifferentDeserializers() { [EOL] JsonDeserializer<?> originalDelegateDeser = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> originalValueDeser = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newDelegateDeser = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newValueDeser = mock(JsonDeserializer.class); [EOL] StringCollectionDeserializer original = new StringCollectionDeserializer(null, null, originalDelegateDeser, originalValueDeser); [EOL] StringCollectionDeserializer result = original.withResolved(newDelegateDeser, newValueDeser); [EOL] assertNotSame(original, result); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] AnnotatedWithParams delegateCreator = mock(AnnotatedWithParams.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDelegate = mock(JsonDeserializer.class); [EOL] when(_valueInstantiator.getDelegateCreator()).thenReturn(delegateCreator); [EOL] when(_valueInstantiator.getDelegateType(ctxt.getConfig())).thenReturn(delegateType); [EOL] when(findDeserializer(ctxt, delegateType, property)).thenReturn(expectedDelegate); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(expectedDelegate, result); [EOL] }
public void testCreateContextualWithNullDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_valueInstantiator.getDelegateCreator()).thenReturn(null); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNullValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(_valueDeserializer).thenReturn(null); [EOL] when(_collectionType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(null); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithValueDeserializerAsContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualDeserializer valueDeser = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<?> expectedValueDeser = mock(JsonDeserializer.class); [EOL] when(_valueDeserializer).thenReturn((JsonDeserializer<?>) valueDeser); [EOL] when(valueDeser.createContextual(ctxt, property)).thenReturn(expectedValueDeser); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(expectedValueDeser, result); [EOL] }
public void testCreateContextualWithDefaultDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] when(_valueDeserializer).thenReturn(valueDeser); [EOL] when(isDefaultDeserializer(valueDeser)).thenReturn(true); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] Collection<String> delegateResult = new ArrayList<>(); [EOL] delegateResult.add("delegate"); [EOL] CustomDeserializer deserializer = new CustomDeserializer(valueInstantiator, delegateDeserializer); [EOL] when(delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(delegateResult); [EOL] Collection<String> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(delegateResult, result); [EOL] }
public void testDeserializeWithDefaultInstantiator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<String> defaultResult = new ArrayList<>(); [EOL] defaultResult.add("default"); [EOL] CustomDeserializer deserializer = new CustomDeserializer(valueInstantiator, null); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(defaultResult); [EOL] Collection<String> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(defaultResult, result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] Collection<String> handlerResult = new ArrayList<>(); [EOL] when(handleNonArray(jp, ctxt, result)).thenReturn(handlerResult); [EOL] Collection<String> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertSame(handlerResult, deserializedResult); [EOL] }
public void testDeserializeUsingCustomDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] JsonDeserializer<String> valueDeserializer = mock(JsonDeserializer.class); [EOL] _valueDeserializer = valueDeserializer; [EOL] Collection<String> customDeserializedResult = new ArrayList<>(); [EOL] when(deserializeUsingCustom(jp, ctxt, result, valueDeserializer)).thenReturn(customDeserializedResult); [EOL] Collection<String> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertSame(customDeserializedResult, deserializedResult); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<String> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertTrue(deserializedResult.isEmpty()); [EOL] }
public void testDeserializeWithNonNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(_parseString(jp, ctxt)).thenReturn("test"); [EOL] Collection<String> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertEquals(Arrays.asList("test"), new ArrayList<>(deserializedResult)); [EOL] }
public void testDeserializeWithNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<String> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<String> deserializedResult = deserialize(jp, ctxt, result); [EOL] assertEquals(Arrays.asList((String) null), new ArrayList<>(deserializedResult)); [EOL] }
public void testDeserializeWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] Object expected = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(expected); [EOL] ArrayDeserializer deserializer = new ArrayDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testPOJONodeWithNull() { [EOL] POJONode result = POJONode(null); [EOL] assertNull(result.getPojo()); [EOL] }
public void testPOJONodeWithNonNull() { [EOL] Object pojo = new Object(); [EOL] POJONode result = POJONode(pojo); [EOL] assertSame(pojo, result.getPojo()); [EOL] }
public void testResolveWithNullContextType() { [EOL] setup(); [EOL] _contextType = null; [EOL] _resolve(); [EOL] assertNotNull(_bindings); [EOL] assertTrue(_bindings.isEmpty()); [EOL] }
public void testResolveWithNonNullContextTypeAndNoContainedTypes() { [EOL] setup(); [EOL] _contextType = createMockContextType(0); [EOL] _resolve(); [EOL] assertNotNull(_bindings); [EOL] assertTrue(_bindings.isEmpty()); [EOL] }
public void testResolveWithNonNullContextTypeAndContainedTypes() { [EOL] setup(); [EOL] _contextType = createMockContextType(2); // Assuming this creates a context type with 2 contained types [EOL] _resolve(); [EOL] assertNotNull(_bindings); [EOL] assertEquals(2, _bindings.size()); [EOL] }
protected void _resolveBindings(Type t) { [EOL] if (t == null) [EOL] return; [EOL] Class<?> raw; [EOL] if (t instanceof ParameterizedType) { [EOL] ParameterizedType pt = (ParameterizedType) t; [EOL] Type[] args = pt.getActualTypeArguments(); [EOL] if (args != null && args.length > 0) { [EOL] Class<?> rawType = (Class<?>) pt.getRawType(); [EOL] TypeVariable<?>[] vars = rawType.getTypeParameters(); [EOL] if (vars.length != args.length) { [EOL] throw new IllegalArgumentException("Strange parametrized type (in class " + rawType.getName() + "): number of type arguments != number of type parameters (" + args.length + " vs " + vars.length + ")"); [EOL] } [EOL] for (int i = 0, len = args.length; i < len; ++i) { [EOL] TypeVariable<?> var = vars[i]; [EOL] String name = var.getName(); [EOL] if (_bindings == null) { [EOL] _bindings = new LinkedHashMap<String, JavaType>(); [EOL] } else { [EOL] if (_bindings.containsKey(name)) [EOL] continue; [EOL] } [EOL] _addPlaceholder(name); [EOL] _bindings.put(name, _typeFactory._constructType(args[i], this)); [EOL] } [EOL] } [EOL] raw = (Class<?>) pt.getRawType(); [EOL] } else if (t instanceof Class<?>) { [EOL] raw = (Class<?>) t; [EOL] Class<?> decl = raw.getDeclaringClass(); [EOL] if (decl != null && !decl.isAssignableFrom(raw)) { [EOL] _resolveBindings(raw.getDeclaringClass()); [EOL] } [EOL] TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL] if (vars != null && vars.length > 0) { [EOL] JavaType[] typeParams = null; [EOL] if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) { [EOL] typeParams = _typeFactory.findTypeParameters(_contextType, raw); [EOL] } [EOL] for (int i = 0; i < vars.length; i++) { [EOL] TypeVariable<?> var = vars[i]; [EOL] String name = var.getName(); [EOL] Type varType = var.getBounds()[0]; [EOL] if (varType != null) { [EOL] if (_bindings == null) { [EOL] _bindings = new LinkedHashMap<String, JavaType>(); [EOL] } else { [EOL] if (_bindings.containsKey(name)) [EOL] continue; [EOL] } [EOL] _addPlaceholder(name); [EOL] if (typeParams != null) { [EOL] _bindings.put(name, typeParams[i]); [EOL] } else { [EOL] _bindings.put(name, _typeFactory._constructType(varType, this)); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } else { [EOL] return; [EOL] } [EOL] _resolveBindings(raw.getGenericSuperclass()); [EOL] for (Type intType : raw.getGenericInterfaces()) { [EOL] _resolveBindings(intType); [EOL] } [EOL] }
public void testWrapAndThrowWithInvocationTargetException() throws IOException { [EOL] SerializerProvider provider = null; [EOL] Throwable cause = new IOException("Inner exception"); [EOL] Throwable t = new InvocationTargetException(cause); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertSame(cause, e.getCause()); [EOL] } [EOL] }
public void testWrapAndThrowWithError() { [EOL] SerializerProvider provider = null; [EOL] Throwable t = new Error("Serious error"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected Error to be thrown"); [EOL] } catch (Error e) { [EOL] assertEquals("Serious error", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithIOException() throws IOException { [EOL] SerializerProvider provider = new SerializerProvider() { [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature feature) { [EOL] return false; [EOL] } [EOL] }; [EOL] Throwable t = new IOException("IO exception"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("IO exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithRuntimeException() { [EOL] SerializerProvider provider = new SerializerProvider() { [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature feature) { [EOL] return false; [EOL] } [EOL] }; [EOL] Throwable t = new RuntimeException("Runtime exception"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithOtherException() throws IOException { [EOL] SerializerProvider provider = new SerializerProvider() { [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature feature) { [EOL] return true; [EOL] } [EOL] }; [EOL] Throwable t = new Exception("Other exception"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertSame(t, e.getCause()); [EOL] } [EOL] }
public void testIsDefaultSerializerWithNonNullSerializerHavingJacksonStdImpl() { [EOL] JsonSerializer<?> serializer = new JsonSerializerWithJacksonStdImpl(); [EOL] boolean result = isDefaultSerializer(serializer); [EOL] assertTrue(result); [EOL] }
public void testIsDefaultSerializerWithNonNullSerializerWithoutJacksonStdImpl() { [EOL] JsonSerializer<?> serializer = new JsonSerializerWithoutJacksonStdImpl(); [EOL] boolean result = isDefaultSerializer(serializer); [EOL] assertFalse(result); [EOL] }
public void testIsDefaultSerializerWithNullSerializer() { [EOL] JsonSerializer<?> serializer = null; [EOL] boolean result = isDefaultSerializer(serializer); [EOL] assertFalse(result); [EOL] }
public void testFindConvertingContentSerializerWithNonNullIntrAndPropAndConvDefAndNullExistingSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> existingSerializer = null; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Object convDef = new Object(); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findSerializationContentConverter(prop.getMember())).thenReturn(convDef); [EOL] when(provider.converterInstance(prop.getMember(), convDef)).thenReturn(conv); [EOL] when(conv.getOutputType(provider.getTypeFactory())).thenReturn(delegateType); [EOL] when(provider.findValueSerializer(delegateType, prop)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindConvertingContentSerializerWithNonNullIntrAndPropAndConvDefAndNonNullExistingSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> existingSerializer = mock(JsonSerializer.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Object convDef = new Object(); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findSerializationContentConverter(prop.getMember())).thenReturn(convDef); [EOL] when(provider.converterInstance(prop.getMember(), convDef)).thenReturn(conv); [EOL] when(conv.getOutputType(provider.getTypeFactory())).thenReturn(delegateType); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindConvertingContentSerializerWithNullIntrOrProp() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = null; [EOL] JsonSerializer<?> existingSerializer = mock(JsonSerializer.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertSame(existingSerializer, result); [EOL] }
public void testFindConvertingContentSerializerWithNonNullIntrAndPropButNullConvDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> existingSerializer = mock(JsonSerializer.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findSerializationContentConverter(prop.getMember())).thenReturn(null); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertSame(existingSerializer, result); [EOL] }
public void testHandleSingleArgumentConstructorWithNameAndInjectId() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] PropertyName pn = new PropertyName("testName"); [EOL] when(ctor.getParameter(0)).thenReturn(param); [EOL] when(intr.findNameForDeserialization(param)).thenReturn(pn); [EOL] when(intr.findInjectableValueId(param)).thenReturn("injectId"); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addPropertyCreator(eq(ctor), any(CreatorProperty[].class)); [EOL] }
public void testHandleSingleArgumentConstructorWithNullNameAndParam() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getParameter(0)).thenReturn(null); [EOL] when(intr.findNameForDeserialization(null)).thenReturn(null); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertFalse(result); [EOL] }
public void testHandleSingleArgumentConstructorWithStringType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(String.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, true, null); [EOL] assertTrue(result); [EOL] verify(creators).addStringCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithIntType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(int.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addIntCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithLongType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(long.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, true, null); [EOL] assertTrue(result); [EOL] verify(creators).addLongCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithDoubleType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(double.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addDoubleCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorIsCreator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addDelegatingCreator(ctor, null); [EOL] }
public void testCreateArrayDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayType(); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> customDeser = createCustomArrayDeserializer(); [EOL] when(_findCustomArrayDeserializer(type, ctxt.getConfig(), beanDesc, null, null)).thenReturn(customDeser); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame(customDeser, result); [EOL] }
public void testCreateArrayDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayTypeWithPrimitiveElement(); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof PrimitiveArrayDeserializers); [EOL] }
public void testCreateArrayDeserializerWithStringType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayTypeWithStringElement(); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame(StringArrayDeserializer.instance, result); [EOL] }
public void testCreateArrayDeserializerWithObjectArray() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayTypeWithObjectElement(); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof ObjectArrayDeserializer); [EOL] }
public void testCreateArrayDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayType(); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> baseDeser = createCustomArrayDeserializer(); [EOL] when(_findCustomArrayDeserializer(type, ctxt.getConfig(), beanDesc, null, null)).thenReturn(baseDeser); [EOL] BeanDeserializerModifier modifier = createBeanDeserializerModifier(); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonDeserializer<?> modifiedDeser = createCustomArrayDeserializer(); [EOL] when(modifier.modifyArrayDeserializer(any(DeserializationConfig.class), any(ArrayType.class), any(BeanDescription.class), any(JsonDeserializer.class))).thenReturn(modifiedDeser); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame(modifiedDeser, result); [EOL] }
public void testCreateCollectionDeserializerWithEnumSet() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(EnumSet.class, MyEnum.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof EnumSetDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithArrayBlockingQueue() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(ArrayBlockingQueue.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ArrayBlockingQueueDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithAbstractType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(AbstractCollection.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] try { [EOL] createCollectionDeserializer(ctxt, type, beanDesc); [EOL] fail("Expected IllegalArgumentException for abstract collection type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateCollectionDeserializerWithStringCollection() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(List.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StringCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(MyCustomCollection.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof MyCustomCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(List.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] addDeserializerModifier(); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ModifierCollectionDeserializer); [EOL] }
public void testMapAbstractCollectionTypeWithKnownCollection() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType type = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, String.class); [EOL] CollectionType result = _mapAbstractCollectionType(type, config); [EOL] assertNotNull(result); [EOL] assertEquals(ArrayList.class, result.getRawClass()); [EOL] } [EOL] public void testMapAbstractCollectionTypeWithUnknownCollection() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType type = TypeFactory.defaultInstance().constructCollectionType(UnknownCollection.class, String.class); [EOL] CollectionType result = _mapAbstractCollectionType(type, config); [EOL] assertNull(result); [EOL] }

public void testFindCustomCollectionDeserializerWithNonNullDeserializer() { [EOL] CollectionType type = mock(CollectionType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializers.findCollectionDeserializer(eq(type), eq(config), eq(beanDesc), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(expectedDeserializer); [EOL] _factoryConfig = new DeserializerFactoryConfig(); [EOL] _factoryConfig = _factoryConfig.withAdditionalDeserializers(deserializers); [EOL] JsonDeserializer<?> result = _findCustomCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomCollectionDeserializerWithNullDeserializer() { [EOL] CollectionType type = mock(CollectionType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(deserializers.findCollectionDeserializer(eq(type), eq(config), eq(beanDesc), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(null); [EOL] _factoryConfig = new DeserializerFactoryConfig(); [EOL] _factoryConfig = _factoryConfig.withAdditionalDeserializers(deserializers); [EOL] JsonDeserializer<?> result = _findCustomCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testCreateCollectionLikeDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> customDeser = mock(JsonDeserializer.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(contentType.getTypeHandler()).thenReturn(null); [EOL] when(this.findTypeDeserializer(config, contentType)).thenReturn(contentTypeDeser); [EOL] when(this._findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser)).thenReturn(customDeser); [EOL] JsonDeserializer<?> result = createCollectionLikeDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(customDeser, result); [EOL] }
public void testCreateCollectionLikeDeserializerWithModifiers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> customDeser = mock(JsonDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] JsonDeserializer<?> modifiedDeser = mock(JsonDeserializer.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(contentType.getTypeHandler()).thenReturn(null); [EOL] when(this.findTypeDeserializer(config, contentType)).thenReturn(contentTypeDeser); [EOL] when(this._findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser)).thenReturn(customDeser); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] when(modifier.modifyCollectionLikeDeserializer(config, type, beanDesc, customDeser)).thenReturn(modifiedDeser); [EOL] JsonDeserializer<?> result = createCollectionLikeDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(modifiedDeser, result); [EOL] }
public void testCreateCollectionLikeDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(contentType.getTypeHandler()).thenReturn(null); [EOL] when(this.findTypeDeserializer(config, contentType)).thenReturn(contentTypeDeser); [EOL] when(this._findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser)).thenReturn(null); [EOL] JsonDeserializer<?> result = createCollectionLikeDeserializer(ctxt, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindCustomCollectionLikeDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_factoryConfig.deserializers()).thenReturn(Collections.singletonList(deserializers)); [EOL] when(deserializers.findCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = _findCustomCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomCollectionLikeDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(_factoryConfig.deserializers()).thenReturn(Collections.singletonList(deserializers)); [EOL] when(deserializers.findCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer)).thenReturn(null); [EOL] JsonDeserializer<?> result = _findCustomCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testCreateEnumDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] JsonDeserializer<?> customDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(_findCustomEnumDeserializer(enumClass, config, beanDesc)).thenReturn(customDeserializer); [EOL] JsonDeserializer<?> result = createEnumDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(customDeserializer, result); [EOL] }
public void testCreateEnumDeserializerWithFactoryMethod() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] AnnotatedMethod factoryMethod = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factoryMethod); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.hasCreatorAnnotation(factoryMethod)).thenReturn(true); [EOL] when(factoryMethod.getParameterCount()).thenReturn(1); [EOL] when(factoryMethod.getRawReturnType()).thenReturn(enumClass); [EOL] JsonDeserializer<?> result = createEnumDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof EnumDeserializer); [EOL] }
public void testCreateEnumDeserializerWithInvalidFactoryMethod() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] AnnotatedMethod factoryMethod = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factoryMethod); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.hasCreatorAnnotation(factoryMethod)).thenReturn(true); [EOL] when(factoryMethod.getParameterCount()).thenReturn(1); [EOL] when(factoryMethod.getRawReturnType()).thenReturn(mock(Class.class)); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] createEnumDeserializer(ctxt, type, beanDesc); [EOL] }); [EOL] assertNotNull(exception); [EOL] }
public void testCreateEnumDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] Class<?> enumClass = mock(Class.class); [EOL] JsonDeserializer<?> baseDeserializer = mock(JsonDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] List<BeanDeserializerModifier> modifiers = Collections.singletonList(modifier); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(_findCustomEnumDeserializer(enumClass, config, beanDesc)).thenReturn(null); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(Collections.emptyList()); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(modifiers); [EOL] when(modifier.modifyEnumDeserializer(config, type, beanDesc, baseDeserializer)).thenReturn(baseDeserializer); [EOL] JsonDeserializer<?> result = createEnumDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(baseDeserializer, result); [EOL] }
public void testFindTypeDeserializerWithNoTypeResolverAndNoDefaultTyper() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(mock(BeanDescription.class)); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.getDefaultTyper(any(JavaType.class))).thenReturn(null); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNull(result); [EOL] }
public void testFindTypeDeserializerWithTypeResolverAndSubtypes() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] BeanDescription bean = mock(BeanDescription.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(bean.getClassInfo()).thenReturn(ac); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] TypeResolverBuilder<?> b = mock(TypeResolverBuilder.class); [EOL] when(ai.findTypeResolver(config, ac, baseType)).thenReturn(b); [EOL] when(config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai)).thenReturn(mock(Collection.class)); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindTypeDeserializerWithDefaultImplAndAbstractType() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(baseType.isAbstract()).thenReturn(true); [EOL] BeanDescription bean = mock(BeanDescription.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(bean.getClassInfo()).thenReturn(ac); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] TypeResolverBuilder<?> b = mock(TypeResolverBuilder.class); [EOL] when(ai.findTypeResolver(config, ac, baseType)).thenReturn(b); [EOL] when(b.getDefaultImpl()).thenReturn(null); [EOL] JavaType defaultType = mock(JavaType.class); [EOL] when(defaultType.getRawClass()).thenReturn(String.class); [EOL] when(mapAbstractType(config, baseType)).thenReturn(defaultType); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testCreateEnumKeyDeserializerWithAnnotatedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createTypeForEnum(); [EOL] when(findDeserializerFromAnnotation(ctxt, any())).thenReturn(mock(JsonDeserializer.class)); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.DelegatingKD); [EOL] }
public void testCreateEnumKeyDeserializerWithCustomEnumDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createTypeForEnum(); [EOL] when(findDeserializerFromAnnotation(ctxt, any())).thenReturn(null); [EOL] when(_findCustomEnumDeserializer(any(), any(), any())).thenReturn(mock(JsonDeserializer.class)); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.DelegatingKD); [EOL] }
public void testCreateEnumKeyDeserializerWithFactoryMethod() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createTypeForEnum(); [EOL] when(findDeserializerFromAnnotation(ctxt, any())).thenReturn(null); [EOL] when(_findCustomEnumDeserializer(any(), any(), any())).thenReturn(null); [EOL] BeanDescription beanDesc = createBeanDescriptionWithFactoryMethod(type.getRawClass(), String.class, true); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.EnumKD); [EOL] }
public void testCreateEnumKeyDeserializerWithInvalidFactoryMethodParameterType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createTypeForEnum(); [EOL] when(findDeserializerFromAnnotation(ctxt, any())).thenReturn(null); [EOL] when(_findCustomEnumDeserializer(any(), any(), any())).thenReturn(null); [EOL] BeanDescription beanDesc = createBeanDescriptionWithFactoryMethod(type.getRawClass(), Integer.class, false); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] _createEnumKeyDeserializer(ctxt, type); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("not suitable, must be java.lang.String")); [EOL] }
public void testCreateEnumKeyDeserializerWithInvalidFactoryMethodAnnotation() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createTypeForEnum(); [EOL] when(findDeserializerFromAnnotation(ctxt, any())).thenReturn(null); [EOL] when(_findCustomEnumDeserializer(any(), any(), any())).thenReturn(null); [EOL] BeanDescription beanDesc = createBeanDescriptionWithInvalidAnnotatedFactoryMethod(type.getRawClass()); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] _createEnumKeyDeserializer(ctxt, type); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Unsuitable method")); [EOL] }
public void testCreateEnumKeyDeserializerWithNoCustomDeserializerOrFactoryMethod() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createTypeForEnum(); [EOL] when(findDeserializerFromAnnotation(ctxt, any())).thenReturn(null); [EOL] when(_findCustomEnumDeserializer(any(), any(), any())).thenReturn(null); [EOL] BeanDescription beanDesc = createBeanDescriptionWithoutFactoryMethod(type.getRawClass()); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.EnumKD); [EOL] }
public void testFindDefaultDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(int.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NumberDeserializers.IntDeserializer); [EOL] }
public void testFindDefaultDeserializerWithStringType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringDeserializer); [EOL] }
public void testFindDefaultDeserializerWithIterableType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Iterable.class); [EOL] when(type.containedTypeCount()).thenReturn(1); [EOL] when(type.containedType(0)).thenReturn(TypeFactory.defaultInstance().constructType(Object.class)); [EOL] when(ctxt.getTypeFactory()).thenReturn(TypeFactory.defaultInstance()); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionDeserializer); [EOL] }
public void testFindDefaultDeserializerWithUnknownType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.unknown.Type"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindDefaultDeserializerWithJacksonType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.fasterxml.jackson.databind.ObjectMapper"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ObjectMapperDeserializer); [EOL] }
public void testFindDeserializerFromAnnotationWithNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(null); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerFromAnnotationWithNonNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] Object deserDef = new Object(); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(deserDef); [EOL] when(ctxt.deserializerInstance(ann, deserDef)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testBeanDeserializerConstructor() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = new HashMap<>(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] boolean ignoreAllUnknown = false; [EOL] boolean hasViews = false; [EOL] BeanDeserializer beanDeserializer = new BeanDeserializer(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] assertNotNull(beanDeserializer); [EOL] }
public void testBeanDeserializerConstructorWithIgnoreAllUnknown() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = new HashMap<>(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] boolean ignoreAllUnknown = true; [EOL] boolean hasViews = false; [EOL] BeanDeserializer beanDeserializer = new BeanDeserializer(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] assertNotNull(beanDeserializer); [EOL] }
public void testBeanDeserializerConstructorWithViews() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = new HashMap<>(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] boolean ignoreAllUnknown = false; [EOL] boolean hasViews = true; [EOL] BeanDeserializer beanDeserializer = new BeanDeserializer(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] assertNotNull(beanDeserializer); [EOL] }
public void testAsArrayDeserializer() { [EOL] BeanDeserializerBase instance = setupBeanDeserializerBase(); [EOL] BeanDeserializerBase result = instance.asArrayDeserializer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof BeanAsArrayDeserializer); [EOL] BeanAsArrayDeserializer arrayDeserializer = (BeanAsArrayDeserializer) result; [EOL] SettableBeanProperty[] props = instance._beanProperties.getPropertiesInInsertionOrder(); [EOL] assertArrayEquals(props, arrayDeserializer.getProperties()); [EOL] }
public void testDeserializeWithStartObjectAndVanillaProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming vanillaDeserialize method handles END_OBJECT [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectAndObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming deserializeWithObjectId method handles END_OBJECT [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectWithoutSpecialHandling() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming deserializeFromObject method handles END_OBJECT [EOL] when(_objectIdReader).thenReturn(null); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonToken otherToken = JsonToken.VALUE_STRING; // Use a different token that is not START_OBJECT [EOL] when(jp.getCurrentToken()).thenReturn(otherToken); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp, never()).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithInjectables() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithInjectables(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithUnwrapped() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithUnwrapped(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithExternalTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithExternalTypeId(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithView() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithView(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithIgnorableProps(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithAnySetter(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithUnknownProperty(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithNormalFlow() throws IOException, JsonProcessingException { [EOL] JsonParser jp = createMockJsonParser(); [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] Object bean = new Object(); [EOL] MyBeanDeserializer deserializer = createDeserializerWithNormalFlow(); [EOL] Object result = deserializer.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationUsingNonDefault() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectUsingDefaultWithInjectables() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectUsingDefaultWithViewProcessing() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectUsingDefaultWithoutViewProcessing() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectWithKnownProperties() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectWithIgnorableProperties() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] }
public void testDeserializeFromObjectWithUnknownProperties() throws IOException, JsonProcessingException { [EOL] }
protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer unknown = null; [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] bean = null; [EOL] } [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(jp, ctxt, bean, unknown); [EOL] } [EOL] if (unknown != null) { [EOL] bean = handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return deserialize(jp, ctxt, bean); [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (unknown == null) { [EOL] unknown = new TokenBuffer(jp.getCodec()); [EOL] } [EOL] unknown.writeFieldName(propName); [EOL] unknown.copyCurrentStructure(jp); [EOL] } [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] bean = null; [EOL] } [EOL] if (unknown != null) { [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(null, ctxt, bean, unknown); [EOL] } [EOL] return handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return bean; [EOL] }
public void testDeserializeWithViewPropertyVisible() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] JsonToken t = JsonToken.FIELD_NAME; [EOL] String propName = "visibleProperty"; [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(jp.getCurrentToken()).thenReturn(t); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(_beanProperties.find(propName)).thenReturn(prop); [EOL] when(prop.visibleInView(activeView)).thenReturn(true); [EOL] Object result = deserializeWithView(jp, ctxt, bean, activeView); [EOL] verify(prop).deserializeAndSet(jp, ctxt, bean); [EOL] assertSame(bean, result); [EOL] }
public void testDeserializeWithViewPropertyNotVisible() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] JsonToken t = JsonToken.FIELD_NAME; [EOL] String propName = "invisibleProperty"; [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(jp.getCurrentToken()).thenReturn(t); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(_beanProperties.find(propName)).thenReturn(prop); [EOL] when(prop.visibleInView(activeView)).thenReturn(false); [EOL] Object result = deserializeWithView(jp, ctxt, bean, activeView); [EOL] verify(jp).skipChildren(); [EOL] assertSame(bean, result); [EOL] }
public void testDeserializeWithViewIgnorableProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] JsonToken t = JsonToken.FIELD_NAME; [EOL] String propName = "ignorableProperty"; [EOL] when(jp.getCurrentToken()).thenReturn(t); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(_beanProperties.find(propName)).thenReturn(null); [EOL] when(_ignorableProps).thenReturn(new HashSet<>(Arrays.asList(propName))); [EOL] Object result = deserializeWithView(jp, ctxt, bean, activeView); [EOL] verify(jp).skipChildren(); [EOL] assertSame(bean, result); [EOL] }
public void testDeserializeWithViewUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] JsonToken t = JsonToken.FIELD_NAME; [EOL] String propName = "unknownProperty"; [EOL] when(jp.getCurrentToken()).thenReturn(t); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(_beanProperties.find(propName)).thenReturn(null); [EOL] when(_ignorableProps).thenReturn(null); [EOL] when(_anySetter).thenReturn(null); [EOL] Object result = deserializeWithView(jp, ctxt, bean, activeView); [EOL] verify(ctxt).handleUnknownProperty(jp, ctxt, bean, propName); [EOL] assertSame(bean, result); [EOL] }
public void testDeserializeWithViewAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] JsonToken t = JsonToken.FIELD_NAME; [EOL] String propName = "anySetterProperty"; [EOL] AnySetter anySetter = mock(AnySetter.class); [EOL] when(jp.getCurrentToken()).thenReturn(t); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(_beanProperties.find(propName)).thenReturn(null); [EOL] when(_ignorableProps).thenReturn(null); [EOL] when(_anySetter).thenReturn(anySetter); [EOL] Object result = deserializeWithView(jp, ctxt, bean, activeView); [EOL] verify(anySetter).deserializeAndSet(jp, ctxt, bean, propName); [EOL] assertSame(bean, result); [EOL] }
public void testGetEnumValues() { [EOL] MyClass instance = new MyClass(); [EOL] EnumValues expected = ...; // Initialize with the expected value [EOL] EnumValues result = instance.getEnumValues(); [EOL] assertNotNull("The getEnumValues method should not return null", result); [EOL] assertEquals("The getEnumValues method should return the expected EnumValues instance", expected, result); [EOL] }
public void testEquals_Reflexive() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key.equals(key)); [EOL] }
public void testEquals_Null() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key.equals(new Object())); [EOL] }
public void testEquals_DifferentName() { [EOL] MemberKey key1 = new MemberKey("method1", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method2", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_DifferentArgLength() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_DifferentArgTypes() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Number.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_CompatibleArgTypes() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Number.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testEquals_Identical() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testGetPropertiesInInsertionOrder_empty() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] SettableBeanProperty[] properties = map.getPropertiesInInsertionOrder(); [EOL] assertNotNull(properties); [EOL] assertEquals(0, properties.length); [EOL] }
public void testGetPropertiesInInsertionOrder_singleProperty() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] SettableBeanProperty property = new MockSettableBeanProperty("prop", 0); [EOL] map = map.withProperty(property); [EOL] SettableBeanProperty[] properties = map.getPropertiesInInsertionOrder(); [EOL] assertNotNull(properties); [EOL] assertEquals(1, properties.length); [EOL] assertSame(property, properties[0]); [EOL] }
public void testGetPropertiesInInsertionOrder_multipleProperties() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] SettableBeanProperty property1 = new MockSettableBeanProperty("prop1", 0); [EOL] SettableBeanProperty property2 = new MockSettableBeanProperty("prop2", 1); [EOL] map = map.withProperty(property1).withProperty(property2); [EOL] SettableBeanProperty[] properties = map.getPropertiesInInsertionOrder(); [EOL] assertNotNull(properties); [EOL] assertEquals(2, properties.length); [EOL] assertSame(property1, properties[0]); [EOL] assertSame(property2, properties[1]); [EOL] }
public void testSizeWhenEmpty() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(false); [EOL] ArrayNode arrayNode = new ArrayNode(factory); [EOL] int size = arrayNode.size(); [EOL] assertEquals(0, size); [EOL] }
public void testSizeWithElements() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(false); [EOL] ArrayNode arrayNode = new ArrayNode(factory); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] int size = arrayNode.size(); [EOL] assertEquals(2, size); [EOL] }
public void testFindWithNullBucket() { [EOL] _buckets = new Bucket[SIZE]; // SIZE should be replaced with the actual size used in the class [EOL] _hashMask = SIZE - 1; // _hashMask should be set according to the actual mask logic used in the class [EOL] String key = "testKey"; [EOL] SettableBeanProperty result = find(key); [EOL] assertNull(result); [EOL] }
public void testFindWithMatchingKeyInFirstBucket() { [EOL] int index = "testKey".hashCode() & _hashMask; [EOL] SettableBeanProperty expectedProperty = new SettableBeanProperty(); // Replace with actual constructor [EOL] _buckets = new Bucket[SIZE]; [EOL] _buckets[index] = new Bucket("testKey", expectedProperty, null); [EOL] _hashMask = SIZE - 1; [EOL] SettableBeanProperty result = find("testKey"); [EOL] assertSame(expectedProperty, result); [EOL] }
public void testFindWithMatchingKeyInSubsequentBucket() { [EOL] int index = "testKey".hashCode() & _hashMask; [EOL] SettableBeanProperty expectedProperty = new SettableBeanProperty(); // Replace with actual constructor [EOL] _buckets = new Bucket[SIZE]; [EOL] _buckets[index] = new Bucket("otherKey", new SettableBeanProperty(), new Bucket("testKey", expectedProperty, null)); [EOL] _hashMask = SIZE - 1; [EOL] SettableBeanProperty result = find("testKey"); [EOL] assertSame(expectedProperty, result); [EOL] }
public void testFindWithEqualsMethod() { [EOL] int index = "testKey".hashCode() & _hashMask; [EOL] SettableBeanProperty expectedProperty = new SettableBeanProperty(); // Replace with actual constructor [EOL] _buckets = new Bucket[SIZE]; [EOL] _buckets[index] = new Bucket(new String("testKey"), new SettableBeanProperty(), null); [EOL] _hashMask = SIZE - 1; [EOL] when(_findWithEquals("testKey", index)).thenReturn(expectedProperty); [EOL] SettableBeanProperty result = find("testKey"); [EOL] assertSame(expectedProperty, result); [EOL] }
public void testFindWithEqualsWhenKeyExists() { [EOL] SettableBeanProperty value = new SettableBeanProperty(); // Mocked or instantiated accordingly [EOL] String key = "testKey"; [EOL] int index = 1; [EOL] Bucket bucket = new Bucket(key, value, null); [EOL] _buckets[index] = bucket; // Assuming _buckets is accessible and properly initialized [EOL] SettableBeanProperty result = _findWithEquals(key, index); [EOL] assertNotNull(result); [EOL] assertEquals(value, result); [EOL] }
public void testFindWithEqualsWhenKeyDoesNotExist() { [EOL] SettableBeanProperty value = new SettableBeanProperty(); // Mocked or instantiated accordingly [EOL] String key = "testKey"; [EOL] String searchKey = "nonExistentKey"; [EOL] int index = 1; [EOL] Bucket bucket = new Bucket(key, value, null); [EOL] _buckets[index] = bucket; // Assuming _buckets is accessible and properly initialized [EOL] SettableBeanProperty result = _findWithEquals(searchKey, index); [EOL] assertNull(result); [EOL] }
public void testFindWithEqualsWhenBucketIsNull() { [EOL] String key = "testKey"; [EOL] int index = 1; [EOL] _buckets[index] = null; // Assuming _buckets is accessible and properly initialized [EOL] SettableBeanProperty result = _findWithEquals(key, index); [EOL] assertNull(result); [EOL] }
public void testFindWithEqualsWithMultipleBuckets() { [EOL] SettableBeanProperty value1 = new SettableBeanProperty(); // Mocked or instantiated accordingly [EOL] SettableBeanProperty value2 = new SettableBeanProperty(); // Mocked or instantiated accordingly [EOL] String key1 = "testKey1"; [EOL] String key2 = "testKey2"; [EOL] int index = 1; [EOL] Bucket bucket2 = new Bucket(key2, value2, null); [EOL] Bucket bucket1 = new Bucket(key1, value1, bucket2); [EOL] _buckets[index] = bucket1; // Assuming _buckets is accessible and properly initialized [EOL] SettableBeanProperty result = _findWithEquals(key2, index); [EOL] assertNotNull(result); [EOL] assertEquals(value2, result); [EOL] }
protected PrimitiveArrayDeserializers(Class<T> cls) { [EOL] super(cls); [EOL] }
public void testForTypeWithIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Integer.TYPE); [EOL] assertTrue(deserializer instanceof IntDeser); [EOL] }
public void testForTypeWithLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Long.TYPE); [EOL] assertTrue(deserializer instanceof LongDeser); [EOL] }
public void testForTypeWithByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Byte.TYPE); [EOL] assertTrue(deserializer instanceof ByteDeser); [EOL] }
public void testForTypeWithShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Short.TYPE); [EOL] assertTrue(deserializer instanceof ShortDeser); [EOL] }
public void testForTypeWithFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Float.TYPE); [EOL] assertTrue(deserializer instanceof FloatDeser); [EOL] }
public void testForTypeWithDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Double.TYPE); [EOL] assertTrue(deserializer instanceof DoubleDeser); [EOL] }
public void testForTypeWithBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Boolean.TYPE); [EOL] assertTrue(deserializer instanceof BooleanDeser); [EOL] }
public void testForTypeWithCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Character.TYPE); [EOL] assertTrue(deserializer instanceof CharDeser); [EOL] }
public void testForTypeWithInvalidType() { [EOL] try { [EOL] YourClass.forType(String.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testByteDeserConstructor() { [EOL] ByteDeser deser = new ByteDeser(); [EOL] assertNotNull(deser); [EOL] }
public void testDeserializeWithJsonValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Base64Variant b64variant = mock(Base64Variant.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getBinaryValue(b64variant)).thenReturn(new byte[]{1, 2, 3}); [EOL] when(ctxt.getBase64Variant()).thenReturn(b64variant); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{1, 2, 3}, result); [EOL] }
public void testDeserializeWithJsonValueEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(new byte[]{4, 5, 6}); [EOL] byte[] result = deserialize(jp, null); [EOL] assertArrayEquals(new byte[]{4, 5, 6}, result); [EOL] }
public void testDeserializeWithJsonValueEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] byte[] result = deserialize(jp, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(ctxt.handleUnexpectedToken(byte[].class, jp)).thenReturn(new byte[]{7, 8, 9}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{7, 8, 9}, result); [EOL] }
public void testDeserializeWithJsonArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ByteBuilder builder = mock(ArrayBuilders.ByteBuilder.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] when(ctxt.getArrayBuilders()).thenReturn(mock(ArrayBuilders.class)); [EOL] when(ctxt.getArrayBuilders().getByteBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new byte[1]); [EOL] when(builder.completeAndClearBuffer(any(byte[].class), anyInt())).thenReturn(new byte[]{10}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{10}, result); [EOL] }
public void testDeserializeWithJsonArrayAndNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ByteBuilder builder = mock(ArrayBuilders.ByteBuilder.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.getArrayBuilders()).thenReturn(mock(ArrayBuilders.class)); [EOL] when(ctxt.getArrayBuilders().getByteBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new byte[1]); [EOL] when(builder.completeAndClearBuffer(any(byte[].class), anyInt())).thenReturn(new byte[]{0}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{0}, result); [EOL] }
public void testDeserializeWithJsonArrayAndInvalidType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("Invalid type")); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] assertEquals("Invalid type", exception.getMessage()); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] double[] result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] double[] result = deserialize(jp, ctxt); [EOL] assertEquals(0, result.length); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getDoubleValue()).thenReturn(1.0); [EOL] double[] result = deserialize(jp, ctxt); [EOL] assertEquals(1, result.length); [EOL] assertEquals(1.0, result[0], 0.0); [EOL] }
public void testDeserializeWithLargeArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT).thenReturn(JsonToken.VALUE_NUMBER_FLOAT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getDoubleValue()).thenReturn(1.0).thenReturn(2.0); [EOL] double[] result = deserialize(jp, ctxt); [EOL] assertEquals(2, result.length); [EOL] assertEquals(1.0, result[0], 0.0); [EOL] assertEquals(2.0, result[1], 0.0); [EOL] }
public void testIndexedListSerializerWithNonNullValues() { [EOL] JavaType elemType = mock(JavaType.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] IndexedListSerializer serializer = new IndexedListSerializer(elemType, true, vts, property, valueSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testIndexedListSerializerWithNullValues() { [EOL] IndexedListSerializer serializer = new IndexedListSerializer(null, false, null, null, null); [EOL] assertNotNull(serializer); [EOL] }
public void testIsEmptyWithNullList() { [EOL] boolean result = isEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithEmptyList() { [EOL] List<Object> emptyList = Collections.emptyList(); [EOL] boolean result = isEmpty(emptyList); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithNonEmptyList() { [EOL] List<Object> nonEmptyList = Arrays.asList(new Object()); [EOL] boolean result = isEmpty(nonEmptyList); [EOL] assertFalse(result); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a non-empty list [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] JsonSerializer<Object> elementSerializer = ...; // Mock element serializer [EOL] _elementSerializer = elementSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithValueTypeSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a non-empty list [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] TypeSerializer valueTypeSerializer = ...; // Mock value type serializer [EOL] _valueTypeSerializer = valueTypeSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); // Empty list [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsDynamicSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a non-empty list containing elements of different types [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] _dynamicSerializers = new PropertySerializerMap.Empty(); [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] List<?> value = Arrays.asList(null, ...); // List with the first element as null and other non-null elements [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsExceptionHandling() throws IOException { [EOL] List<?> value = ...; // Initialize with a non-empty list that will cause an exception during serialization [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testSerializeContentsUsingEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(ser); [EOL] }
public void testSerializeContentsUsingNonNullElements() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(ser, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithNullElements() throws IOException { [EOL] List<Object> value = Arrays.asList(null, "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(ser).serialize(eq("elem2"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithTypeSerializer() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser, typeSer); [EOL] verify(ser, times(2)).serializeWithType(any(), eq(jgen), eq(provider), eq(typeSer)); [EOL] }
public void testSerializeContentsUsingWithException() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] when(ser.serialize(any(), eq(jgen), eq(provider))).thenThrow(new IOException()); [EOL] try { [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(ser).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeTypedContentsEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeTypedContentsWithNullElement() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add(null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeTypedContentsWithNonNullElement() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add("test"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] _valueTypeSerializer = typeSer; [EOL] _dynamicSerializers = PropertySerializerMap.emptyForProperties(); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verify(jgen).writeString("test"); [EOL] }
public void testSerializeTypedContentsWithException() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add("test"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] _valueTypeSerializer = typeSer; [EOL] _dynamicSerializers = PropertySerializerMap.emptyForProperties(); [EOL] doThrow(new IOException()).when(jgen).writeString("test"); [EOL] try { [EOL] serializeTypedContents(value, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testWriteTypePrefixForArrayWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] writeTypePrefixForArray(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(anyString()); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] }
public void testWriteTypePrefixForArrayWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] writeTypePrefixForArray(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator, never()).writeString(anyString()); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] }
public void testWriteTypeSuffixForArrayWithNonNullGenerator() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException { [EOL] jgen.writeEndArray(); [EOL] jgen.writeEndArray(); [EOL] } [EOL] }; [EOL] serializer.writeTypeSuffixForArray(new Object(), mockGenerator); [EOL] verify(mockGenerator, times(2)).writeEndArray(); [EOL] }
public void testWriteTypeSuffixForArrayWithNullGenerator() { [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) { [EOL] } [EOL] }; [EOL] try { [EOL] serializer.writeTypeSuffixForArray(new Object(), null); [EOL] fail("Expected IOException was not thrown."); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testIsEmptyWithNullValue() { [EOL] boolean result = isEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithEmptyString() { [EOL] boolean result = isEmpty(""); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithNonEmptyString() { [EOL] boolean result = isEmpty("non-empty"); [EOL] assertFalse(result); [EOL] }
public void testTypeWrappedDeserializerWithNonNullValues() { [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] TypeWrappedDeserializer typeWrappedDeserializer = new TypeWrappedDeserializer(typeDeser, deser); [EOL] assertNotNull(typeWrappedDeserializer); [EOL] }
public void testTypeWrappedDeserializerWithNullTypeDeserializer() { [EOL] TypeDeserializer typeDeser = null; [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] try { [EOL] new TypeWrappedDeserializer(typeDeser, deser); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testTypeWrappedDeserializerWithNullJsonDeserializer() { [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<Object> deser = null; [EOL] try { [EOL] new TypeWrappedDeserializer(typeDeser, deser); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithNonNullValues() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] Object expected = new Object(); [EOL] when(deserializer.deserializeWithType(jp, ctxt, typeDeserializer)).thenReturn(expected); [EOL] StdDelegatingDeserializer stdDelegatingDeserializer = new StdDelegatingDeserializer(deserializer, typeDeserializer); [EOL] Object result = stdDelegatingDeserializer.deserialize(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeWithException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] IOException exception = new IOException(); [EOL] when(deserializer.deserializeWithType(jp, ctxt, typeDeserializer)).thenThrow(exception); [EOL] StdDelegatingDeserializer stdDelegatingDeserializer = new StdDelegatingDeserializer(deserializer, typeDeserializer); [EOL] try { [EOL] stdDelegatingDeserializer.deserialize(jp, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertSame(exception, e); [EOL] } [EOL] }
public void testCreateContextualWithDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<Object> delegateDeser = mock(JsonDeserializer.class); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(delegateType); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(findDeserializer(ctxt, delegateType, property)).thenReturn(delegateDeser); [EOL] CollectionDeserializer deserializer = new CollectionDeserializer(); [EOL] deserializer._valueInstantiator = valueInstantiator; [EOL] CollectionDeserializer result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertEquals(delegateDeser, result._delegateDeserializer); [EOL] }
public void testCreateContextualWithoutDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType collectionType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(_collectionType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(valueDeser); [EOL] CollectionDeserializer deserializer = new CollectionDeserializer(); [EOL] deserializer._valueInstantiator = valueInstantiator; [EOL] deserializer._collectionType = collectionType; [EOL] CollectionDeserializer result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertEquals(valueDeser, result._valueDeserializer); [EOL] }
public void testCreateContextualWithNullDelegateType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(null); [EOL] CollectionDeserializer deserializer = new CollectionDeserializer(); [EOL] deserializer._valueInstantiator = valueInstantiator; [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] deserializer.createContextual(ctxt, property); [EOL] }); [EOL] }
public void testCreateContextualWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] TypeDeserializer propertyValueTypeDeser = mock(TypeDeserializer.class); [EOL] when(_valueTypeDeserializer).thenReturn(valueTypeDeser); [EOL] when(valueTypeDeser.forProperty(property)).thenReturn(propertyValueTypeDeser); [EOL] CollectionDeserializer deserializer = new CollectionDeserializer(); [EOL] deserializer._valueTypeDeserializer = valueTypeDeser; [EOL] CollectionDeserializer result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertEquals(propertyValueTypeDeser, result._valueTypeDeserializer); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt))).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(valueInstantiator.createFromString(ctxt, "")).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeUsingDefault() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testGetType() { [EOL] MyClass myClassInstance = new MyClass(); [EOL] Class<?> expectedType = myClassInstance.getClass(); [EOL] Class<?> actualType = myClassInstance.getType(); [EOL] assertEquals(expectedType, actualType); [EOL] }
public void testGetNameWhenNameIsSet() { [EOL] MyClass obj = new MyClass("TestName"); [EOL] String name = obj.getName(); [EOL] assertEquals("TestName", name); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> contextualSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(elementSerializer); [EOL] when(elementSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] when(((ContextualSerializer) elementSerializer).createContextual(provider, property)).thenReturn(contextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(contextualSerializer, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(elementSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyButNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(property.getMember()).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(elementSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(elementSerializer, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(null); [EOL] when(_elementType).thenReturn(Object.class); [EOL] when(_staticTyping).thenReturn(true); [EOL] when(provider.findValueSerializer(Object.class, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testCreateContextualWithContentTypeAnnotation() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(null); [EOL] when(_elementType).thenReturn(Object.class); [EOL] when(_staticTyping).thenReturn(false); [EOL] when(hasContentTypeAnnotation(provider, property)).thenReturn(true); [EOL] when(provider.findValueSerializer(Object.class, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testIsEmptyWithNullArray() { [EOL] boolean result = isEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithEmptyArray() { [EOL] Object[] emptyArray = new Object[0]; [EOL] boolean result = isEmpty(emptyArray); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithNonEmptyArray() { [EOL] Object[] nonEmptyArray = new Object[1]; [EOL] boolean result = isEmpty(nonEmptyArray); [EOL] assertFalse(result); [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] Object[] value = new Object[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new StdArraySerializers.ObjectArraySerializer(null, null, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] StdSerializer<Object[]> serializer = new StdArraySerializers.ObjectArraySerializer(null, null, elementSerializer); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(elementSerializer).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] StdSerializer<Object[]> serializer = new StdArraySerializers.ObjectArraySerializer(null, typeSerializer, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeValue(any(), eq(jgen)); [EOL] }
public void testSerializeContentsWithDynamicSerializers() throws IOException { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new StdArraySerializers.ObjectArraySerializer(null, null, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeValue(any(), eq(jgen)); [EOL] }
public void testSerializeContentsWithIOException() { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new StdArraySerializers.ObjectArraySerializer(null, null, null); [EOL] doThrow(IOException.class).when(jgen).writeString(any(String.class)); [EOL] assertThrows(IOException.class, () -> serializer.serializeContents(value, jgen, provider)); [EOL] }
public void testSerializeContentsWithRuntimeException() { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new StdArraySerializers.ObjectArraySerializer(null, null, null); [EOL] doThrow(RuntimeException.class).when(jgen).writeString(any(String.class)); [EOL] assertThrows(JsonMappingException.class, () -> serializer.serializeContents(value, jgen, provider)); [EOL] }
public void testSerializeContentsUsingWithEmptyArray() throws IOException { [EOL] Object[] value = new Object[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verifyNoMoreInteractions(jgen); [EOL] verifyNoMoreInteractions(ser); [EOL] }
public void testSerializeContentsUsingWithNullElement() throws IOException { [EOL] Object[] value = new Object[1]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verifyNoMoreInteractions(ser); [EOL] }
public void testSerializeContentsUsingWithNonNullElementNoTypeSerializer() throws IOException { [EOL] Object[] value = new Object[] { "test" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(ser).serialize("test", jgen, provider); [EOL] }
public void testSerializeContentsUsingWithNonNullElementWithTypeSerializer() throws IOException { [EOL] Object[] value = new Object[] { "test" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser, typeSer); [EOL] verify(ser).serializeWithType("test", jgen, provider, typeSer); [EOL] }
public void testSerializeContentsUsingWithIOException() { [EOL] Object[] value = new Object[] { "test" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] doThrow(new IOException()).when(ser).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] assertThrows(IOException.class, () -> serializeContentsUsing(value, jgen, provider, ser)); [EOL] }
public void testSerializeContentsUsingWithRuntimeException() { [EOL] Object[] value = new Object[] { "test" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] doThrow(new RuntimeException()).when(ser).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] assertThrows(JsonMappingException.class, () -> serializeContentsUsing(value, jgen, provider, ser)); [EOL] }
public void testSerializeContentsUsingWithError() { [EOL] Object[] value = new Object[] { "test" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] doThrow(new Error()).when(ser).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] assertThrows(Error.class, () -> serializeContentsUsing(value, jgen, provider, ser)); [EOL] }
public void testSerializeContentsUsingWithInvocationTargetException() throws IOException { [EOL] Object[] value = new Object[] { "test" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] InvocationTargetException ite = new InvocationTargetException(new RuntimeException()); [EOL] doThrow(ite).when(ser).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] assertThrows(JsonMappingException.class, () -> serializeContentsUsing(value, jgen, provider, ser)); [EOL] }
public void testBeanAsArrayDeserializerWithNonNullProperties() { [EOL] BeanDeserializerBase delegate = mock(BeanDeserializerBase.class); [EOL] SettableBeanProperty[] ordered = new SettableBeanProperty[0]; [EOL] BeanAsArrayDeserializer deserializer = new BeanAsArrayDeserializer(delegate, ordered); [EOL] assertNotNull(deserializer); [EOL] }
public void testBeanAsArrayDeserializerWithNullProperties() { [EOL] BeanDeserializerBase delegate = mock(BeanDeserializerBase.class); [EOL] BeanAsArrayDeserializer deserializer = new BeanAsArrayDeserializer(delegate, null); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, times(1)).getCurrentToken(); [EOL] }
public void testDeserializeWithVanillaProcessingDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, times(1)).getCurrentToken(); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, times(1)).nextToken(); [EOL] }
public void testDeserializeWithFullPropsAndIgnoreAllUnknown() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(_ignoreAllUnknown).thenReturn(true); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[1]; [EOL] props[0] = mock(SettableBeanProperty.class); [EOL] when(_orderedProperties).thenReturn(props); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(new Object()); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(props[0], times(1)).deserializeAndSet(jp, ctxt, result); [EOL] }
public void testDeserializeWithFullPropsAndNotIgnoreAllUnknown() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(_ignoreAllUnknown).thenReturn(false); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[1]; [EOL] props[0] = mock(SettableBeanProperty.class); [EOL] when(_orderedProperties).thenReturn(props); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(new Object()); [EOL] assertThrows(JsonMappingException.class, () -> deserialize(jp, ctxt)); [EOL] verify(jp, times(2)).nextToken(); [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] if (_nonStandardCreation) { [EOL] return _deserializeWithCreator(jp, ctxt); [EOL] } [EOL] final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] if (_injectables != null) { [EOL] injectValues(ctxt, bean); [EOL] } [EOL] Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL] final SettableBeanProperty[] props = _orderedProperties; [EOL] int i = 0; [EOL] final int propCount = props.length; [EOL] while (true) { [EOL] if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL] return bean; [EOL] } [EOL] if (i == propCount) { [EOL] break; [EOL] } [EOL] SettableBeanProperty prop = props[i]; [EOL] ++i; [EOL] if (prop != null) { [EOL] if (activeView == null || prop.visibleInView(activeView)) { [EOL] try { [EOL] prop.deserializeAndSet(jp, ctxt, bean); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL] } [EOL] continue; [EOL] } [EOL] } [EOL] jp.skipChildren(); [EOL] } [EOL] if (!_ignoreAllUnknown) { [EOL] throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL] } [EOL] while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL] jp.skipChildren(); [EOL] } [EOL] return bean; [EOL] }
protected SerializableSerializer() { [EOL] super(JsonSerializable.class); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonSerializable value = mock(JsonSerializable.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new JsonSerializerSubClass().serialize(value, jgen, provider); [EOL] verify(value).serialize(jgen, provider); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonSerializable value = null; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializerSubClass serializer = new JsonSerializerSubClass(); [EOL] try { [EOL] serializer.serialize(value, jgen, provider); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testDeserializeWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] Object expectedObject = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromScalar(jp, ctxt)).thenReturn(expectedObject); [EOL] StdDeserializer<Object> deserializer = new StdDeserializer<Object>(Object.class) { [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL] return super.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] } [EOL] }; [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expectedObject, result); [EOL] }
public void testSerializeContentsWithEmptyIterator() throws IOException { [EOL] Iterator<?> value = Collections.emptyIterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] verifyNoMoreInteractions(provider); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] Iterator<?> value = Arrays.asList((Object) null).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithNonNullElement() throws IOException { [EOL] Object elem = new Object(); [EOL] Iterator<?> value = Arrays.asList(elem).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer).serialize(elem, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] verifyNoMoreInteractions(provider); [EOL] }
public void testSerializeContentsWithMultipleElementsOfSameType() throws IOException { [EOL] Object elem1 = new Object(); [EOL] Object elem2 = new Object(); [EOL] Iterator<?> value = Arrays.asList(elem1, elem2).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] verifyNoMoreInteractions(jgen); [EOL] verifyNoMoreInteractions(provider); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] Object elem = new Object(); [EOL] Iterator<?> value = Arrays.asList(elem).iterator(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] when(provider.findValueSerializer(Object.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider, typeSer); [EOL] verify(serializer).serializeWithType(elem, jgen, provider, typeSer); [EOL] verifyNoMoreInteractions(jgen); [EOL] verifyNoMoreInteractions(provider); [EOL] }
public void testCreateSerializerWithAnnotationSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<?> annotationSerializer = mock(JsonSerializer.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(findSerializerFromAnnotation(prov, beanDesc.getClassInfo())).thenReturn(annotationSerializer); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertSame(annotationSerializer, result); [EOL] }
public void testCreateSerializerWithoutAnnotationAndWithoutConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(findSerializerFromAnnotation(prov, beanDesc.getClassInfo())).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType)).thenReturn(origType); [EOL] when(beanDesc.findSerializationConverter()).thenReturn(null); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertNotNull(result); [EOL] }
public void testCreateSerializerWithModifiedTypeAndConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] JavaType modifiedType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(config.introspect(modifiedType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(findSerializerFromAnnotation(prov, beanDesc.getClassInfo())).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType)).thenReturn(modifiedType); [EOL] when(modifiedType.getRawClass()).thenReturn(mock(Class.class)); [EOL] when(origType.getRawClass()).thenReturn(mock(Class.class)); [EOL] when(beanDesc.findSerializationConverter()).thenReturn(converter); [EOL] when(converter.getOutputType(prov.getTypeFactory())).thenReturn(delegateType); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindBeanSerializerWithNonBeanType() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType nonBeanType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(nonBeanType.getRawClass()).thenReturn(String.class); [EOL] when(nonBeanType.isEnumType()).thenReturn(false); [EOL] JsonSerializer<Object> result = findBeanSerializer(prov, nonBeanType, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindBeanSerializerWithEnumType() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType enumType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(enumType.getRawClass()).thenReturn(Enum.class); [EOL] when(enumType.isEnumType()).thenReturn(true); [EOL] JsonSerializer<Object> result = findBeanSerializer(prov, enumType, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindBeanSerializerWithBeanType() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanType.getRawClass()).thenReturn(MyBean.class); [EOL] when(beanType.isEnumType()).thenReturn(false); [EOL] JsonSerializer<Object> result = findBeanSerializer(prov, beanType, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithObjectClass() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(Object.class); [EOL] when(prov.getUnknownTypeSerializer(Object.class)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] SerializerFactoryConfig factoryConfig = mock(SerializerFactoryConfig.class); [EOL] when(factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] when(factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(mock(BeanSerializerModifier.class))); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithoutModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] SerializerFactoryConfig factoryConfig = mock(SerializerFactoryConfig.class); [EOL] when(factoryConfig.hasSerializerModifiers()).thenReturn(false); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithAnyGetter() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] AnnotatedMember anyGetter = mock(AnnotatedMember.class); [EOL] when(beanDesc.findAnyGetter()).thenReturn(anyGetter); [EOL] when(anyGetter.getName()).thenReturn("anyGetter"); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithNullSerializer() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(builder.build()).thenReturn(null); [EOL] when(beanDesc.hasKnownClassAnnotations()).thenReturn(true); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL] ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL] if (objectIdInfo == null) { [EOL] return null; [EOL] } [EOL] ObjectIdGenerator<?> gen; [EOL] Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL] if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL] String propName = objectIdInfo.getPropertyName(); [EOL] BeanPropertyWriter idProp = null; [EOL] for (int i = 0, len = props.size(); ; ++i) { [EOL] if (i == len) { [EOL] throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL] } [EOL] BeanPropertyWriter prop = props.get(i); [EOL] if (propName.equals(prop.getName())) { [EOL] idProp = prop; [EOL] if (i > 0) { [EOL] props.remove(i); [EOL] props.add(0, idProp); [EOL] } [EOL] break; [EOL] } [EOL] } [EOL] JavaType idType = idProp.getType(); [EOL] gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL] return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL] } [EOL] JavaType type = prov.constructType(implClass); [EOL] JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL] gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL] return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
public void testFindBeanPropertiesWithEmptyProperties() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.emptyList()); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNull(result); [EOL] }
public void testFindBeanPropertiesWithIgnorableTypes() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] propertyDefinitions.add(mock(BeanPropertyDefinition.class)); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] doNothing().when(this).removeIgnorableTypes(any(SerializationConfig.class), any(BeanDescription.class), anyList()); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithSetterlessGetters() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] propertyDefinitions.add(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(true); [EOL] doNothing().when(this).removeSetterlessGetters(any(SerializationConfig.class), any(BeanDescription.class), anyList()); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithTypeIds() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] when(propertyDefinition.isTypeId()).thenReturn(true); [EOL] propertyDefinitions.add(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithBackReference() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(propertyDefinition.findReferenceType()).thenReturn(refProperty); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] propertyDefinitions.add(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithAccessorMethod() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMethod accessor = mock(AnnotatedMethod.class); [EOL] when(propertyDefinition.getAccessor()).thenReturn(accessor); [EOL] propertyDefinitions.add(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(1, result.size()); [EOL] }
public void testFindBeanPropertiesWithAccessorField() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] AnnotatedField accessor = mock(AnnotatedField.class); [EOL] when(propertyDefinition.getAccessor()).thenReturn(accessor); [EOL] propertyDefinitions.add(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(1, result.size()); [EOL] }
public void testFilterBeanPropertiesWithNoPropertiesToIgnore() { [EOL] SerializationConfig config = createMockConfig(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] List<BeanPropertyWriter> props = createMockPropertyWriters(); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(any(AnnotatedClass.class))).thenReturn(null); [EOL] List<BeanPropertyWriter> filteredProps = filterBeanProperties(config, beanDesc, props); [EOL] assertSame(props, filteredProps); [EOL] }
public void testFilterBeanPropertiesWithPropertiesToIgnore() { [EOL] SerializationConfig config = createMockConfig(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] List<BeanPropertyWriter> props = createMockPropertyWriters(); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(any(AnnotatedClass.class))).thenReturn(new String[]{"propToIgnore"}); [EOL] BeanPropertyWriter propToIgnore = createMockPropertyWriter("propToIgnore"); [EOL] props.add(propToIgnore); [EOL] List<BeanPropertyWriter> filteredProps = filterBeanProperties(config, beanDesc, props); [EOL] assertFalse(filteredProps.contains(propToIgnore)); [EOL] assertEquals(props.size() - 1, filteredProps.size()); [EOL] }
public void testValueInjectorConstructor() { [EOL] String propertyName = "testProperty"; [EOL] JavaType type = mock(JavaType.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] AnnotatedMember mutator = mock(AnnotatedMember.class); [EOL] Object valueId = new Object(); [EOL] ValueInjector injector = new ValueInjector(propertyName, type, contextAnnotations, mutator, valueId); [EOL] assertEquals(propertyName, injector.getPropertyName()); [EOL] assertEquals(type, injector.getType()); [EOL] assertEquals(contextAnnotations, injector.getContextAnnotations()); [EOL] assertEquals(mutator, injector.getMember()); [EOL] assertEquals(valueId, injector.getValueId()); [EOL] }
public void testFindValueWithNonNullContextAndBeanInstance() { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] Object beanInstance = new Object(); [EOL] Object expectedValue = new Object(); [EOL] when(context.findInjectableValue(any(), any(), any())).thenReturn(expectedValue); [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] injectableValues.addValue("valueId", expectedValue); [EOL] Object actualValue = injectableValues.findValue(context, beanInstance); [EOL] assertSame("The returned value should be the one provided by the context", expectedValue, actualValue); [EOL] }
public void testFindValueWithNullContext() { [EOL] try { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] injectableValues.findValue(null, new Object()); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Context cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testFindValueWithNullBeanInstance() { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] Object expectedValue = new Object(); [EOL] when(context.findInjectableValue(any(), any(), any())).thenReturn(expectedValue); [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] Object actualValue = injectableValues.findValue(context, null); [EOL] assertSame("The returned value should be the one provided by the context even with null beanInstance", expectedValue, actualValue); [EOL] }
public void testInjectWithValidContextAndBeanInstance() throws IOException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] Object beanInstance = new Object(); [EOL] InjectableBeanProperty injectableBeanProperty = new InjectableBeanProperty(...); // Provide necessary arguments [EOL] injectableBeanProperty.inject(context, beanInstance); [EOL] verify(_member).setValue(eq(beanInstance), any()); // Use the correct matcher for the second argument [EOL] }
public void testInjectWithNullContext() { [EOL] Object beanInstance = new Object(); [EOL] InjectableBeanProperty injectableBeanProperty = new InjectableBeanProperty(...); // Provide necessary arguments [EOL] assertThrows(NullPointerException.class, () -> injectableBeanProperty.inject(null, beanInstance)); [EOL] }
public void testInjectWithNullBeanInstance() throws IOException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] InjectableBeanProperty injectableBeanProperty = new InjectableBeanProperty(...); // Provide necessary arguments [EOL] assertThrows(NullPointerException.class, () -> injectableBeanProperty.inject(context, null)); [EOL] }
public JavaType constructSpecializedTypeTest_BaseTypeNull() { [EOL] try { [EOL] JavaType result = constructSpecializedType(null, SomeSubclass.class); [EOL] fail("Expected exception was not thrown."); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("baseType must not be null", e.getMessage()); [EOL] } [EOL] }
public JavaType constructSpecializedTypeTest_SubclassNull() { [EOL] JavaType baseType = new BaseJavaType(); // Assuming BaseJavaType is a valid JavaType [EOL] try { [EOL] JavaType result = constructSpecializedType(baseType, null); [EOL] fail("Expected exception was not thrown."); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("subclass must not be null", e.getMessage()); [EOL] } [EOL] }
public JavaType constructSpecializedTypeTest_ValidArguments() { [EOL] JavaType baseType = new BaseJavaType(); // Assuming BaseJavaType is a valid JavaType [EOL] Class<?> subclass = SomeSubclass.class; // Assuming SomeSubclass is a valid subclass [EOL] JavaType expectedType = new SpecializedJavaType(); // Assuming this is the expected specialized JavaType [EOL] when(getConfig().constructSpecializedType(baseType, subclass)).thenReturn(expectedType); [EOL] JavaType result = constructSpecializedType(baseType, subclass); [EOL] assertNotNull(result); [EOL] assertEquals(expectedType, result); [EOL] }
public void testConverterInstanceWithNull() { [EOL] Converter<Object, Object> result = converterInstance(mock(Annotated.class), null); [EOL] assertNull(result); [EOL] }
public void testConverterInstanceWithConverter() { [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] Converter<Object, Object> result = converterInstance(mock(Annotated.class), converter); [EOL] assertSame(converter, result); [EOL] }
public void testConverterInstanceWithInvalidType() { [EOL] Object invalidConverterDef = new Object(); [EOL] try { [EOL] converterInstance(mock(Annotated.class), invalidConverterDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Converter definition of type " + invalidConverterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead", e.getMessage()); [EOL] } [EOL] }
public void testConverterInstanceWithNoneClass() { [EOL] Converter<Object, Object> result = converterInstance(mock(Annotated.class), Converter.None.class); [EOL] assertNull(result); [EOL] }
public void testConverterInstanceWithNoClass() { [EOL] Converter<Object, Object> result = converterInstance(mock(Annotated.class), NoClass.class); [EOL] assertNull(result); [EOL] }
public void testConverterInstanceWithNonConverterClass() { [EOL] Class<?> nonConverterClass = String.class; [EOL] try { [EOL] converterInstance(mock(Annotated.class), nonConverterClass); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class " + nonConverterClass.getName() + "; expected Class<Converter>", e.getMessage()); [EOL] } [EOL] }
public void testConverterInstanceWithConverterClass() { [EOL] Class<Converter<Object, Object>> converterClass = mock(Class.class); [EOL] when(converterClass.isAssignableFrom(Converter.class)).thenReturn(true); [EOL] when(converterClass.getName()).thenReturn("com.example.ConverterImpl"); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] when(hi.converterInstance(any(MapperConfig.class), any(Annotated.class), eq(converterClass))).thenReturn(converter); [EOL] when(config.getHandlerInstantiator()).thenReturn(hi); [EOL] when(getConfig()).thenReturn(config); [EOL] Converter<Object, Object> result = converterInstance(mock(Annotated.class), converterClass); [EOL] assertSame(converter, result); [EOL] }
public void testConverterInstanceWithConverterClassAndNoHandlerInstantiator() { [EOL] Class<Converter<Object, Object>> converterClass = mock(Class.class); [EOL] when(converterClass.isAssignableFrom(Converter.class)).thenReturn(true); [EOL] when(converterClass.getName()).thenReturn("com.example.ConverterImpl"); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] when(config.getHandlerInstantiator()).thenReturn(null); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(getConfig()).thenReturn(config); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] when(ClassUtil.createInstance(converterClass, true)).thenReturn(converter); [EOL] Converter<Object, Object> result = converterInstance(mock(Annotated.class), converterClass); [EOL] assertSame(converter, result); [EOL] }
public void testAnnotatedConstructorWithSerialization() { [EOL] Serialization ser = new Serialization(); // Assuming Serialization is a valid class that can be instantiated [EOL] AnnotatedConstructor ac = new AnnotatedConstructor(ser); [EOL] assertNull(ac.getAnnotated()); [EOL] assertNull(ac.getMember()); [EOL] assertNull(ac.getConstructor()); [EOL] assertEquals(ser, ac.getSerialization()); [EOL] }
public void testCall1WithValidArg() throws Exception { [EOL] Constructor<?> constructor = MyClass.class.getConstructor(MyArgClass.class); [EOL] Object validArg = new MyArgClass(); [EOL] MyClass instance = new MyClass(constructor); [EOL] Object result = instance.call1(validArg); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyClass); [EOL] }
public void testCall1WithInvalidArg() { [EOL] Constructor<?> constructor = MyClass.class.getConstructor(MyArgClass.class); [EOL] Object invalidArg = new NotMyArgClass(); [EOL] MyClass instance = new MyClass(constructor); [EOL] try { [EOL] instance.call1(invalidArg); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertEquals(InvocationTargetException.class, e.getClass()); [EOL] } [EOL] }
public void testCall1WithNullArg() { [EOL] Constructor<?> constructor = MyClass.class.getConstructor(MyArgClass.class); [EOL] MyClass instance = new MyClass(constructor); [EOL] try { [EOL] instance.call1(null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertEquals(NullPointerException.class, e.getClass()); [EOL] } [EOL] }
public void testWriteReplace() { [EOL] AnnotatedConstructor constructor = new AnnotatedConstructor(null); [EOL] Object result = constructor.writeReplace(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof AnnotatedConstructor.Serialization); [EOL] }
public void testReadResolveWithAccessibleConstructor() { [EOL] _serialization.clazz = SomeClassWithAccessibleConstructor.class; [EOL] _serialization.args = new Class<?>[0]; // Assuming it takes no arguments [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof AnnotatedConstructor); [EOL] }
public void testReadResolveWithInaccessibleConstructor() { [EOL] _serialization.clazz = SomeClassWithInaccessibleConstructor.class; [EOL] _serialization.args = new Class<?>[0]; // Assuming it takes no arguments [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof AnnotatedConstructor); [EOL] }
public void testReadResolveConstructorNotFound() { [EOL] _serialization.clazz = SomeClassWithoutMatchingConstructor.class; [EOL] _serialization.args = new Class<?>[] {String.class}; // Assuming it looks for a constructor with a single String argument [EOL] try { [EOL] readResolve(); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Could not find constructor with 1 args from Class '" + SomeClassWithoutMatchingConstructor.class.getName(), e.getMessage()); [EOL] } [EOL] }
public void testSerializationWithValidConstructor() { [EOL] Constructor<?> constructor = String.class.getConstructors()[0]; [EOL] Serialization serialization = new Serialization(constructor); [EOL] assertEquals(String.class, serialization.clazz); [EOL] assertArrayEquals(constructor.getParameterTypes(), serialization.args); [EOL] }
public void testSerializationWithNullConstructor() { [EOL] try { [EOL] Serialization serialization = new Serialization(null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testIndexedListSerializerWithStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] TypeSerializer vts = new MockTypeSerializer(); [EOL] JsonSerializer<Object> valueSerializer = new MockJsonSerializer(); [EOL] ContainerSerializer<?> result = JacksonDatabindUtils.indexedListSerializer(elemType, true, vts, valueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testIndexedListSerializerWithoutStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] JsonSerializer<Object> valueSerializer = new MockJsonSerializer(); [EOL] ContainerSerializer<?> result = JacksonDatabindUtils.indexedListSerializer(elemType, false, null, valueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testFindWithPrimitiveIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Integer.TYPE, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertEquals(IntegerDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Boolean.TYPE, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertEquals(BooleanDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Long.TYPE, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertEquals(LongDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Double.TYPE, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertEquals(DoubleDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Character.TYPE, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertEquals(CharacterDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Byte.TYPE, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertEquals(ByteDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Short.TYPE, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertEquals(ShortDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Float.TYPE, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertEquals(FloatDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithWrapperIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Integer.class, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertEquals(IntegerDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Boolean.class, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertEquals(BooleanDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Long.class, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertEquals(LongDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Double.class, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertEquals(DoubleDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Character.class, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertEquals(CharacterDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Byte.class, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertEquals(ByteDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Short.class, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertEquals(ShortDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Float.class, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertEquals(FloatDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithNumberType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Number.class, "java.lang.Number"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof NumberDeserializer); [EOL] assertEquals(NumberDeserializer.instance, deserializer); [EOL] }
public void testFindWithBigDecimalType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(BigDecimal.class, "java.math.BigDecimal"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigDecimalDeserializer); [EOL] assertEquals(BigDecimalDeserializer.instance, deserializer); [EOL] }
public void testFindWithBigIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(BigInteger.class, "java.math.BigInteger"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigIntegerDeserializer); [EOL] assertEquals(BigIntegerDeserializer.instance, deserializer); [EOL] }
public void testFindWithUnrecognizedType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Object.class, "java.lang.Object"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithNullType() { [EOL] try { [EOL] YourClass.find(null, "java.lang.Integer"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithValidNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(65); // ASCII value for 'A' [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] Character result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Character.valueOf('A'), result); [EOL] }
public void testDeserializeWithInvalidNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(70000); // Out of char range [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithValidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("A"); [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] Character result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Character.valueOf('A'), result); [EOL] }
public void testDeserializeWithEmptyStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] Character result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Character.valueOf((char) 0), result); // Assuming getEmptyValue() returns Character.valueOf((char) 0) [EOL] }
public void testDeserializeWithInvalidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("AB"); // More than one character [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); // Invalid token for this context [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDoubleDeserializerWithNonNullClassAndValue() { [EOL] Double expectedValue = 10.0; [EOL] DoubleDeserializer deserializer = new DoubleDeserializer(Double.class, expectedValue); [EOL] assertEquals(Double.class, deserializer.handledType()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testDoubleDeserializerWithNonNullClassAndNullValue() { [EOL] DoubleDeserializer deserializer = new DoubleDeserializer(Double.class, null); [EOL] assertEquals(Double.class, deserializer.handledType()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidDouble() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("42.0"); [EOL] Double result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(42.0), result); [EOL] }
public void testDeserializeWithInvalidDouble() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] Double result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithIntAndUseBigIntegerForIntsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345"), result); [EOL] }
public void testDeserializeWithIntAndUseBigIntegerForIntsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(12345); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(12345, result); [EOL] }
public void testDeserializeWithFloatAndUseBigDecimalForFloatsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithFloatAndUseBigDecimalForFloatsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(123.45), result); [EOL] }
public void testDeserializeWithStringContainingDotAndUseBigDecimalForFloatsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithStringContainingDotAndUseBigDecimalForFloatsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(Double.valueOf("123.45"), result); [EOL] }
public void testDeserializeWithStringRepresentingIntAndUseBigIntegerForIntsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345"), result); [EOL] }
public void testDeserializeWithStringRepresentingIntAndFitsInInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(Integer.valueOf(12345), result); [EOL] }
public void testDeserializeWithStringRepresentingLongAndDoesNotFitInInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(String.valueOf(Long.MAX_VALUE)); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(Long.valueOf(Long.MAX_VALUE), result); [EOL] }
public void testDeserializeWithInvalidStringThrowsException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDeserializeWithInvalidTokenThrowsException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDeserializeWithType_ValueNumberInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(deserializer).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithType_ValueNumberFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(deserializer).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithType_ValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(deserializer).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithType_OtherToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); // Using a token that is not covered by the switch case [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(typeDeserializer).deserializeTypedFromScalar(jp, ctxt); [EOL] }
public void testDeserializeKeyWithNull() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] Object result = deserializer.deserializeKey(null, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeKeyWithValidKey() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String validKey = "validKey"; [EOL] when(deserializer._parse(validKey, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializer.deserializeKey(validKey, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeKeyWithInvalidKeyAndException() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String invalidKey = "invalidKey"; [EOL] when(deserializer._parse(invalidKey, ctxt)).thenThrow(new Exception("invalid")); [EOL] try { [EOL] deserializer.deserializeKey(invalidKey, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertEquals("not a valid representation: invalid", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeKeyWithInvalidKeyAndEnumNullSetting() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String invalidKey = "invalidKey"; [EOL] when(deserializer._parse(invalidKey, ctxt)).thenThrow(new Exception("invalid")); [EOL] when(ctxt.weirdKeyException(any(), any(), any())).thenThrow(new JsonProcessingException("") {}); [EOL] when(deserializer._keyClass.isEnum()).thenReturn(true); [EOL] when(ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] Object result = deserializer.deserializeKey(invalidKey, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeKeyWithInvalidKeyAndEnumNonNullSetting() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String invalidKey = "invalidKey"; [EOL] when(deserializer._parse(invalidKey, ctxt)).thenThrow(new Exception("invalid")); [EOL] when(ctxt.weirdKeyException(any(), any(), any())).thenThrow(new JsonProcessingException("") {}); [EOL] when(deserializer._keyClass.isEnum()).thenReturn(true); [EOL] when(ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] try { [EOL] deserializer.deserializeKey(invalidKey, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertEquals("not a valid representation", e.getMessage()); [EOL] } [EOL] }
public void testEnumKDWithValidEnumResolverAndFactory() { [EOL] EnumResolver<?> enumResolver = EnumResolver.constructFor(MyEnum.class, null); [EOL] AnnotatedMethod factory = new AnnotatedMethod(null, MyEnum.class.getMethod("someFactoryMethod"), null, null); [EOL] EnumKD enumKD = new EnumKD(enumResolver, factory); [EOL] assertNotNull(enumKD); [EOL] assertEquals(MyEnum.class, enumKD.getEnumClass()); [EOL] assertEquals(factory, enumKD.getFactory()); [EOL] }
public void testEnumKDWithNullEnumResolver() { [EOL] AnnotatedMethod factory = new AnnotatedMethod(null, MyEnum.class.getMethod("someFactoryMethod"), null, null); [EOL] try { [EOL] EnumKD enumKD = new EnumKD(null, factory); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEnumKDWithNullFactory() { [EOL] EnumResolver<?> enumResolver = EnumResolver.constructFor(MyEnum.class, null); [EOL] EnumKD enumKD = new EnumKD(enumResolver, null); [EOL] assertNotNull(enumKD); [EOL] assertEquals(MyEnum.class, enumKD.getEnumClass()); [EOL] assertNull(enumKD.getFactory()); [EOL] }
public void testParseWithFactory() throws JsonMappingException { [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] deserializer._factory = key -> "factoryResult"; [EOL] Object result = deserializer._parse("key", new DeserializationContext(...)); [EOL] assertEquals("factoryResult", result); [EOL] }
public void testParseWithResolverReturningNonNull() throws JsonMappingException { [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] deserializer._resolver = key -> Enum.valueOf(MyEnum.class, key); [EOL] Object result = deserializer._parse("EXISTING_ENUM_VALUE", new DeserializationContext(...)); [EOL] assertEquals(MyEnum.EXISTING_ENUM_VALUE, result); [EOL] }
public void testParseWithResolverReturningNullAndFeatureEnabled() throws JsonMappingException { [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] deserializer._resolver = key -> null; [EOL] DeserializationContext ctxt = new DeserializationContext(...); [EOL] ctxt.getConfig().setEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL] Object result = deserializer._parse("UNKNOWN_ENUM_VALUE", ctxt); [EOL] assertNull(result); [EOL] }
public void testParseWithResolverReturningNullAndFeatureDisabled() { [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] deserializer._resolver = key -> null; [EOL] DeserializationContext ctxt = new DeserializationContext(...); [EOL] ctxt.getConfig().setEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, false); [EOL] assertThrows(JsonMappingException.class, () -> deserializer._parse("UNKNOWN_ENUM_VALUE", ctxt)); [EOL] }
public void testStringFactoryKeyDeserializerWithValidMethod() throws NoSuchMethodException { [EOL] Method factoryMethod = String.class.getMethod("valueOf", Object.class); [EOL] StringFactoryKeyDeserializer deserializer = new StringFactoryKeyDeserializer(factoryMethod); [EOL] assertNotNull(deserializer); [EOL] }
public void testParseWithValidKey() throws Exception { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains _parse method [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); // Mock DeserializationContext [EOL] String validKey = "validKey"; // Replace with a valid key for the factory method [EOL] Object expected = new Object(); // Replace with the expected result from the factory method [EOL] Method factoryMethod = YourClass.class.getDeclaredMethod("_factoryMethod", String.class); // Replace with actual factory method [EOL] factoryMethod.setAccessible(true); [EOL] when(factoryMethod.invoke(null, validKey)).thenReturn(expected); [EOL] Field field = YourClass.class.getDeclaredField("_factoryMethod"); // Replace with actual field name [EOL] field.setAccessible(true); [EOL] field.set(instance, factoryMethod); [EOL] Object result = instance._parse(validKey, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithInvalidKey() throws Exception { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains _parse method [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); // Mock DeserializationContext [EOL] String invalidKey = "invalidKey"; // Replace with an invalid key for the factory method [EOL] Method factoryMethod = YourClass.class.getDeclaredMethod("_factoryMethod", String.class); // Replace with actual factory method [EOL] factoryMethod.setAccessible(true); [EOL] when(factoryMethod.invoke(null, invalidKey)).thenThrow(new Exception("Invalid key")); [EOL] Field field = YourClass.class.getDeclaredField("_factoryMethod"); // Replace with actual field name [EOL] field.setAccessible(true); [EOL] field.set(instance, factoryMethod); [EOL] try { [EOL] instance._parse(invalidKey, ctxt); [EOL] fail("Exception was expected for invalid key"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testNodeCursorConstructorWithValidContextType() { [EOL] int contextType = 1; // Assuming 1 is a valid context type [EOL] NodeCursor parentCursor = new NodeCursor(0, null); // Assuming 0 is a valid context type [EOL] NodeCursor cursor = new NodeCursor(contextType, parentCursor); [EOL] assertNotNull(cursor); [EOL] assertEquals(contextType, cursor._type); [EOL] assertEquals(-1, cursor._index); [EOL] assertEquals(parentCursor, cursor._parent); [EOL] }
public void testNodeCursorConstructorWithNullParent() { [EOL] int contextType = 1; // Assuming 1 is a valid context type [EOL] NodeCursor cursor = new NodeCursor(contextType, null); [EOL] assertNotNull(cursor); [EOL] assertEquals(contextType, cursor._type); [EOL] assertEquals(-1, cursor._index); [EOL] assertNull(cursor._parent); [EOL] }
public void testGetParentWhenParentIsNull() { [EOL] NodeCursor nodeCursor = new NodeCursor(null); [EOL] assertNull(nodeCursor.getParent()); [EOL] }
public void testGetParentWhenParentIsNotNull() { [EOL] NodeCursor parentNodeCursor = new NodeCursor(null); [EOL] NodeCursor nodeCursor = new NodeCursor(parentNodeCursor); [EOL] assertSame(parentNodeCursor, nodeCursor.getParent()); [EOL] }
public void testRootValueWithNonNullNodeAndCursor() { [EOL] JsonNode node = new TextNode("test"); [EOL] NodeCursor parentCursor = new NodeCursor.ArrayCursor(null, null); [EOL] RootValue rootValue = new RootValue(node, parentCursor); [EOL] assertNotNull(rootValue.getNode()); [EOL] assertEquals(JsonStreamContext.TYPE_ROOT, rootValue.getType()); [EOL] assertEquals(parentCursor, rootValue.getParent()); [EOL] }
public void testRootValueWithNullNode() { [EOL] NodeCursor parentCursor = new NodeCursor.ArrayCursor(null, null); [EOL] RootValue rootValue = new RootValue(null, parentCursor); [EOL] assertNull(rootValue.getNode()); [EOL] assertEquals(JsonStreamContext.TYPE_ROOT, rootValue.getType()); [EOL] assertEquals(parentCursor, rootValue.getParent()); [EOL] }
public void testRootValueWithNullCursor() { [EOL] JsonNode node = new TextNode("test"); [EOL] RootValue rootValue = new RootValue(node, null); [EOL] assertNotNull(rootValue.getNode()); [EOL] assertEquals(JsonStreamContext.TYPE_ROOT, rootValue.getType()); [EOL] assertNull(rootValue.getParent()); [EOL] }
public void testNextToken_NotDone() { [EOL] JsonToken expectedToken = JsonToken.VALUE_STRING; // Assuming _node.asToken() would return VALUE_STRING [EOL] reader._done = false; [EOL] JsonToken actualToken = reader.nextToken(); [EOL] assertEquals(expectedToken, actualToken); [EOL] assertTrue(reader._done); [EOL] }
public void testNextToken_AlreadyDone() { [EOL] reader._done = true; // Set _done to true to simulate that nextToken has already been called [EOL] JsonToken actualToken = reader.nextToken(); [EOL] assertNull(actualToken); [EOL] assertNull(reader._node); [EOL] }
public void testEndTokenReturnsNull() { [EOL] JsonToken result = endToken(); [EOL] assertNull(result); [EOL] }
public void testCurrentNodeWhenNodeIsNull() { [EOL] JsonNodeCursor cursor = new JsonNodeCursor(null); [EOL] JsonNode result = cursor.currentNode(); [EOL] assertNull(result); [EOL] }
public void testCurrentNodeWhenNodeIsNotNull() { [EOL] JsonNode mockNode = mock(JsonNode.class); [EOL] JsonNodeCursor cursor = new JsonNodeCursor(mockNode); [EOL] JsonNode result = cursor.currentNode(); [EOL] assertSame(mockNode, result); [EOL] }
public void testFindAndAddSerializerWithValidType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(provider.findValueSerializer(type, property)).thenReturn(expectedSerializer); [EOL] SerializerAndMapResult result = findAndAddSerializer(type, provider, property); [EOL] assertNotNull(result); [EOL] assertEquals(expectedSerializer, result.getSerializer()); [EOL] assertNotNull(result.getTypeToId()); [EOL] assertEquals(expectedSerializer, result.getTypeToId().get(Object.class)); [EOL] }
public void testFindAndAddSerializerWithNullType() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JavaType type = null; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] assertThrows(NullPointerException.class, () -> { [EOL] findAndAddSerializer(type, provider, property); [EOL] }); [EOL] }
public void testFindAndAddSerializerWithNullProvider() { [EOL] SerializerProvider provider = null; [EOL] JavaType type = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] assertThrows(NullPointerException.class, () -> { [EOL] findAndAddSerializer(type, provider, property); [EOL] }); [EOL] }
public void testConstructEnumKeyDeserializerWithNullFactory() { [EOL] EnumResolver<?> enumResolver = EnumResolver.constructFor(EnumType.class, null); [EOL] KeyDeserializer keyDeserializer = StdKeyDeserializer.constructEnumKeyDeserializer(enumResolver, null); [EOL] assertNotNull(keyDeserializer); [EOL] }
public void testConstructEnumKeyDeserializerWithNonNullFactory() throws Exception { [EOL] EnumResolver<?> enumResolver = EnumResolver.constructFor(EnumType.class, null); [EOL] AnnotatedMethod factory = new AnnotatedMethod(null, EnumType.class.getMethod("someFactoryMethod"), null, null); [EOL] KeyDeserializer keyDeserializer = StdKeyDeserializer.constructEnumKeyDeserializer(enumResolver, factory); [EOL] assertNotNull(keyDeserializer); [EOL] }
public void testFindStringBasedKeyDeserializerWithConstructor() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Constructor<?> ctor = mock(Constructor.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findSingleArgConstructor(String.class)).thenReturn(ctor); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] KeyDeserializer result = JacksonDatabindUtils.findStringBasedKeyDeserializer(config, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializer.StringCtorKeyDeserializer); [EOL] }
public void testFindStringBasedKeyDeserializerWithFactoryMethod() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Method m = mock(Method.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findSingleArgConstructor(String.class)).thenReturn(null); [EOL] when(beanDesc.findFactoryMethod(String.class)).thenReturn(m); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] KeyDeserializer result = JacksonDatabindUtils.findStringBasedKeyDeserializer(config, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializer.StringFactoryKeyDeserializer); [EOL] }
public void testFindStringBasedKeyDeserializerWithNoConstructorOrFactoryMethod() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findSingleArgConstructor(String.class)).thenReturn(null); [EOL] when(beanDesc.findFactoryMethod(String.class)).thenReturn(null); [EOL] KeyDeserializer result = JacksonDatabindUtils.findStringBasedKeyDeserializer(config, type); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithStringClass() { [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming BeanDescription can be null or a mock [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithObjectClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming BeanDescription can be null or a mock [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithUUIDClass() { [EOL] JavaType type = SimpleType.constructUnsafe(UUID.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming BeanDescription can be null or a mock [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.UuidKD); [EOL] }
public void testFindKeyDeserializerWithPrimitiveClass() { [EOL] JavaType type = SimpleType.constructUnsafe(int.class); // int is a primitive type [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming BeanDescription can be null or a mock [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithIntegerClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Integer.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Assuming BeanDescription can be null or a mock [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] JsonSerializer<Object> elementSerializer = ...; // Initialize an element serializer [EOL] _elementSerializer = elementSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsEmptyCollection() throws IOException { [EOL] Collection<?> value = Collections.emptySet(); // Empty collection [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] Collection<?> value = Arrays.asList(null, null); // Collection with null elements [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNonNullElementAndNoTypeSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection containing non-null elements [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] _valueTypeSerializer = null; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNonNullElementAndTypeSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection containing non-null elements [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] TypeSerializer typeSerializer = ...; // Initialize a TypeSerializer [EOL] _valueTypeSerializer = typeSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithDynamicSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection containing elements of a class without a predefined serializer [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection that will cause an exception during serialization [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testClassKeyWithNonNullClass() { [EOL] Class<?> clazz = String.class; [EOL] ClassKey classKey = new ClassKey(clazz); [EOL] assertNotNull(classKey); [EOL] assertEquals(String.class, classKey.getClazz()); [EOL] assertEquals("java.lang.String", classKey.getClassName()); [EOL] assertEquals("java.lang.String".hashCode(), classKey.hashCode()); [EOL] }
public void testCompareToWithEqualClassKeys() { [EOL] ClassKey key1 = new ClassKey(String.class); [EOL] ClassKey key2 = new ClassKey(String.class); [EOL] int result = key1.compareTo(key2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareToWithLesserClassKey() { [EOL] ClassKey key1 = new ClassKey(String.class); [EOL] ClassKey key2 = new ClassKey(Integer.class); [EOL] int result = key1.compareTo(key2); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareToWithGreaterClassKey() { [EOL] ClassKey key1 = new ClassKey(Integer.class); [EOL] ClassKey key2 = new ClassKey(String.class); [EOL] int result = key1.compareTo(key2); [EOL] assertTrue(result > 0); [EOL] }
public void testEquals_Reflexive() { [EOL] ClassKey classKey = new ClassKey(String.class); [EOL] assertTrue(classKey.equals(classKey)); [EOL] }
public void testEquals_Null() { [EOL] ClassKey classKey = new ClassKey(String.class); [EOL] assertFalse(classKey.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] ClassKey classKey1 = new ClassKey(String.class); [EOL] ClassKey classKey2 = new ClassKey(Integer.class); [EOL] assertFalse(classKey1.equals(classKey2)); [EOL] }
public void testEquals_SameClass() { [EOL] ClassKey classKey1 = new ClassKey(String.class); [EOL] ClassKey classKey2 = new ClassKey(String.class); [EOL] assertTrue(classKey1.equals(classKey2)); [EOL] }
public void testToStringReturnsClassName() { [EOL] MyClass instance = new MyClass("ExampleClassName"); [EOL] String expected = "ExampleClassName"; [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testUnrecognizedPropertyExceptionWithNullValues() { [EOL] String msg = "Test message"; [EOL] JsonLocation loc = null; [EOL] Class<?> referringClass = null; [EOL] String propName = null; [EOL] Collection<Object> propertyIds = null; [EOL] UnrecognizedPropertyException exception = new UnrecognizedPropertyException(msg, loc, referringClass, propName, propertyIds); [EOL] assertNull(exception.getLocation()); [EOL] assertNull(exception.getReferringClass()); [EOL] assertNull(exception.getUnrecognizedPropertyName()); [EOL] assertNull(exception.getPropertyIds()); [EOL] }
public void testUnrecognizedPropertyExceptionWithNonNullValues() { [EOL] String msg = "Test message"; [EOL] JsonLocation loc = new JsonLocation(new Object(), 1L, 2, 3); [EOL] Class<?> referringClass = String.class; [EOL] String propName = "propertyName"; [EOL] Collection<Object> propertyIds = new ArrayList<>(); [EOL] propertyIds.add("propertyId1"); [EOL] propertyIds.add("propertyId2"); [EOL] UnrecognizedPropertyException exception = new UnrecognizedPropertyException(msg, loc, referringClass, propName, propertyIds); [EOL] assertEquals(loc, exception.getLocation()); [EOL] assertEquals(referringClass, exception.getReferringClass()); [EOL] assertEquals(propName, exception.getUnrecognizedPropertyName()); [EOL] assertEquals(propertyIds, exception.getPropertyIds()); [EOL] }
public void testFromWithNullFromObjectOrClass() { [EOL] try { [EOL] UnrecognizedPropertyException.from(null, null, "propertyName", null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFromWithClassTypeFromObjectOrClass() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentLocation()).thenReturn(new JsonLocation(new Object(), -1, -1, -1, -1)); [EOL] Collection<Object> propertyIds = Collections.emptyList(); [EOL] UnrecognizedPropertyException e = UnrecognizedPropertyException.from(String.class, "propertyName", propertyIds); [EOL] assertNotNull(e); [EOL] assertEquals("Unrecognized field \"propertyName\" (class java.lang.String), not marked as ignorable", e.getMessage()); [EOL] }
public void testFromWithObjectTypeFromObjectOrClass() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentLocation()).thenReturn(new JsonLocation(new Object(), -1, -1, -1, -1)); [EOL] Collection<Object> propertyIds = Collections.emptyList(); [EOL] Object fromObject = new Object(); [EOL] UnrecognizedPropertyException e = UnrecognizedPropertyException.from(fromObject, "propertyName", propertyIds); [EOL] assertNotNull(e); [EOL] assertEquals("Unrecognized field \"propertyName\" (class java.lang.Object), not marked as ignorable", e.getMessage()); [EOL] }
public void testGetMessageSuffixWithNullProperties() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance._propertiesAsString = null; [EOL] instance._propertyIds = null; [EOL] String result = instance.getMessageSuffix(); [EOL] assertEquals("", result); [EOL] }
public void testGetMessageSuffixWithEmptyProperties() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance._propertiesAsString = null; [EOL] instance._propertyIds = Collections.emptySet(); [EOL] String result = instance.getMessageSuffix(); [EOL] assertEquals(" (0 known properties: ])", result); [EOL] }
public void testGetMessageSuffixWithOneProperty() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance._propertiesAsString = null; [EOL] instance._propertyIds = new HashSet<>(Arrays.asList("propertyOne")); [EOL] String result = instance.getMessageSuffix(); [EOL] assertEquals(" (one known property: \"propertyOne\"])", result); [EOL] }
public void testGetMessageSuffixWithMultipleProperties() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance._propertiesAsString = null; [EOL] Set<Object> properties = new LinkedHashSet<>(); [EOL] properties.add("propertyOne"); [EOL] properties.add("propertyTwo"); [EOL] instance._propertyIds = properties; [EOL] String result = instance.getMessageSuffix(); [EOL] assertTrue(result.startsWith(" (2 known properties: ")); [EOL] assertTrue(result.contains(", \"propertyOne\"")); [EOL] assertTrue(result.contains(", \"propertyTwo\"")); [EOL] }
public void testGetMessageSuffixWithTruncatedProperties() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance._propertiesAsString = null; [EOL] Set<Object> properties = new LinkedHashSet<>(); [EOL] for (int i = 0; i < 100; i++) { [EOL] properties.add("property" + i); [EOL] } [EOL] instance._propertyIds = properties; [EOL] String result = instance.getMessageSuffix(); [EOL] assertTrue(result.endsWith(" [truncated]])")); [EOL] }
public void testGetReferringClass() { [EOL] ReferringClassHolder holder = new ReferringClassHolder(SomeClass.class); [EOL] Class<?> referringClass = holder.getReferringClass(); [EOL] assertEquals(SomeClass.class, referringClass); [EOL] }
public void testGetUnrecognizedPropertyName_Null() { [EOL] JsonMappingException jme = new JsonMappingException(null, ""); [EOL] assertNull(jme.getUnrecognizedPropertyName()); [EOL] }
public void testGetUnrecognizedPropertyName_NonNull() { [EOL] String expectedPropertyName = "testProperty"; [EOL] JsonMappingException jme = new JsonMappingException(null, "", null, null, expectedPropertyName); [EOL] assertEquals(expectedPropertyName, jme.getUnrecognizedPropertyName()); [EOL] }
protected IndexedStringListSerializer() { [EOL] this(null); [EOL] }
public void testIndexedStringListSerializerWithNonNullSerializer() { [EOL] JsonSerializer<?> nonNullSerializer = new StdSerializer<String>(String.class) {}; [EOL] IndexedStringListSerializer serializer = new IndexedStringListSerializer(nonNullSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testIndexedStringListSerializerWithNullSerializer() { [EOL] JsonSerializer<?> nullSerializer = null; [EOL] try { [EOL] IndexedStringListSerializer serializer = new IndexedStringListSerializer(nullSerializer); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof ClassCastException); [EOL] } [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerializerDefinition() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinition() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<?> serializerInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(serializerInstance); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinitionButDefaultSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<?> serializerInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(serializerInstance); [EOL] when(isDefaultSerializer(serializerInstance)).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinitionAndContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<?> contextualInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(contextualSerializer); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(contextualInstance); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertSame(contextualInstance, result); [EOL] }
public void testSerializeWithSingleElementUnwrapped() throws IOException { [EOL] List<String> value = Collections.singletonList("singleElement"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithMultipleElements() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] }
public void testSerializeWithCustomSerializer() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] _serializer = mock(JsonSerializer.class); [EOL] serialize(value, jgen, provider); [EOL] verify(_serializer).serialize(any(), eq(jgen), eq(provider)); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] }
public void testSerializeWithNoCustomSerializer() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] _serializer = null; [EOL] serialize(value, jgen, provider); [EOL] verify(jgen, times(value.size())).writeString(any(String.class)); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] }
public void testSerializeContentsWithNonNullValues() throws IOException { [EOL] List<String> value = Arrays.asList("string1", "string2", "string3"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] int len = value.size(); [EOL] serializeContents(value, jgen, provider, len); [EOL] verify(jgen).writeString("string1"); [EOL] verify(jgen).writeString("string2"); [EOL] verify(jgen).writeString("string3"); [EOL] }
public void testSerializeContentsWithNullValues() throws IOException { [EOL] List<String> value = Arrays.asList("string1", null, "string3"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] int len = value.size(); [EOL] serializeContents(value, jgen, provider, len); [EOL] verify(jgen).writeString("string1"); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(jgen).writeString("string3"); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] List<String> value = Arrays.asList("string1", "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] int len = value.size(); [EOL] doThrow(new IOException()).when(jgen).writeString(anyString()); [EOL] try { [EOL] serializeContents(value, jgen, provider, len); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(jgen).writeString("string1"); // This should throw the exception [EOL] verify(provider, never()).defaultSerializeNull(jgen); [EOL] }
public void testFileSerializerConstructor() { [EOL] FileSerializer serializer = new FileSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithNonNullFile() throws IOException { [EOL] File value = new File("/path/to/file"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new FileSerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeString(value.getAbsolutePath()); [EOL] }
public void testSerializeWithNullFile() throws IOException { [EOL] File value = null; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] try { [EOL] new FileSerializer().serialize(value, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testClassSerializerConstructor() { [EOL] ClassSerializer classSerializer = new ClassSerializer(); [EOL] assertNotNull(classSerializer); [EOL] }
public void testSerializeWithNonNullClass() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Class<?> clazz = Object.class; [EOL] new CustomSerializer().serialize(clazz, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeString("java.lang.Object"); [EOL] }
public void testSerializeWithPrimitiveClass() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Class<?> clazz = int.class; [EOL] new CustomSerializer().serialize(clazz, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeString("int"); [EOL] }
public void testPathWithIndex() { [EOL] JsonNode node = new TestNode(); [EOL] JsonNode result = node.path(5); [EOL] assertTrue(result instanceof MissingNode); [EOL] }
public void testSetWithNonNullValue() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode valueNode = TextNode.valueOf("value"); [EOL] JsonNode result = node.set("fieldName", valueNode); [EOL] assertSame("The method should return the same ObjectNode", node, result); [EOL] assertTrue("The value should be set in the node", node.get("fieldName").equals(valueNode)); [EOL] }
public void testSetWithNullValue() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode result = node.set("fieldName", null); [EOL] assertSame("The method should return the same ObjectNode", node, result); [EOL] assertTrue("A nullNode should be set in the node", node.get("fieldName").equals(node.nullNode())); [EOL] }
public void testEqualsWithSameObject() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertTrue(objectNode.equals(objectNode)); [EOL] }
public void testEqualsWithNull() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertFalse(objectNode.equals(null)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertFalse(objectNode.equals(new String("Not an ObjectNode"))); [EOL] }
public void testEqualsWithEqualObjectNodes() { [EOL] ObjectNode objectNode1 = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode objectNode2 = new ObjectNode(JsonNodeFactory.instance); [EOL] assertTrue(objectNode1.equals(objectNode2)); [EOL] }
public void testEqualsWithDifferentObjectNodes() { [EOL] ObjectNode objectNode1 = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode objectNode2 = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode2.set("field", new TextNode("value")); [EOL] assertFalse(objectNode1.equals(objectNode2)); [EOL] }
public void testGetFormatName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String formatName = mapper.getFactory().getFormatName(); [EOL] assertEquals("JSON", formatName); [EOL] }
public void testValueConstructorWithValidJsonPOJOBuilder() { [EOL] JsonPOJOBuilder jsonPOJOBuilder = mock(JsonPOJOBuilder.class); [EOL] when(jsonPOJOBuilder.buildMethodName()).thenReturn("build"); [EOL] when(jsonPOJOBuilder.withPrefix()).thenReturn("with"); [EOL] Value value = new Value(jsonPOJOBuilder); [EOL] assertEquals("build", value.buildMethodName); [EOL] assertEquals("with", value.withPrefix); [EOL] }
public void testValueConstructorWithEmptyJsonPOJOBuilder() { [EOL] JsonPOJOBuilder jsonPOJOBuilder = mock(JsonPOJOBuilder.class); [EOL] when(jsonPOJOBuilder.buildMethodName()).thenReturn(""); [EOL] when(jsonPOJOBuilder.withPrefix()).thenReturn(""); [EOL] Value value = new Value(jsonPOJOBuilder); [EOL] assertEquals("", value.buildMethodName); [EOL] assertEquals("", value.withPrefix); [EOL] }
public void testIsInt() { [EOL] JsonNode node = new IntNode(5); [EOL] assertTrue(node.isInt()); [EOL] }
public void testLongValue_Positive() { [EOL] double input = 123.0; [EOL] YourClass instance = new YourClass(input); [EOL] long expected = 123L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Negative() { [EOL] double input = -123.0; [EOL] YourClass instance = new YourClass(input); [EOL] long expected = -123L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Zero() { [EOL] double input = 0.0; [EOL] YourClass instance = new YourClass(input); [EOL] long expected = 0L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MaxLong() { [EOL] double input = (double) Long.MAX_VALUE; [EOL] YourClass instance = new YourClass(input); [EOL] long expected = Long.MAX_VALUE; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MinLong() { [EOL] double input = (double) Long.MIN_VALUE; [EOL] YourClass instance = new YourClass(input); [EOL] long expected = Long.MIN_VALUE; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testDoubleValue_Positive() { [EOL] YourType instance = new YourType(5); // Replace 'YourType' with the actual type that contains the doubleValue method [EOL] double result = instance.doubleValue(); [EOL] assertEquals(5.0, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] YourType instance = new YourType(-5); // Replace 'YourType' with the actual type that contains the doubleValue method [EOL] double result = instance.doubleValue(); [EOL] assertEquals(-5.0, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] YourType instance = new YourType(0); // Replace 'YourType' with the actual type that contains the doubleValue method [EOL] double result = instance.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testEquals_sameObject() { [EOL] IntNode node = new IntNode(5); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] IntNode node = new IntNode(5); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_differentClass() { [EOL] IntNode node = new IntNode(5); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] } [EOL] public void testEquals_differentValue() { [EOL] IntNode node1 = new IntNode(5); [EOL] IntNode node2 = new IntNode(10); [EOL] assertFalse(node1.equals(node2)); [EOL] } [EOL] public void testEquals_sameValue() { [EOL] IntNode node1 = new IntNode(5); [EOL] IntNode node2 = new IntNode(5); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testAddIntCreatorWithNull() { [EOL] BeanDeserializerModifier underTest = new BeanDeserializerModifier(); [EOL] AnnotatedWithParams initialCreator = null; [EOL] underTest.addIntCreator(initialCreator); [EOL] }
public void testAddIntCreatorWithNonNull() { [EOL] BeanDeserializerModifier underTest = new BeanDeserializerModifier(); [EOL] AnnotatedWithParams newCreator = new AnnotatedParameter(); // Assuming AnnotatedParameter is a valid implementation of AnnotatedWithParams [EOL] underTest.addIntCreator(newCreator); [EOL] }
public void testAddIntCreatorWithDuplicate() { [EOL] BeanDeserializerModifier underTest = new BeanDeserializerModifier(); [EOL] AnnotatedWithParams firstCreator = new AnnotatedParameter(); // Assuming AnnotatedParameter is a valid implementation of AnnotatedWithParams [EOL] AnnotatedWithParams secondCreator = new AnnotatedParameter(); // Assuming AnnotatedParameter is a valid implementation of AnnotatedWithParams [EOL] underTest.addIntCreator(firstCreator); [EOL] try { [EOL] underTest.addIntCreator(secondCreator); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTypeWrappedSerializerWithNonNullTypeSerializerAndSerializer() { [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeWrappedSerializer tws = new TypeWrappedSerializer(typeSer, ser); [EOL] assertNotNull(tws); [EOL] assertSame(typeSer, tws._typeSerializer); [EOL] assertSame(ser, tws._serializer); [EOL] }
public void testTypeWrappedSerializerWithNullTypeSerializer() { [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] try { [EOL] new TypeWrappedSerializer(null, ser); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testTypeWrappedSerializerWithNullSerializer() { [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] try { [EOL] new TypeWrappedSerializer(typeSer, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSerializeWithNonNullValue() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(_serializer, typeSerializer); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(_serializer).serializeWithType(value, jgen, provider, typeSerializer); [EOL] }
public void testSerializeWithNullValue() throws IOException, JsonProcessingException { [EOL] Object value = null; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] StdDelegatingSerializer serializer = new StdDelegatingSerializer(_serializer, typeSerializer); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(_serializer, never()).serializeWithType(value, jgen, provider, typeSerializer); [EOL] }
public void testDataFormatReadersWithNullDetectors() { [EOL] ObjectReader[] detectors = null; [EOL] try { [EOL] new DataFormatReaders(detectors); [EOL] fail("Expected IllegalArgumentException for null detectors"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDataFormatReadersWithEmptyDetectors() { [EOL] ObjectReader[] detectors = new ObjectReader[0]; [EOL] DataFormatReaders dataFormatReaders = new DataFormatReaders(detectors); [EOL] assertNotNull(dataFormatReaders); [EOL] assertEquals(0, dataFormatReaders.getDetectors().length); [EOL] }
public void testDataFormatReadersWithSingleDetector() { [EOL] ObjectReader detector = mock(ObjectReader.class); [EOL] ObjectReader[] detectors = new ObjectReader[]{detector}; [EOL] DataFormatReaders dataFormatReaders = new DataFormatReaders(detectors); [EOL] assertNotNull(dataFormatReaders); [EOL] assertEquals(1, dataFormatReaders.getDetectors().length); [EOL] assertSame(detector, dataFormatReaders.getDetectors()[0]); [EOL] }
public void testDataFormatReadersWithMultipleDetectors() { [EOL] ObjectReader detector1 = mock(ObjectReader.class); [EOL] ObjectReader detector2 = mock(ObjectReader.class); [EOL] ObjectReader[] detectors = new ObjectReader[]{detector1, detector2}; [EOL] DataFormatReaders dataFormatReaders = new DataFormatReaders(detectors); [EOL] assertNotNull(dataFormatReaders); [EOL] assertEquals(2, dataFormatReaders.getDetectors().length); [EOL] assertSame(detector1, dataFormatReaders.getDetectors()[0]); [EOL] assertSame(detector2, dataFormatReaders.getDetectors()[1]); [EOL] }
public void testDataFormatReadersConstructor() { [EOL] ObjectReader[] detectors = new ObjectReader[] { mock(ObjectReader.class) }; [EOL] MatchStrength optMatch = MatchStrength.SOLID_MATCH; [EOL] MatchStrength minMatch = MatchStrength.WEAK_MATCH; [EOL] int maxInputLookahead = 1024; [EOL] DataFormatReaders dataFormatReaders = new DataFormatReaders(detectors, optMatch, minMatch, maxInputLookahead); [EOL] assertNotNull(dataFormatReaders); [EOL] assertArrayEquals(detectors, dataFormatReaders._readers); [EOL] assertEquals(optMatch, dataFormatReaders._optimalMatch); [EOL] assertEquals(minMatch, dataFormatReaders._minimalMatch); [EOL] assertEquals(maxInputLookahead, dataFormatReaders._maxInputLookahead); [EOL] }
public void testFindFormatWithValidInput() throws IOException { [EOL] byte[] fullInputData = new byte[] { /* some valid data that would lead to a successful match */ }; [EOL] int offset = 0; [EOL] int len = fullInputData.length; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Match result = mapper.findFormat(fullInputData, offset, len); [EOL] assertNotNull(result); [EOL] }
public void testFindFormatWithOffset() throws IOException { [EOL] byte[] fullInputData = new byte[] { /* data that requires an offset to find a match */ }; [EOL] int offset = /* appropriate non-zero offset */; [EOL] int len = fullInputData.length - offset; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Match result = mapper.findFormat(fullInputData, offset, len); [EOL] assertNotNull(result); [EOL] }
public void testFindFormatWithInvalidInput() throws IOException { [EOL] byte[] fullInputData = new byte[] { /* invalid data that would not lead to a match */ }; [EOL] int offset = 0; [EOL] int len = fullInputData.length; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.findFormat(fullInputData, offset, len); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testToStringEmptyReadersArray() { [EOL] Reader[] readers = new Reader[0]; [EOL] MyClass instance = new MyClass(readers); [EOL] String result = instance.toString(); [EOL] assertEquals("[]", result); [EOL] }
public void testToStringSingleReader() { [EOL] Reader[] readers = new Reader[] {new Reader("JSON")}; // Assuming Reader class has a constructor accepting format name [EOL] MyClass instance = new MyClass(readers); [EOL] String result = instance.toString(); [EOL] assertEquals("[JSON]", result); [EOL] }
public void testToStringMultipleReaders() { [EOL] Reader[] readers = new Reader[] {new Reader("JSON"), new Reader("XML")}; // Assuming Reader class has a constructor accepting format name [EOL] MyClass instance = new MyClass(readers); [EOL] String result = instance.toString(); [EOL] assertEquals("[JSON, XML]", result); [EOL] }
public void testFindFormatWithNoReaders() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] MatchStrength minimalMatch = MatchStrength.WEAK_MATCH; [EOL] MatchStrength optimalMatch = MatchStrength.FULL_MATCH; [EOL] List<ObjectReader> readers = Collections.emptyList(); [EOL] JacksonDatabind databind = new JacksonDatabind(readers, minimalMatch, optimalMatch); [EOL] Match result = databind._findFormat(acc); [EOL] assertNull(result.getBestMatch()); [EOL] assertNull(result.getBestMatchStrength()); [EOL] }
public void testFindFormatWithOneReaderNoMatch() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] MatchStrength minimalMatch = MatchStrength.SOLID_MATCH; [EOL] MatchStrength optimalMatch = MatchStrength.FULL_MATCH; [EOL] ObjectReader reader = mock(ObjectReader.class); [EOL] ObjectFactory factory = mock(ObjectFactory.class); [EOL] when(reader.getFactory()).thenReturn(factory); [EOL] when(factory.hasFormat(acc)).thenReturn(null); [EOL] List<ObjectReader> readers = Collections.singletonList(reader); [EOL] JacksonDatabind databind = new JacksonDatabind(readers, minimalMatch, optimalMatch); [EOL] Match result = databind._findFormat(acc); [EOL] assertNull(result.getBestMatch()); [EOL] assertNull(result.getBestMatchStrength()); [EOL] }
public void testFindFormatWithMultipleReadersAndOneMatch() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] MatchStrength minimalMatch = MatchStrength.WEAK_MATCH; [EOL] MatchStrength optimalMatch = MatchStrength.FULL_MATCH; [EOL] ObjectReader matchingReader = mock(ObjectReader.class); [EOL] ObjectReader nonMatchingReader = mock(ObjectReader.class); [EOL] ObjectFactory matchingFactory = mock(ObjectFactory.class); [EOL] ObjectFactory nonMatchingFactory = mock(ObjectFactory.class); [EOL] when(matchingReader.getFactory()).thenReturn(matchingFactory); [EOL] when(nonMatchingReader.getFactory()).thenReturn(nonMatchingFactory); [EOL] when(matchingFactory.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] when(nonMatchingFactory.hasFormat(acc)).thenReturn(null); [EOL] List<ObjectReader> readers = Arrays.asList(nonMatchingReader, matchingReader); [EOL] JacksonDatabind databind = new JacksonDatabind(readers, minimalMatch, optimalMatch); [EOL] Match result = databind._findFormat(acc); [EOL] assertEquals(matchingReader, result.getBestMatch()); [EOL] assertEquals(MatchStrength.SOLID_MATCH, result.getBestMatchStrength()); [EOL] }
public void testFindFormatWithMultipleReadersAndMultipleMatches() throws IOException { [EOL] AccessorForReader acc = mock(AccessorForReader.class); [EOL] MatchStrength minimalMatch = MatchStrength.WEAK_MATCH; [EOL] MatchStrength optimalMatch = MatchStrength.FULL_MATCH; [EOL] ObjectReader bestMatchingReader = mock(ObjectReader.class); [EOL] ObjectReader goodMatchingReader = mock(ObjectReader.class); [EOL] ObjectFactory bestMatchingFactory = mock(ObjectFactory.class); [EOL] ObjectFactory goodMatchingFactory = mock(ObjectFactory.class); [EOL] when(bestMatchingReader.getFactory()).thenReturn(bestMatchingFactory); [EOL] when(goodMatchingReader.getFactory()).thenReturn(goodMatchingFactory); [EOL] when(bestMatchingFactory.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] when(goodMatchingFactory.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] List<ObjectReader> readers = Arrays.asList(goodMatchingReader, bestMatchingReader); [EOL] JacksonDatabind databind = new JacksonDatabind(readers, minimalMatch, optimalMatch); [EOL] Match result = databind._findFormat(acc); [EOL] assertEquals(bestMatchingReader, result.getBestMatch()); [EOL] assertEquals(MatchStrength.FULL_MATCH, result.getBestMatchStrength()); [EOL] }
public void testAccessorForReaderWithValidInput() { [EOL] byte[] inputDocument = new byte[]{1, 2, 3, 4, 5}; [EOL] int start = 1; [EOL] int len = 3; [EOL] AccessorForReader accessor = new AccessorForReader(inputDocument, start, len); [EOL] assertNotNull(accessor); [EOL] }
public void testAccessorForReaderWithFullLength() { [EOL] byte[] inputDocument = new byte[]{1, 2, 3, 4, 5}; [EOL] int start = 0; [EOL] int len = inputDocument.length; [EOL] AccessorForReader accessor = new AccessorForReader(inputDocument, start, len); [EOL] assertNotNull(accessor); [EOL] }
public void testAccessorForReaderWithStartOutOfBounds() { [EOL] byte[] inputDocument = new byte[]{1, 2, 3, 4, 5}; [EOL] int start = -1; [EOL] int len = 3; [EOL] try { [EOL] AccessorForReader accessor = new AccessorForReader(inputDocument, start, len); [EOL] fail("Should have thrown an exception due to start being out of bounds"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAccessorForReaderWithLengthOutOfBounds() { [EOL] byte[] inputDocument = new byte[]{1, 2, 3, 4, 5}; [EOL] int start = 1; [EOL] int len = 10; [EOL] try { [EOL] AccessorForReader accessor = new AccessorForReader(inputDocument, start, len); [EOL] fail("Should have thrown an exception due to length being out of bounds"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAccessorForReaderWithNegativeLength() { [EOL] byte[] inputDocument = new byte[]{1, 2, 3, 4, 5}; [EOL] int start = 1; [EOL] int len = -1; [EOL] try { [EOL] AccessorForReader accessor = new AccessorForReader(inputDocument, start, len); [EOL] fail("Should have thrown an exception due to negative length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateMatcherWithNonNullValues() { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] byte[] buffer = new byte[10]; [EOL] int bufferedStart = 0; [EOL] int bufferedEnd = 10; [EOL] ObjectReader match = new ObjectReader(); // Assuming ObjectReader is a valid class [EOL] MatchStrength matchStrength = MatchStrength.SOLID_MATCH; // Assuming MatchStrength is an enum [EOL] YourClass instance = new YourClass(in, buffer, bufferedStart, bufferedEnd); // Replace YourClass with the actual class name [EOL] Match result = instance.createMatcher(match, matchStrength); [EOL] assertNotNull(result); [EOL] assertEquals(in, result.getSourceRef()); [EOL] assertArrayEquals(buffer, result.getBuffer()); [EOL] assertEquals(bufferedStart, result.getBufferedStart()); [EOL] assertEquals(bufferedEnd - bufferedStart, result.getBufferedLength()); [EOL] assertEquals(match, result.getMatch()); [EOL] assertEquals(matchStrength, result.getMatchStrength()); [EOL] }
public void testCreateMatcherWithNullValues() { [EOL] InputStream in = null; [EOL] byte[] buffer = null; [EOL] int bufferedStart = 0; [EOL] int bufferedEnd = 0; [EOL] ObjectReader match = null; [EOL] MatchStrength matchStrength = null; [EOL] YourClass instance = new YourClass(in, buffer, bufferedStart, bufferedEnd); // Replace YourClass with the actual class name [EOL] Match result = instance.createMatcher(match, matchStrength); [EOL] assertNotNull(result); [EOL] assertNull(result.getSourceRef()); [EOL] assertNull(result.getBuffer()); [EOL] assertEquals(bufferedStart, result.getBufferedStart()); [EOL] assertEquals(bufferedEnd - bufferedStart, result.getBufferedLength()); [EOL] assertNull(result.getMatch()); [EOL] assertNull(result.getMatchStrength()); [EOL] }
public void testMatchConstructor() { [EOL] InputStream dummyInputStream = new ByteArrayInputStream(new byte[0]); [EOL] byte[] dummyBuffered = new byte[10]; [EOL] int dummyBufferedStart = 0; [EOL] int dummyBufferedLength = dummyBuffered.length; [EOL] ObjectReader dummyMatch = mock(ObjectReader.class); [EOL] MatchStrength dummyStrength = MatchStrength.WEAK; [EOL] Match match = new Match(dummyInputStream, dummyBuffered, dummyBufferedStart, dummyBufferedLength, dummyMatch, dummyStrength); [EOL] assertNotNull(match); [EOL] assertEquals(dummyInputStream, match._originalStream); [EOL] assertEquals(dummyBuffered, match._bufferedData); [EOL] assertEquals(dummyBufferedStart, match._bufferedStart); [EOL] assertEquals(dummyBufferedLength, match._bufferedLength); [EOL] assertEquals(dummyMatch, match._match); [EOL] assertEquals(dummyStrength, match._matchStrength); [EOL] }
public void testHasMatchWhenMatchIsNull() { [EOL] JsonPointer pointer = new JsonPointer(""); [EOL] assertFalse(pointer.hasMatch()); [EOL] }
public void testHasMatchWhenMatchIsNotNull() { [EOL] JsonPointer pointer = new JsonPointer("/match"); [EOL] assertTrue(pointer.hasMatch()); [EOL] }
public void testAddOrOverrideParam_NewAnnotationMap() { [EOL] AnnotationMap[] paramAnnotations = new AnnotationMap[1]; [EOL] AnnotatedMethod underTest = new AnnotatedMethod(null, null, null, paramAnnotations); [EOL] Annotation a = new SomeAnnotationImpl(); [EOL] underTest.addOrOverrideParam(0, a); [EOL] assertNotNull(paramAnnotations[0]); [EOL] assertTrue(paramAnnotations[0].has(a)); [EOL] }
public void testAddOrOverrideParam_ExistingAnnotationMap() { [EOL] AnnotationMap[] paramAnnotations = new AnnotationMap[1]; [EOL] paramAnnotations[0] = new AnnotationMap(); [EOL] AnnotatedMethod underTest = new AnnotatedMethod(null, null, null, paramAnnotations); [EOL] Annotation a = new SomeAnnotationImpl(); [EOL] underTest.addOrOverrideParam(0, a); [EOL] assertNotNull(paramAnnotations[0]); [EOL] assertTrue(paramAnnotations[0].has(a)); [EOL] }
public void testRemoveProperty_ExistingProperty() { [EOL] BeanPropertyDefinition existingProp = BeanPropertyDefinition.construct(...); // Provide necessary arguments [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(existingProp); [EOL] _properties = properties; [EOL] boolean result = removeProperty("existingProp"); [EOL] assertFalse(_properties.contains(existingProp)); [EOL] assertTrue(result); [EOL] }
public void testRemoveProperty_NonExistingProperty() { [EOL] BeanPropertyDefinition someProp = BeanPropertyDefinition.construct(...); // Provide necessary arguments [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(someProp); [EOL] _properties = properties; [EOL] boolean result = removeProperty("nonExistingProp"); [EOL] assertTrue(_properties.contains(someProp)); [EOL] assertFalse(result); [EOL] }
public void testHasKnownClassAnnotations_WhenClassHasAnnotations_ShouldReturnTrue() { [EOL] AnnotatedClass ac = new AnnotatedClass(AnnotatedClassWithAnnotations.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] JacksonAnnotationIntrospector jacksonIntrospector = (JacksonAnnotationIntrospector) introspector; [EOL] AnnotatedClassInfo classInfo = AnnotatedClassInfo.construct(ac, jacksonIntrospector, null); [EOL] boolean result = classInfo.hasKnownClassAnnotations(); [EOL] assertTrue(result); [EOL] }
public void testHasKnownClassAnnotations_WhenClassHasNoAnnotations_ShouldReturnFalse() { [EOL] AnnotatedClass ac = new AnnotatedClass(AnnotatedClassWithoutAnnotations.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] JacksonAnnotationIntrospector jacksonIntrospector = (JacksonAnnotationIntrospector) introspector; [EOL] AnnotatedClassInfo classInfo = AnnotatedClassInfo.construct(ac, jacksonIntrospector, null); [EOL] boolean result = classInfo.hasKnownClassAnnotations(); [EOL] assertFalse(result); [EOL] }
public void testFindBackReferenceProperties_NoBackReferences() { [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.getMutator()).thenReturn(null); [EOL] List<BeanPropertyDefinition> properties = Collections.singletonList(property); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(any(AnnotatedMember.class))).thenReturn(null); [EOL] Map<String, AnnotatedMember> result = new BeanDeserializerBuilder(null, null) [EOL] .findBackReferenceProperties(); [EOL] assertNull(result); [EOL] }
public void testFindBackReferenceProperties_WithBackReferences() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.getMutator()).thenReturn(annotatedMember); [EOL] List<BeanPropertyDefinition> properties = Collections.singletonList(property); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] when(refProperty.getName()).thenReturn("backRef"); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember)).thenReturn(refProperty); [EOL] Map<String, AnnotatedMember> result = new BeanDeserializerBuilder(properties, annotationIntrospector) [EOL] .findBackReferenceProperties(); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsKey("backRef")); [EOL] assertEquals(annotatedMember, result.get("backRef")); [EOL] }
public void testFindBackReferenceProperties_MultipleBackReferencesSameName() { [EOL] AnnotatedMember annotatedMember1 = mock(AnnotatedMember.class); [EOL] AnnotatedMember annotatedMember2 = mock(AnnotatedMember.class); [EOL] BeanPropertyDefinition property1 = mock(BeanPropertyDefinition.class); [EOL] BeanPropertyDefinition property2 = mock(BeanPropertyDefinition.class); [EOL] when(property1.getMutator()).thenReturn(annotatedMember1); [EOL] when(property2.getMutator()).thenReturn(annotatedMember2); [EOL] List<BeanPropertyDefinition> properties = Arrays.asList(property1, property2); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] when(refProperty.getName()).thenReturn("backRef"); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember1)).thenReturn(refProperty); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember2)).thenReturn(refProperty); [EOL] try { [EOL] new BeanDeserializerBuilder(properties, annotationIntrospector) [EOL] .findBackReferenceProperties(); [EOL] fail("Expected IllegalArgumentException due to multiple back-reference properties with the same name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Multiple back-reference properties with name 'backRef'", e.getMessage()); [EOL] } [EOL] }
public void testFindSingleArgConstructor_MatchFound() { [EOL] AnnotatedConstructor ac = createAnnotatedConstructor(String.class); [EOL] ClassInfo classInfo = createClassInfoWithConstructors(ac); [EOL] ConstructorDetector detector = new ConstructorDetector(classInfo); [EOL] Constructor<?> result = detector.findSingleArgConstructor(String.class); [EOL] assertNotNull(result); [EOL] assertEquals(ac.getAnnotated(), result); [EOL] }
public void testFindSingleArgConstructor_NoMatchFound() { [EOL] AnnotatedConstructor ac = createAnnotatedConstructor(String.class); [EOL] ClassInfo classInfo = createClassInfoWithConstructors(ac); [EOL] ConstructorDetector detector = new ConstructorDetector(classInfo); [EOL] Constructor<?> result = detector.findSingleArgConstructor(Integer.class); [EOL] assertNull(result); [EOL] }
public void testFindSingleArgConstructor_NoSingleArgConstructors() { [EOL] ClassInfo classInfo = createClassInfoWithNoSingleArgConstructors(); [EOL] ConstructorDetector detector = new ConstructorDetector(classInfo); [EOL] Constructor<?> result = detector.findSingleArgConstructor(String.class); [EOL] assertNull(result); [EOL] }
public void testFindFactoryMethodWithMatchingType() { [EOL] Class<?>[] expArgTypes = new Class<?>[]{String.class}; [EOL] Method result = findFactoryMethod(expArgTypes); [EOL] assertNotNull(result); [EOL] assertEquals("Expected factory method not found", "createInstance", result.getName()); [EOL] }
public void testFindFactoryMethodWithNonMatchingType() { [EOL] Class<?>[] expArgTypes = new Class<?>[]{Integer.class}; [EOL] Method result = findFactoryMethod(expArgTypes); [EOL] assertNull("Factory method found with non-matching argument type", result); [EOL] }
public void testFindFactoryMethodWithNoStaticMethods() { [EOL] Class<?>[] expArgTypes = new Class<?>[]{String.class}; [EOL] Method result = findFactoryMethod(expArgTypes); [EOL] assertNull("Factory method found in class with no static methods", result); [EOL] }
public void testCreateFromObjectWithNullWithArgsCreator() { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(null); [EOL] try { [EOL] instantiator.createFromObjectWith(null, new Object[]{}); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No with-args constructor for " + instantiator.getValueTypeDesc(), e.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Expected an IllegalStateException, but got a different exception"); [EOL] } [EOL] }
public void testCreateFromObjectWithValidArgs() throws Exception { [EOL] Object[] args = new Object[]{"arg1", "arg2"}; [EOL] WithArgsCreator withArgsCreator = mock(WithArgsCreator.class); [EOL] when(withArgsCreator.call(args)).thenReturn(new Object()); [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(withArgsCreator); [EOL] Object result = instantiator.createFromObjectWith(null, args); [EOL] assertNotNull(result); [EOL] }
public void testCreateFromObjectWithExceptionInInitializerError() { [EOL] Object[] args = new Object[]{"arg1", "arg2"}; [EOL] WithArgsCreator withArgsCreator = mock(WithArgsCreator.class); [EOL] when(withArgsCreator.call(args)).thenThrow(new ExceptionInInitializerError()); [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(withArgsCreator); [EOL] try { [EOL] instantiator.createFromObjectWith(null, args); [EOL] fail("Expected a JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected a JsonProcessingException, but got a different exception"); [EOL] } [EOL] }
public void testCreateFromObjectWithGenericException() { [EOL] Object[] args = new Object[]{"arg1", "arg2"}; [EOL] WithArgsCreator withArgsCreator = mock(WithArgsCreator.class); [EOL] when(withArgsCreator.call(args)).thenThrow(new Exception()); [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(withArgsCreator); [EOL] try { [EOL] instantiator.createFromObjectWith(null, args); [EOL] fail("Expected a JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected a JsonProcessingException, but got a different exception"); [EOL] } [EOL] }
public void testCreateFromStringWithFromStringCreator() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "testValue"; [EOL] FromStringCreator mockFromStringCreator = mock(FromStringCreator.class); [EOL] when(mockFromStringCreator.call1(value)).thenReturn(value); [EOL] setFromStringCreator(mockFromStringCreator); [EOL] Object result = createFromString(ctxt, value); [EOL] assertEquals("The result should be the same as the test value", value, result); [EOL] }
public void testCreateFromStringWithException() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "testValue"; [EOL] FromStringCreator mockFromStringCreator = mock(FromStringCreator.class); [EOL] when(mockFromStringCreator.call1(value)).thenThrow(new Exception()); [EOL] setFromStringCreator(mockFromStringCreator); [EOL] try { [EOL] createFromString(ctxt, value); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertNotNull("The exception should be wrapped", e.getCause()); [EOL] } [EOL] }
public void testCreateFromStringWithExceptionInInitializerError() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "testValue"; [EOL] FromStringCreator mockFromStringCreator = mock(FromStringCreator.class); [EOL] when(mockFromStringCreator.call1(value)).thenThrow(new ExceptionInInitializerError()); [EOL] setFromStringCreator(mockFromStringCreator); [EOL] try { [EOL] createFromString(ctxt, value); [EOL] fail("Expected an ExceptionInInitializerError to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertNotNull("The exception should be wrapped", e.getCause()); [EOL] } [EOL] }
public void testCreateFromStringFallback() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "testValue"; [EOL] setFromStringCreator(null); [EOL] when(_createFromStringFallbacks(ctxt, value)).thenReturn(value); [EOL] Object result = createFromString(ctxt, value); [EOL] assertEquals("The result should be the same as the test value", value, result); [EOL] }
public void testWrapExceptionWithJsonMappingException() { [EOL] Throwable jsonMappingException = new JsonMappingException("Test message"); [EOL] JsonMappingException result = wrapException(jsonMappingException); [EOL] assertEquals("Test message", result.getMessage()); [EOL] }
public void testWrapExceptionWithOtherException() { [EOL] Throwable otherException = new Exception("Test message", new RuntimeException("Cause")); [EOL] JsonMappingException result = wrapException(otherException); [EOL] assertEquals("Instantiation of value failed: Cause", result.getMessage()); [EOL] }
public void testWrapExceptionWithNestedJsonMappingException() { [EOL] Throwable nestedException = new Exception("Root cause", new JsonMappingException("Nested message")); [EOL] JsonMappingException result = wrapException(nestedException); [EOL] assertTrue(result instanceof JsonMappingException); [EOL] assertEquals("Nested message", result.getMessage()); [EOL] }
public void testFindStandardImplWithExistingClass() { [EOL] Class<?> cls = String[].class; // Assuming String array serializer is a standard implementation [EOL] JsonSerializer<?> serializer = StdSerializer.findStandardImpl(cls); [EOL] assertNotNull(serializer); [EOL] }
public void testFindStandardImplWithNonExistingClass() { [EOL] Class<?> cls = Object.class; // Assuming Object serializer is not a standard implementation [EOL] JsonSerializer<?> serializer = StdSerializer.findStandardImpl(cls); [EOL] assertNull(serializer); [EOL] }
protected TypedPrimitiveArraySerializer(Class<T> cls) { [EOL] super(cls); [EOL] _valueTypeSerializer = null; [EOL] }
public void testBooleanArraySerializerConstructor() { [EOL] BooleanArraySerializer serializer = new BooleanArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testByteArraySerializerConstructor() { [EOL] ByteArraySerializer serializer = new ByteArraySerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(byte[].class, serializer.handledType()); [EOL] }
public void testSerializeWithValidInput() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] Base64Variant mockBase64Variant = mock(Base64Variant.class); [EOL] when(mockProvider.getConfig()).thenReturn(mockConfig); [EOL] when(mockConfig.getBase64Variant()).thenReturn(mockBase64Variant); [EOL] byte[] value = new byte[] { 1, 2, 3, 4 }; [EOL] new TestClass().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBinary(mockBase64Variant, value, 0, value.length); [EOL] }
public void testShortArraySerializerConstructor() { [EOL] ShortArraySerializer serializer = new ShortArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testCharArraySerializerConstructor() { [EOL] CharArraySerializer serializer = new CharArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testIntArraySerializerConstructor() { [EOL] IntArraySerializer serializer = new IntArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testLongArraySerializerConstructor() { [EOL] LongArraySerializer serializer = new LongArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testFloatArraySerializerConstructor() { [EOL] FloatArraySerializer serializer = new FloatArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeContentsWithValueTypeSerializer() throws IOException { [EOL] float[] value = new float[]{1.0f, 2.0f, 3.0f}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ValueTypeSerializer valueTypeSerializer = mock(ValueTypeSerializer.class); [EOL] FloatArraySerializer serializer = new FloatArraySerializer(); [EOL] serializer._valueTypeSerializer = valueTypeSerializer; [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(valueTypeSerializer, times(value.length)).writeTypePrefixForScalar(null, jgen, Float.TYPE); [EOL] verify(jgen, times(value.length)).writeNumber(anyFloat()); [EOL] verify(valueTypeSerializer, times(value.length)).writeTypeSuffixForScalar(null, jgen); [EOL] }
public void testSerializeContentsWithoutValueTypeSerializer() throws IOException { [EOL] float[] value = new float[]{1.0f, 2.0f, 3.0f}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] FloatArraySerializer serializer = new FloatArraySerializer(); [EOL] serializer._valueTypeSerializer = null; [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(jgen, times(value.length)).writeNumber(anyFloat()); [EOL] }
public void testDoubleArraySerializerConstructor() { [EOL] DoubleArraySerializer serializer = new DoubleArraySerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testNarrowContentsBy_SameContentClass() { [EOL] MapType original = createMapTypeInstance(SomeClass.class, String.class, Integer.class); [EOL] JavaType result = original.narrowContentsBy(Integer.class); [EOL] assertSame("Narrowing with same content class should return the same MapType instance", original, result); [EOL] }
public void testNarrowContentsBy_DifferentContentClass() { [EOL] MapType original = createMapTypeInstance(SomeClass.class, String.class, Integer.class); [EOL] JavaType result = original.narrowContentsBy(Double.class); [EOL] assertNotSame("Narrowing with different content class should not return the same MapType instance", original, result); [EOL] assertTrue("Result should be an instance of MapType", result instanceof MapType); [EOL] MapType resultMapType = (MapType) result; [EOL] assertEquals("Content class should be narrowed to Double", Double.class, resultMapType.getContentType().getRawClass()); [EOL] }
public void testNarrowKeyWithSameClass() { [EOL] Class<?> originalKeyClass = String.class; [EOL] JavaType originalKeyType = ...; // Initialize with a JavaType that has String.class as its raw class [EOL] JavaType originalValueType = ...; // Initialize with some JavaType [EOL] MapType mapType = new MapType(Map.class, originalKeyType, originalValueType, null, null, false); [EOL] JavaType result = mapType.narrowKey(originalKeyClass); [EOL] assertSame("The result should be the same as the original MapType", mapType, result); [EOL] }
public void testNarrowKeyWithDifferentClass() { [EOL] Class<?> originalKeyClass = String.class; [EOL] Class<?> newKeySubclass = StringBuilder.class; [EOL] JavaType originalKeyType = ...; // Initialize with a JavaType that has String.class as its raw class [EOL] JavaType originalValueType = ...; // Initialize with some JavaType [EOL] MapType mapType = new MapType(Map.class, originalKeyType, originalValueType, null, null, false); [EOL] JavaType result = mapType.narrowKey(newKeySubclass); [EOL] assertNotSame("The result should not be the same as the original MapType", mapType, result); [EOL] assertEquals("The raw class of the key type should be the new subclass", newKeySubclass, result.getKeyType().getRawClass()); [EOL] }
public void testRenameWithNoChange() { [EOL] BeanPropertyWriter originalWriter = createBeanPropertyWriter("originalName"); [EOL] NameTransformer transformer = NameTransformer.NOP; [EOL] BeanPropertyWriter resultWriter = originalWriter.rename(transformer); [EOL] assertSame("Expected same BeanPropertyWriter instance when name is unchanged", originalWriter, resultWriter); [EOL] } [EOL] public void testRenameWithChange() { [EOL] BeanPropertyWriter originalWriter = createBeanPropertyWriter("originalName"); [EOL] NameTransformer transformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformedName"; [EOL] } [EOL] }; [EOL] BeanPropertyWriter resultWriter = originalWriter.rename(transformer); [EOL] assertNotSame("Expected different BeanPropertyWriter instance when name is changed", originalWriter, resultWriter); [EOL] assertEquals("Expected transformed name", "transformedName", resultWriter.getName().getValue()); [EOL] }
public void testSetNonTrivialBaseType() { [EOL] TargetClass instance = new TargetClass(); [EOL] JavaType javaType = new JavaType(); // Assuming JavaType is a valid type for the argument [EOL] instance.setNonTrivialBaseType(javaType); [EOL] assertEquals(javaType, instance.getNonTrivialBaseType()); // Assuming there's a getter to verify the set operation [EOL] }
public void testGetContextAnnotationWithExistingClass() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] Class<Override> annotationClass = Override.class; [EOL] Override expectedAnnotation = mock(Override.class); [EOL] collector._contextAnnotations.put(annotationClass, expectedAnnotation); [EOL] Override actualAnnotation = collector.getContextAnnotation(annotationClass); [EOL] assertSame("The retrieved annotation should be the one that was put in the map.", expectedAnnotation, actualAnnotation); [EOL] }
public void testGetContextAnnotationWithNonExistingClass() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] Class<Deprecated> annotationClass = Deprecated.class; [EOL] Deprecated actualAnnotation = collector.getContextAnnotation(annotationClass); [EOL] assertNull("The retrieved annotation should be null as it was not put in the map.", actualAnnotation); [EOL] }
public void testSerializeAsFieldWithNonNullValueAndSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] PropertySerializerMap map = mock(PropertySerializerMap.class); [EOL] when(map.serializerFor(any(Class.class))).thenReturn(ser); [EOL] MySerializer mySerializer = new MySerializer(bean, jgen, prov, ser, map, null, null, null, null); [EOL] mySerializer.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(ser).serialize(any(), eq(jgen), eq(prov)); [EOL] }
public void testSerializeAsFieldWithNullValueAndNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] MySerializer mySerializer = new MySerializer(bean, jgen, prov, null, null, null, null, null, null); [EOL] mySerializer.serializeAsField(bean, jgen, prov); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(jgen, never()).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] }
public void testSerializeAsFieldWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] Object suppressableValue = new Object(); [EOL] MySerializer mySerializer = new MySerializer(bean, jgen, prov, ser, null, suppressableValue, null, null, null); [EOL] mySerializer.serializeAsField(suppressableValue, jgen, prov); [EOL] verify(ser, never()).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] }
public void testSerializeAsFieldWithSelfReference() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] MySerializer mySerializer = new MySerializer(bean, jgen, prov, ser, null, null, null, null, null); [EOL] mySerializer.serializeAsField(bean, jgen, prov); [EOL] verify(mySerializer)._handleSelfReference(bean, ser); [EOL] }
public void testSerializeAsPlaceholderWithNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> nullSerializer = mock(JsonSerializer.class); [EOL] PlaceholderSerializer serializer = new PlaceholderSerializer(nullSerializer); [EOL] serializer.serializeAsPlaceholder(bean, jgen, prov); [EOL] verify(nullSerializer).serialize(null, jgen, prov); [EOL] }
public void testSerializeAsPlaceholderWithoutNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] PlaceholderSerializer serializer = new PlaceholderSerializer(null); [EOL] serializer.serializeAsPlaceholder(bean, jgen, prov); [EOL] verify(jgen).writeNull(); [EOL] }
public void testFindAndAddDynamicWithNonTrivialBaseType() throws JsonMappingException { [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBaseSettings())); [EOL] JavaType nonTrivialBaseType = provider.constructType(Object.class); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer._nonTrivialBaseType = nonTrivialBaseType; [EOL] JsonSerializer<Object> serializer = writer._findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertNotSame(map, writer._dynamicSerializers); [EOL] }
public void testFindAndAddDynamicWithoutNonTrivialBaseType() throws JsonMappingException { [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBaseSettings())); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] JsonSerializer<Object> serializer = writer._findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertSame(map, writer._dynamicSerializers); [EOL] }
public void testHandleSelfReferenceWithSerializerUsingObjectId() { [EOL] Object bean = new Object(); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(ser.usesObjectId()).thenReturn(true); [EOL] _handleSelfReference(bean, ser); [EOL] }
public void testHandleSelfReferenceWithSerializerNotUsingObjectId() { [EOL] Object bean = new Object(); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(ser.usesObjectId()).thenReturn(false); [EOL] try { [EOL] _handleSelfReference(bean, ser); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Direct self-reference leading to cycle", e.getMessage()); [EOL] } [EOL] }
public void testWithDeserializerSameDeserializers() { [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<Object> jsonDeserializer = mock(JsonDeserializer.class); [EOL] JavaType arrayType = mock(JavaType.class); [EOL] ObjectArrayDeserializer original = new ObjectArrayDeserializer(arrayType, jsonDeserializer, typeDeserializer); [EOL] ObjectArrayDeserializer result = original.withDeserializer(typeDeserializer, jsonDeserializer); [EOL] assertSame(original, result); [EOL] }
public void testWithDeserializerDifferentElementDeserializer() { [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<Object> jsonDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<Object> newJsonDeserializer = mock(JsonDeserializer.class); [EOL] JavaType arrayType = mock(JavaType.class); [EOL] ObjectArrayDeserializer original = new ObjectArrayDeserializer(arrayType, jsonDeserializer, typeDeserializer); [EOL] ObjectArrayDeserializer result = original.withDeserializer(typeDeserializer, newJsonDeserializer); [EOL] assertNotSame(original, result); [EOL] assertSame(newJsonDeserializer, result.elementDeserializer()); [EOL] }
public void testWithDeserializerDifferentTypeDeserializer() { [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] TypeDeserializer newTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<Object> jsonDeserializer = mock(JsonDeserializer.class); [EOL] JavaType arrayType = mock(JavaType.class); [EOL] ObjectArrayDeserializer original = new ObjectArrayDeserializer(arrayType, jsonDeserializer, typeDeserializer); [EOL] ObjectArrayDeserializer result = original.withDeserializer(newTypeDeserializer, jsonDeserializer); [EOL] assertNotSame(original, result); [EOL] assertSame(newTypeDeserializer, result.elementTypeDeserializer()); [EOL] }
public void testCreateContextualWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(_arrayType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] _elementDeserializer = initialDeserializer; [EOL] when(findConvertingContentDeserializer(ctxt, property, initialDeserializer)).thenReturn(initialDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertSame(initialDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<?> initialDeserializer = (JsonDeserializer<?>) contextualDeserializer; [EOL] _elementDeserializer = initialDeserializer; [EOL] when(findConvertingContentDeserializer(ctxt, property, initialDeserializer)).thenReturn(initialDeserializer); [EOL] when(contextualDeserializer.createContextual(ctxt, property)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(initialDeserializer, result); [EOL] }
public void testCreateContextualWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] _elementTypeDeserializer = typeDeserializer; [EOL] when(typeDeserializer.forProperty(property)).thenReturn(typeDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testGetContentDeserializerWhenDeserializerIsNull() { [EOL] CustomDeserializer deserializer = new CustomDeserializer(null); [EOL] JsonDeserializer<Object> result = deserializer.getContentDeserializer(); [EOL] assertNull(result); [EOL] }
public void testGetContentDeserializerWhenDeserializerIsNotNull() { [EOL] CustomDeserializer deserializer = new CustomDeserializer(null); [EOL] JsonDeserializer<Object> elementDeserializer = new SomeConcreteDeserializer(); [EOL] deserializer.setElementDeserializer(elementDeserializer); [EOL] JsonDeserializer<Object> result = deserializer.getContentDeserializer(); [EOL] assertSame(elementDeserializer, result); [EOL] }
public void testReferencePropertyWithNonNullValues() { [EOL] Type type = mock(Type.class); [EOL] String name = "testName"; [EOL] ReferenceProperty referenceProperty = new ReferenceProperty(type, name); [EOL] assertNotNull(referenceProperty); [EOL] assertEquals(type, referenceProperty.getType()); [EOL] assertEquals(name, referenceProperty.getName()); [EOL] }
public void testReferencePropertyWithNullValues() { [EOL] ReferenceProperty referenceProperty = new ReferenceProperty(null, null); [EOL] assertNotNull(referenceProperty); [EOL] assertNull(referenceProperty.getType()); [EOL] assertNull(referenceProperty.getName()); [EOL] }
public void testManagedReferencePropertyWithName() { [EOL] String name = "testName"; [EOL] ReferenceProperty result = ReferenceProperty.managed(name); [EOL] assertNotNull(result); [EOL] assertEquals(Type.MANAGED_REFERENCE, result.getType()); [EOL] assertEquals(name, result.getName()); [EOL] }
public void testBackReferencePropertyWithName() { [EOL] String name = "testBackRef"; [EOL] ReferenceProperty result = ReferenceProperty.back(name); [EOL] assertNotNull(result); [EOL] assertEquals(Type.BACK_REFERENCE, result.getType()); [EOL] assertEquals(name, result.getName()); [EOL] }
public void testIsManagedReference_ManagedReferenceType() { [EOL] PropertyMetadata metadata = new PropertyMetadata(Type.MANAGED_REFERENCE, null, null, null); [EOL] assertTrue(metadata.isManagedReference()); [EOL] }
public void testIsManagedReference_NonManagedReferenceType() { [EOL] PropertyMetadata metadata = new PropertyMetadata(Type.OTHER, null, null, null); [EOL] assertFalse(metadata.isManagedReference()); [EOL] }
public void testIsBackReference_True() { [EOL] PropertyMetadata propertyMetadata = new PropertyMetadata(Type.BACK_REFERENCE, null, null, null); [EOL] assertTrue(propertyMetadata.isBackReference()); [EOL] }
public void testIsBackReference_False() { [EOL] PropertyMetadata propertyMetadata = new PropertyMetadata(Type.OTHER, null, null, null); [EOL] assertFalse(propertyMetadata.isBackReference()); [EOL] }
public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { [EOL] return null; [EOL] }
public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL] return null; [EOL] }
public void testDeserializeIfNaturalWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] Class<?> base = String.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertNull(result); [EOL] }
public void testDeserializeIfNaturalWithString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] Class<?> base = String.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertEquals("test", result); [EOL] }
public void testDeserializeIfNaturalWithInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] Class<?> base = Integer.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeIfNaturalWithDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(45.67); [EOL] Class<?> base = Double.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertEquals(Double.valueOf(45.67), result); [EOL] }
public void testDeserializeIfNaturalWithTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Class<?> base = Boolean.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeIfNaturalWithFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Class<?> base = Boolean.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeIfNaturalWithUnsupportedType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Class<?> base = Integer.class; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, base); [EOL] assertNull(result); [EOL] }
public void testRemoveWithNonNullMethods() { [EOL] AnnotatedMethodMap map = new AnnotatedMethodMap(); [EOL] Method method = String.class.getMethod("toString"); [EOL] map.add(new AnnotatedMethod(null, method, null, null)); [EOL] MemberKey key = new MemberKey(method); [EOL] AnnotatedMethod removed = map.remove(method); [EOL] assertNotNull(removed); [EOL] assertEquals(method, removed.getMember()); [EOL] }
public void testRemoveWithNullMethods() { [EOL] AnnotatedMethodMap map = new AnnotatedMethodMap(); [EOL] AnnotatedMethod removed = map.remove(String.class.getMethod("toString")); [EOL] assertNull(removed); [EOL] }
public void testToSetWithNullInput() { [EOL] HashSet<String> result = toSet(null); [EOL] assertNull(result); [EOL] } [EOL] public void testToSetWithEmptyArray() { [EOL] HashSet<String> result = toSet(new String[]{}); [EOL] assertNull(result); [EOL] } [EOL] public void testToSetWithNonEmptyArray() { [EOL] String[] input = new String[]{"entry1", "entry2", "entry3"}; [EOL] HashSet<String> result = toSet(input); [EOL] assertNotNull(result); [EOL] assertEquals(input.length, result.size()); [EOL] for (String entry : input) { [EOL] assertTrue(result.contains(entry)); [EOL] } [EOL] }
public JsonSerializer<?> createContextualTest_PropertyIsNull() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextualTest_PropertyMemberIsNull() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextualTest_PropertyMemberNotNull_KeySerializerNotNull() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findKeySerializer(member)).thenReturn(mock(Object.class)); [EOL] when(provider.serializerInstance(member, mock(Object.class))).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextualTest_PropertyMemberNotNull_ContentSerializerNotNull() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findContentSerializer(member)).thenReturn(mock(Object.class)); [EOL] when(provider.serializerInstance(member, mock(Object.class))).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextualTest_ValueSerializerNotNull_ContextualSerializer() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class, withSettings().extraInterfaces(ContextualSerializer.class)); [EOL] when(((ContextualSerializer) valueSerializer).createContextual(provider, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextualTest_KeySerializerNotNull_ContextualSerializer() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> keySerializer = mock(JsonSerializer.class, withSettings().extraInterfaces(ContextualSerializer.class)); [EOL] when(((ContextualSerializer) keySerializer).createContextual(provider, property)).thenReturn(keySerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextualTest_IgnoredEntriesNotNull() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(member)).thenReturn(new String[]{"propToIgnore"}); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testIsEmptyWithNullMap() { [EOL] boolean result = isEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithEmptyMap() { [EOL] Map<Object, Object> emptyMap = new HashMap<>(); [EOL] boolean result = isEmpty(emptyMap); [EOL] assertTrue(result); [EOL] }
public void testIsEmptyWithNonEmptyMap() { [EOL] Map<Object, Object> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("key", "value"); [EOL] boolean result = isEmpty(nonEmptyMap); [EOL] assertFalse(result); [EOL] }
public void testResolveWithDelegateTypeNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(valueInstantiator.getDelegateType(any())).thenReturn(null); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, null, null, null); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] mapDeserializer.resolve(ctxt); [EOL] }); [EOL] String expectedMessage = "Invalid delegate-creator definition for "; [EOL] assertTrue(exception.getMessage().contains(expectedMessage)); [EOL] }
public void testResolveWithDelegateTypeNotNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(valueInstantiator.getDelegateType(any())).thenReturn(delegateType); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findRootValueDeserializer(delegateType)).thenReturn(delegateDeserializer); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, null, null, null); [EOL] mapDeserializer.resolve(ctxt); [EOL] assertNotNull(mapDeserializer._delegateDeserializer); [EOL] }
public void testResolveWithCanCreateFromObjectWith() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(valueInstantiator.getFromObjectArguments(any())).thenReturn(creatorProps); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, null, null, null); [EOL] mapDeserializer.resolve(ctxt); [EOL] assertNotNull(mapDeserializer._propertyBasedCreator); [EOL] }
public void testResolveWithStandardStringKey() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeserializer, null, null); [EOL] mapDeserializer.resolve(ctxt); [EOL] assertEquals(mapDeserializer._standardStringKey, mapDeserializer._isStdKeyDeser(mapType, keyDeserializer)); [EOL] }
public void testDeserializeWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(mock(PropertyBasedCreator.class)); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new HashMap<>()); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Map); [EOL] }
public void testDeserializeWithoutDefaultCreator() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] try { [EOL] deserialize(mock(JsonParser.class), ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (InstantiationException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected an InstantiationException"); [EOL] } [EOL] }
public void testDeserializeFromStringValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string value"); [EOL] when(_valueInstantiator.createFromString(eq(ctxt), anyString())).thenReturn(new HashMap<>()); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Map); [EOL] }
public void testDeserializeWithMappingException() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected a mapping exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected a JsonMappingException"); [EOL] } [EOL] }
public void testDeserializeUsingDefaultWithStandardStringKey() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(new HashMap<>()); [EOL] when(_standardStringKey).thenReturn(true); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeUsingDefault() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(new HashMap<>()); [EOL] when(_standardStringKey).thenReturn(false); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testReadAndBindWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] when(valueDes.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn("value1"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertEquals("value1", result.get("key1")); [EOL] }
public void testReadAndBindWithIgnorableProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key1"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1", "key2"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1", "key2"); [EOL] when(valueDes.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn("value1", "value2"); [EOL] _ignorableProperties = ignorableProperties; [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key2")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testReadAndBindWithValueDeserializerWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] when(valueDes.deserializeWithType(any(JsonParser.class), any(DeserializationContext.class), any(TypeDeserializer.class))).thenReturn("value1"); [EOL] _valueTypeDeserializer = typeDeser; [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertEquals("value1", result.get("key1")); [EOL] }
It appears that the provided input text is for a constructor of a class named `OptionalHandlerFactory` which is empty. Since the constructor does not contain any executable code, there are no lines of code to cover with unit tests. Therefore, no unit test cases can be generated for this specific input. [EOL] If you have another method or a more complex constructor with executable code, please provide that, and I can generate the corresponding unit test cases.
public void testFindSerializerWithJavaxXml() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(PACKAGE_PREFIX_JAVAX_XML + ".DummyClass"); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof MyJavaxXmlSerializer); [EOL] }
public void testFindSerializerWithDomNode() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(CLASS_NAME_DOM_NODE); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof MyDomNodeSerializer); [EOL] }
public void testFindSerializerWithNonJavaxXmlOrDomNode() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType("com.example.NonJavaxXmlClass"); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNull(serializer); [EOL] }
public void testFindDeserializerWithJavaxXmlPrefix() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) JavaxXmlType.class); [EOL] when(JavaxXmlType.class.getName()).thenReturn("javax.xml.Type"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Deserializers); [EOL] }
public void testFindDeserializerWithDomDocument() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) DomDocumentType.class); [EOL] when(DomDocumentType.class.getName()).thenReturn("org.w3c.dom.Document"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonDeserializer); [EOL] }
public void testFindDeserializerWithDomNode() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) DomNodeType.class); [EOL] when(DomNodeType.class.getName()).thenReturn("org.w3c.dom.Node"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonDeserializer); [EOL] }
public void testFindDeserializerReturnsNull() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) OtherType.class); [EOL] when(OtherType.class.getName()).thenReturn("com.example.OtherType"); [EOL] JsonDeserializer<?> result = findDeserializer(type, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testInstantiateWithValidClassName() { [EOL] String validClassName = "java.lang.Object"; [EOL] Object result = instantiate(validClassName); [EOL] assertNotNull(result); [EOL] }
public void testInstantiateWithInvalidClassName() { [EOL] String invalidClassName = "non.existent.ClassName"; [EOL] Object result = instantiate(invalidClassName); [EOL] assertNull(result); [EOL] }
public void testInstantiateWithClassNameCausingLinkageError() { [EOL] String linkageErrorClassName = "some.class.CausingLinkageError"; [EOL] Object result = instantiate(linkageErrorClassName); [EOL] assertNull(result); [EOL] }
public void testHasSupertypeStartingWith_SuperclassMatch() { [EOL] class SuperclassWithPrefix {} [EOL] class Subclass extends SuperclassWithPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "SuperclassWithPrefix"); [EOL] assert result; [EOL] }
public void testHasSupertypeStartingWith_NoSuperclassMatch() { [EOL] class SuperclassWithoutPrefix {} [EOL] class Subclass extends SuperclassWithoutPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "NonExistentPrefix"); [EOL] assert !result; [EOL] }
public void testHasSupertypeStartingWith_InterfaceMatch() { [EOL] class InterfaceWithPrefix {} [EOL] class Subclass implements InterfaceWithPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "InterfaceWithPrefix"); [EOL] assert result; [EOL] }
public void testHasSupertypeStartingWith_NoInterfaceMatch() { [EOL] class InterfaceWithoutPrefix {} [EOL] class Subclass implements InterfaceWithoutPrefix {} [EOL] boolean result = hasSupertypeStartingWith(Subclass.class, "NonExistentPrefix"); [EOL] assert !result; [EOL] }
public void testStdConstructorWithDefaultVisibility() { [EOL] Visibility defaultVisibility = Visibility.DEFAULT; [EOL] Std std = new Std(defaultVisibility); [EOL] assertEquals(DEFAULT._getterMinLevel, std._getterMinLevel); [EOL] assertEquals(DEFAULT._isGetterMinLevel, std._isGetterMinLevel); [EOL] assertEquals(DEFAULT._setterMinLevel, std._setterMinLevel); [EOL] assertEquals(DEFAULT._creatorMinLevel, std._creatorMinLevel); [EOL] assertEquals(DEFAULT._fieldMinLevel, std._fieldMinLevel); [EOL] }
public void testStdConstructorWithNonDefaultVisibility() { [EOL] Visibility nonDefaultVisibility = Visibility.PUBLIC_ONLY; // Assuming PUBLIC_ONLY is a different enum constant [EOL] Std std = new Std(nonDefaultVisibility); [EOL] assertEquals(nonDefaultVisibility, std._getterMinLevel); [EOL] assertEquals(nonDefaultVisibility, std._isGetterMinLevel); [EOL] assertEquals(nonDefaultVisibility, std._setterMinLevel); [EOL] assertEquals(nonDefaultVisibility, std._creatorMinLevel); [EOL] assertEquals(nonDefaultVisibility, std._fieldMinLevel); [EOL] }
public void testWithDefaultVisibility() { [EOL] Std std = new Std(Visibility.ANY); [EOL] Std result = std.with(Visibility.DEFAULT); [EOL] assertSame(Std.DEFAULT, result); [EOL] }
public void testWithNonDefaultVisibility() { [EOL] Std std = new Std(Visibility.ANY); [EOL] Std result = std.with(Visibility.PUBLIC_ONLY); [EOL] assertNotNull(result); [EOL] assertNotSame(Std.DEFAULT, result); [EOL] assertEquals(Visibility.PUBLIC_ONLY, result.getVisibility()); [EOL] }
public void testWithVisibilityGetter() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(PropertyAccessor.GETTER, v); [EOL] assertNotNull(result); [EOL] }
public void testWithVisibilitySetter() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(PropertyAccessor.SETTER, v); [EOL] assertNotNull(result); [EOL] }
public void testWithVisibilityCreator() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(PropertyAccessor.CREATOR, v); [EOL] assertNotNull(result); [EOL] }
public void testWithVisibilityField() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(PropertyAccessor.FIELD, v); [EOL] assertNotNull(result); [EOL] }
public void testWithVisibilityIsGetter() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(PropertyAccessor.IS_GETTER, v); [EOL] assertNotNull(result); [EOL] }
public void testWithVisibilityAll() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(PropertyAccessor.ALL, v); [EOL] assertNotNull(result); [EOL] }
public void testWithVisibilityDefault() { [EOL] Std std = new Std(); [EOL] Visibility v = Visibility.ANY; [EOL] Std result = std.withVisibility(null, v); // Assuming null will trigger the default case [EOL] assertSame(std, result); [EOL] }
public void testWithGetterVisibility_Default() { [EOL] Visibility defaultVisibility = Visibility.DEFAULT; [EOL] Std std = new Std(defaultVisibility, false, Visibility.NONE, Visibility.NONE, Visibility.NONE); [EOL] Std result = std.withGetterVisibility(defaultVisibility); [EOL] assertSame(std, result); [EOL] }
public void testWithGetterVisibility_NonDefaultSameAsCurrent() { [EOL] Visibility currentVisibility = Visibility.PUBLIC_ONLY; [EOL] Std std = new Std(currentVisibility, false, Visibility.NONE, Visibility.NONE, Visibility.NONE); [EOL] Std result = std.withGetterVisibility(currentVisibility); [EOL] assertSame(std, result); [EOL] }
public void testWithGetterVisibility_NonDefaultNotSameAsCurrent() { [EOL] Visibility currentVisibility = Visibility.PUBLIC_ONLY; [EOL] Visibility newVisibility = Visibility.PROTECTED_AND_PUBLIC; [EOL] Std std = new Std(currentVisibility, false, Visibility.NONE, Visibility.NONE, Visibility.NONE); [EOL] Std result = std.withGetterVisibility(newVisibility); [EOL] assertNotSame(std, result); [EOL] assertEquals(newVisibility, result.getGetterVisibility()); [EOL] }
public void testFindWithTokenBufferClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerCache.find(TokenBuffer.class); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TokenBufferDeserializer); [EOL] }
public void testFindWithJavaTypeClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerCache.find(JavaType.class); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof JavaTypeDeserializer); [EOL] }
public void testFindWithUnassignableClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerCache.find(String.class); [EOL] assertNull(deserializer); [EOL] }
public void testTokenBufferDeserializerConstructor() { [EOL] TokenBufferDeserializer deserializer = new TokenBufferDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(TokenBuffer.class, deserializer.handledType()); [EOL] }
public void testDeserializeWithNonNullParserAndContext() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCodec()).thenReturn(null); [EOL] TokenBuffer result = new TokenBufferDeserializer().deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).copyCurrentStructure(jp); [EOL] }
public void testDeserializeWithNullParser() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] new TokenBufferDeserializer().deserialize(null, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithNullContext() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCodec()).thenReturn(null); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] new TokenBufferDeserializer().deserialize(jp, null); [EOL] }); [EOL] }
public void testReferenceConstructorWithNonNullField() { [EOL] Object from = new Object(); [EOL] String fieldName = "testField"; [EOL] Reference ref = new Reference(from, fieldName); [EOL] assertNotNull(ref); [EOL] assertEquals(from, ref.getFrom()); [EOL] assertEquals(fieldName, ref.getFieldName()); [EOL] }
public void testReferenceConstructorWithNullField() { [EOL] Object from = new Object(); [EOL] try { [EOL] new Reference(from, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Can not pass null fieldName", e.getMessage()); [EOL] } [EOL] }
public void testReferenceConstructorWithNonNullFrom() { [EOL] Object from = new Object(); [EOL] int index = 1; [EOL] Reference reference = new Reference(from, index); [EOL] assertNotNull(reference.getFrom()); [EOL] assertEquals(index, reference.getIndex()); [EOL] }
public void testReferenceConstructorWithNullFrom() { [EOL] Object from = null; [EOL] int index = 1; [EOL] Reference reference = new Reference(from, index); [EOL] assertNull(reference.getFrom()); [EOL] assertEquals(index, reference.getIndex()); [EOL] }
public void testToStringWithClassFrom() { [EOL] MyClass instance = new MyClass(String.class, "fieldName"); [EOL] String result = instance.toString(); [EOL] assertTrue(result.contains("java.lang.String[fieldName]")); [EOL] }
public void testToStringWithNonClassFrom() { [EOL] MyClass instance = new MyClass(new Object(), 1); [EOL] String result = instance.toString(); [EOL] assertTrue(result.contains("Object[1]")); [EOL] }
public void testToStringWithNullFieldAndNegativeIndex() { [EOL] MyClass instance = new MyClass(new Object(), null, -1); [EOL] String result = instance.toString(); [EOL] assertTrue(result.contains("Object[?]")); [EOL] }
public void testJsonMappingExceptionWithMessageAndRootCause() { [EOL] String expectedMessage = "Test message"; [EOL] Throwable expectedCause = new Throwable("Test cause"); [EOL] JsonMappingException exception = new JsonMappingException(expectedMessage, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public void testJsonMappingExceptionWithMessageAndLocation() { [EOL] String expectedMessage = "Test message"; [EOL] JsonLocation location = new JsonLocation(new Object(), 1L, 2, 3); [EOL] JsonMappingException exception = new JsonMappingException(expectedMessage, location); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(location, exception.getLocation()); [EOL] }
public void testWrapWithPathWithThrowableAndIndex() { [EOL] Throwable src = new Throwable("Test Throwable"); [EOL] Object refFrom = new Object(); [EOL] int index = 5; [EOL] JsonMappingException exception = JsonMappingException.wrapWithPath(src, refFrom, index); [EOL] assertNotNull(exception); [EOL] assertEquals("Test Throwable", exception.getCause().getMessage()); [EOL] assertEquals(1, exception.getPath().size()); [EOL] assertEquals(index, exception.getPath().get(0).getIndex()); [EOL] assertEquals(refFrom, exception.getPath().get(0).getFrom()); [EOL] }
public void testWrapWithPath_WithJsonMappingException() { [EOL] Throwable src = new JsonMappingException("Error message"); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertEquals("Error message", result.getMessage()); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testWrapWithPath_WithNonJsonMappingExceptionAndNonNullMessage() { [EOL] Throwable src = new Exception("Error message"); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertEquals("Error message", result.getMessage()); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testWrapWithPath_WithNonJsonMappingExceptionAndNullMessage() { [EOL] Throwable src = new Exception(); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertTrue(result.getMessage().contains("was java.lang.Exception")); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testWrapWithPath_WithNonJsonMappingExceptionAndEmptyMessage() { [EOL] Throwable src = new Exception(""); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertTrue(result.getMessage().contains("was java.lang.Exception")); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testGetPathReferenceWithNonNullStringBuilder() { [EOL] JsonPointer ptr = new JsonPointer(""); // Assuming JsonPointer is the class where getPathReference is defined [EOL] StringBuilder sb = new StringBuilder(); [EOL] StringBuilder result = ptr.getPathReference(sb); [EOL] assertNotNull(result); [EOL] assertSame(sb, result); // Assert that the original StringBuilder is returned [EOL] }
public void testGetPathReferenceAppendingPath() { [EOL] JsonPointer ptr = new JsonPointer("/path/to/node"); // Assuming JsonPointer is the class where getPathReference is defined [EOL] StringBuilder sb = new StringBuilder(); [EOL] StringBuilder result = ptr.getPathReference(sb); [EOL] assertNotNull(result); [EOL] assertEquals("/path/to/node", result.toString()); // Assuming _appendPathDesc appends the path to the StringBuilder [EOL] }
public void testPrependPathWithNonNullValues() { [EOL] JsonMappingException exception = new JsonMappingException(null, "Test exception"); [EOL] exception.prependPath(new Object(), "fieldName"); [EOL] assertEquals(1, exception.getPath().size()); [EOL] assertEquals("fieldName", exception.getPath().get(0).getFieldName()); [EOL] assertEquals(Object.class, exception.getPath().get(0).getFrom().getClass()); [EOL] }
public void testPrependPathWithNullValues() { [EOL] JsonMappingException exception = new JsonMappingException(null, "Test exception"); [EOL] exception.prependPath(null, null); [EOL] assertEquals(1, exception.getPath().size()); [EOL] assertNull(exception.getPath().get(0).getFieldName()); [EOL] assertNull(exception.getPath().get(0).getFrom()); [EOL] }
public void testPrependPathWithNullPath() { [EOL] YourClass instance = new YourClass(); [EOL] Reference ref = new Reference(); // Replace with actual Reference object creation [EOL] instance.prependPath(ref); [EOL] assertNotNull(instance.getPath()); [EOL] assertTrue(instance.getPath().contains(ref)); [EOL] }
public void testPrependPathWithNonEmptyPath() { [EOL] YourClass instance = new YourClass(); [EOL] Reference ref1 = new Reference(); // Replace with actual Reference object creation [EOL] instance.prependPath(ref1); [EOL] Reference ref2 = new Reference(); // Replace with another Reference object creation [EOL] instance.prependPath(ref2); [EOL] assertNotNull(instance.getPath()); [EOL] assertEquals(2, instance.getPath().size()); [EOL] assertSame(ref2, instance.getPath().getFirst()); [EOL] assertSame(ref1, instance.getPath().getLast()); [EOL] }
public void testPrependPathWithMaxRefsToList() { [EOL] YourClass instance = new YourClass(); [EOL] for (int i = 0; i < YourClass.MAX_REFS_TO_LIST; i++) { [EOL] instance.prependPath(new Reference()); // Replace with actual Reference object creation [EOL] } [EOL] Reference overflowRef = new Reference(); // Replace with another Reference object creation [EOL] instance.prependPath(overflowRef); [EOL] assertEquals(YourClass.MAX_REFS_TO_LIST, instance.getPath().size()); [EOL] assertFalse(instance.getPath().contains(overflowRef)); [EOL] }
public void testBuildMessageWithNullPath() { [EOL] JsonMappingException exception = new JsonMappingException("Test message", (JsonLocation)null); [EOL] String result = exception._buildMessage(); [EOL] assertEquals("Test message", result); [EOL] }
public void testBuildMessageWithPath() { [EOL] JsonMappingException exception = new JsonMappingException("Test message", (JsonLocation)null); [EOL] exception.prependPath(new Object(), "fieldName"); [EOL] String result = exception._buildMessage(); [EOL] assertTrue(result.startsWith("Test message (through reference chain: ")); [EOL] assertTrue(result.endsWith(")")); [EOL] }
public void test_appendPathDesc_withNullPath() { [EOL] JsonMappingException instance = new JsonMappingException((Closeable) null, "Test exception"); [EOL] StringBuilder sb = new StringBuilder(); [EOL] instance._appendPathDesc(sb); [EOL] assertEquals("", sb.toString()); [EOL] }
public void test_appendPathDesc_withEmptyPath() { [EOL] JsonMappingException instance = new JsonMappingException((Closeable) null, "Test exception"); [EOL] instance.prependPath(new Object(), "field"); [EOL] instance._path.clear(); // Clear the path to simulate an empty iterator [EOL] StringBuilder sb = new StringBuilder(); [EOL] instance._appendPathDesc(sb); [EOL] assertEquals("", sb.toString()); [EOL] }
public void test_appendPathDesc_withSingleElementPath() { [EOL] JsonMappingException instance = new JsonMappingException((Closeable) null, "Test exception"); [EOL] instance.prependPath(new Object(), "field"); [EOL] StringBuilder sb = new StringBuilder(); [EOL] instance._appendPathDesc(sb); [EOL] assertEquals("field", sb.toString()); [EOL] }
public void test_appendPathDesc_withMultipleElementsPath() { [EOL] JsonMappingException instance = new JsonMappingException((Closeable) null, "Test exception"); [EOL] instance.prependPath(new Object(), "field1"); [EOL] instance.prependPath(new Object(), "field2"); [EOL] StringBuilder sb = new StringBuilder(); [EOL] instance._appendPathDesc(sb); [EOL] assertEquals("field2->field1", sb.toString()); [EOL] }
public void testFindTypedValueSerializerWithKnownSerializer() { [EOL] SerializerProvider provider = createProviderWithKnownSerializers(); [EOL] Class<?> valueType = String.class; [EOL] boolean cache = false; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof KnownSerializer); [EOL] } [EOL] public void testFindTypedValueSerializerWithCachedSerializer() { [EOL] SerializerProvider provider = createProviderWithCachedSerializers(); [EOL] Class<?> valueType = String.class; [EOL] boolean cache = false; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CachedSerializer); [EOL] } [EOL] public void testFindTypedValueSerializerWithTypeWrappedSerializer() { [EOL] SerializerProvider provider = createProviderWithTypeWrappedSerializers(); [EOL] Class<?> valueType = String.class; [EOL] boolean cache = false; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeWrappedSerializer); [EOL] } [EOL] public void testFindTypedValueSerializerWithCaching() { [EOL] SerializerProvider provider = createProviderWithoutSerializers(); [EOL] Class<?> valueType = String.class; [EOL] boolean cache = true; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] JsonSerializer<Object> cachedResult = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertSame(result, cachedResult); [EOL] }

public void testFindTypedValueSerializerWithKnownSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] boolean cache = ...; // Set to true or false as needed [EOL] JsonSerializer<Object> knownSerializer = ...; // Create a mock JsonSerializer [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(knownSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertSame(knownSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithCachedSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] boolean cache = ...; // Set to true or false as needed [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] JsonSerializer<Object> cachedSerializer = ...; // Create a mock JsonSerializer [EOL] when(_serializerCache.typedValueSerializer(valueType)).thenReturn(cachedSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertSame(cachedSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithTypeWrappedSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] boolean cache = true; // Set to true to test caching behavior [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(_serializerCache.typedValueSerializer(valueType)).thenReturn(null); [EOL] TypeSerializer typeSerializer = ...; // Create a mock TypeSerializer [EOL] when(_serializerFactory.createTypeSerializer(_config, valueType)).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] JsonSerializer<Object> valueSerializer = ...; // Create a mock JsonSerializer [EOL] when(findValueSerializer(valueType, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeWrappedSerializer); [EOL] }
public void testFindTypedValueSerializerWithoutCaching() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] boolean cache = false; // Set to false to test non-caching behavior [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(_serializerCache.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(_serializerFactory.createTypeSerializer(_config, valueType)).thenReturn(null); [EOL] JsonSerializer<Object> valueSerializer = ...; // Create a mock JsonSerializer [EOL] when(findValueSerializer(valueType, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertNotNull(result); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testDefaultSerializeDateValueWithTimestampsEnabled() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Date date = new Date(); [EOL] mapper.getSerializationConfig().defaultSerializeDateValue(date, jgen); [EOL] verify(jgen).writeNumber(date.getTime()); [EOL] }
public void testDefaultSerializeDateValueWithTimestampsDisabled() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Date date = new Date(); [EOL] DateFormat df = new SimpleDateFormat(); [EOL] mapper.setDateFormat(df); [EOL] mapper.getSerializationConfig().defaultSerializeDateValue(date, jgen); [EOL] verify(jgen).writeString(df.format(date)); [EOL] }
public void testDefaultSerializeDateKeyWithTimestampEnabled() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL] JsonGenerator jgen = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates a JsonGenerator [EOL] Date date = new Date(); [EOL] mapper.defaultSerializeDateKey(date, jgen); [EOL] verify(jgen).writeFieldName(String.valueOf(date.getTime())); [EOL] }
public void testDefaultSerializeDateKeyWithTimestampDisabled() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, false); [EOL] JsonGenerator jgen = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates a JsonGenerator [EOL] Date date = new Date(); [EOL] mapper.defaultSerializeDateKey(date, jgen); [EOL] verify(jgen).writeFieldName(mapper.getDateFormat().format(date)); [EOL] }
public void test_dateFormatNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DateFormat initialFormat = mapper.getSerializationConfig().getDateFormat(); [EOL] DateFormat retrievedFormat = mapper._dateFormat(); [EOL] assertSame("Expected the same DateFormat instance", initialFormat, retrievedFormat); [EOL] }
public void test_dateFormatInitialization() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setConfig(mapper.getSerializationConfig().with((DateFormat) null)); [EOL] DateFormat retrievedFormat = mapper._dateFormat(); [EOL] assertNotNull("DateFormat should not be null after initialization", retrievedFormat); [EOL] }
