public static TypeInfoArray getTypeInfoForArray(Type type) { [EOL]     Preconditions.checkArgument(TypeUtils.isArray(type)); [EOL]     return new TypeInfoArray(type); [EOL] }
public static TypeInfoArray getTypeInfoForArray(Type type) { [EOL]     Preconditions.checkArgument(TypeUtils.isArray(type)); [EOL]     return new TypeInfoArray(type); [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }
public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }
public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public JsonWriter name(String name) throws IOException { [EOL]     if (name == null) { [EOL]         throw new NullPointerException("name == null"); [EOL]     } [EOL]     beforeName(); [EOL]     string(name); [EOL]     return this; [EOL] }
public JsonWriter name(String name) throws IOException { [EOL]     if (name == null) { [EOL]         throw new NullPointerException("name == null"); [EOL]     } [EOL]     beforeName(); [EOL]     string(name); [EOL]     return this; [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void beforeName() throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context == JsonScope.NONEMPTY_OBJECT) { [EOL]         out.write(','); [EOL]     } else if (context != JsonScope.EMPTY_OBJECT) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     newline(); [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL] }
private void beforeName() throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context == JsonScope.NONEMPTY_OBJECT) { [EOL]         out.write(','); [EOL]     } else if (context != JsonScope.EMPTY_OBJECT) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     newline(); [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL] }
private void beforeName() throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context == JsonScope.NONEMPTY_OBJECT) { [EOL]         out.write(','); [EOL]     } else if (context != JsonScope.EMPTY_OBJECT) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     newline(); [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target; [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target; [EOL] }
TypeInfoArray(Type type) { [EOL]     super(type); [EOL]     Class<?> rootComponentType = rawClass; [EOL]     while (rootComponentType.isArray()) { [EOL]         rootComponentType = rootComponentType.getComponentType(); [EOL]     } [EOL]     this.componentRawType = rootComponentType; [EOL]     this.secondLevel = extractSecondLevelType(actualType, rawClass); [EOL] }
TypeInfoArray(Type type) { [EOL]     super(type); [EOL]     Class<?> rootComponentType = rawClass; [EOL]     while (rootComponentType.isArray()) { [EOL]         rootComponentType = rootComponentType.getComponentType(); [EOL]     } [EOL]     this.componentRawType = rootComponentType; [EOL]     this.secondLevel = extractSecondLevelType(actualType, rawClass); [EOL] }
TypeInfoArray(Type type) { [EOL]     super(type); [EOL]     Class<?> rootComponentType = rawClass; [EOL]     while (rootComponentType.isArray()) { [EOL]         rootComponentType = rootComponentType.getComponentType(); [EOL]     } [EOL]     this.componentRawType = rootComponentType; [EOL]     this.secondLevel = extractSecondLevelType(actualType, rawClass); [EOL] }
private static Type extractSecondLevelType(Type actualType, Class<?> rawClass) { [EOL]     return actualType instanceof GenericArrayType ? ((GenericArrayType) actualType).getGenericComponentType() : rawClass.getComponentType(); [EOL] }
private static Type extractSecondLevelType(Type actualType, Class<?> rawClass) { [EOL]     return actualType instanceof GenericArrayType ? ((GenericArrayType) actualType).getGenericComponentType() : rawClass.getComponentType(); [EOL] }
public Type getSecondLevelType() { [EOL]     return secondLevel; [EOL] }
public String escapeJsonString(CharSequence plainText) { [EOL]     StringBuffer escapedString = new StringBuffer(plainText.length() + 20); [EOL]     try { [EOL]         escapeJsonString(plainText, escapedString); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return escapedString.toString(); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
public String escapeJsonString(CharSequence plainText) { [EOL]     StringBuffer escapedString = new StringBuffer(plainText.length() + 20); [EOL]     try { [EOL]         escapeJsonString(plainText, escapedString); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return escapedString.toString(); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
public String escapeJsonString(CharSequence plainText) { [EOL]     StringBuffer escapedString = new StringBuffer(plainText.length() + 20); [EOL]     try { [EOL]         escapeJsonString(plainText, escapedString); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return escapedString.toString(); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
public String escapeJsonString(CharSequence plainText) { [EOL]     StringBuffer escapedString = new StringBuffer(plainText.length() + 20); [EOL]     try { [EOL]         escapeJsonString(plainText, escapedString); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return escapedString.toString(); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
public String escapeJsonString(CharSequence plainText) { [EOL]     StringBuffer escapedString = new StringBuffer(plainText.length() + 20); [EOL]     try { [EOL]         escapeJsonString(plainText, escapedString); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return escapedString.toString(); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
public String escapeJsonString(CharSequence plainText) { [EOL]     StringBuffer escapedString = new StringBuffer(plainText.length() + 20); [EOL]     try { [EOL]         escapeJsonString(plainText, escapedString); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return escapedString.toString(); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private boolean mustEscapeCharInJsString(int codepoint) { [EOL]     if (!Character.isSupplementaryCodePoint(codepoint)) { [EOL]         char c = (char) codepoint; [EOL]         return JS_ESCAPE_CHARS.contains(c) || (escapeHtmlCharacters && HTML_ESCAPE_CHARS.contains(c)); [EOL]     } [EOL]     return false; [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private boolean mustEscapeCharInJsString(int codepoint) { [EOL]     if (!Character.isSupplementaryCodePoint(codepoint)) { [EOL]         char c = (char) codepoint; [EOL]         return JS_ESCAPE_CHARS.contains(c) || (escapeHtmlCharacters && HTML_ESCAPE_CHARS.contains(c)); [EOL]     } [EOL]     return false; [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private boolean mustEscapeCharInJsString(int codepoint) { [EOL]     if (!Character.isSupplementaryCodePoint(codepoint)) { [EOL]         char c = (char) codepoint; [EOL]         return JS_ESCAPE_CHARS.contains(c) || (escapeHtmlCharacters && HTML_ESCAPE_CHARS.contains(c)); [EOL]     } [EOL]     return false; [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private static boolean isControlCharacter(int codePoint) { [EOL]     return codePoint < 0x20 || codePoint == 0x2028 || codePoint == 0x2029 || (codePoint >= 0x7f && codePoint <= 0x9f); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private static boolean isControlCharacter(int codePoint) { [EOL]     return codePoint < 0x20 || codePoint == 0x2028 || codePoint == 0x2029 || (codePoint >= 0x7f && codePoint <= 0x9f); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void checkLenient() throws IOException { [EOL]     if (!lenient) { [EOL]         throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON"); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextString(char quote) throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             if (c == quote) { [EOL]                 if (skipping) { [EOL]                     return "skipped!"; [EOL]                 } else if (builder == null) { [EOL]                     return new String(buffer, start, pos - start - 1); [EOL]                 } else { [EOL]                     builder.append(buffer, start, pos - start - 1); [EOL]                     return builder.toString(); [EOL]                 } [EOL]             } else if (c == '\\') { [EOL]                 if (builder == null) { [EOL]                     builder = new StringBuilder(); [EOL]                 } [EOL]                 builder.append(buffer, start, pos - start - 1); [EOL]                 builder.append(readEscapeCharacter()); [EOL]                 start = pos; [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     throw syntaxError("Unterminated string"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextLiteral() throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             switch(c) { [EOL]                 case '/': [EOL]                 case '\\': [EOL]                 case ';': [EOL]                 case '#': [EOL]                 case '=': [EOL]                     checkLenient(); [EOL]                 case '{': [EOL]                 case '}': [EOL]                 case '[': [EOL]                 case ']': [EOL]                 case ':': [EOL]                 case ',': [EOL]                 case ' ': [EOL]                 case '\t': [EOL]                 case '\f': [EOL]                 case '\r': [EOL]                 case '\n': [EOL]                     pos--; [EOL]                     if (skipping) { [EOL]                         return "skipped!"; [EOL]                     } else if (builder == null) { [EOL]                         return new String(buffer, start, pos - start); [EOL]                     } else { [EOL]                         builder.append(buffer, start, pos - start); [EOL]                         return builder.toString(); [EOL]                     } [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     return builder.toString(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private IOException syntaxError(String message) throws IOException { [EOL]     throw new MalformedJsonException(message + " near " + getSnippet()); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private CharSequence getSnippet() { [EOL]     StringBuilder snippet = new StringBuilder(); [EOL]     int beforePos = Math.min(pos, 20); [EOL]     snippet.append(buffer, pos - beforePos, beforePos); [EOL]     int afterPos = Math.min(limit - pos, 20); [EOL]     snippet.append(buffer, pos, afterPos); [EOL]     return snippet; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
DefaultDateTypeAdapter(final int style) { [EOL]     this.format = DateFormat.getDateInstance(style); [EOL] }
DefaultDateTypeAdapter(final int style) { [EOL]     this.format = DateFormat.getDateInstance(style); [EOL] }
DefaultDateTypeAdapter(final int style) { [EOL]     this.format = DateFormat.getDateInstance(style); [EOL] }
DefaultDateTypeAdapter(final int style) { [EOL]     this.format = DateFormat.getDateInstance(style); [EOL] }
public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] }
public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] }
public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toExternalForm()); [EOL] }
public Properties createInstance(Type type) { [EOL]     return new Properties(); [EOL] }
public Properties createInstance(Type type) { [EOL]     return new Properties(); [EOL] }
public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Map<Object, Object> map = constructMapType(typeOfT, context); [EOL]     TypeInfoMap mapTypeInfo = new TypeInfoMap(typeOfT); [EOL]     for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) { [EOL]         Object key = context.deserialize(new JsonPrimitive(entry.getKey()), mapTypeInfo.getKeyType()); [EOL]         Object value = context.deserialize(entry.getValue(), mapTypeInfo.getValueType()); [EOL]         map.put(key, value); [EOL]     } [EOL]     return map; [EOL] }
public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Map<Object, Object> map = constructMapType(typeOfT, context); [EOL]     TypeInfoMap mapTypeInfo = new TypeInfoMap(typeOfT); [EOL]     for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) { [EOL]         Object key = context.deserialize(new JsonPrimitive(entry.getKey()), mapTypeInfo.getKeyType()); [EOL]         Object value = context.deserialize(entry.getValue(), mapTypeInfo.getValueType()); [EOL]         map.put(key, value); [EOL]     } [EOL]     return map; [EOL] }
public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Map<Object, Object> map = constructMapType(typeOfT, context); [EOL]     TypeInfoMap mapTypeInfo = new TypeInfoMap(typeOfT); [EOL]     for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) { [EOL]         Object key = context.deserialize(new JsonPrimitive(entry.getKey()), mapTypeInfo.getKeyType()); [EOL]         Object value = context.deserialize(entry.getValue(), mapTypeInfo.getValueType()); [EOL]         map.put(key, value); [EOL]     } [EOL]     return map; [EOL] }
private Map constructMapType(Type mapType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Map) objectConstructor.construct(mapType); [EOL] }
private Map constructMapType(Type mapType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Map) objectConstructor.construct(mapType); [EOL] }
public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
@Override [EOL] public String toString() { [EOL]     return BigIntegerTypeAdapter.class.getSimpleName(); [EOL] }
public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsNumber(); [EOL] }
public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsNumber(); [EOL] }
public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsNumber(); [EOL] }
public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return longSerializationPolicy.serialize(src); [EOL] }
public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return longSerializationPolicy.serialize(src); [EOL] }
public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsLong(); [EOL] }
public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsLong(); [EOL] }
public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsLong(); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsString(); [EOL] }
public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsString(); [EOL] }
public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsString(); [EOL] }
public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBoolean(); [EOL] }
public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBoolean(); [EOL] }
public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBoolean(); [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
JsonArrayDeserializationVisitor(JsonArray jsonArray, Type arrayType, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context) { [EOL]     super(jsonArray, arrayType, factory, objectConstructor, deserializers, context); [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
public static void checkArgument(boolean condition) { [EOL]     if (!condition) { [EOL]         throw new IllegalArgumentException("condition failed: " + condition); [EOL]     } [EOL] }
public static void checkArgument(boolean condition) { [EOL]     if (!condition) { [EOL]         throw new IllegalArgumentException("condition failed: " + condition); [EOL]     } [EOL] }
public int size() { [EOL]     return elements.size(); [EOL] }
public int size() { [EOL]     return elements.size(); [EOL] }
public JsonElement get(int i) { [EOL]     return elements.get(i); [EOL] }
public JsonElement get(int i) { [EOL]     return elements.get(i); [EOL] }
@Override [EOL] public String getAsString() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsString(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public String getAsString() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsString(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public String getAsString() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsString(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public boolean getAsBoolean() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBoolean(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public boolean getAsBoolean() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBoolean(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] }
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] }
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
public String translateName(FieldAttributes f) { [EOL]     Preconditions.checkNotNull(f); [EOL]     SerializedName serializedName = f.getAnnotation(SerializedName.class); [EOL]     return serializedName == null ? delegate.translateName(f) : fieldNameValidator.validate(serializedName.value()); [EOL] }
public String translateName(FieldAttributes f) { [EOL]     Preconditions.checkNotNull(f); [EOL]     SerializedName serializedName = f.getAnnotation(SerializedName.class); [EOL]     return serializedName == null ? delegate.translateName(f) : fieldNameValidator.validate(serializedName.value()); [EOL] }
public String translateName(FieldAttributes f) { [EOL]     Preconditions.checkNotNull(f); [EOL]     SerializedName serializedName = f.getAnnotation(SerializedName.class); [EOL]     return serializedName == null ? delegate.translateName(f) : fieldNameValidator.validate(serializedName.value()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
private static Class<?> checkNotNull(Class<?> type) { [EOL]     Preconditions.checkNotNull(type); [EOL]     return type; [EOL] }
private static Class<?> checkNotNull(Class<?> type) { [EOL]     Preconditions.checkNotNull(type); [EOL]     return type; [EOL] }
public static <T> Class<T> wrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type); [EOL]     return (wrapped == null) ? type : wrapped; [EOL] }
public static <T> Class<T> wrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type); [EOL]     return (wrapped == null) ? type : wrapped; [EOL] }
public static <T> Class<T> wrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type); [EOL]     return (wrapped == null) ? type : wrapped; [EOL] }
public static <T> Class<T> wrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type); [EOL]     return (wrapped == null) ? type : wrapped; [EOL] }
public static <T> Class<T> unwrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type); [EOL]     return (unwrapped == null) ? type : unwrapped; [EOL] }
public static <T> Class<T> unwrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type); [EOL]     return (unwrapped == null) ? type : unwrapped; [EOL] }
public static <T> Class<T> unwrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type); [EOL]     return (unwrapped == null) ? type : unwrapped; [EOL] }
public static <T> Class<T> unwrap(Class<T> type) { [EOL]     checkNotNull(type); [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type); [EOL]     return (unwrapped == null) ? type : unwrapped; [EOL] }
JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) { [EOL]     Preconditions.checkNotNull(delegate); [EOL]     this.delegate = delegate; [EOL] }
JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) { [EOL]     Preconditions.checkNotNull(delegate); [EOL]     this.delegate = delegate; [EOL] }
public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return delegate.deserialize(json, typeOfT, context); [EOL]     } catch (JsonParseException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         StringBuilder errorMsg = new StringBuilder().append("The JsonDeserializer ").append(delegate).append(" failed to deserialized json object ").append(json).append(" given the type ").append(typeOfT); [EOL]         throw new JsonParseException(errorMsg.toString(), e); [EOL]     } [EOL] }
public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return delegate.deserialize(json, typeOfT, context); [EOL]     } catch (JsonParseException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         StringBuilder errorMsg = new StringBuilder().append("The JsonDeserializer ").append(delegate).append(" failed to deserialized json object ").append(json).append(" given the type ").append(typeOfT); [EOL]         throw new JsonParseException(errorMsg.toString(), e); [EOL]     } [EOL] }
public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return delegate.deserialize(json, typeOfT, context); [EOL]     } catch (JsonParseException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         StringBuilder errorMsg = new StringBuilder().append("The JsonDeserializer ").append(delegate).append(" failed to deserialized json object ").append(json).append(" given the type ").append(typeOfT); [EOL]         throw new JsonParseException(errorMsg.toString(), e); [EOL]     } [EOL] }
public JsonParseException(String msg) { [EOL]     super(msg); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     for (RecursiveFieldNamingPolicy policy : fieldPolicies) { [EOL]         target = policy.translateName(target, fieldType, annotations); [EOL]     } [EOL]     return target; [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     for (RecursiveFieldNamingPolicy policy : fieldPolicies) { [EOL]         target = policy.translateName(target, fieldType, annotations); [EOL]     } [EOL]     return target; [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     for (RecursiveFieldNamingPolicy policy : fieldPolicies) { [EOL]         target = policy.translateName(target, fieldType, annotations); [EOL]     } [EOL]     return target; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return false; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (genericComponentType == null) ? 0 : genericComponentType.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (genericComponentType == null) ? 0 : genericComponentType.hashCode(); [EOL] }
final Object visitChildAsArray(Type childType, JsonArray jsonChild) { [EOL]     JsonDeserializationVisitor<?> childVisitor = new JsonArrayDeserializationVisitor<Object>(jsonChild.getAsJsonArray(), childType, factory, objectConstructor, deserializers, context); [EOL]     return visitChild(childType, childVisitor); [EOL] }
private Object visitChild(Type type, JsonDeserializationVisitor<?> childVisitor) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(null, type, false)); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getTarget(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
public Object constructArray(Type type, int length) { [EOL]     return Array.newInstance(TypeUtils.toRawClass(type), length); [EOL] }
public Object constructArray(Type type, int length) { [EOL]     return Array.newInstance(TypeUtils.toRawClass(type), length); [EOL] }
public Object constructArray(Type type, int length) { [EOL]     return Array.newInstance(TypeUtils.toRawClass(type), length); [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public GsonBuilder setVersion(double ignoreVersionsAfter) { [EOL]     this.ignoreVersionsAfter = ignoreVersionsAfter; [EOL]     return this; [EOL] }
public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) { [EOL]     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>); [EOL]     if (typeAdapter instanceof InstanceCreator<?>) { [EOL]         registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonSerializer<?>) { [EOL]         registerSerializer(type, (JsonSerializer<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonDeserializer<?>) { [EOL]         registerDeserializer(type, (JsonDeserializer<?>) typeAdapter); [EOL]     } [EOL]     return this; [EOL] }
public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) { [EOL]     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>); [EOL]     if (typeAdapter instanceof InstanceCreator<?>) { [EOL]         registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonSerializer<?>) { [EOL]         registerSerializer(type, (JsonSerializer<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonDeserializer<?>) { [EOL]         registerDeserializer(type, (JsonDeserializer<?>) typeAdapter); [EOL]     } [EOL]     return this; [EOL] }
public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) { [EOL]     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>); [EOL]     if (typeAdapter instanceof InstanceCreator<?>) { [EOL]         registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonSerializer<?>) { [EOL]         registerSerializer(type, (JsonSerializer<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonDeserializer<?>) { [EOL]         registerDeserializer(type, (JsonDeserializer<?>) typeAdapter); [EOL]     } [EOL]     return this; [EOL] }
public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) { [EOL]     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>); [EOL]     if (typeAdapter instanceof InstanceCreator<?>) { [EOL]         registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonSerializer<?>) { [EOL]         registerSerializer(type, (JsonSerializer<?>) typeAdapter); [EOL]     } [EOL]     if (typeAdapter instanceof JsonDeserializer<?>) { [EOL]         registerDeserializer(type, (JsonDeserializer<?>) typeAdapter); [EOL]     } [EOL]     return this; [EOL] }
private <T> GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator) { [EOL]     instanceCreators.register(typeOfT, instanceCreator); [EOL]     return this; [EOL] }
private <T> GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer) { [EOL]     serializers.register(typeOfT, serializer); [EOL]     return this; [EOL] }
private <T> GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer) { [EOL]     serializers.register(typeOfT, serializer); [EOL]     return this; [EOL] }
private <T> GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer) { [EOL]     serializers.register(typeOfT, serializer); [EOL]     return this; [EOL] }
private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) { [EOL]     deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer)); [EOL]     return this; [EOL] }
private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) { [EOL]     deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer)); [EOL]     return this; [EOL] }
private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) { [EOL]     deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer)); [EOL]     return this; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annnotations) { [EOL]     StringBuilder translation = new StringBuilder(); [EOL]     for (int i = 0; i < target.length(); i++) { [EOL]         char character = target.charAt(i); [EOL]         if (Character.isUpperCase(character) && translation.length() != 0) { [EOL]             translation.append(separatorString); [EOL]         } [EOL]         translation.append(character); [EOL]     } [EOL]     return translation.toString(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annnotations) { [EOL]     StringBuilder translation = new StringBuilder(); [EOL]     for (int i = 0; i < target.length(); i++) { [EOL]         char character = target.charAt(i); [EOL]         if (Character.isUpperCase(character) && translation.length() != 0) { [EOL]             translation.append(separatorString); [EOL]         } [EOL]         translation.append(character); [EOL]     } [EOL]     return translation.toString(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annnotations) { [EOL]     StringBuilder translation = new StringBuilder(); [EOL]     for (int i = 0; i < target.length(); i++) { [EOL]         char character = target.charAt(i); [EOL]         if (Character.isUpperCase(character) && translation.length() != 0) { [EOL]             translation.append(separatorString); [EOL]         } [EOL]         translation.append(character); [EOL]     } [EOL]     return translation.toString(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annnotations) { [EOL]     StringBuilder translation = new StringBuilder(); [EOL]     for (int i = 0; i < target.length(); i++) { [EOL]         char character = target.charAt(i); [EOL]         if (Character.isUpperCase(character) && translation.length() != 0) { [EOL]             translation.append(separatorString); [EOL]         } [EOL]         translation.append(character); [EOL]     } [EOL]     return translation.toString(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annnotations) { [EOL]     StringBuilder translation = new StringBuilder(); [EOL]     for (int i = 0; i < target.length(); i++) { [EOL]         char character = target.charAt(i); [EOL]         if (Character.isUpperCase(character) && translation.length() != 0) { [EOL]             translation.append(separatorString); [EOL]         } [EOL]         translation.append(character); [EOL]     } [EOL]     return translation.toString(); [EOL] }
public ObjectTypePair push(ObjectTypePair obj) { [EOL]     Preconditions.checkNotNull(obj); [EOL]     return stack.push(obj); [EOL] }
public ObjectTypePair push(ObjectTypePair obj) { [EOL]     Preconditions.checkNotNull(obj); [EOL]     return stack.push(obj); [EOL] }
public ObjectTypePair pop() { [EOL]     return stack.pop(); [EOL] }
public ObjectTypePair pop() { [EOL]     return stack.pop(); [EOL] }
public ObjectTypePair peek() { [EOL]     return stack.peek(); [EOL] }
public ObjectTypePair peek() { [EOL]     return stack.peek(); [EOL] }
public Class<?> getDeclaringClass() { [EOL]     return declaringClazz; [EOL] }
public Type getDeclaredType() { [EOL]     if (genericType == null) { [EOL]         genericType = field.getGenericType(); [EOL]     } [EOL]     return genericType; [EOL] }
public Type getDeclaredType() { [EOL]     if (genericType == null) { [EOL]         genericType = field.getGenericType(); [EOL]     } [EOL]     return genericType; [EOL] }
public Class<?> getDeclaredClass() { [EOL]     return declaredType; [EOL] }
public Collection<Annotation> getAnnotations() { [EOL]     if (annotations == null) { [EOL]         Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name); [EOL]         annotations = ANNOTATION_CACHE.getElement(key); [EOL]         if (annotations == null) { [EOL]             annotations = Collections.unmodifiableCollection(Arrays.asList(field.getAnnotations())); [EOL]             ANNOTATION_CACHE.addElement(key, annotations); [EOL]         } [EOL]     } [EOL]     return annotations; [EOL] }
public Collection<Annotation> getAnnotations() { [EOL]     if (annotations == null) { [EOL]         Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name); [EOL]         annotations = ANNOTATION_CACHE.getElement(key); [EOL]         if (annotations == null) { [EOL]             annotations = Collections.unmodifiableCollection(Arrays.asList(field.getAnnotations())); [EOL]             ANNOTATION_CACHE.addElement(key, annotations); [EOL]         } [EOL]     } [EOL]     return annotations; [EOL] }
@SuppressWarnings("unchecked") [EOL] private static <T extends Annotation> T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation) { [EOL]     for (Annotation a : annotations) { [EOL]         if (a.annotationType() == annotation) { [EOL]             return (T) a; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] private static <T extends Annotation> T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation) { [EOL]     for (Annotation a : annotations) { [EOL]         if (a.annotationType() == annotation) { [EOL]             return (T) a; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] private static <T extends Annotation> T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation) { [EOL]     for (Annotation a : annotations) { [EOL]         if (a.annotationType() == annotation) { [EOL]             return (T) a; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Boolean bool) { [EOL]     setValue(bool); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isBoolean() { [EOL]     return value instanceof Boolean; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isBoolean() { [EOL]     return value instanceof Boolean; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isBoolean() { [EOL]     return value instanceof Boolean; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isBoolean() { [EOL]     return value instanceof Boolean; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Boolean getAsBooleanWrapper() { [EOL]     return (Boolean) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean getAsBoolean() { [EOL]     return isBoolean() ? getAsBooleanWrapper().booleanValue() : Boolean.parseBoolean(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isPrimitiveOrString(Object target) { [EOL]     if (target instanceof String) { [EOL]         return true; [EOL]     } [EOL]     Class<?> classOfPrimitive = target.getClass(); [EOL]     for (Class<?> standardPrimitive : PRIMITIVE_TYPES) { [EOL]         if (standardPrimitive.isAssignableFrom(classOfPrimitive)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.deserialize(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.deserialize(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.deserialize(); [EOL] }
public JsonObject getAsJsonObject() { [EOL]     if (isJsonObject()) { [EOL]         return (JsonObject) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Object."); [EOL] }
public JsonObject getAsJsonObject() { [EOL]     if (isJsonObject()) { [EOL]         return (JsonObject) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Object."); [EOL] }
ObjectTypePair toMoreSpecificType() { [EOL]     if (preserveType || obj == null) { [EOL]         return this; [EOL]     } [EOL]     Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass()); [EOL]     if (actualType == type) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectTypePair(obj, actualType, preserveType); [EOL] }
ObjectTypePair toMoreSpecificType() { [EOL]     if (preserveType || obj == null) { [EOL]         return this; [EOL]     } [EOL]     Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass()); [EOL]     if (actualType == type) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectTypePair(obj, actualType, preserveType); [EOL] }
ObjectTypePair toMoreSpecificType() { [EOL]     if (preserveType || obj == null) { [EOL]         return this; [EOL]     } [EOL]     Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass()); [EOL]     if (actualType == type) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectTypePair(obj, actualType, preserveType); [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     ObjectTypePair other = (ObjectTypePair) obj; [EOL]     if (this.obj == null) { [EOL]         if (other.obj != null) { [EOL]             return false; [EOL]         } [EOL]     } else if (this.obj != other.obj) { [EOL]         return false; [EOL]     } [EOL]     if (type == null) { [EOL]         if (other.type != null) { [EOL]             return false; [EOL]         } [EOL]     } else if (!type.equals(other.type)) { [EOL]         return false; [EOL]     } [EOL]     return preserveType == other.preserveType; [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return isInnerClass(clazz); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return isInnerClass(clazz); [EOL] }
