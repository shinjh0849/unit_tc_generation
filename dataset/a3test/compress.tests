@Test public void testGzip() throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream(); new GzipCompressorOutputStream(os).write(42); assertThat(os.toString(), is("42\n")); }
@Test public void testGzip() throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream(); try (GZIPOutputStream gzipStream = new GZIPOutputStream(os)) { gzipStream.write(42); } try (GZIPOutputStream gzipStream = new GZIPOutputStream(os)) { gzipStream.write(42); } try (GZIPOutputStream gzipStream = new GZIPOutputStream(os)) { gzipStream.write(42); } try (InputStream in = new GZIPInputStream(os)) { in.read(42); } try (InputStream in = new GZIPInputStream(os)) { in.read(42); } }
@Test public void testWrite() throws IOException { byte[] b = new byte[100]; new Thread(new Runnable() { @Override public void run() { new Thread(new Runnable() { @Override public void run() { new Thread(new Runnable() { @Override public void run() { new Thread(new Runnable() { @Override public void run() { new Thread(new Runnable() { @Override public void run() { new Thread(new Runnable() { @Override public void run() { try { new Thread(new Runnable() { @Override public void run() { @Override public void run() { } }.run() { @Override public void run() { } }.run() { @Override public void run() { } }.run() { } }.run() { }.run() { }.run() { }.run() { }.run() { }.run() { }.run() { }.run() throws Exception { }.run() throws Exception { }.run() throws Exception { }.run() throws Exception { }.run() }; } }.run() { }.run() throws Exception { }.run() throws Exception { }.run() throws Exception { }.run() throws Exception { }.run() throws Exception { } }.run() }; } }.run()
@Test public void testWrite() throws IOException { byte[] b = new byte[100]; new Random().nextBytes(b); out.write(b); out.write(b); out.write(b); out.write(b); }
@Test public void close() throws IOException { new GzipCompressorOutputStream(outputStream).close(); }
@Test public void close() throws IOException { out.write(42); out.close(); verify(out).close(); }
@Test public void testClone() throws Exception { ZipLong zl; zl = new ZipLong(Long.MAX_VALUE); zl.setValue(Long.MAX_VALUE); zl.setByte(Byte.MAX_VALUE, (byte) 0); zl.setByte(Byte.MAX_VALUE, (byte) 1); zl.setByte(Byte.MAX_VALUE, (byte) 2); zl.setByte(Byte.MAX_VALUE, (byte) 2); zl.setByte(Byte.MAX_VALUE, (byte) 3); zl.setByte(Byte.MAX_VALUE, (byte) 4); zl.setByte(Byte.MAX_VALUE, (byte) 5); zl.setByte(Byte.MAX_VALUE, (byte) 6); zl.setByte(Byte.MAX_VALUE, (byte) 7); zl.setByte(Byte.MAX_VALUE, (byte) 8); zl.setByte(Byte.MAX_VALUE, (byte) 9); zl.setByte(Byte.MAX_VALUE, (byte) 12); zl.setByte(Byte.MAX_VALUE, (byte) 13
@Test public void testClone() throws IOException { ZipLong z = new ZipLong(Long.MAX_VALUE); z.setValue(Long.MAX_VALUE); z.setByte(Byte.MAX_VALUE, (byte) 0); z.setByte(Byte.MAX_VALUE, (byte) 1); z.setByte(Byte.MAX_VALUE, (byte) 2); z.setByte(Byte.MAX_VALUE, (byte) 3); z.setByte(Byte.MAX_VALUE, (byte) 4); z.setByte(Byte.MAX_VALUE, (byte) 5); z.setByte(Byte.MAX_VALUE, (byte) 6); z.setByte(Byte.MAX_VALUE, (byte) 7); z.setByte(Byte.MAX_VALUE, (byte) 8); z.setByte(Byte.MAX_VALUE, (byte) 9); z.setByte(Byte.MAX_VALUE, (byte) 12); z.setByte(Byte.MAX_VALUE, (byte) 13); z.setByte(Byte.MAX_VALUE, (byte) 14); z.setByte(Byte.MAX_VALUE, (byte) 15);
@Test public void testClone() throws Exception { ZipLong z = new ZipLong(42); z.setValue(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); z.setByte(42); try { z.clone(); fail(); } catch (RuntimeException cnfe) { } }
@Test public void testZipShort () throws IOException { ZipShort zs = new ZipShort((short) 1); byte[] bytes = zs.getBytes(); assertEquals(zs.getValue(), 2); assertEquals((short) 1, zs.getValue(bytes, 0)); assertEquals((short) 0, zs.getValue(bytes, 1)); }
@Test public void testZipShort() throws IOException { byte[] bytes=new byte[20]; ZipShort zipShort = new ZipShort(bytes); byte[] value = new byte[20]; zipShort.getValue(value, 0); assertArrayEquals(bytes, value); }
@Test public void testGetBytes() { ZipShort zysi = new ZipShort(Short.MAX_VALUE); byte[] bytes = zysi.getBytes(); assertEquals(zip.getValue(), ZipShort.MAX_VALUE); assertEquals(zip.getValue(), ZipShort.MAX_VALUE); }
@Test public void testGetBytes() { ZipShort zy = new ZipShort(Short.MAX_VALUE); byte[] result = zy.getBytes(); assertEquals(zipShort.getValue(), ZipShort.MAX_VALUE); assertEquals(zipShort.getValue(), ZipShort.MAX_VALUE); }
@Test public void ZipShort() { byte[] bytes = new byte[] { (byte) 0x01}; ZipShort z = new ZipShort(bytes); byte[] result = z.getBytes(); assertEquals(zip.getValue(), ZipShort.getValue(result, 0)); assertEquals(zip.getValue(), ZipShort.getValue(result, 1)); assertEquals(zip.getBytes(zip.getValue()), ZipShort.getValue(result, 2)); assertEquals(zip.getBytes(zip.getValue()), ZipShort.getValue(result, 3)); assertEquals(zip.getBytes(zip.getValue()), ZipShort.getValue(result, 4)); }
@Test public void testGetBytes() { byte[] result = new byte[2]; result[0] = (byte) (value & BYTE_1_MASK); result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); result[3] = (byte) (value & BYTE_1_MASK); assertThat(result).isEqualTo(zipShort); }
@Test public void testGetBytes() { ZipShort zy = new ZipShort(1234); byte[] bytes = zy.getBytes(); assertEquals(1234, bytes.length); assertEquals(1234, zy.getValue()); }
@Test public void testCreateArchiveInputStream() throws Exception { try { final String archiveName = "ar.zip"; final String zipName = "zip.zip"; final String tarName = "tar.tar"; final String jarName = "jar.jar"; final String cpioName = "cpio"; final String cpioVersion = "cpio"; final ByteArrayInputStream in = new ByteArrayInputStream(zipName.getBytes()); final ArchiveInputStream archiveInputStream = sut.createArchiveInputStream(arName, in); try { archiveInputStream.read(in); fail("expected exception not thrown"); } catch (ArchiveException e) { } try { archiveInputStream.read(in); fail("expected exception not thrown"); } catch (ArchiveException e) { } try { archiveInputStream.read(in); fail("expected exception not thrown"); } catch (ArchiveException e) { } try { archiveInputStream.read(cpioName, in); fail("expected exception not thrown"); } catch (ArchiveException e) { } try { archiveInputStream.read(cpioVersion, in); fail("expected exception not thrown"); } catch (ArchiveException e) { } try { archiveInputStream.read(cpioName, in); fail("expected exception not
@Test public void testExtractZip() throws Exception { try ( ZipFile z = new ZipFile(zipFile)) { z.extract(zipFile); } }
@Test public void testEncoding() throws Exception { File f = FileHelper.findFile("zip.zip"); ZipFile z = new ZipFile(f); z.close(); }
@Test public void testEncoding() throws Exception { ZipFile z = new ZipFile(zipFile); assertEquals("UTF-8", z.getZipEncoding()); z.close(); }
@Test public void testEncoding() throws Exception { try ( ZipFile z = new ZipFile(zipFile);) { z.addEntry("name", "This is a test"); z.addEntry("name", "This is a test"); z.addEntry("name", "This is a test"); z.addEntry("name", "This is a test"); } }
@Test public void testExtractZip() throws Exception { File f = testFolder.newFile("testExtractZip.zip"); ZipFile z = new ZipFile(f); try { z.extractZip(testFolder.getRoot(), "UTF-8"); } catch (ZipException e) { fail("ExtractZip failed with exception: " + e); } z.close(); }
@Test public void testExtractZip() throws Exception { File f = FileHelper.findFile("zip.zip"); ZipFile z = new ZipFile(f); try { z.extract(new ZipEntry("zip.zip"), "UTF-8"); } catch (ZipException e) { fail("Unexpected exception: " + e); } z.close(); }
@Test public void testEncoding() throws Exception { try { ZipFile z = new ZipFile(zipFile); assertEquals("UTF-8", z.getEncoding()); z.close(); } catch (ZipException e) { fail("This test case is a bug"); } }
@Test public void testPopulateFromCentralDirectory() throws Exception { try ( ZipFile zip = new ZipFile("zip.zip")) { ZipEntry entry = zip.getEntry("zip/ZIPZIP.zip"); assertNotNull(entry); assertEquals("ZIPZIPZIP", entry.getName()); assertEquals("ZIPZIPZIPZIP", entry.getContentType()); assertEquals("ZIPZIPZIP", entry.getZipName()); assertEquals("ZIPZIPZIPZIPZIP", entry.getZipVersion()); assertEquals("ZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIP
@Test public void testResolveLocalFileHeaderData() throws Exception { try ( ZipFile zip = new ZipFile("zip.zip")) { ZipEntry entry = zip.getEntry("foo.bar"); assertNotNull(entry); assertEquals("foo", entry.getName()); assertEquals("bar", entry.getValue()); } try ( ZipFile zip = new ZipFile("zip.zip")) { ZipEntry entry = zip.getEntry("foo.bar"); assertNotNull(entry); assertEquals("foo", entry.getName()); assertEquals("bar", entry.getValue()); } try ( ZipFile zip = new ZipFile("zip.zip")) { ZipEntry entry = zip.getEntry("foo.bar"); assertNotNull(entry); assertEquals("foo", entry.getName()); assertEquals("bar", entry.getValue()); } }
@Test public void testExtractZip() throws Exception { File f = FileHelper.findFile("zip.zip"); ZipFile z = new ZipFile(f); try { z.extractZip(f); } catch (ZipException e) { fail("Extract zip throws IOException instead of ZipException"); } }
@Test public void testEncoding() throws Exception { File f = FileHelper.findFile("zip.zip", "UTF-8"); ZipFile z = new ZipFile(f); try { z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); z.createEntry("test", "test"); try { z.createEntry("test", "test"); } catch (ZipException e) { fail("zip exception should not be thrown"); } } finally { f.delete(); } }
@Test public void testEncodingSpecifiedInNameAndComment() throws Exception { File f = File.createTempFile("zip", ".zip"); f.deleteOnExit(); try ( ZipFile z = new ZipFile(f)) { z.createEntry("a", "text/plain"); z.createEntry("a", "text/plain"); z.createEntry("a", "text/plain"); z.createEntry("a", "text/plain"); z.createEntry("a", "text/plain"); z.createEntry("a", "text/plain"); z.close(); } }
@Test public void testEncoding() throws Exception { ZipFile z = new ZipFile("foo.zip"); z.close(); z.close(); }
@Test public void testCloseQuietly() throws Exception { ZipFile z = new ZipFile("foo"); try { z.close(); fail("Should throw IOException"); } catch (IOException e) { } ZipFile z2 = new ZipFile("foo"); try { z2.close(); fail("Should throw IOException"); } catch (IOException e) { } z.close(); z2.close(); z.close(); }
@Test public void testCloseQuietly() throws Exception { ZipFile z = new ZipFile("foo"); z.close(); z.close(); }
@Test public void testCloseQuietly() throws Exception { ZipFile z = new ZipFile("foo"); try { z.close(); } catch (ZipException e) { fail("expected exception: " + e); } z.close(); }
@Test public void testCloseQuietly() throws Exception { ZipFile z = new ZipFile("foo"); z.close(); }
@Test public void testEncodingSpecifiedInConstructor() throws Exception { String name = "name.zip"; ZipFile z = new ZipFile(name); Enumeration e = z.getEntries(); while (e.hasMoreElements()) { ZipEntry e = (Entry) e.nextElement(); String encoding = e.getEncoding(); if (encoding.startsWith("UTF-8")) { assertEquals("UTF-8", encoding); } else { assertEquals("UTF-8", encoding); } } }
@Test public void testZipEntryEncoding() throws Exception { String name = "foo.zip"; ZipFile z = new ZipFile(name); Enumeration e = z.getEntries(); while (e.hasMoreElements()) { ZipEntry e = (Entry) e.nextElement(); String name = e.getName(); if (name.startsWith("zip")) { break; } } assertTrue(name.contains("foo.zip")); assertTrue(name.contains("foo.zip")); }
try { populateFromCentralDirectory(); } catch (IOException e) { fail("should throw an exception"); } }
),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
try { populateFromCentralDirectory(); } catch (IOException e) { } }
) public,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Test public void populateFromCentralDirectory() throws IOException { try { populateFromCentralDirectory(); fail("did not throw exception"); } catch (IOException ex) { } }
) public void populateFromCentralDirectory_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip_zip
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { populateFromCentralDirectory(); } catch (IOException e) { }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { }
) public void populateFromCentralDirectory() throws IOException, URISyntaxException, URISyntaxException, URISyntaxException, URISyntaxException, URISyntaxException, URISyntaxException, URISyntaxException, URISyntaxException, URISyntaxException, URI, URI, URI, URI, URI, URI, URI,, URI,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { ZipEntry entry = new ZipEntry("versionMadeBy"); entry.setFile("versionMadeBy"); entry.setFile("versionMadeBy"); entry.setFile("versionMadeBy"); entry.setPlatform("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMadeBy"); new File("").setFile("versionMade
try { populateFromCentralDirectory(); } catch (IOException e) { } }
@Test public void populateFromCentralDirectory() throws IOException { byte[] cfh = new byte[WORD]; byte[] signature = new byte[WORD]; byte[] cfhSig = new byte[CFH_LEN]; byte[] signatureBytes = new byte[WORD]; byte[] signature = new byte[ZipArchiveOutputStream.CFH_SIG]; try (InputStream fis = new FileInputStream(zipFile)) { int actual = populateFromCentralDirectory(fis, signature, cfhSig, signatureBytes, signature); assertEquals(actual, 0, "can't corrupt corrupt archive."); } }
@Test public populateFromCentralDirectory() throws Exception { populateFromCentralDirectory(); }
populateFromCentralDirectory() throws IOException { populateFromCentralDirectory(); }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
public void populateFromCentralDirectory() throws IOException { final File temp = File.createTempFile("temp", "populateFromCentralDirectory"); temp.deleteOnExit(); try (OutputStream out = new OutputStream(temp)) { out.write("Z"); out.write("Z"); out.write("Z"); } try (ZipInputStream in = new ZipInputStream(temp)) { in.read(); } try (ZipZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp)) { in.read(); } try (ZipArchiveInputStream in = new ZipArchiveInputStream(temp
try { populateFromCentralDirectory(); } catch (IOException e) { }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { ZipEntry zipEntry = new ZipEntry("zip"); zipEntry.setsetSize((long) (zipEntry.getSize())); zipEntry.setSize((long) (zipEntry.getSize())); }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Test public void populateFromCentralDirectory() throws IOException { try { populateFromCentralDirectory(); fail("did not throw exception"); } catch (IOException ex) { } }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
) public void populateFromCentralDirectory() throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalFieldException, IllegalField,, Illegal,, Illegal,,, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
)) public))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { ZipEntry entry = new ZipEntry("version"); entry.setLength(Short.MAX_VALUE); entry.setEntry(entry); ZipEntry entry2 = new ZipEntry("version2"); entry2.setLength(Short.MAX_VALUE); entry2.setEntry(entry2); try { populateFromCentralDirectory(); fail("no exception"); } catch (IOException ioe) { } }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { ZipEntry entry = new ZipEntry("version"); entry.setNextByte(entry); ZipEntry entry2 = new ZipEntry("version2"); entry2.setNextByte(entry2); entry2.setNextByte(entry2); try { populateFromCentralDirectory(); fail("no exception"); } catch (IOException ioe) { } }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { }
try { populateFromCentralDirectory(); } catch (IOException e) { }
try { ZipEntry ze = new ZipEntry("zipfile"); ze.setLength(zipfile.length()); ze.setEntryName(zipfile.getName()); populateFromCentralDirectory(); }
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { populateFromCentralDirectory(); } catch (IOException e) { }
try { populateFromCentralDirectory(); } catch (IOException e) { } }
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { comment = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
try { ZipEntry entry = new ZipEntry("comment"); entry.setLength(Long.MAX_VALUE); entry.setComment("comment"); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setComment("comment"); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setComment("comment"); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setComment("comment"); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setComment("comment"); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setComment("comment"); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipFile(zipFile).setEntry(entry); new ZipEntry("comment").setEntry(entry); new ZipFile(zipFile).setEntry
try { populateFromCentralDirectory(); } catch (IOException e) { } }
try { populateFromCentralDirectory(); } catch (IOException e) { } }
]]]]]]]]]]]]]],,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray())); ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchiveInputStream); zipArchiveOutputStream.close(); try { new PositionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream.close(); try { new PositionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream = new ZipArchiveInputStream(zipArchiveInputStream); zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchiveOutputStream); zipArchiveOutputStream.close(); try { new PositionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.close(); ZipArchiveInputStream zipInputStream = new ZipArchiveInputStream(zipFile); zipInputStream.close(); byte[] data = new byte[zipFile.length()]; zipInputStream.read(data); zipInputStream.close(); byte[] expected = new byte[zipFile.length()]; zipInputStream = new ZipArchiveInputStream(zipFile); zipInputStream.read(expected); zipInputStream.close(); zipFile = new File("test.zip"); zipInputStream = new ZipArchiveInputStream(zipFile); zipInputStream.close(); byte[] actual = new byte[zipFile.length()]; zipInputStream.read(actual); zipInputStream.close(); zipFile = new File("test.zip"); zipInputStream = new ZipArchiveInputStream(zipFile); zipInputStream.close(); zipFile = new File("test.zip"); try { new PositionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException ioe) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = Mockito.mock(ZipArchiveInputStream.class); Mockito.when(zipArchiveInputStream.read()).thenReturn(-1); Mockito.when(zipArchiveInputStream.read()).thenReturn(-1); ZipArchiveOutputStream zipArchiveOutputStream = Mockito.mock(ZipArchiveOutputStream.class); Mockito.when(zipArchive.length()).thenReturn(ZipArchiveOutputStream.MAX_EOCD_SIZE); Mockito.when(zipArchive.read()).thenReturn(-1); Mockito.when(zipArchiveOutputStream.write(Mockito.anyInt())).thenReturn(-1); Mockito.when(zipArchive.write(Mockito.anyInt())).thenReturn(-1); ZipArchiveInputStream zipInputStream = Mockito.mock(ZipArchiveInputStream.class); Mockito.when(zipArchiveInputStream.read()).thenReturn(-1); Mockito.when(zipArchiveInputStream.read()).thenReturn(-1); ZipArchiveInputStream zipArchiveInputStream2 = Mockito.mock(ZipArchiveInputStream.class); Mockito.when(zipArchiveInputStream2.read()).thenReturn(-1); Mockito.when(zipArchiveInputStream2.read()).thenReturn(-1); Mockito.when(zipArchiveInputStream.read()).thenReturn(-1); ZipArchiveOutputStream zipArchiveOutputStream2 = Mockito
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(new ByteArrayInputStream(zip.toByteArray())); zipArchiveOutputStream.close(); ZipArchiveInputStream zipInputStream = new ZipArchiveInputStream(zipArchiveOutputStream.getInputStream()); zipInputStream.close(); try { positionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveOutputStream = new ZipArchiveOutputStream(new ByteArrayInputStream(zip.toByteArray())); zipArchiveOutputStream.close(); try { positionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveOutputStream = new ZipArchiveOutputStream(new ByteArrayInputStream(zip.toByteArray())); try { positionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveOutputStream = new ZipArchiveOutputStream(new ByteArrayInputStream(zip.toByteArray())); try { positionAtCentralDirectory(); fail("Expected IOException"); } catch (IOException e) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray()) ); zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream).read(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream).read(); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream); fail("Expected IOException"); } catch (IOException e) { } zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream); fail("Expected IOException"); } catch (IOException e) { } }
@Test public void testSeekAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray())); ZipArchiveInputStream zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveTester(zipArchiveInputStream, zipArchiveOutputStream2).test(); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveTester(zipArchiveInputStream2, zipArchiveOutputStream2).test(); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveTester(zipArchiveInputStream2, zipArchiveOutputStream2).test(); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveTester(zipArchiveInputStream2, zipArchiveOutputStream2).test(); fail("Expected IOException"); } catch (IOException ioe) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.writeCentralDirectory(); zipArchiveOutputStream.close(); byte[] sig = ZipArchiveOutputStream.EOCD_SIG; zipArchiveOutputStream.writeCentralDirectory(); zipArchiveOutputStream.close(); byte[] positionAtCentralDirectory = new byte[zipFile.length()]; zipArchiveOutputStream.writeCentralDirectory(positionAtCentralDirectory); zipArchiveOutputStream.close(); zipFile = new File(zipFile.getParentFile(), ZipArchiveOutputStream.EOCD_NAME); zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchiveOutputStream); zipArchiveOutputStream.close(); zipFile = new File(zipFile.getParentFile(), ZipArchiveOutputStream.EOCD_NAME); zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchiveOutputStream); zipArchiveOutputStream.close(); byte[] positionAtCentralDirectory = new byte[zipFile.length()]; zipArchiveOutputStream.writeCentralDirectory(positionAtCentralDirectory); zipArchiveOutputStream.close(); byte[] positionAtCentralDirectory2 = new byte[zipFile.length()]; zipArchiveOutputStream.writeCentralDirectory(positionAtCentralDirectory2); zip
@Test public void testPositionAtCentralDirectory() throws IOException { byte[] data = new byte[100]; Arrays.fill(data, (byte) 'a'); ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream(new ByteArrayInputStream(data)); zipArchiveInputStream.seek(0); int curr = zipArchiveInputStream.read(); Assert.assertEquals(data[100], curr); zipArchiveInputStream.close(); byte[] data2 = new byte[100]; Arrays.fill(data2, (byte) 'b'); zipArchiveInputStream = new ZipArchiveInputStream(new ByteArrayInputStream(data2)); zipArchiveInputStream.seek(0); int curr = zipArchiveInputStream.read(); Assert.assertEquals(data[100], curr); }
try { byte[] zip = ZipArchiveOutputStream.EOCD_ZIP.getBytes(); ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zip); zipArchive.write(zip); zipArchiveOutputStream.close(); byte[] positionAtCentralDirectory = new byte[zip.length() - MIN_EOCD_SIZE]; ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchive); zipArchiveOutputStream.write(positionAtCentralDirectory); zipArchiveOutputStream.close(); byte[] positionAtCentralDirectory2 = new byte[zip.length() - MAX_EOCD_SIZE]; ZipArchiveOutputStream zipArchiveOutputStream2 = new ZipArchiveOutputStream(zipArchiveOutputStream2); byte[] positionAtCentralDirectory3 = new byte[zip.length() - MAX_EOCD_SIZE]; ZipArchiveOutputStream zipArchive = new ZipArchiveOutputStream(zipArchive); zipArchive.write(positionAtCentralDirectory2); zipArchive.write(positionAtCentralDirectory3); zipArchive.close(); byte[] positionAtCentralDirectory4 = new byte[zip.length() - MAX_EOCD_SIZE]; ZipArchiveOutputStream zipArchive3 = new ZipArchiveOutputStream(zipArchive3); byte[] positionAtCentralDirectory5 = new byte[zip
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.write(CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + Central
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray())); ZipArchiveInputStream zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2).read(); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.write(CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + Central
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray())); ZipArchiveInputStream zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2).read(); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.write(CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + "test"); zipArchiveOutputStream.close(); ZipArchiveInputStream zipInputStream = new ZipArchiveInputStream(zipFile); try { byte[] sig = ZipArchiveOutputStream.EOCD_SIG; zipInputStream.read(); zipInputStream.read(); zipInputStream.close(); byte[] actual = new byte[zipFile.length()]; zipInputStream.read(); zipInputStream.read(); zipInputStream.read(); zipInputStream.close(); byte[] expected = new byte[zipFile.length()]; expected[zipFile.length() - 1] = CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + "test".getBytes(); assertArrayEquals(expected, actual); } finally { zipArchiveOutputStream.close(); } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray())); ZipArchiveInputStream zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2).read(); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream2 = new ZipArchiveInputStream( new ByteArrayInputStream(zip2.toByteArray())); try { new ZipArchiveOutputStream(zipArchiveInputStream2); fail("Expected IOException"); } catch (IOException ioe) { } }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.write(CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + CentralDirectory.SEPARATOR + Central
try { positionAtCentralDirectory(); } catch (IOException ioe) { fail("expected IOException"); } }
try { positionAtCentralDirectory(); } catch (IOException e) { fail("expected exception: " + e); } }
public void testPositionAtCentralDirectory() throws IOException { ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray()) ); zipArchiveInputStream.seek(0); try { new ZipArchiveOutputStream(zipArchiveInputStream).write(zip.toByteArray()); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream.close(); zipArchiveInputStream = new ZipArchiveInputStream( new ByteArrayInputStream(zip.toByteArray()) ); try { new ZipArchiveOutputStream(zipArchiveInputStream).write(zip.toByteArray()); fail("Expected IOException"); } catch (IOException ioe) { } zipArchiveInputStream.close(); }
@Test public void testPositionAtCentralDirectory() throws IOException { ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(zipFile); zipArchiveOutputStream.writeCentralDirectory("Central Directory"); zipArchiveOutputStream.close(); zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchiveOutputStream); zipArchiveOutputStream.writeCentralDirectory("Central Directory"); zipArchiveOutputStream.close(); zipArchive = new ZipArchiveOutputStream(zipArchiveOutputStream); zipArchiveOutputStream = new ZipArchiveOutputStream(zipArchiveOutputStream); zipArchiveOutputStream.writeCentralDirectory("Central Directory"); zipArchiveOutputStream.close(); zipArchive = new ZipArchiveOutputStream(zipArchiveOutputStream); byte[] data = new byte[zipFile.length()]; zipArchive.write(data); zipArchiveOutputStream.close(); byte[] positionAtCentralDirectory = new byte[zipFile.length() - MIN_EOCD_SIZE]; positionAtCentralDirectory[zipFile.length() - 1] = 0; positionAtCentralDirectory[zipFile.length() - 1]; positionAtCentralDirectory[zipFile.length() - 1]; positionAtCentralDirectory[zipFile.length() - 2]; positionAtCentralDirectory[zipFile.length() - 3]; positionAtCentralDirectory[zipFile.length()
@Test public void test_position_atCentralDirectory() throws IOException { byte[] cfdOffset = new byte[WORD]; byte[] cfdOffset2 = new byte[WORD]; byte[] cfdOffset3 = new byte[WORD]; byte[] cfdOffset4 = new byte[WORD]; byte[] cfdOffset5 = new byte[WORD]; byte[] cfdOffset6 = new byte[WORD]; byte[] cfdOffset7 = new byte[WORD]; byte[] cfdOffset8 = new byte[WORD]; byte[] cfdOffset9 = new byte[WORD]; byte[] cfdOffset10 = new byte[WORD]; byte[] cfdOffset11 = new byte[WORD]; byte[] cfdOffset12 = new byte[WORD]; byte[] cfdOffset13 = new byte[WORD]; byte[] cfdOffset14 = new byte[WORD]; byte[] cfdOffset15 = new byte[WORD]; byte[] cfdOffset16 = new byte[WORD]; byte[] cfdOffset17 = new byte[WORD]; byte[] cfdOffset18 = new byte[WORD]; byte[] cfdOffset18 = new byte[WORD]; byte[] cfdOffset19 = new byte[WORD]; byte
@Test public void testPositionAtCentralDirectory() throws IOException { byte[] data = new byte[100]; Arrays.fill(data, (byte) 'a'); byte[] expected = new byte[100]; Arrays.fill(expected, (byte) 'b'); byte[] actual = new byte[100]; archive.readFully(cfdOffset); assertArrayEquals(expected, actual); }
@Test public void testSeekCentralDirectory() throws IOException { ZipLong.setValue(zipFile.getOffset()); ZipLong.setValue(zipFile.getLength()); ZipLong.setValue(zipFile.getOffset() + 1); positionAtCentralDirectory(); }
@Test public void testResolveLocalFileHeaderData() throws Exception { Map<String, ZipEntry> map = new HashMap<>(); map.put("file", new ZipEntry("file.txt")); map.put("file.txt", new ZipEntry("file.txt")); map.put("file.txt", new ZipEntry("file.txt")); map.put("file.txt", new ZipEntry("file.txt")); resolveLocalFileHeaderData(map); }
@Test public void testResolveLocalFileHeaderData() throws IOException { try ( ZipFile zip = new ZipFile(new File("src/test/resources/test-local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data/local-file-with-data"))) { ZipEntry entry = zip.getEntry("local-file"); byte[] data = entry.getData(); Map<String, ZipEntry> entriesWithoutEFS = new HashMap<>(); entriesWithoutEFS.put("local-file", entry); Enumeration e = entriesWithoutEFS.entries(); try { while (e.hasMoreElements()) {
try { resolveLocalFileHeaderData(entriesWithoutEFS); } catch (IOException e) { throw new RuntimeException(e); } }
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipArchiveEntry l1 = new ZipArchiveEntry("foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "foo", "bar", "bar", "foo", "bar", "bar", "foo", "bar", "bar", "foo", "bar", "bar", "bar", "foo", "bar", "bar", "bar", "bar", "foo", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar", "bar",
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipEntry entry1 = mock(ZipArchiveEntry.class); ZipEntry entry2 = mock(ZipArchiveEntry.class); ZipEntry entry3 = mock(ZipArchiveEntry.class); Enumeration e = mock(Enumeration.class); when(entry1.hasMoreElements()).thenReturn(true).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).when(entry1).nextElement(); when(entry2.hasMoreElements()).thenReturn(true).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).thenReturn(false).when(entry3).nextElement(); Map<OffsetEntry, OffsetEntry> offsetEntries = new HashMap<OffsetEntry, OffsetEntry>(); offsetEntries.put(entry1, new OffsetEntry(entry1)); offsetEntries.put(entry2, new OffsetEntry(entry2)); offsetEntries.put(entry3, new OffsetEntry(entry3)); offsetEntries.put(entry4, new
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipEntry entry = mock(Entry.class); ZipEntry entry2 = mock(Entry.class); ZipEntry entry3 = mock(Entry.class); Map<Long, OffsetEntry> offsets = new HashMap<Long, OffsetEntry>(); offsets.put(0L, new OffsetEntry(0L)); offsets.put(1L, new OffsetEntry(1L)); offsets.put(2L, new OffsetEntry(2L)); offsets.put(3L, new OffsetEntry(3L)); offsets.put(4L, new OffsetEntry(4L)); Map<Long, OffsetEntry> entriesWithoutEFS = new HashMap<Long, OffsetEntry>(); entriesWithoutEFS.put(0L, new OffsetEntry(0L)); entriesWithoutEFS.put(4L, new OffsetEntry(0L)); entriesWithoutEFS.put(4L, new OffsetEntry(0L)); resolveLocalFileHeaderData(entriesWithoutEFS); }
try { resolveLocalFileHeaderData(entriesWithoutEFS); } catch (IOException ioe) { fail("should not fail resolveLocalFileHeaderData"); } }
try { resolveLocalFileHeaderDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataDataData(inout).invoke(); }
try { resolveLocalFileHeaderData(entriesWithoutFS); }
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipArchive archive = new ZipArchive(); archive.setEntrySize(ZIP_FILE_HEADER_SIZE); archive.setEntrySize(ZIP_FILE_HEADER_SIZE + 2); archive.setEntrySize(ZIP_FILE_HEADER_SIZE + 2); Map entriesWithoutEFS = new HashMap(); entriesWithoutEFS.put(ZIP_FILE_HEADER_SIZE, ZipShort.getValue(ZIP_FILE_HEADER_SIZE)); resolveLocalFileHeaderData(entriesWithoutEFS); }
try { resolveLocalFileHeaderData(entriesWithoutFS); }
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipArchiveEntry entry1 = new ZipArchiveEntry("foo", "bar", "baz.txt", "foo/bar"); ZipArchiveEntry entry2 = new ZipArchiveEntry("foo", "bar", "baz.txt", "foo/bar"); ZipArchiveEntry entry3 = new ZipArchiveEntry("foo", "bar", "baz.txt", "foo/bar"); ZipArchiveEntry entry4 = new ZipArchiveEntry("foo", "bar", "baz.txt", "foo/bar"); ZipArchiveEntry entry5 = new ZipArchiveEntry("foo", "bar", "baz.txt", "foo/bar"); Map<byte[], byte[]> entriesWithoutEFS = new HashMap<byte[], byte[]>(); entriesWithoutEFS.put(entry1.headerOffset, (byte) 0); entriesWithoutEFS.put(entry2.headerOffset, (byte) 0); entriesWithoutEFS.put(entry3.headerOffset, (byte) 0); entriesWithoutEFS.put(entry4.headerOffset, (byte) 0); entriesWithoutEFS.put(entry5.headerOffset, (byte) 0); entriesWithoutEFS.put(entry6.headerOffset,
@Test public void testResolveLocalFileHeaderData() throws IOException { try { resolveLocalFileHeaderData(entriesWithoutEFS); fail("expected to throw exception"); } catch (RuntimeException e) { } }
try { resolveLocalFileHeaderData(entriesWithoutEFS); } catch (IOException e) { throw new RuntimeException(e); } }
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipArchiveEntry entry1 = new ZipArchiveEntry("foo", "bar", "foobar.gz"); ZipArchiveEntry entry2 = new ZipArchiveEntry("foo", "bar", "foobar.bz2"); ZipArchiveEntry entry3 = new ZipArchiveEntry("foo", "bar", "foobar.bz3"); ZipEntry entry4 = new ZipEntry("foo", "bar", "foobar.bz4"); try { resolveLocalFileHeaderData(Collections.singletonMap(entry1, entry2))); fail("no exception"); } catch (RuntimeException e) { } }
try { resolveLocalFileHeaderData(entriesWithoutEFS); } catch (IOException e) { throw new RuntimeException(e); } }
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(ZIP_DATA.getBytes())); ZipEntry entry; try { entry = zis.createEntry("foo"); } catch (IOException ioe) { throw new RuntimeException(ioe); } try { entry = zis.createEntry("foo"); } catch (IOException ioe) { throw new RuntimeException(ioe); } try { entry = zis.createEntry("foo"); } catch (IOException ioe) { throw new RuntimeException(ioe); } try { entry = zis.createEntry("foo"); } catch (IOException ioe) { throw new RuntimeException(ioe); } Map entriesWithoutEFS = new HashMap(); entriesWithoutEFS.put("foo", "bar"); resolveLocalFileHeaderData(entriesWithoutEFS); ZipEntry entry2 = zis.createEntry("foo2"); try { entry2 = zis.createEntry("foo2"); } catch (IOException ioe) { throw new RuntimeException(ioe); } try { entry2 = zis.createEntry("foo3"); } catch (IOException ioe) { throw new RuntimeException(ioe); } try { entry2
try { resolveLocalFileHeaderData(entriesWithoutEFS); } catch (IOException e) { throw new RuntimeException(e); } }
try { resolveLocalFileHeaderData(ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIPZIP_ZIPZIP_ZIPZIPZIP_ZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIPZIP
try { resolveLocalFileHeaderData(ZIP_ZIP_ZIP_ZIP_ZIP); } catch (IOException e) { throw new RuntimeException(e); } }
@Test public void testResolveLocalFileHeaderData() throws IOException { ZipEntry entry = new OffsetEntry(); entry.dataOffset = offsetEntry.dataOffset; ZipEntry entry2 = new OffsetEntry(); entry2.dataOffset = offsetEntry2.dataOffset; Map<ZipArchiveEntry, OffsetEntry> map = new HashMap<>(); map.put(entry, offsetEntry); map.put(entry2, offsetEntry2); resolveLocalFileHeaderData(map); }
@Test public void testResolveLocalFileHeaderData() throws IOException { Map<OffsetEntry, OffsetEntry> map = new HashMap<>(); map.put(new OffsetEntry(0, (byte) 0) { @Override public long getOffset() { return 0; } @Override public void skipBytes(long lenToSkip) { } @Override public void setEntry(OffsetEntry entry) { throw new UnsupportedOperationException(); } @Override public void closeEntry() throws IOException { throw new UnsupportedOperationException(); } }); resolveLocalFileHeaderData(map); }
@Test public void testAbstractUnicodeExtraField() throws Exception { byte[] bytes = new byte[TEST_DATA.length]; AbstractUnicodeExtraField a = new AbstractUnicodeExtraField(TEST_DATA, bytes, 0, bytes.length); assertEquals(TEST_DATA.length, a.getNameCRC32()); assertEquals(TEST_DATA, a.getUnicodeName()); assertArrayEquals(TEST_DATA, a.getData()); }
@Test public void testExtraField() throws Exception { byte[] bytes = "test".getBytes("UTF-8"); AbstractUnicodeExtraField extraField = new TestAbstractUnicodeExtraField() { @Override protected void assembleData() { } }; byte[] result = extraField.getUnicodeName(); byte[] result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicodeName(); assertArrayEquals("test", result2); result2 = extraField.getUnicode
@Test public void testCrc32() throws Exception { byte[] bytes = new byte[] { (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte) 0x4E, (byte)
@Test public void testExtraField() throws Exception { byte[] data = "0123456789".getBytes("UTF-8"); AbstractUnicodeExtraField dummy = new DummyUnicodeExtraField("test", data); byte[] result = dummy.getCrc32().getValue(); byte[] result2 = dummy.getCrc32().getValue(); assertEquals("test crc32 update", result, result2); dummy.setNameCRC32(123456L); result2 = dummy.getCrc32().getValue(); assertEquals("123456 crc32 update", result2, result2); dummy.setUnicodeName(new byte[] { (byte) 0xFB, (byte) 0xFB }); result2 = dummy.getCrc32().getValue(); assertEquals("123456 crc32 update", result2, result2); dummy.setUnicodeName(new byte[] { (byte) 0xFB, (byte) 0xFB }); result2 = dummy.getCrc32().getValue(); assertEquals("123456 crc32 update", result2, result2); dummy.setUnicodeName(new byte[] { (byte) 0xFB, (byte) 0xFB }); result2 = dummy.getCrc32().getValue(); assertEquals("123456 crc32 update", result2, result2);
@Test public void testExtraField() throws Exception { byte[] data = "testExtraField".getBytes("UTF-8"); AbstractUnicodeExtraField dummy = new DummyUnicodeExtraField(data); byte[] result = dummy.getNameCRC32(); byte[] result2 = dummy.getUnicodeName(); assertArrayEquals(data, result2); result = dummy.getUnicodeName(); assertArrayEquals(data, result2); result2 = dummy.getUnicodeName(); assertArrayEquals(data, result2); result2 = dummy.getUnicodeName(); assertArrayEquals(data, result2); result2 = dummy.getUnicodeName(); assertArrayEquals(data, result2); result2 = dummy.getUnicodeName(); assertArrayEquals(data, result2); }
@Test public void testExtraField() throws Exception { byte[] data = "This is a test.".getBytes("UTF-8"); AbstractUnicodeExtraField dummy = new TestExtraField(data); dummy.setNameCRC32(0x1234); dummy.setUnicodeName("test"); byte[] result = dummy.getData(); assertEquals(0x1234, result[0]); dummy.parseFromLLEGAL(data); assertEquals(0x1234, result[0]); result = dummy.getData(); assertEquals(0x1234, result[1]); }
@Test public void testAbstractUnicodeExtraField() throws Exception { byte[] bytes = "test".getBytes("UTF-8"); AbstractUnicodeExtraField abstractUnicodeExtraField = new AbstractUnicodeExtraField() { @Override protected byte[] getUnicodeName() { return bytes; } }; abstractUnicodeExtraField.setUnicodeName(unicodeName); byte[] result = abstractUnicodeExtraField.getUnicodeName(); assertEquals(result.length, 4); assertEquals(result[0], "test"); }
@Test public void assembleData() throws Exception { byte[] data = new byte[5 + nameCRC32.length]; System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); byte[] data2 = new byte[5 + unicodeName.length]; System.arraycopy(unicodeName, 0, data2, 5, 4); byte[] assembleData = new byte[5 + nameCRC32.length]; assembleData[0] = 0x01; assembleData[1] = 0x02; assembleData[2] = 0x03; assembleData[3] = 0x04; assembleData[4] = 0x05; assertEquals(nameCRC32, assembleData[0]); assertEquals(unicodeName, assembleData[1]); assertEquals(zipShort, assembleData[2]); assertEquals(zipShort, assembleData[3]); assertEquals(zipShort, assembleData[4]); assertEquals(zipShort, assembleData[5]); assertEquals(zipShort, assembleData[5 + unicodeName.length]); }
@Test public void assembleData() throws Exception { byte[] data = new byte[5 + nameCRC32.length]; byte[] data2 = new byte[5 + nameCRC32.length]; System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); System.arraycopy(unicodeName, 0, data2, 5, nameCRC32.length); byte[] result = new byte[5 + unicodeName.length]; result[0] = 0x01; result[1] = 0x00; result[2] = 0x00; result[3] = 0x00; result[4] = 0x00; result[5] = 0x00; result[6] = 0x00; result[7] = 0x00; result[8] = 0x00; result[9] = 0x00; result[10] = 0x00; result[11] = 0x00; result[12] = 0x00; result[13] = 0x00; result[102] = 0x00; result[14] = 0x00; result[15] = 0x00; result[16] = 0x00; result[17] = 0x00; result[18] = 0x00
@Test public void assembleData() throws Exception { byte[] data = new byte[5 + unicodeName.length]; System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); byte[] result = new byte[5 + unicodeName.length]; result[0] = 0x01; result[1] = 0x01; result[2] = 0x01; result[3] = 0x01; result[4] = 0x01; result[5] = 0x01; result[6] = 0x01; result[7] = 0x01; result[8] = 0x01; result[9] = 0x01; result[10] = 0x01; result[11] = 0x01; result[10] = 0x01; result[12] = 0x01; result[13] = 0x01; result[14] = 0x01; result[15] = 0x01; result[16] = 0x01; result[17] = 0x01; result[18] = 0x01; result[19] = 0x01; result[20] = 0x01; result[21] = 0x01; result[22] = 0x01;
@Test public void assembleData() throws Exception { byte[] data = new byte[5 + nameCRC32.length]; System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); byte[] result = new byte[5 + unicodeName.length]; result[0] = 0x01; result[1] = 0x01; result[2] = 0x01; result[3] = 0x01; result[4] = 0x01; result[5] = 0x01; result[6] = 0x01; result[7] = 0x01; result[8] = 0x01; result[9] = 0x01; result[10] = 0x01; result[11] = 0x01; result[10] = 0x01; result[12] = 0x01; result[13] = 0x01; result[14] = 0x01; result[15] = 0x01; result[16] = 0x01; result[17] = 0x01; result[18] = 0x01; result[19] = 0x01; result[20] = 0x01; result[21] = 0x01; result[22] = 0x
@Test public void assembleData() throws Exception { byte[] data = new byte[5 + nameCRC32.length]; System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); byte[] result = ZipLong.getBytes(nameCRC32); result[0] = 0x01; result[1] = 0x01; result[2] = 0x01; result[3] = 0x01; result[4] = 0x01; result[5] = 0x01; result[6] = 0x01; result[7] = 0x01; result[8] = 0x01; result[9] = 0x01; result[10] = 0x01; result[11] = 0x01; result[10] = 0x01; result[12] = 0x01; result[13] = 0x01; result[14] = 0x01; result[15] = 0x01; result[16] = 0x01; result[17] = 0x01; result[18] = 0x01; result[19] = 0x01; result[20] = 0x01; result[21] = 0x01; result[22] = 0
@Test public void assembleData() throws Exception { byte[] bytes = new byte[5 + nameCRC32.length]; System.arraycopy(ZipLong.getBytes(nameCRC32), 0, bytes, 1, 4); byte[] result = ZipLong.getBytes(nameCRC32); result[0] = 0x00; result[1] = 0x00; result[2] = 0x00; result[3] = 0x00; result[4] = 0x00; result[5] = 0x00; result[6] = 0x00; result[7] = 0x00; result[8] = 0x00; result[9] = 0x00; result[10] = 0x00; result[11] = 0x00; result[12] = 0x00; result[13] = 0x00; result[102] = 0x00; result[14] = 0x00; result[15] = 0x00; result[16] = 0x00; result[17] = 0x00; result[18] = 0x00; result[19] = 0x00; result[20] = 0x00; result[21] = 0x00; result[22] = 0
@Test public void testGetNameCRC32() throws Exception { byte[] name = new byte[14]; name[0] = (byte) 0xFE; name[1] = (byte) 0xFE; name[2] = (byte) 0xFE; name[3] = (byte) 0xFE; name[4] = (byte) 0xFE; name[5] = (byte) 0xFE; name[6] = (byte) 0xFE; name[7] = (byte) 0xFE; result = instance.getNameCRC32(); assertEquals(name[0], result[0]); assertEquals(name[1], result[1]); assertEquals(name[2], result[2]); }
@Test public void testGetNameCRC32() throws Exception { assertEquals(0L, dummy.getNameCRC32()); assertEquals(0L, dummy.getNameCRC32()); assertEquals(0L, dummy.getNameCRC32()); assertEquals(0L, dummy.getNameCRC32()); assertEquals(0L, dummy.getNameCRC32()); }
@Test public void testGetUnicodeName() throws Exception { byte[] bytes = new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF, (byte) 0xCD, (byte) 0xEF, (byte) 0xBB, (byte) 0xBF, (byte) 0xCD, (byte) 0xBF, (byte) 0xEF, (byte) 0xBB, (byte) 0xBF, (byte) 0xCD, (byte) 0xBF, (byte) 0xBF, (byte) 0xCD, (byte) 0xBF, (byte) 0xBF, (byte) 0xEF, (byte) 0xBB, (byte) 0xBF, (byte) 0xBF, (byte) 0xCD, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF, (byte) 0x
@Test public void testGetUnicodeName() throws Exception { assertEquals("test", dummyZip.getUnicodeName()); }
@Test public void getCentralDirectoryData() throws Exception { byte[] result = new byte[zip.getCentralDirectoryData().length]; assertEquals(zip.getCentralDirectoryData(), result); }
@Test public void getCentralDirectoryData() throws Exception { byte[] result = new byte[zipShort.getLocalFileData().length]; zipShort.getLocalFileDataLength(); result = zip.getCentralDirectoryData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData(); assertEquals(zipShort.getLocalFileDataLength(), result.length); result = zip.getZipData();
@Test public void testAssembleData() throws Exception { byte[] data = new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF, (byte) 0xCD, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0xFE, (byte) 0
@Test public void getCentralDirectoryData() throws Exception { byte[] result = ZipMockUtil.getCentralDirectoryData(); assertEquals(result, result); result = ZipMockUtil.getLocalFileData(); assertEquals(result, result); result = ZipMockUtil.getLocalFileDataLength(); assertEquals(result, ZipMockUtil.getLocalFileDataLength()); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMockUtil.getUnicodeName(); assertEquals(result, result); result = ZipMock
@Test public void getCentralDirectoryLength() throws Exception { ZipShort zipLength = zip.getCentralDirectoryLength(); assertEquals(zipLength.getLength(), ZipShort.DEFAULT_EOL); zipLength = zip.getCentralDirectoryLength(); assertEquals(zipLength.getLength(), ZipShort.DEFAULT_EOL); zipLength = zip.getCentralDirectoryLength(); assertEquals(zipLength.getLength(), ZipShort.DEFAULT_EOL); }
@Test public void getCentralDirectoryLength() throws Exception { ZipShort zipLength = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.SIZE)))))))))))); byte[] data = new byte[zipLength.length]; ZipShort zipLength2 = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf(((byte) ZipShort.SIZE)))))); byte[] result = zip.getCentralDirectoryData(); assertEquals(zipLength, result); zip = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf(((byte) ZipShort.valueOf(((byte) ZipShort.SIZE
@Test public void testAssembleData() throws ZipException { ZipShort zipLength = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf((short) 0x7F))); byte[] data = zipLength.assembleData(); assertEquals(zipLength.length, data.length); zipLength = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf((short) 0x7F))); byte[] data2 = zipLength.assembleData(); assertEquals(zipLength.length, data2.length); zipLength = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf((short) 0x7F))); byte[] data3 = zipLength.assembleData(); assertEquals(zipLength.length, data3.length); }
@Test public void getCentralDirectoryLength() throws Exception { ZipShort zipLength = ZipShort.valueOf((byte) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((short) ZipShort.valueOf((byte) ZipShort.MAX_EOL)))))))))); byte[] data = zipLength.getCentralDirectoryData(); assertEquals(zipLength.length, data.length); }
@Test public void getLocalFileDataData() throws Exception { byte[] data = new byte[zipFile.getLocalFileDataData().length]; assertEquals(zipFile.getLocalFileDataData().length, data.length); assertEquals(zipFile.getLocalFileDataData()[0], data[0]); assertEquals(zipFile.getLocalFileDataData()[1], data[1]); assertEquals(zipFile.getLocalFileDataData()[2], data[2]); }
@Test public void getLocalFileDataData() throws Exception { byte[] data = new byte[zip.getLocalFileDataData().length]; assertEquals(zip.getLocalFileDataData().length, data.length); assertEquals(zip.getLocalFileDataData(), data); }
@Test public void getLocalFileDataLength() throws Exception { ZipShort zipLength = ZipManager.getZipManager().getLocalFileDataLength(); assertEquals(zipLength, ZipManager.getZipManager().getLocalFileDataLength()); }
@Test public void getLocalFileDataLength() throws Exception { ZipShort zipLength = ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.valueOf((byte) ZipShort.MAX_VALUE)))))))); byte[] data = new byte[zipLength.getValue()]; byte[] result = new byte[zipLength.getValue()]; result[0] = zip; result[1] = zipLength; result[2] = zipLength; result[3] = zipLength; result[4] = zipLength; assertEquals(zipLength, result[4]); assertEquals(zipLength, result[5]); assertEquals(zipLength, result[6]); assertEquals(zipLength, result[7]); }
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = "Hello world!".getBytes(); dummy.parseFromLocalFileData(data, 0, data.length); assertEquals("Hello world!", dummy.data); dummy.parseFromLocalFileData(data, 0, data.length); assertEquals("Hello world!", dummy.data); }
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = new byte[50]; data[0] = (byte) 0x01; data[1] = (byte) 0x00; data[2] = (byte) 0x00; data[3] = (byte) 0x00; data[4] = (byte) 0x00; ZipZipExtraField field = new ZipZipExtraField(); field.parseFromLocalFileData(data, 0, data.length); assertEquals(zip.getNameCRC32(), ZipLong.getValue(data, 0)); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x01 }); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x00 }); assertEquals(zip.getZipPath(), data[0]); assertEquals(zip.getZipVersion(), ZipLong.getValue(data, 0)); assertEquals(zip.getZipExtraField(), field); assertEquals(zip.getZipPath(), data[3]); assertEquals(zip.getZipVersion(), ZipLong.getValue(zip, 4)); assertEquals(zip.getZipExtraField(), field); assertEquals(zip.getZipExtraField(), field); assertEquals(zip.getZipExtraField(), field); assertEquals
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = new byte[50]; data[0] = (byte) 0x01; data[1] = (byte) 0x02; data[2] = (byte) 0x03; data[3] = (byte) 0x04; data[4] = (byte) 0x05; data[5] = (byte) 0x06; data[6] = (byte) 0x07; data[7] = (byte) 0x08; data[8] = (byte) 0xFE; data[9] = (byte) 0xFE; data[10] = (byte) 0xFE; data[11] = (byte) 0xFE; data[12] = (byte) 0xFE; data[13] = (byte) 0xFE; data[14] = (byte) 0xFE; data[14] = (byte) 0xFE; data[15] = (byte) 0xFE; data[15] = (byte) 0xFE; data[16] = (byte) 0xFE; data[17] = (byte) 0xFE; data[18] = (byte) 0xFE; data[19] =
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = "Hello world!".getBytes(); byte[] data2 = "Hello world!".getBytes(); Zip.parseFromLocalFileData(data, 0, data.length); assertEquals("Hello world!", data2); }
@Test public void testParseFromLocalFileData() throws Exception { byte[] nameCRC32 = name.getBytes(); byte[] data = nameCRC32; nameCRC32 = ZipLong.getValue(data, 0); assertEquals(nameCRC32, data.length); assertEquals(0, nameCRC32.length); }
@Test public void testParseFromLocalFileData() throws Exception { byte[] name = new byte[name.length - 5]; byte[] data = name; byte[] data2 = new byte[name.length - 5]; try { dummyZip.parseFromLocalFileData(data, 0, name.length); fail("Did not throw exception"); } catch (ZipException e) { } }
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = new byte[50]; data[0] = (byte) 0x01; data[1] = (byte) 0x02; data[2] = (byte) 0x03; data[3] = (byte) 0x04; data[4] = (byte) 0x05; data[5] = (byte) 0x06; data[6] = (byte) 0x07; data[7] = (byte) 0x08; data[8] = (byte) 0xFE; data[9] = (byte) 0xFE; data[10] = (byte) 0xFE; data[11] = (byte) 0xFE; data[12] = (byte) 0xFE; data[13] = (byte) 0xFE; data[14] = (byte) 0xFE; data[14] = (byte) 0xFE; data[15] = (byte) 0xFE; data[15] = (byte) 0xFE; data[16] = (byte) 0xFE; data[17] = (byte) 0xFE; data[18] = (byte) 0xFE; data[19] =
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = new byte[50]; data[0] = (byte) 0x80; data[1] = (byte) 0x80; data[2] = (byte) 0x80; data[3] = (byte) 0x80; data[4] = (byte) 0x80; data[5] = (byte) 0x80; data[6] = (byte) 0x80; data[7] = (byte) 0x80; data[8] = (byte) 0x80; data[9] = (byte) 0x80; Zip.parseFromLocalFileData(data, 0, data.length); assertEquals(zip.getNameCRC32(), ZipLong.getValue(zip, 0)); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x80 }); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x80 }); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x80 }); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x80 }); assertEquals(zip.getUnicodeName(), new byte[] { (byte) 0x80 }); assertEquals
@Test public void testParseFromCentralDirectoryData() throws Exception { byte[] data = new byte[zip.getLocalFileDataLength()]; data[0] = (byte) 0x80; data[1] = (byte) 0x8A; data[2] = (byte) 0x8D; data[3] = (byte) 0x8E; data[4] = (byte) 0x8A; data[5] = (byte) 0x8D; data[6] = (byte) 0x8E; data[7] = (byte) 0x8E; data[8] = (byte) 0x8E; data[9] = (byte) 0x8E; data[10] = (byte) 0x8E; data[11] = (byte) 0x8E; data[12] = (byte) 0x8E; data[13] = (byte) 0x8E; data[14] = (byte) 0x8E; data[15] = (byte) 0x8E; data[16] = (byte) 0x8E; data[17] = (byte) 0x8E; data[18] = (byte) 0x8
@Test public void testParseFromLocalFileData() throws Exception { byte[] data = new byte[zipFile.getLocalFileDataLength()]; for (int i = 0; i < data.length; i++) { data[i] = (byte) i; } byte[] result = new byte[zipFile.getLocalFileDataLength()]; zipFile.parseFromCentralDirectoryData(data, 0, data.length); assertEquals(zipFile.getLocalFileDataLength(), result.length); }
@Test public void testRemoveExtraField() throws Exception { ZipShort zipShort = ZipShort.valueOf((byte) 1); ZipExtraField[] fields = new ZipExtraField[1]; fields[0] = ZipShort.valueOf((byte) 2); ZipExtraField[] extraFields = new ZipExtraField[1]; extraFields[0] = ZipShort.valueOf((byte) 3); ZipShort type = ZipShort.valueOf((byte) 2); ZipArchiveEntry zipEntry = new ZipArchiveEntry(); zipEntry.setExtraFields(extraFields); zipEntry.setPlatform(zipShort.getPlatform()); zipEntry.setExtra(); zipEntry.setExtra(extraFields); zip.addExtraField(zipShort); zip.addExtraField(zipShort); zip.removeExtraField(zipShort); zip.removeExtraField(zipShort); }
@Test public void testRemoveExtraField() throws Exception { ZipExtrexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexexex
@Test public void testRemoveExtraField() throws Exception { ZipShort type = ZipShort.valueOf((byte) 1); ZipExtraField[] fields = new ZipExtraField[1]; fields[0] = new ZipShort(zipShort); fields[1] = new ZipShort(zipShort); ZipExtraField[] extraFields = new ZipExtraField[1]; extraFields[0] = new ZipShort(zipShort); extraFields[1] = new ZipShort(zipShort); ZipExtraField[] extraFields2 = new ZipExtraField[1]; extraFields2[0] = new ZipShort(zipShort); extraFields2[1] = new ZipShort(zipShort); ZipExtraField[] extraFields3 = new ZipExtraField[1]; extraFields3[0] = new ZipShort(zipShort); extraFields3[1] = new ZipShort(zipShort); extraFields3[2] = new ZipShort(zipShort); ZipExtraField[] extraFields4 = new ZipExtraField[1]; extraFields4.length = new ZipShort[]{zipShort}; extraFields4.length = new ZipShort[]{zipShort}; extraFields4.length = new ZipShort[]{zipShort}; ZipExtraField[] extraFields5 = new ZipExtraField[1]; extraFields5.length = new ZipShort[]{zipShort}; extraFields5.length = new Zip
@Test public void testRemoveExtraField() throws Exception { ZipShort type = new ZipShort(); try { zipArchiveEntry.removeExtraField(type); fail("expected NoSuchElementException"); } catch (NoSuchElementException e) { } }
@Test public void testRemoveExtraField() throws Exception { ZipShort type = ZipShort.getExtractType(); ZipExtraField[] fields = new ZipExtraField[1]; ZipExtraField[] extraFields = new ZipExtraField[1]; ZipShort[] type2 = new ZipShort[1]; ZipShort[] type3 = new ZipShort[2]; fields[0] = type; fields[1] = type2; fields[2] = type3; ZipShort[] type4 = new ZipShort[3]; type4.setExtra(extraFields); ZipShort[] type5 = new ZipShort[4]; type5.setExtra(extraFields); ZipShort[] type6 = new ZipShort[5]; type6.setExtra(extraFields); ZipShort[] type7 = new ZipShort[6]; type7.setExtra(extraFields); ZipShort[] type8 = new ZipShort[6]; type8.setExtra(extraFields); ZipShort[] type9 = new ZipShort[6]; type9.setExtra(extraFields); ZipShort[] type10 = new ZipShort[6]; type9.setExtra(extraFields); ZipShort[] type11 = new ZipShort[6]; type11.setExtra(extraFields); ZipShort[] type12 = new ZipShort[6]; type12.setExtra(extraFields); ZipShort[]
@Test public void testFallbackZipEncoding() throws IOException { FallbackZipEncoding fallbackZipEncoding = new FallbackZipEncoding(); byte[] data = fallbackZipEncoding.encode(null); Assert.assertEquals("Returned charset must be 'UTF-8'", "UTF-8", data); fallbackZipEncoding = new FallbackZipEncoding("US-ASCII"); data = fallbackZipEncoding.encode(null); Assert.assertEquals("Returned charset must be 'US-ASCII', US-ASCII", data); fallbackZipEncoding = new FallbackZipEncoding("US-ASCII"); data = fallbackZipEncoding.encode(null); Assert.assertEquals("Returned charset must be 'US-ASCII', US-ASCII", data); fallbackZipEncoding = new FallbackZipEncoding("US-ASCII"); data = fallbackZipEncoding.encode(null); Assert.assertEquals("Returned charset must be 'US-ASCII', US-ASCII", data); fallbackZipEncoding = new FallbackZipEncoding("US-ASCII"); data = fallbackZipEncoding.encode(null); Assert.assertEquals("Returned charset must be 'US-ASCII', US-ASCII", data); fallbackZipEncoding = new FallbackZipEncoding("
@Test public void testFallbackZipEncoding() throws IOException { FallbackZipEncoding fallbackZipEncoding = new FallbackZipEncoding(DEFAULT_CHARSET); byte[] data = new byte[DEFAULT_CHARSET.length]; Arrays.fill(data, (byte) 'a'); try { new FallbackZipEncoding(DEFAULT_CHARSET).encode(null); fail(); } catch (IOException e) { } byte[] data2 = new byte[DEFAULT_CHARSET.length]; Arrays.fill(data2, (byte) 'b'); try { new FallbackZipEncoding(DEFAULT_CHARSET).decode(null); fail(); } catch (IOException e) { } byte[] data3 = new byte[DEFAULT_CHARSET.length]; Arrays.fill(data3, (byte) 'c'); try { new FallbackZipEncoding(DEFAULT_CHARSET).decode(null); fail(); } catch (IOException e) { } byte[] data4 = new byte[DEFAULT_CHARSET.length]; Arrays.fill(data4, (byte) 'd'); try { new FallbackZipEncoding(DEFAULT_CHARSET).decode(null); fail(); } catch (IOException e) { } byte[] data5 = new byte[DEFAULT_CHARSET.length]; Arrays.fill(
@Test public void testAdjustToLong() { assertEquals(14141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414
@Test public void testAdjustToLong() { assertEquals(0, adjustToLong(-1)); assertEquals(1, adjustToLong(1)); assertEquals(2, adjustToLong(2)); assertEquals(2, adjustToLong(3)); assertEquals(2, adjustToLong(4)); assertEquals(2, adjustToLong(5)); assertEquals(2, adjustToLong(6)); assertEquals(2, adjustToLong(7)); assertEquals(2, adjustToLong(8)); assertEquals(2, adjustToLong(9)); assertEquals(2, adjustToLong(10)); assertEquals(2, adjustToLong(11)); assertEquals(2, adjustToLong(12)); assertEquals(2, adjustToLong(22)); assertEquals(2, adjustToLong(33)); assertEquals(2, adjustToLong(Integer.MAX_VALUE)); assertEquals(Integer.MAX_VALUE, adjustToLong(Integer.MIN_VALUE)); }
@Test public void testAdjustToLong() { assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(i)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(-1)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(1)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(2)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(-1)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(1)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(2)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(2)); assertEquals(22 * ((long) Integer.MAX_VALUE) + 2 + i, adjustToLong(Integer.MAX_VALUE + 1)); }
@Test public void testAdjustToLong() { assertEquals(i, adjustToLong(-1)); assertEquals(i, adjustToLong(1)); assertEquals(i, adjustToLong(2)); assertEquals(i, adjustToLong(3)); assertEquals(i, adjustToLong(4)); assertEquals(i, adjustToLong(5)); assertEquals(i, adjustToLong(6)); assertEquals(i, adjustToLong(7)); assertEquals(i, adjustToLong(8)); assertEquals(i, adjustToLong(9)); assertEquals(i, adjustToLong(10)); assertEquals(i, adjustToLong(11)); assertEquals(i, adjustToLong(22)); assertEquals(i, adjustToLong(33)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(33)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong(24)); assertEquals(i, adjustToLong
@Test public void setHeaderId() throws Exception { new ZipShort(zipShort).setHeaderId(zipShortShort); zip.setHeaderId(zipShort); assertArrayEquals(zipShort, zip.getHeaderId()); }
@Test public void setHeaderId() throws Exception { new ZipShort(zipShort).setHeaderId(zipShort); zipShort.setLocalFileDataData(localData); new ZipShort(zipShort).setCentralDirectoryData(centralData); new ZipShort(zipShort).setLocalFileDataDataLength(localData.length); new ZipShort(zipShort).setEOL(zipShort); zip.setHeaderId(zipShort); zipShort.setEOL(zipShort); }
@Test public void testGetHeaderId() { ZipShort headerId = new ZipShort(); zip.setHeaderId(headerId); assertEquals(zip.getHeaderId(), headerId); }
@Test public void testGetHeaderId() throws Exception { ZipShort result = zip.getHeaderId(); assertEquals(zip.getHeaderId(), result); }
@Test public void setLocalFileDataData() throws Exception { byte[] localFileData = new byte[zipShort.getHeaderId() + 1]; zipShort.setLocalFileDataData(localFileData); byte[] centralData = new byte[zipShort.getCentralDataLength() + 1]; zip.setLocalFileDataData(centralData); byte[] result = zip.getLocalFileDataData(); assertArrayEquals(localFileData, result); }
@Test public void setLocalFileDataData() throws Exception { byte[] localFileData = ZipUtils.copy(zipFile); zipFile.setLocalFileDataData(localFileData); zipFile.setEOL(ZipShort.EOL_MAX); zipFile.parseFromLocalFileData(localFileData, 0, localFileData.length); assertArrayEquals(zipFile.getLocalFileData(), localFileData); }
@Test public void getLocalFileDataLength() { ZipShort zipLength = ZipShort.valueOf(zipFile.getLocalFileDataLength()); zipFile.getLocalFileDataLength(); assertArrayEquals(zipLength.getBytes(), localFile.getLocalFileDataLength()); }
@Test public void getLocalFileDataLength() { ZipShort zipShort = ZipShort.valueOf((byte) ZipShort.MAX_VALUE); byte[] localFileData = zipShort.getLocalFileDataData(); assertArrayEquals(zipLocalData, localFileData); }
@Test public void getLocalFileDataData() throws Exception { byte[] localFileData = zip.getLocalFileDataData(); assertEquals(zip.getHeaderId(), ZipShort.valueOf(LOCAL_FILE_ID)); assertEquals(zip.getLocalFileDataLength(), ZipShort.valueOf(LOCAL_FILE_DATA_LENGTH)); assertEquals(localFileData, new String(localFileData)); }
@Test public void getLocalFileDataData() throws Exception { byte[] localFileData = ZipUtils.copy(zipFile); assertEquals(zipFile, localFileData); }
@Test public void testCopy() throws Exception { byte[] data = ZipUtil.copy(zip); assertEquals(zip, data); }
@Test public void testCopy() { byte[] localFileData = new byte[] { (byte) ZipShort.getHeaderId(), (byte) ZipShort.getLocalFileDataLength(), (byte) ZipShort.getCentralDirectoryLength(), (byte) ZipShort.getCentralDataLength() }; byte[] localFileData2 = new byte[] { (byte) ZipShort.getHeaderId(), (byte) ZipShort.getLocalFileDataLength(), (byte) ZipShort.getCentralDirectoryLength(), (byte) ZipShort.getCentralDataLength() }; byte[] localFileData3 = new byte[] { (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC, (byte) 0xAC,
@Test public void testCopy() throws Exception { byte[] to = new byte[LINE]; Arrays.copy(to, to); assertArrayEquals(to, new byte[LINE]); }
@Test public void testCopy() { byte[] localFileData = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0
@Test public void testCopy() throws Exception { byte[] from = new byte[zip.length]; byte[] to = new byte[zip.length]; System.arraycopy(zip, 0, to, 0, zip.length); assertArrayEquals(zip, copy); from = new byte[zip.length]; System.arraycopy(zip, 0, to, 0, zip.length); assertArrayEquals(zip, copy); from = new byte[zip.length]; System.arraycopy(zip, 0, to, 0, zip.length); assertArrayEquals(zip, copy); from = new byte[zip.length]; System.arraycopy(zip, 0, to, 0, zip.length); assertArrayEquals(zip, copy); }
@Test public void testReadGzip() throws IOException { byte[] compressed = Files.readAllBytes(GZIP_FILE_PATH); Assert.assertNotNull(compressed); Assert.assertEquals(GZIP_FILE_PATH, new File(compressed).getPath()); byte[] compressed2 = Files.readAllBytes(GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH + GZIP_FILE_PATH); Assert.assertNotNull(compressed2); Assert.assertEquals(GZIP_FILE_PATH, new File(compressed2).getPath()); }
@Test public void testReadGzip() throws IOException { String content; try (InputStream in = new GZIPInputStream(new ByteArrayInputStream(content.getBytes(UTF_8)))) { content = in.read(); } Assert.assertEquals(content, "abcde"); }
@Test public void testRead() throws IOException { byte[] input = new byte[32]; input[0] = (byte) 0x01; input[1] = (byte) 0x02; input[2] = (byte) 0x03; input[3] = (byte) 0x04; input[4] = (byte) 0x05; input[5] = (byte) 0x06; input[6] = (byte) 0x07; input[7] = (byte) 0x08; input[8] = (byte) 0x09; input[9] = (byte) 0x10; input[10] = (byte) 0x11; input[11] = (byte) 0x12; input[12] = (byte) 0x13; input[13] = (byte) 0x14; input[14] = (byte) 0x16; input[15] = (byte) 0x17; input[16] = (byte) 0x18; input[17] = (byte) 0x18; input[18] = (byte) 0x09; input[24] = (byte) 0x10; input[24] = (byte) 0x11; input[
@Test public void testRead() throws IOException { byte[] buf = new byte[10]; int n; while ((n = in.read())!= -1) { buf[n] = n; } assertEquals(10, buf[0]); assertEquals(10, in.read()); }
@Test public void testGetHeaderId() throws Exception { ZipShort headerId = new ZipShort(55); ZipShort result = zip.getHeaderId(); assertEquals(zip.getHeaderId(), result); }
@Test public void testGetHeaderId() throws Exception { ZipShort headerId = new ZipShort(zip.getHeaderId()); assertEquals(zip.getHeaderId(), ZipShort.HEADER_ID); }
@Test public void testGetCentralDirectoryLength() throws Exception { ZipShort length = ZipShort.valueOf((byte) ZipShort.MAX_VALUE); byte[] localFileData = new byte[zipFile.getLocalFileDataLength().length]; zip.getCentralDirectoryLength(); assertArrayEquals(zipFile.getLocalFileDataData(), localFileData); }
@Test public void testGetLocalFileDataLength() throws Exception { ZipShort fd = new ZipShort(1); byte[] localFileData = new byte[zipFile.getLocalFileDataLength().length]; Arrays.fill(localFileData, (byte) 0); ZipShort result = new AsiExtraField().getLocalFileDataLength(); assertEquals(zipFile.getLocalFileDataLength().length, result.getLocalFileDataLength().length); }
@Test public void testGetCentralDirectoryData() throws Exception { byte[] localFileData = new byte[zip.getCentralDirectoryData().length]; zip.getCentralDirectoryData(); assertArrayEquals(localFileData, zip.getLocalFileDataData()); }
@Test public void testGetLocalFileDataData() throws Exception { byte[] localFileData = new byte[zipFile.getLocalFileDataLength()]; zipFile.getLocalFileDataData(); assertArrayEquals(localFileData, zipFile.getLocalFileDataData()); }
@Test public void SimpleEncodingHolderTest() { char [] highChars = new char[0]; new SimpleEncodingHolder(highChars).setEncoding(new Simple8BitZipEncoding(zipEncoding)); }
@Test public void testSimpleEncodingHolder() { char[] highChars = new char[0]; SimpleEncodingHolder holder = new SimpleEncodingHolder(highChars); assertEquals(holder.getHighChars(), highChars.length); holder = new SimpleEncodingHolder(highChars); assertEquals(holder.getHighChars(), highChars.length); }
@Test public void testGetEncoding() { Simple8BitZipEncoding[] zipEncoding = new Simple8BitZipEncoding[1]; zipEncoding[0] = new Simple8BitZipEncoding(zipEncoding[1]); zipEncoding[1] = new Simple8BitZipEncoding(zipEncoding[2]); zipEncoding[2] = new Simple8BitZipEncoding(zipEncoding[3]); zipEncoding[3] = new Simple8BitZipEncoding(zipEncoding[4]); assertEquals("zip encoding", zipEncoding[0].getEncoding().getName()); assertEquals("zip encoding 2", zipEncoding[1].getEncoding().getName()); assertEquals("zip encoding 3", zipEncoding[2].getEncoding().getName()); assertEquals("zip encoding 4", zipEncoding[3].getEncoding().getName()); }
@Test public void testJarArchiveEntry() throws Exception { String name="testJarArchiveEntry"; try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { JarArchiveEntry entry=new JarArchiveEntry(name); } catch (ZipException e) { fail(e.getMessage()); } try { Jar
@Test public void testJarArchiveEntry() throws Exception { String name="testJarArchiveEntry"; JarArchiveEntry entry = new JarArchiveEntry(name); try { entry.addEntry(new JarEntry(name)); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } entry.addEntry(new JarEntry(name)); try { entry.addEntry(new JarEntry(name)); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } entry.addEntry(new JarEntry(name)); try { entry.addEntry(new JarEntry(name)); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testRegister() throws Exception { ZipExtraFi.register(ZipExtraFi.class); }
@Test public void testRegister() throws Exception { try { ZipExtraField.register(ZipExtraField.class); fail("Should have thrown an exception"); } catch (ClassNotFoundException cnfe) { } }
@Test public void testRegister() throws Exception { ZipExtraField ze = ZipExtraField.createExtraField(ZipShort.parseShort("01")); ze.register(ZipExtraField.class); }
@Test public void testRegister() throws Exception { ZipExtraField ze = new ZipExtraField(); ze.setHeaderId(ZipShort.valueOf((byte) 0)); try { ZipExtraField.register(ZipExtraField.class); fail(); } catch (ClassNotFoundException cnfe) { } }
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("1234567890") }; byte[] result = mergeLocalFileDataDataData(data); assertArrayEquals(new byte[] { (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x02, (byte) 0x04, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x02, (byte) 0x03, (byte) 0x0
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("1234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x8
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("headerId"), new ZipShort("localFileDataLength"), new ZipShort("localFileDataLength"), new ZipShort("localFileDataLength"), new ZipShort("localFileDataLength"), }; byte[] result = ZipExtraField.mergeLocalFileDataDataData(data); assertArrayEquals(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testMergeLocalFileDataData() throws Exception { ZipShort headerId = new ZipShort("00"); byte[] localFileData = new byte[16]; zipExtraField[0] = new ZipShort("00"); zipExtraField[1] = new ZipShort("00"); zipExtraField[2] = new ZipShort("00"); zipExtraField[3] = new ZipShort("00"); zipExtraField[4] = new ZipShort("00"); zipExtraField[5] = new ZipShort("00"); zipExtraField[6] = new ZipShort("00"); zipExtraField[7] = new ZipShort("00"); zipExtraField[8] = new ZipShort("00"); zipExtraField[9] = new ZipShort("00"); zipExtraField[10] = new ZipShort("00"); zipExtraField[11] = new ZipShort("00"); zipExtraField[12] = new ZipShort("00"); zipExtraField[13] = new ZipShort("00"); zipExtraField[14] = new ZipShort("00"); zipExtraField[15] = new ZipShort("00"); zipExtraField[16] = new ZipShort("00"); zipExtraField[17] = new ZipShort("00"); zipExtra
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("1234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("1234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("headerId"), new ZipShort("localFileDataLength"), new ZipShort("localFileDataLength"), new ZipShort("localFileDataLength"), new ZipShort("localFileDataLength"), }; byte[] result = ZipExtraField.mergeLocalFileDataDataData(data); assertArrayEquals(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testMergeLocalFileDataData() throws Exception { ZipShort headerId = new ZipShort("00"); byte[] localFileData = new byte[16]; localFileData[0] = (byte) 0x00; localFileData[1] = (byte) 0x00; localFileData[2] = (byte) 0x00; localFileData[3] = (byte) 0x00; zipExtraField = new ZipExtraField(headerId, localFileData); byte[] result = mergeLocalFileDataData(zipExtraField); assertArrayEquals(new byte[] { (byte) 0x00 }, result); }
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (
@Test public void testMergeLocalFileDataData() throws Exception { ZipShort headerId = new ZipShort("01"); byte[] local = new byte[] { (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x04, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x02, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x0
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (
@Test public void testMergeLocalFileDataData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new ZipShort("0023"), new ZipShort("0024"), new ZipShort("0025"), new ZipShort("0026"), new ZipShort("0027"), new ZipShort("0028"), new ZipShort("0029"), new ZipShort("00292"), new ZipShort("00293") }; byte[] result = mergeCentralDirectoryData(data
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("1234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new ZipShort("234"), new Zip
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new ZipShort("0023"), new ZipShort("0024"), new ZipShort("0025"), new ZipShort("0026"), new ZipShort("0027"), new ZipShort("0027"), new ZipShort("0028"), new ZipShort("0029"), new ZipShort("00292"), new ZipShort("00273"), new ZipShort("
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new ZipShort("0023"), new ZipShort("0024"), new ZipShort("0025"), new ZipShort("0026"), new ZipShort("0027"), new ZipShort("0028"), new ZipShort("0029"), new ZipShort("00292"), new ZipShort("0030"), new ZipShort("0035"), new ZipShort("00
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort(ZIP_HEADER_ID), new ZipShort(ZIP_HEADER_LENGTH), new ZipShort(ZIP_Central_DIRECTORY_LENGTH), new ZipShort(ZIP_Central_DIRECTORY_LENGTH + WORD), new ZipShort(ZIP_Central_DIRECTORY_LENGTH + WORD) }; byte[] result = mergeCentralDirectoryData(data); assertArrayEquals(zip(zip(zip(zip_HEADER_ID), zip(zip_HEADER_LENGTH), zip(zip_Central_DIRECTORY_LENGTH), zip(zip_Central_DIRECTORY_DATA), zip(zip(zip_Central_FILENAME)), result)), new byte[] { (byte) 0xAA, (byte) 0xBB, (byte) 0xCC, (byte) 0xDD, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (byte) 0xEE, (
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new ZipShort("0023"), new ZipShort("0024"), new ZipShort("0025"), new ZipShort("0026"), new ZipShort("0027"), new ZipShort("0027"), new ZipShort("0028"), new ZipShort("0029"), new ZipShort("00292"), new ZipShort("00273"), new ZipShort("
@Test public void mergeCentralDirectoryDataTest() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort(ZIP_HEADER_ID.getValue()), new ZipShort(ZIP_HEADER_LENGTH.getValue()), new ZipShort(ZIP_Central_DIRECTORY_LENGTH.getValue()), new ZipShort(ZIP_Central_DIRECTORY_LENGTH.getValue() + WORD), new ZipShort(ZIP_Central_DIRECTORY_LENGTH.getValue() + WORD) }; byte[] expected = new byte[] { (byte) (ZIP_HEADER_ID.getValue() + WORD) }; byte[] actual = mergeCentralDirectoryData(data); assertArrayEquals(expected, actual); }
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new ZipShort("0023"), new ZipShort("0024"), new ZipShort("0025"), new ZipShort("0026"), new byte[] { (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte
@Test public void testMergeCentralDirectoryData() throws Exception { ZipShort headerId = ZipShort.parseShort("0102"); ZipShort headerLength = ZipShort.parseShort("0103"); ZipExtraField[] data = new ZipExtraField[] { new ZipShort(headerId.getValue()), new ZipShort(headerLength.getValue()), new ZipShort(headerId.getValue() + "Z") }; byte[] local = data[0]; byte[] result = mergeCentralDirectoryData(data); assertArrayEquals(new byte[] { (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte
@Test public void mergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte)
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new ZipShort("0023"), new ZipShort("0024"), new ZipShort("0025"), new ZipShort("0026"), new ZipShort("0027"), new ZipShort("0028"), new ZipShort("0029"), new ZipShort("00292"), new ZipShort("0030"), new ZipShort("0035"), new ZipShort("00
@Test public void testMergeCentralDirectoryData() throws Exception { ZipExtraField[] data = new ZipExtraField[] { new ZipShort("001"), new ZipShort("002"), new ZipShort("003"), new ZipShort("004"), new ZipShort("005"), new ZipShort("006"), new ZipShort("007"), new ZipShort("008"), new ZipShort("009"), new ZipShort("0010"), new ZipShort("0011"), new ZipShort("0012"), new ZipShort("0013"), new ZipShort("0014"), new ZipShort("0015"), new ZipShort("0016"), new ZipShort("0017"), new ZipShort("0018"), new ZipShort("0019"), new ZipShort("0020"), new ZipShort("0021"), new ZipShort("0022"), new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte
@Test public void testSimple8BitChar() { assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\n')); assertEquals(new Simple8BitChar(code, '\r'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\n')); assertEquals(new Simple8BitChar(code, '\r'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8BitChar(code, '\n'), new Simple8BitChar(code, '\r')); assertEquals(new Simple8
@Test public void testSimple8BitChar() { Simple8BitChar f = new Simple8BitChar(7,''); assertEquals(7, f.code); assertEquals('a', f.unicode); assertEquals('a', f.code); assertEquals('a', f.unicode); assertEquals('a', f.code); assertEquals('a', f.unicode); }
@Test public void testSimple8BitChar() { Simple8BitChar f = new Simple8BitChar(1_000_000, 'x'); assertEquals(1_000_000, f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000)); assertEquals('x', f.decodeByte((byte)1_000
@Test public void testCompareTo() { Simple8BitChar f1 = new Simple8BitChar(1_F_U_LF, 'x'); Simple8BitChar f2 = new Simple8BitChar(1_F_U_LF, 'x'); Simple8BitChar f3 = new Simple8BitChar(1_F_U_LF, 'x'); Assert.assertEquals(0, f1.compareTo(f2)); Assert.assertEquals(0, f2.compareTo(f1)); Assert.assertEquals(0, f3.compareTo(f1)); Assert.assertEquals(0, f1.compareTo(f3)); Assert.assertEquals(0, f3.compareTo(f1)); Assert.assertEquals(0, f3.compareTo(f2)); Assert.assertEquals(0, f3.compareTo(f3)); }
@Test public void testCompareTo() { Simple8BitChar f = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f2 = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f3 = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f4 = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f5 = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f6 = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f7 = new Simple8BitChar(1_000_byte, 'x'); Simple8BitChar f8 = new Simple8BitChar(1_000_byte, 'x'); Assert.assertEquals(f.compareTo(f2), 0); Assert.assertEquals(f1.compareTo(f3), 0); Assert.assertEquals(f1.compareTo(f4), 0); Assert.assertEquals(f1.compareTo(f2), 0); Assert.assertEquals(f1.compareTo(f3), 0); Assert.assertEquals(f1.compareTo(f6), 0); Assert.assertEquals(
@Test public void testCompareTo() throws Exception { Simple8BitChar f1 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f2 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f3 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f4 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f5 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f6 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f7 = new Simple8BitChar((byte) 0x1F, 'x'); Simple8BitChar f8 = new Simple8BitChar((byte) 0x1F, 'x'); Assert.assertEquals(0, f8.compareTo(f1)); Assert.assertEquals(1, f8.compareTo(f2)); Assert.assertEquals(2, f8.compareTo(f3)); Assert.assertEquals(3, f8.compareTo(f4)); Assert.assertEquals(4, f8.compareTo(f5));
@Test public void testSimple8BitZipEncoding() throws IOException { Simple8BitZipEncoding[] zipEncoding = new Simple8BitZipEncoding(new char[] { 'a', 'b', 'c' }); for (char c : zipEncoding) { assertEquals(c, zipEncoding[c]); } }
@Test public void testSimple8BitZipEncoding() throws IOException { char[] highChars = new char[] { 'a', 'b', 'c' }; Simple8BitZipEncoding f = new Simple8BitZipEncoding(highChars); assertEquals(new Simple8BitChar('a'), f.decodeHighChar()); assertEquals(new Simple8BitZipEncoding(highChars), f.decodeHighChar()); }
@Test public void testSimple8BitZipEncoding() throws IOException { char[] highChars = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'o', 'p', 'p', 'o', 'p', 'p', 'o', 'p', 'o', 'p', 'p', 'o', 'p', 'o', 'p', 'p', 'o
@Test public void testSimple8BitZipEncoding() throws IOException { Simple8BitZipEncoding f = new Simple8BitZipEncoding(('a', 'b')); assertEquals('a', f.decodeHighChar('a')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.decodeHighChar('b')); assertEquals('b', f.
@Test public void testSimple8BitZipEncoding() throws IOException { Simple8BitZipEncoding f1 = new Simple8BitZipEncoding(('a', 'b', 'c')); Simple8BitZipEncoding f2 = new Simple8BitZipEncoding(('a', 'b', 'c')); assertEquals(f1, f2); f1 = new Simple8BitZipEncoding(('a', 'b', 'c')); f2 = new Simple8BitZipEncoding(('a', 'b', 'c')); assertEquals(f1, f2); f1 = new Simple8BitZipEncoding(('a', 'b', 'c')); f2 = new Simple8BitZipEncoding(('a', 'b', 'c')); assertEquals(f1, f2); f1 = new Simple8BitZipEncoding(('a', 'b', 'c')); f2 = new Simple8BitZipEncoding(('a', 'b', 'c')); assertEquals(f1, f2); f1 = new Simple8BitZipEncoding(('a', 'b', 'c')); f2 = new Simple8BitZipEncoding(('a', 'b', 'c')); assertEquals(f1, f2); f1 = new Simple8BitZipEncoding(('
@Test public void testSimple8BitZipEncoding() { char[] highChars = new char[] { 'a', 'b', 'c' }; Simple8BitZipEncoding[] result = new Simple8BitZipEncoding[] { new Simple8BitChar('a'), new Simple8BitChar('b'), new Simple8BitChar('c'), new Simple8BitChar('d'), new Simple8BitChar('e'), new Simple8BitChar('f'), new Simple8BitChar('g'), new Simple8BitChar('h'), new Simple8BitChar('i'), new Simple8BitChar('k'), new Simple8BitChar('l'), new Simple8BitChar('o'), new Simple8BitChar('l'), new Simple8BitChar('k'), new Simple8BitChar('l'), new Simple8BitChar('k'), new Simple8BitChar('l'), new Simple8BitChar('k'), new Simple8BitChar('l'), new Simple8BitChar('k'), new Simple8BitChar('k'), new Simple8BitChar('k'), new Simple8BitChar('k'), new Simple8BitChar('k'), new Simple8BitChar('k'), new Simple8BitChar('k'),
@Test public void testSimple8BitZipEncoding() throws IOException { char[] highChars = new char[7]; Arrays.fill(highChars, 'a'); Simple8BitZipEncoding[] zipEncoding = new Simple8BitZipEncoding(highChars); Assert.assertEquals(zipEncoding.length, 2); Assert.assertEquals(zipEncoding[0], Simple8BitChar.decodeHighChar(highChars[0])); Assert.assertEquals(zipEncoding[1], Simple8BitChar.decodeHighChar(highChars[1])); Assert.assertEquals(zipEncoding[2], Simple8BitChar.decodeHighChar(highChars[2])); Assert.assertEquals(zipEncoding[3], Simple8BitChar.decodeHighChar(highChars[3])); Assert.assertEquals(zipEncoding[4], Simple8BitChar.decodeHighChar(highChars[4])); Assert.assertEquals(zipEncoding[5], Simple8BitChar.decodeHighChar(highChars[5])); Assert.assertEquals(zipEncoding[6], Simple8BitChar.decodeHighChar(highChars[6])); Assert.assertEquals(zipEncoding[7], Simple8BitChar.decodeHighChar(highChars[7])); Assert.assertEquals(zipEncoding[8], Simple8BitChar.decode
@Test public void decodeByte() { assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8
@Test public void decodeByte() { assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8BitChar('a', 'a').decodeByte('a')); assertEquals('a', new Simple8
@Test public void decodeByte() { assertEquals('a', decodeByte('a')); assertEquals('b', decodeByte('b')); assertEquals('c', decodeByte('c')); assertEquals('d', decodeByte('d')); assertEquals('e', decodeByte('e')); assertEquals('f', decodeByte('f')); assertEquals('g', decodeByte('g')); assertEquals('h', decodeByte('h')); assertEquals('i', decodeByte('i')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o', decodeByte('o')); assertEquals('o',
@Test public void decodeByte() { assertEquals('a', new Simple8BitChar('a', 'x').decodeByte('a')); assertEquals('b', new Simple8BitChar('b', 'x').decodeByte('b')); assertEquals('c', new Simple8BitChar('c', 'x').decodeByte('c')); assertEquals('d', new Simple8BitChar('d', 'x').decodeByte('d')); assertEquals('e', new Simple8BitChar('e', 'x').decodeByte('e')); assertEquals('f', new Simple8BitZipEncoding(new char[] { 'f', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o',
@Test public void testCanEncodeChar() { Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES,'').canEncodeChar('a')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 'b').canEncodeChar('b')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 'c').canEncodeChar('c')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').canEncodeChar('t')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').canEncodeChar('t')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').canEncodeChar('t')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').canEncodeChar('t')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').canEncodeChar('t')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').canEncodeChar('t')); Assert.assertTrue(new Simple8BitZipEncoding(Byte.BYTES, 't').can
@Test public void canEncodeChar() { Simple8BitChar f = new Simple8BitChar(7,''); Assert.assertTrue(f.canEncodeChar('a')); Assert.assertTrue(f.canEncodeChar('b')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('a')); Assert.assertTrue(f.canEncodeChar('b')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('a')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('a')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncodeChar('c')); Assert.assertTrue(f.canEncode
@Test public void testCanEncodeChar() throws IOException { Simple8BitChar f = new Simple8BitChar(Byte.MIN_VALUE,''); assertTrue(f.canEncodeChar('a')); assertTrue(f.canEncodeChar('b')); assertTrue(f.canEncodeChar('c')); assertTrue(f.canEncodeChar('d')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('f')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(f.canEncodeChar('e')); assertTrue(
@Test public void canEncodeCharWithMultipleLines() { assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals(new Simple8BitChar(25,''), new Simple8BitChar(25,'')); assertEquals
@Test public void testCanEncodeChar() throws IOException { Simple8BitChar f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8BitChar('a', 'x'); Assert.assertTrue(f.canEncodeChar('a')); f = new Simple8
@Test public void testPushEncodedChar() { ByteBuffer bb = ByteBuffer.allocate(128); bb.flip(); Simple8BitChar s = new Simple8BitChar(7,''); s.pushEncodedChar(bb, 'a'); s.pushEncodedChar(bb, 'b'); s.pushEncodedChar(bb, 'c'); s.pushEncodedChar(bb, 'd'); s.pushEncodedChar(bb, 'e'); assertEquals(s.getByte(0), bb.getByte(0)); assertEquals(s.getByte(1), bb.getByte(1)); assertEquals(s.getByte(2), bb.getByte(2)); assertEquals(s.getByte(3), bb.getByte(3)); assertEquals(s.getByte(4), bb.getByte(4)); assertEquals(s.getByte(5), bb.getByte(5)); assertEquals(s.getByte(6), bb.getByte(6)); assertEquals(s.getByte(7), bb.getByte(7)); }
@Test public void testPushEncodedChar() { ByteBuffer bb = ByteBuffer.allocate(128); Simple8BitChar c = new Simple8BitChar('a'); c.setCode('a'); c.pushEncodedChar(bb, 'a'); assertEquals('a', bb.get(0)); assertEquals('a', bb.get(1)); assertEquals('a', bb.get(2)); assertEquals('a', bb.get(3)); assertEquals('a', bb.get(4)); assertEquals('a', bb.get(5)); assertEquals('a', bb.get(6)); assertEquals('a', bb.get(7)); assertEquals('a', bb.get(8)); assertEquals('a', bb.get(9)); assertEquals('a', bb.get(10)); assertEquals('a', bb.get(11)); assertEquals('a', bb.get(12)); assertEquals('a', bb.get(13)); assertEquals('a', bb.get(14)); assertEquals('a', bb.get(15)); assertEquals('a', bb.get(16)); assertEquals('a', bb.get(17)); assertEquals('a', bb.get(18)); assertEquals('a', bb.get(19)); assertEquals('a', bb.get(19)); assertEquals('a', bb.get
@Test public void testPushEncodedChar() { Simple8BitChar c = new Simple8BitChar('a', 'x'); ByteBuffer bb = ByteBuffer.allocate(128); c.set((byte) 0x1); c.set((byte) 0x2); c.set((byte) 0x3); c.set((byte) 0x4); c.set((byte) 0x5c); c.set((byte) 0x6c); c.set((byte) 0x7f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte) 0x8f); c.set((byte)
@Test public void testPushEncodedChar() throws IOException { byte[] code = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0
@Test public void testPushEncodedChar() { ByteBuffer bb = ByteBuffer.allocate(128); for (int i = 0; i < 256; i++) { Simple8BitChar c = new Simple8BitChar(i, 'x'); bb.put((byte) c); } Simple8BitChar c = new Simple8BitChar(-22, 'x'); c.pushEncodedChar(bb, 'x'); assertEquals(c.code, bb.get()); assertEquals(c.code, bb.get()); }
@Test public void testPushEncodedChar() { Simple8BitChar f = new Simple8BitChar('a', 'x'); ByteBuffer bb = ByteBuffer.allocate(128); f.pushEncodedChar(bb, 'a'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x
@Test public void testPushEncodedChar() throws IOException { Simple8BitChar f = new Simple8BitChar(7, 'x'); ByteBuffer bb = ByteBuffer.allocate(128); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, '
@Test public void testPushEncodedChar() { Simple8BitChar f = new Simple8BitChar('a', 'x'); ByteBuffer bb = ByteBuffer.allocate(128); f.pushEncodedChar(bb, 'a'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x'); f.pushEncodedChar(bb, 'x
@Test public void testPushEncodedChar() throws IOException { byte[] code = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0
@Test public void testEncodeHighChar() { assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x'), encodeHighChar('x')); assertEquals(new Simple8BitChar(25, 'x
@Test public void testEncodeHighChar() { assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); }
@Test public void testEncodeHighChar() { Simple8BitChar c = new Simple8BitChar('a', 'x'); Simple8BitChar c2 = new Simple8BitChar('a', 'x'); Simple8BitChar c3 = new Simple8BitChar('a', 'x'); Simple8BitChar c4 = new Simple8BitChar('a', 'x'); Simple8BitChar c5 = new Simple8BitChar('a', 'x'); Simple8BitChar c6 = new Simple8BitChar('a', 'x'); Simple8BitChar c7 = new Simple8BitChar('a', 'x'); Simple8BitChar c8 = new Simple8BitChar('a', 'x'); Simple8BitZipEncoding z = new Simple8BitZipEncoding(new char[] { c.code, c.code, c.unicode, c.code, c2.code, c3.code, c4.code, c5.code, c6.code, c7.code, c8.code}); Assert.assertEquals(c, z.decodeHighChar(c2)); Assert.assertEquals(c, z.decodeHighChar(c3)); Assert.assertEquals(c, z
@Test public void testEncodeHighChar() { Simple8BitChar c = encodeHighChar('a'); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assertEquals('a', c.code); Assert.assertEquals('a', c.highchar); Assert.assert
@Test public void testEncodeHighChar() { Simple8BitChar c = new Simple8BitChar('a', 'x'); Simple8BitChar c2 = new Simple8BitChar('a', 'x'); Simple8BitChar c3 = new Simple8BitChar('a', 'x'); Simple8BitChar c4 = new Simple8BitChar('a', 'x'); Simple8BitChar c5 = new Simple8BitChar('a', 'x'); Simple8BitZipEncoding z = new Simple8BitZipEncoding(c.highChars, c.highChars); Assert.assertEquals(c, z.decodeHighChar(c2)); Assert.assertEquals(c, z.decodeHighChar(c3)); Assert.assertEquals(c, z.decodeHighChar(c4)); Assert.assertEquals(c, z.decodeHighChar(c5)); Assert.assertEquals(c, z.decodeHighChar(c6)); Assert.assertEquals(c, z.decodeHighChar(c7)); Assert.assertEquals(c, z.decodeHighChar(c8)); Assert.assertEquals(c, z.decodeHighChar(c9)); Assert.assertEquals
@Test public void testEncodeHighChar() { assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); }
@Test public void testEncodeHighChar() { Simple8BitChar c = new Simple8BitChar('a', 'a'); Simple8BitChar c2 = new Simple8BitChar('a', 'a'); Simple8BitChar c3 = new Simple8BitChar('a', 'a'); Simple8BitChar c4 = new Simple8BitChar('a', 'a'); Simple8BitChar c5 = new Simple8BitChar('a', 'a'); Simple8BitChar c6 = new Simple8BitChar('a', 'a'); Simple8BitChar c7 = new Simple8BitChar('a', 'a'); Simple8BitChar c8 = new Simple8BitChar('a', 'a'); Simple8BitZipEncoding z = new Simple8BitZipEncoding(new char[] { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
@Test public void testEncodeHighChar() { assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); assertEquals(null, encodeHighChar
@Test public void testEncodeHighChar() { Simple8BitChar c = new Simple8BitChar('a', 'a'); Simple8BitChar c2 = new Simple8BitChar('a', 'a'); Simple8BitChar c3 = new Simple8BitChar('a', 'a'); Simple8BitChar c4 = new Simple8BitChar('a', 'a'); Simple8BitChar c5 = new Simple8BitChar('a', 'a'); Simple8BitChar c6 = new Simple8BitChar('a', 'a'); Simple8BitChar c7 = new Simple8BitChar('a', 'a'); Simple8BitChar c8 = new Simple8BitChar('a', 'a'); Simple8BitZipEncoding z = new Simple8BitZipEncoding(new char[] { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
@Test public void testEncodeHighChar() { Simple8BitChar[] chars = new Simple8BitChar[] { Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), Simple8BitChar.decodeHighChar('a'), }; for (int i = 0; i < 3; i++) { assertEquals(chars[i], encodeHighChar(chars[i])); } }
@Test public void testEncodeHighChar() { Simple8BitChar c = encodeHighChar('a'); assertEquals('a', c.code); assertEquals('a', c.highchar); assertEquals('a', c.code); assertEquals('a', c.highchar); assertEquals('a', c.code); assertEquals('a', c.highchar); }
@Test public void testEncodeHighChar() { Simple8BitChar c = new Simple8BitChar((byte) 'a'); Simple8BitChar c2 = new Simple8BitChar((byte) 'b'); Simple8BitChar c3 = new Simple8BitChar((byte) 'c'); Simple8BitChar c4 = new Simple8BitChar((byte) 'd'); Simple8BitChar c5 = new Simple8BitChar((byte) 'e'); Simple8BitZipEncoding z = new Simple8BitZipEncoding(c.code, c.unicode); Assert.assertEquals(z.encodeHighChar(c.code), c2); Assert.assertEquals(z.encodeHighChar(c3.code), c3); Assert.assertEquals(z.encodeHighChar(c4.code), c1); Assert.assertEquals(z.encodeHighChar(c5.code), c2); Assert.assertEquals(z.encodeHighChar(c4.code), c3); Assert.assertEquals(z.encodeHighChar(c5.code), c1); Assert.assertEquals(z.encodeHighChar(c4.code), c2); Assert.assertEquals(z.encodeHighChar(c4.code),
@Test public void testEncodeHighChar() { assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(encodeHighChar('a'), encodeHighChar('a')); assertEquals(null, encodeHighChar('a')); }
@Test public void testEncodeHighChar() { Simple8BitChar c = new Simple8BitChar('a', 'a'); Simple8BitChar c2 = new Simple8BitChar('a', 'a'); Simple8BitChar c3 = new Simple8BitChar('a', 'a'); Simple8BitChar c4 = new Simple8BitChar('a', 'a'); Simple8BitChar c5 = new Simple8BitChar('a', 'a'); Simple8BitChar c6 = new Simple8BitChar('a', 'a'); Simple8BitChar c7 = new Simple8BitChar('a', 'a'); Simple8BitChar c8 = new Simple8BitChar('a', 'a'); Simple8BitZipEncoding z = new Simple8BitZipEncoding(new char[] { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
@Test public void testEncodeHighChar() { assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encodeHighChar('h')); assertEquals(null, encode
@Test public void testCanEncode() throws IOException { Simple8BitChar f = new Simple8BitChar((char) 0xDD, 'X'); byte[] encoded = f.encode(new byte[] { (byte) 0xDD, (byte) 0xDD }); Assert.assertEquals(true, f.canEncode(encoded)); f = new Simple8BitChar((char) 0xDD, 'X'); encoded = f.encode(new byte[] { (byte) 0xDD, (byte) 0xDD }); Assert.assertEquals(false, f.canEncode(encoded)); f = new Simple8BitChar((char) 0xDD, 'X'); encoded = f.encode(new byte[] { (byte) 0xDD, (byte) 0xDD }); Assert.assertEquals(false, f.canEncode(encoded)); }
@Test public void canEncode_nameWithUnAsciiChar_shouldReturnTrue() { assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.canEncode("abc")); assert(simple8bit.
@Test public void testCanEncode() throws IOException { Simple8BitChar f = new Simple8BitChar(zipcode.getHighChars(), 'Z'); assertTrue(f.canEncodeChar('Z')); }
@Test public void testCanEncodeChar() { Simple8BitChar f = new Simple8BitChar(zipcode.getHighChars().charAt(0), 'x'); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x')); Assert.assertTrue(f.canEncodeChar('x
@Test public void canEncode_false() { Simple8BitChar f = new Simple8BitChar(Byte.MIN_VALUE, 'Z'); Assert.assertFalse(f.canEncode("")); Assert.assertFalse(f.canEncode("")); Assert.assertFalse(f.canEncode("abc")); Assert.assertFalse(f.canEncode("abc")); }
@Test public void canEncode() throws IOException { Simple8BitChar f = new Simple8BitChar(zipcode, 'x'); assertTrue(f.canEncode(zipcode)); f = new Simple8BitChar(zipcode, 'x'); assertTrue(f.canEncode(zipcode)); f = new Simple8BitChar(zipcode, 'x'); assertTrue(f.canEncode(zipcode)); f = new Simple8BitChar(zipcode, 'x'); assertTrue(f.canEncode(zipcode)); }
@Test public void testEncode() { byte[] name = "foo".getBytes(); ByteBuffer encoded = ZipEncodingHelper.encode(name); assertEquals(name, encoded.array()); ByteBuffer encoded2 = ZipEncodingHelper.encodeHighChar(name); assertEquals(name, encoded2.array()); ByteBuffer encoded3 = ZipEncodingHelper.encodeHighChar(name); assertEquals(name, encoded3.array()); ByteBuffer encoded4 = ZipEncodingHelper.encodeHighChar(name); assertEquals(name, encoded4.array()); }
@Test public void testEncode() { byte[] encoded = ZipEncodingHelper.encodeHighChar('Z'); Assert.assertEquals(encoded.length, 6 + (encoded.length() / 2) + 1); Assert.assertEquals(encoded[0], ZipEncodingHelper.encodeHighChar('Z')); encoded = ZipEncodingHelper.encodeHighChar('Z'); Assert.assertEquals(encoded.length, 6 + (encoded.length() / 2) + 1); Assert.assertEquals(encoded[0], ZipEncodingHelper.encodeHighChar('Z')); encoded = ZipEncodingHelper.encodeHighChar('Z'); Assert.assertEquals(encoded.length, 6 + (encoded.length() / 2) + 1); Assert.assertEquals(encoded[0], ZipEncodingHelper.encodeHighChar('Z')); }
@Test public void testEncode() { byte[] encoded = ZipEncodingHelper.encode("test"); Assert.assertEquals(zipEncoded.length, encoded.length); Assert.assertEquals(zipEncoded, ZipEncodingHelper.encodeHighChar('Z')); Assert.assertEquals(zipEncoded, ZipEncodingHelper.encodeHighChar('Z')); }
@Test public void testEncode() { byte[] encoded = ZipEncodingHelper.encodeHighChar('Z'); Assert.assertEquals(encoded[0], 'Z'); Assert.assertEquals(encoded[1], 'Z'); Assert.assertEquals(encoded[2], 'Z'); Assert.assertEquals(encoded[3], 'Z'); Assert.assertEquals(encoded[4], 'Z'); Assert.assertEquals(encoded[5], 'Z'); Assert.assertEquals(encoded[6], 'Z'); Assert.assertEquals(encoded[7], 'Z'); Assert.assertEquals(encoded[8], 'Z'); }
@Test public void testEncode() { byte[] encoded = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (
@Test public void testEncode() throws Exception { ByteBuffer tmp = ByteBuffer.allocate(zipName.length() + 6 + zipName.length() / 2); tmp.put((char)zipName.charAt(0)); tmp.put((char)zipName.charAt(1)); tmp.put((char)zipName.charAt(2)); tmp.put((char)zipName.charAt(3)); tmp.put((char)zipName.charAt(4)); tmp.put((char)zipName.charAt(5)); ByteBuffer encoded = ZipEncodingHelper.encode(zipName); Assert.assertEquals(zipName, encoded.array()); Assert.assertEquals(zipName.length() + 6, encoded.position()); Assert.assertEquals(zipName.charAt(0), encoded.charAt(0)); Assert.assertEquals(zipName.charAt(1), encoded.charAt(1)); Assert.assertEquals(zipName.charAt(2), encoded.charAt(2)); Assert.assertEquals(zipName.charAt(3), encoded.charAt(3)); }
@Test public void testEncode() throws IOException { byte[] encoded = ZipEncodingHelper.encode("test"); Assert.assertEquals("test", encoded[0]); Assert.assertEquals("test", encoded[1]); Assert.assertEquals("test", encoded[2]); Assert.assertEquals("test", encoded[3]); Assert.assertEquals("test", encoded[4]); Assert.assertEquals("test", encoded[5]); Assert.assertEquals("test", encoded[6]); Assert.assertEquals("test", encoded[7]); Assert.assertEquals("test", encoded[8]); Assert.assertEquals("test", encoded[9]); Assert.assertEquals("test", encoded[10]); Assert.assertEquals("test", encoded[11]); Assert.assertEquals("test", encoded[12]); Assert.assertEquals("test", encoded[13]); Assert.assertEquals("test", encoded[14]); Assert.assertEquals("test", encoded[15]); Assert.assertEquals("test", encoded[16]); Assert.assertEquals("test", encoded[17]); Assert.assertEquals("test", encoded[18]); Assert.assertEquals("test", encoded[19]); Assert.assertEquals("test", encoded[20]); Assert.assertEquals("test", encoded[30]);
@Test public void testEncode() throws Exception { byte[] encoded = ZipEncodingHelper.encode("foo"); assertEquals("foo", encoded[0]); assertEquals("foo", encoded[1]); assertEquals("foo", encoded[2]); assertEquals("foo", encoded[3]); assertEquals("foo", encoded[4]); assertEquals("foo", encoded[5]); assertEquals("foo", encoded[6]); assertEquals("foo", encoded[7]); assertEquals("foo", encoded[8]); assertEquals("foo", encoded[9]); assertEquals("foo", encoded[10]); assertEquals("foo", encoded[11]); assertEquals("foo", encoded[12]); assertEquals("foo", encoded[13]); assertEquals("foo", encoded[14]); assertEquals("foo", encoded[15]); assertEquals("foo", encoded[16]); assertEquals("foo", encoded[17]); assertEquals("foo", encoded[18]); assertEquals("foo", encoded[19]); assertEquals("foo", encoded[20]); assertEquals("foo", encoded[21]); assertEquals("foo", encoded[22]); assertEquals("foo", encoded[23]); assertEquals("foo", encoded[24]); assertEquals("foo", encoded[26]); assertEquals("foo", encoded[27]); assertEquals("foo", encoded[28]); assertEquals("foo", encoded[29]); assertEquals("foo", encoded[30]); assertEquals("foo
@Test public void testEncode() { byte[] encoded = ZipEncodingHelper.encodeHighChar('Z'); assertEquals(zipEncoded.length, encoded.length); for (int i = 0; i < encoded.length; ++i) { assertEquals(zipEncoded[i], encoded[i]); } }
@Test public void testEncode() throws Exception { ByteBuffer s = ByteBuffer.allocate(name.length() + 6 + name.length() / 2); s.put(name.getBytes(Charset.forName("US-ASCII"))); s.rewind(); byte[] encoded = s.array(); assertEquals(name.length() + 6, encoded.length); ByteBuffer encoded2 = s.array(); assertEquals(encoded.length() + 2, encoded2.length); ByteBuffer encoded3 = s.array(); assertEquals(encoded.length() + 3, encoded3.length); ByteBuffer encoded4 = s.array(); assertEquals(encoded.length() + 3, encoded4.length); ByteBuffer encoded5 = s.array(); assertEquals(encoded5.length() + 3, encoded5.length); ByteBuffer encoded6 = s.array(); assertEquals(encoded6.rewind(), ZipEncodingHelper.growBuffer(encoded5, 6)); assertEquals(encoded6.rewind(), ZipEncodingHelper.growBuffer(encoded6, 6)); assertEquals(encoded6.rewind(), ZipEncodingHelper.appendSurrogate(encoded6, 'Z')); assertEquals(encoded6.rewind(), ZipEncodingHelper.appendSurrogate(encoded6, 'Z')); assertEquals(encoded6.rewind(), ZipEncodingHelper.appendSurrogate(encoded6, 'Z'));
@Test public void testEncode() throws Exception { byte[] encoded = ZipEncodingHelper.encode("test"); Assert.assertEquals(encoded.length, encoded.length); for (int i = 0; i < encoded.length; ++i) { Assert.assertEquals(encoded[i], ZipEncodingHelper.encodeHighChar(encoded[i])); } }
@Test public void testDecode() throws IOException { byte[] data = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x8
@Test public void testDecode() throws IOException { char [] expected = new char[] { 'a', 'b', 'c' }; char [] actual = new char[] { 'a', 'b', 'c' }; byte[] data = new byte[] { 'a', 'b', 'c' }; Simple8BitChar f = new Simple8BitChar(codeHighChar, unicode); String result = f.decode(data); Assert.assertEquals(expected, result); }
@Test public void testDecode() throws IOException { Simple8BitZipEncoding z = new Simple8BitZipEncoding(char.valueOf('a')); byte[] data = z.decode(new byte[] { 'a' }); Assert.assertEquals("a", new String(data)); }
@Test public void testDecode() throws IOException { byte[] data = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x8
@Test public void testDecode() throws IOException { byte[] data = "abc".getBytes(); assertEquals("abc", new Simple8BitChar(code, 'a').decode(data)); }
@Test public void testGetNextArEntry() throws Exception { final byte[] header = "!<arch>\n" + "!<arch>\n" + "!<name>!<lastmodified>!<uid>!<rid>!<rid>!<file>!<file>!<data>!<data>!<file>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>!<data>
@Test public void testGetNextArEntry() throws IOException { final ByteArrayInputStream input = new ByteArrayInputStream(new byte[] { (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x8
@Test public void testGetNextArEntry() throws IOException { final byte[] expected = "!<arch>\n".getBytes(); final ArArchiveEntry arEntry = new ArArchiveEntry(expected); assertArrayEquals(expected, arEntry.getNextArEntry()); }
@Test public void testGetNextArEntry() throws Exception { final byte[] expected = "!<arch>\n".getBytes(); final byte[] realized = new byte[expected.length]; final ArArchiveEntry actual = sut.getNextArEntry(); assertArrayEquals(expected, actual.bytes()); assertArrayEquals(expected, actual.bytes()); assertArrayEquals(expected, actual.bytes()); }
@Test public void testGetNextArEntry() throws IOException { final byte[] data = "!<arch>\n" + "!<user>\n" + "!<password>!<userpass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>
@Test public void testGetNextArEntry() throws IOException { final byte[] expected = "!<arch>\n" + "!<user>\n" + "!<group>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n
@Test public void testGetNextArEntry() throws IOException { final byte[] expected = "!<arch>\n".getBytes(); final byte[] realized = "!<arch>\n".getBytes(); final int read = 0; final int expect = input.available(); IOUtils.write(expected, realized, 0, expect); IOUtils.write(expected, realized, 0, expect); final ArArchiveEntry actual = sut.getNextArEntry(); assertArrayEquals(expected, actual.getExpected()); assertArrayEquals( realized, actual.getRealized()); }
@Test public void testGetNextArEntry() throws Exception { final byte[] expected = "!<arch>\n".getBytes(); final byte[] realized = "!<arch>\n".getBytes(); final int offset = 0; final int read = 0; final int expectedLen = expected.length; final byte[] name = new byte[expected.length]; final byte[] lastmodified = new byte[expected.length]; final byte[] userid = new byte[6]; final byte[] groupi = new byte[expected.length]; final byte[] group = new byte[expected.length]; final byte[] groupbytes = new byte[expected.length]; final ByteArrayInputStream input = new ByteArrayInputStream(expected); final ArArchiveEntry entry; while ((entry = reader.readNextArEntry())!= -1) { expected[++offset] = entry.getOffset(); } assertArrayEquals(expected, realized); assertArrayEquals(expectedLen, entry.getLength()); assertArrayEquals(new byte[]{'!', 'arch'}, entry.getRealized()); assertArrayEquals(new byte[]{'!', 'arch'}, entry.getuserid()); assertArrayEquals(new byte[]{'!', 'arch'}, entry.getGroupi()); assertArrayEquals(new byte[]{'!', '
@Test public void testGetNextArEntry() throws IOException { final byte[] header = "!<arch>\n" + "!<name>!<version>!<revision>!<time>!<offset>!<time>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<size>!<offset>!<size>!<size>!<size>!<size>!
@Test public void testGetNextArEntry() throws IOException { byte[] expected = "!<arch>\n".getBytes(); final byte[] actual = read(input); final ArArchiveEntry actualArEntry = new ArArchiveEntry(actual); assertArrayEquals(expected, actualArEntry.getNextArEntry()); }
@Test public void testGetNextArEntry() throws IOException { final byte[] name = new byte[16]; final byte[] userid = new byte[6]; final byte[] groupi = new byte[6]; final byte[] group = new byte[6]; final byte[] expected = "!<arch>\n".getBytes(); final byte[] read = "!<arch>\n".getBytes(); final byte[] realized = new byte[expected.length]; final int read = input.available(); expect(input.read(isA(byte[].class))).andReturn(read); expect(input.available()).andReturn(expected.length); expect(input.read(isA(byte[].class))).andReturn(read); expect(input.available()).andReturn(expected.length); expect(input.read(isA(byte[].class))).andReturn(read); expect(input.available()).andReturn(expected.length); expect(input.read(isA(byte[].class))).andReturn(read); expect(input.available()).andReturn(expected.length); expect(input.read(isA(byte[].class))).andReturn(read); expect(input.available()).andReturn(expected
@Test public void testGetNextArEntry() throws IOException { final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6]; final byte[] expected = "!<arch>\n".getBytes(); final byte[] expectedRead = "!<arch>\n".getBytes(); final byte[] realized = new byte[expected.length]; final int read = input.available(); final int expectedLen = expected.length; final int readExpected = expectedRead; final byte[] actual = new byte[expected.length]; Arrays.fill(actual, 0, expectedLen); Arrays.fill(actual, 0, expectedLen); final ArArchiveEntry entry = sut.getNextArEntry(); assertArrayEquals(expected, actual); }
@Test public void testGetNextArEntry() throws IOException { final byte[] userid = new byte[6]; final ArArchiveEntry entry = new ArArchiveEntry(userid); final byte[] actual = entry.getNextArEntry(); assertArrayEquals(userid, actual); }
@Test public void testGetNextArEntry() throws IOException { final byte[] gid = new byte[6]; final byte[] groupid = new byte[6]; final ArArchiveEntry entry = new ArArchiveEntry(gid, groupid); final byte[] actual = entry.getNextArEntry(); assertArrayEquals(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testGetNextArEntry() throws Exception { final byte[] filemode = new byte[8]; final ArArchiveEntry entry = new ArArchiveEntry(filemode, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testGetNextArEntry() throws IOException { final byte[] data = "!<arch>\n".getBytes(); final byte[] expected = data; final byte[] actual = new byte[10]; final int offset = 0; Mockito.when(input.available()).thenReturn(data.length); Mockito.when(input.read(Mockito.anyInt())).thenReturn(offset); Mockito.when(input.available()).thenReturn(data.length); Mockito.when(input.available()).thenReturn(data.length); Mockito.when(input.read(Mockito.anyInt())).thenReturn(data.length); ArArchiveEntry actual = arEntry.getNextArEntry(); Assert.assertArrayEquals(expected, actual); }
@Test public void testGetNextArEntry() throws IOException { final byte[] name = "!<arch>\n".getBytes(); final byte[] first = "!<arch>\n".getBytes(); final byte[] second = "!<arch>\n".getBytes(); final byte[] third = "!<arch>\n".getBytes(); final byte[] expect = "!<arch>\n".getBytes(); final byte[] expectLast = "!<arch>\n".getBytes(); final byte[] expectFirst = "!<arch>\n".getBytes(); final byte[] expectSecond = "!<arch>\n".getBytes(); final byte[] expectLast = "!<arch>\n".getBytes(); final byte[] expectFirst = "!<arch>\n".getBytes(); final byte[] expectSecond = "!<arch>\n".getBytes(); final byte[] expect = "!<arch>\n".getBytes(); final byte[] expect = "!<arch>\n".getBytes(); final byte[] expectLast = "!<arch>\n".getBytes(); final byte[] expect = "!<arch>\n".getBytes(); final byte[] expect = "!<arch>\n".getBytes(); final byte[] expect = "!<arch>\n".
@Test public void testGetNextArEntry() throws IOException { final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6]; final byte[] groupid = new byte[6]; final byte[] group = new byte[6]; final byte[] data = "!<arch>\n".getBytes(); final ByteArrayInputStream input = new ByteArrayInputStream(data); final ArArchiveEntry entry = new ArArchiveEntry(input, name, lastmodified, userid, groupid, data); final ArArchiveEntry next = new ArArchiveEntry(input, name, lastmodified, userid, groupid, group); Assert.assertEquals(entry, next); }
@Test public void testGetNextArEntry() throws IOException { final byte[] data = "!<arch>\n" + "!<user>\n" + "!<password>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!
@Test public void testGetNextArEntry() throws IOException { final byte[] arr = new byte[16]; arr[0] = (byte) 0x01; arr[1] = (byte) 0x02; arr[2] = (byte) 0x03; arr[3] = (byte) 0x04; arr[4] = (byte) 0x05; arr[5] = (byte) 0x06; arr[6] = (byte) 0x07; arr[7] = (byte) 0x08; arr[8] = (byte) 0x09; arr[9] = (byte) 0x10; arr[10] = (byte) 0x08; arr[11] = (byte) 0x09; arr[12] = (byte) 0x10; arr[13] = (byte) 0x0f; arr[14] = (byte) 0x0d; arr[15] = (byte) 0x0f; arr[16] = (byte) 0x06; arr[17] = (byte) 0x08; arr[18] = (byte) 0x09; arr[19] = (byte) 0x10; arr[20] = (byte
@Test public void testGetNextArEntry() throws IOException { final byte[] data = "!<arch>\n".getBytes(); final ByteArrayInputStream input = new ByteArrayInputStream(data); final byte[] expected = "!<arch>\n".getBytes(); final int offset = 0; Mockito.when(input.available()).thenReturn(input.available()); Mockito.when(input.read(Mockito.anyInt())).thenReturn(offset); Mockito.when(input.available()).thenReturn(input.available()); ArArchiveEntry actual = arArchive.getNextArEntry(); Assert.assertEquals(expected, actual); Mockito.verify(input).available(); Mockito.verify(input).read(Mockito.anyInt()); Mockito.verify(input).available(); }
@Test public void testGetNextArEntry() throws IOException { final byte[] data = "!<arch>\n" + "!<file>dVVzZhZm9uZhZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZm9uZ
@Test public void testGetNextArEntry() throws IOException { final byte[] expected = "`\012".getBytes(); final ArArchiveEntry arEntry = new ArArchiveEntry(expected); assertArrayEquals(expected, arEntry.getNextArEntry()); }
@Test public void testGetNextArEntry() throws Exception { final byte[] expected = "!<arch>\n".getBytes(); final byte[] realized = new byte[expected.length]; final ArArchiveEntry actual = sut.getNextArEntry(); assertArrayEquals(expected, actual.bytes()); assertArrayEquals(expected, actual.bytes()); assertArrayEquals(expected, actual.bytes()); }
@Test public void testGetNextArEntry() throws IOException { final byte[] data = "!<arch>\n" + "!<user>\n" + "!<password>!<userpass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>!<pass>
@Test public void testGetNextArEntry() throws IOException { final byte[] expected = "!<arch>\n" + "!<user>\n" + "!<group>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n" + "!<data>\n
@Test public void testGetNextArEntry() throws IOException { final byte[] expected = "!<arch>\n".getBytes(); final byte[] realized = "!<arch>\n".getBytes(); final int read = 0; final int expect = input.available(); IOUtils.write(expected, realized, 0, expect); IOUtils.write(expected, realized, 0, expect); final ArArchiveEntry actual = sut.getNextArEntry(); assertArrayEquals(expected, actual.getExpected()); assertArrayEquals( realized, actual.getRealized()); }
@Test public void testGetNextArEntry() throws Exception { final byte[] expected = "!<arch>\n".getBytes(); final byte[] realized = "!<arch>\n".getBytes(); final int offset = 0; final int read = 0; final int expectedLen = expected.length; final byte[] name = new byte[expected.length]; final byte[] lastmodified = new byte[expected.length]; final byte[] userid = new byte[6]; final byte[] groupi = new byte[expected.length]; final byte[] group = new byte[expected.length]; final byte[] groupbytes = new byte[expected.length]; final ByteArrayInputStream input = new ByteArrayInputStream(expected); final ArArchiveEntry entry; while ((entry = reader.readNextArEntry())!= -1) { expected[++offset] = entry.getOffset(); } assertArrayEquals(expected, realized); assertArrayEquals(expectedLen, entry.getLength()); assertArrayEquals(new byte[]{'!', 'arch'}, entry.getRealized()); assertArrayEquals(new byte[]{'!', 'arch'}, entry.getuserid()); assertArrayEquals(new byte[]{'!', 'arch'}, entry.getGroupi()); assertArrayEquals(new byte[]{'!', '
@Test public void testGetNextArEntry() throws Exception { byte[] name = "!<arch>\n".getBytes(); byte[] length = "!<file>!<file>!<directory>!<directory>!<archive>".getBytes(); final byte[] expected = "!<arch>!<file>!<directory>!<archive>".getBytes(); final int length = (length - 1) * 2; final byte[] actual = new byte[length]; final int expect = input.available(); expect(input.read(expected)).andReturn(expect).atLeastOnce(); expect(input.available()).andReturn(length).atLeastOnce(); expect(input.read(expected)).andReturn(expect).atLeastOnce(); expect(input.available()).andReturn(length).atLeastOnce(); expect(input.read(expected)).andReturn(expect).atLeastOnce(); expect(input.read(expected)).andReturn(expect).atLeastOnce(); expect(input.available()).andReturn(length).atLeastOnce(); expect(input.read(expected)).andReturn(expect).atLeastOnce(); expect(input.available()).andReturn(length).atLeastOnce(); expect(input.
@Test public void test2() throws IOException { String s = "Archive:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n" + "ARCHIVE_FILE:ARM\n"; ByteArrayInputStream bais = new ByteArrayInputStream(s.getBytes()); ArArchiveInputStream aiis = new ArArchiveInputStream(bais); ArchiveEntry ai = aiis.getNextEntry(); Assert.assertNotNull(ai); Assert.assertEquals(ai.getArchetype(), ArchiveEntry.ARCHIVE_FILE); Assert.assertEquals(ai.getFlags(), ArchiveEntry.FLAG_ARCHIVE); }
@Test public void test2() throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream(new byte[] { (byte)0xfe, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte)0x80, (byte
@Test public void testRead() throws IOException { byte[] b = new byte[8]; int ret; ret = read(b, 0, b.length); Assert.assertEquals(8, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); ret = read(b, 0, b.length); Assert.assertEquals(0, ret); }
@Test public void testRead() throws IOException { byte[] b = new byte[100]; int i; try { i = inputStream.read(b, 0, b.length); Assert.assertEquals(i, b[i]); } catch (IOException e) { Assert.fail(e.getMessage()); } }
@Test public void testRead() throws IOException { byte[] b = new byte[8]; int i = 0; while (i < 8 && i < 256) { i += b[i]; } byte[] buff = new byte[i]; buff[i] = (byte) i; buff[i] = (byte) i; buff[i] = (byte) i; byte[] buff2 = new byte[i]; buff2[i] = (byte) i; buff2[i] = (byte) i; buff2[i] = (byte) i; byte[] buff3 = new byte[i]; buff3.length = i; byte[] buff4 = new byte[i]; buff4.length = i; byte[] buff5 = new byte[i]; buff5.length = i; ByteArrayInputStream bais = new ByteArrayInputStream(buff); ArArchiveInputStream iis = new ArArchiveInputStream(bais); byte[] buff2 = new byte[i]; int i = 0; while (i < buff2.length) { i += b[i]; buff2[i] = (byte) i; buff3.length = i; i = i; iis.read(buff2, i, i + b.length
@Test public void testRead() throws IOException { byte[] b = new byte[100]; int i = 0; try { new ArArchiveInputStream(input).read(b, 0, i); Assert.fail("Expected to throw an IOException"); } catch (IOException e) { } }
@Test public void testRead() throws IOException { byte[] b = new byte[8]; int i = 0; try (InputStream in = new ByteArrayInputStream(b)) { int r = in.read(b, 0, b.length); Assert.assertEquals(r, b[i++]); } }
@Test public void testRead() throws IOException { byte[] b = new byte[20]; int i = 0; try { new Random().nextBytes(b); i++; } catch (IOException e) { Assert.fail(e.getMessage()); } byte[] buff = new byte[20]; int i = 0; try { new Random().nextBytes(buff); i++; buff[i] = (byte) (b[i] & 0xFF); } catch (IOException e) { Assert.fail(e.getMessage()); } byte[] buff2 = new byte[20]; try { new Random().nextBytes(buff2); i++; buff2[i] = (byte) (b[i] & 0xFF); } catch (IOException e) { Assert.fail(e.getMessage()); } int i2 = 0; try { new Random().nextBytes(buff2); i2++; buff2[i] = (byte) (b[i] & 0xFF); } catch (IOException e) { Assert.fail(e.getMessage()); } byte[] buff3 = new byte[20]; try { new Random().nextBytes(buff3); i2++; buff3.length = (byte) (b[i] & 0xFF); } catch
@Test public void testRead() throws IOException { byte[] b = new byte[100]; int i = 0; try { i = inputStream.read(b, 0, b.length); } catch (IOException e) { Assert.fail("read() failed"); } Assert.assertEquals(i, b.length); }
@Test public void testCreateCompressorInputStreamGzip2() throws IOException { try (InputStream in = getClass().getResourceAsStream("/bzip2.gz")) { try (CompressorInputStream inputStream = new GzipCompressorInputStream(in)) { assertEquals(new Gzip2CompressorInputStream(in), inputStream); } } try (CompressorInputStream inputStream = new GzipCompressorInputStream(in)) { try (CompressorInputStream inputStream = new Gzip2CompressorInputStream(in)) { assertEquals(new BZip2CompressorInputStream(in), inputStream); } } try (InputStream in = new BZip2CompressorInputStream(in)) { try (CompressorInputStream inputStream = new BZip2CompressorInputStream(in)) { assertEquals(new BZip2CompressorInputStream(in), inputStream); } } try (CompressorInputStream inputStream = new GZIPCompressorInputStream(in)) { try (CompressorInputStream inputStream = new GZIPCompressorInputStream(in)) { try (CompressorInputStream inputStream = new GZIPCompressorInputStream(in)) { assertEquals(new GZIPCompressorInputStream(in), inputStream); } } } try (CompressorInputStream inputStream = new GZIPCompressorInputStream(in)) { try (CompressorInputStream inputStream = new GZIPCompressorInputStream(in)) { try (CompressorInputStream inputStream = new GZIPCompressorInputStream(in)) { try (CompressorInputStream inputStream = new GZIPCompressor
@Test public void testCreateCompressorInputStreamNullName() throws Exception { thrown.expect(IllegalArgumentException.class); thrown.expectMessage("Compressor name and stream must not be null."); sut.createCompressorInputStream(null, null); }
@Test public void testCreateCompressorInputStreamGzip2() throws IOException, CompressorException { final String name = "gzip2"; final InputStream in = new ByteArrayInputStream(GZIP2_DEFLATE_STREAM.getBytes()); try (final CompressorInputStream inputStream = sut.createCompressorInputStream(name, in)) { assertTrue(inputStream instanceof GzipCompressorInputStream); assertTrue(inputStream.isClose()); } }
@Test public void testCreateCompressorInputStreamThrowsExceptionWhenNameIsNull() throws Exception { expectedException.expect(IllegalArgumentException.class); expectedException.expectMessage("Compressor name and stream must not be null."); sut.createCompressorInputStream(null, mock(InputStream.class)); }
@Test public void testCreateCompressorInputStreamGzip2() throws IOException { try (InputStream in = getClass().getResourceAsStream("/bzip2.gz")) { try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new GzipCompressorInputStream(in).close(); } } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2CompressorInputStream(in).close(); } try (CompressorInputStream in = new GzipCompressorInputStream(in)) { new BZip2
@Test public void testCreateCompressorOutputStream_bzip2() throws Exception { try (final OutputStream out = new ByteArrayOutputStream()) { final CompressorOutputStream os = this.classifier.createCompressorOutputStream("bzip2", out); os.close(); } try (final OutputStream out2 = new ByteArrayOutputStream()) { final CompressorOutputStream os2 = this.classifier.createCompressorOutputStream("bzip2", out2); os2.close(); } try (final OutputStream out3 = new ByteArrayOutputStream()) { final CompressorOutputStream os3 = this.classifier.createCompressorOutputStream("bzip2", out3); os3.close(); } try (final OutputStream out4 = new ByteArrayOutputStream()) { final CompressorOutputStream os4 = this.classifier.createCompressorOutputStream("bzip2", out4); final ByteArrayOutputStream out5 = new ByteArrayOutputStream(); final CompressorOutputStream os5 = this.classifier.createCompressorOutputStream("bzip2", out5); final ByteArrayOutputStream out6 = new ByteArrayOutputStream(); try (final OutputStream out7 = new ByteArrayOutputStream()) { final CompressorOutputStream os6 = this.classifier.createCompressorOutputStream("bzip2", out6); os6.close(); } } try (final OutputStream out7 = new ByteArrayOutputStream()) { final CompressorOutputStream os =
@Test public void testCreateCompressorOutputStreamNullName() throws Exception { expectedEx.expect(IllegalArgumentException.class); expectedEx.expectMessage("Compressor name and stream must not be null."); new MockCompressorOutputStream(null, null); }
@Test public void testCreateCompressorOutputStreamGzip2() throws Exception { try (final OutputStream out = new ByteArrayOutputStream()) { try (final CompressorOutputStream outputStream = sut.createCompressorOutputStream("gzip2", out)) { assertThat(outputStream).isInstanceOf(Gzip2CompressorOutputStream.class); } } }
@Test public void testCreateCompressorOutputStreamThrowsNullPointerException() throws Exception { expectedException.expect(NullPointerException.class); expectedException.expectMessage("Compressor name and stream must not be null."); new MockGzip2CompressorOutputStream(null).createCompressorOutputStream("test", null); }
@Test public void testCreateCompressorOutputStream() throws Exception { try (final OutputStream out = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out).createCompressorOutputStream("test", out); } try (final OutputStream out2 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out2).createCompressorOutputStream("test", out2); } try (final OutputStream out3 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out3).createCompressorOutputStream("test", out3); } try (final OutputStream out4 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out4).createCompressorOutputStream("test", out3); } try (final OutputStream out5 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out5).createCompressorOutputStream("test", out3); } try (final OutputStream out4 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out4).createCompressorOutputStream("test", out3); } try (final OutputStream out4 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out4).createCompressorOutputStream("test", out3); } try (final OutputStream out5 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream(out5).createCompressorOutputStream("test", out3); } try (final OutputStream out4 = new ByteArrayOutputStream()) { new GzipCompressorOutputStream
@Test public void test UnicodePathExtraField () { UnicodePathExtraField UnicodePathExtraField = new UnicodePathExtraField (); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_NAME); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_NAME); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_BYTES); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_NAME); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_BYTES); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_NAME); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_BYTES); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_NAME); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_BYTES); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_NAME); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_BYTES); assertEquals ("", UnicodePathExtraField.URINOTED_PATH_FIELD_BYTES); assertEquals
@Test public void testUnicodePathExtraField() throws IOException { byte[] bytes = Files.readAllBytes(Paths.get("extra_field.txt")); UnicodePathExtraField UnicodePathExtraField UnicodePathExtraField = new UnicodePathExtraField("name", bytes); assertEquals("name", UnicodePathExtraField.getName()); assertEquals("", UnicodePathExtraField.getPathId()); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(0x7F)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(1)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(2)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(3)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(4)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(5)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(6)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(7)); assertEquals(Byte.valueOf(14), UnicodePathExtraField.getByteCode(8)); assertEquals(Byte.valueOf(14), UnicodePathExtra
@Test public void testSuperSuperClass() throws IOException { byte[] bytes = new byte[20]; UnicodePathExtraField unicodePathExtraField = new UnicodePathExtraField("name", bytes, 0, bytes.length); assertEquals("name", unicodePathExtraField.getName()); assertEquals(zip2_id, unicodePathExtraField.getHeaderId()); assertEquals(zip2_id, unicodePathExtraField.getUPATH_ID()); assertEquals(zip2_id, unicodePathExtraField.getUPATH_ID().getValue()); }
@Test public void getHeaderId() { ZipShort headerId = new ZipShort(0x7075); ZipShort result = zip.getHeaderId(); assertEquals(zip.getHeaderId(), result); }
@Test public void getHeaderId() { assertEquals(ZipShort.UPATH_ID, UnicodePathExtraField.UPATH_ID.getHeaderId()); }
